[
    {
        "content": "<p>starting in 40 minutes (really sorry for the late announcement here — i was convinced i'd already posted about it...)</p>\n<p>Abstract:</p>\n<p>The advantages of functional programming are well-known: programs are easier to write, understand and verify than their imperative counterparts. However, functional languages tend to be more memory intensive and these problems have hindered their wider use in industry. The xSLAM project tried to address these issues by using <em>explicit substitutions</em> to construct and implement more efficient abstract machines, proved correct by construction.</p>\n<p>In this talk I recap two results from the xSLAM project which haven't been sufficiently discussed. First, we provided categorical models for the calculi of explicit substitutions (linear and cartesian) that we are interested in. No one else seems to have provided categorical models for explicit substitutions calculi, despite the large number of explicit substitutions systems available in the literature. Indexed categories provide models of cartesian calculi of explicit substitutions. However, these structures are inherently non-linear and hence cannot be used to model <em>linear</em> calculi of explicit substitutions. Our work replaces indexed categories with pre-sheaves, thus providing a categorical semantics covering both the linear and cartesian cases. Our models satisfy soundness and completeness, as expected.</p>\n<p>Secondly, we recall a different linear-non-linear type theory, built from Barber and Plotkin DILL ideas, which, like DILL, is better for implementations. Unlike DILL, this type theory, called ILT, satisfies an internal language theorem. Thus we describe ILT, show categorical semantics for it and sketch the proof of its internal language theorem, thus justifying its use in implementations. These results are examples of `(categorically) structured deep syntax', to borrow Hyland's characterization.</p>",
        "id": 250009947,
        "sender_full_name": "Tim Hosgood",
        "timestamp": 1629390143
    },
    {
        "content": "<p>YouTube: <a href=\"https://www.youtube.com/watch?v=Z_gu1r7LNyc\">https://www.youtube.com/watch?v=Z_gu1r7LNyc</a><br>\nZoom: <a href=\"https://topos-institute.zoom.us/my/it.admin?pwd=Znh3UlUrek41T3RLQXJVRVNkM3Ewdz09\">https://topos-institute.zoom.us/my/it.admin?pwd=Znh3UlUrek41T3RLQXJVRVNkM3Ewdz09</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"Z_gu1r7LNyc\" href=\"https://www.youtube.com/watch?v=Z_gu1r7LNyc\"><img src=\"https://uploads.zulipusercontent.net/ce10dee8cd1d6b040fcb5c26191bb9648ec2de40/68747470733a2f2f692e7974696d672e636f6d2f76692f5a5f67753172374c4e79632f64656661756c742e6a7067\"></a></div>",
        "id": 250010043,
        "sender_full_name": "Tim Hosgood",
        "timestamp": 1629390198
    },
    {
        "content": "<p>Thank you for the great talk! I was unaware of \"Categorical Models for Intuitionistic and Linear Type Theory\", so now my reading list is extended :)</p>",
        "id": 250030270,
        "sender_full_name": "Jesse Sigal",
        "timestamp": 1629399015
    },
    {
        "content": "<p>thanks Jesse! do send questions, if you have them!</p>",
        "id": 250031221,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1629399427
    },
    {
        "content": "<p>Indeed, great talk! Just finished watching the stream. I have been working on defining semantics for a quantum language with both classical and substructural core calculi with a clean separation between the two and ILT seems like something I should look into in more detail.</p>",
        "id": 250034358,
        "sender_full_name": "Kartik",
        "timestamp": 1629400364
    },
    {
        "content": "<p>Thanks, Kartik! I don't know much about quantum phenomena, but always happy to discuss stuff.</p>",
        "id": 250036326,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1629401061
    },
    {
        "content": "<p>I'm sorry that I missed this talk, but I just watched the video.  Very nice!  This idea of taking contexts more seriously in the categorical models is definitely something that I feel strongly about too.  Although my own approach, at least in the simply typed case, has generally been multicategorical: rather than the contexts being incarnated as objects of some category, there is a multicategory whose objects are single types, and it's just the <em>morphisms</em> that can have multiple types in their domains (and possibly also codomains, if you move to polycategories).  The indexed approach has its own virtues, of course (e.g. it seems to generalize better to the dependently typed case).  Anyway, I thought maybe I would mention that there is also a multicategorical approach to  linear-nonlinear logic, which I recently posted <a href=\"https://arxiv.org/abs/2106.15042\">a preprint about</a>.  I believe your IL-indexed categories are equivalent to a certain class of LNL multicategories (Examples 3.10 in my preprint), so in this case both approaches are capturing the same information.</p>",
        "id": 250045558,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629405352
    },
    {
        "content": "<p>Many thanks for your message, Mike! I know that your preprint exists and have been meaning to read it for a while, will do that as soon as possible. yes, I must say that the idea of context-handling categories came about after we tried somewhat with the idea of \"syntactic multicategories\". Starting from Lambek's definition of multicategories (Multicategories Revisited) and wanting to pin down  composition of morphisms (to make them closer to the implementation) we were led (back -- in Eike's case), not very willingly (in my case), to the indexed category notions. Thomas Ehrhard's \"A Categorical Semantics of Constructions\". LICS 1988:  is the original motivation for Eike's calculus of constructions semantics, I think. and yes, I also believe that our IL-indexed cats are equivalent to a class of LNL multicategories and that more work will make clearer what do we need exactly from where. I am hoping to find people interested in investigating e.g. SystemF+Linearity, cutdown versions of MLTT + linearity, modal type theories of various stripes, etc. Because I still believe that  (well-established) categorical semantics can really help debugging programmers  wildly clever uses of syntax. thanks.</p>",
        "id": 250063051,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1629417387
    },
    {
        "content": "<p>Something else, which may be a bit of a digression: I didn't quite follow what your opinion is about Mellies's famous counterexample.</p>\n<p>As an outsider, my understanding is that it was a counterexample to <em>strong</em> normalization, i.e. the claim that <em>every</em> reduction sequence built from certain rewrite rules terminates in a normal form.  But in practice, does strong normalization really matter?  It seems like in practice what we want is a normalization <em>algorithm</em>, i.e. a particular reduction strategy that does always terminate, and why would we care that there are other strategies built from the same \"rewrite rules\" that don't terminate?</p>",
        "id": 250067764,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629422583
    },
    {
        "content": "<p>yes, this is how I understand it too. Mellies example shows lambda-sigma doesn't satisfy <em>strong</em> normalization. But in practice we don't need strong normalization, at least  not for abstract machines and for proof assistants, our intended applications. this was what I tried to say--that the goal that people thinking of rewriting theories gave themselves was (to my mind) the wrong goal.</p>",
        "id": 250074428,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1629430530
    },
    {
        "content": "<p>Thanks!  I thought that's what you might have been saying but I didn't quite follow.  Do you know of a good reference that explains <em>syntactic</em> explicit substitutions from this correct viewpoint?  E.g. proving that a sensible reduction strategy does succeed in normalizing things?</p>",
        "id": 250123137,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629468970
    },
    {
        "content": "<p>Another odd thought I had today is that explicit substitutions seem a little bit related to normalization by evaluation.  If we think of the \"evaluation in an environment\" step of NbE as pushing a multiple explicit substitution through a term, and give rules saying that it gets stuck when it hits an abstraction and doesn't go further in until the abstraction is applied, at which point it gets augmented by the term being substituted (which could be a variable at readback time).</p>",
        "id": 250123277,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629469047
    },
    {
        "content": "<p>Does that make any sense?</p>",
        "id": 250123286,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629469052
    },
    {
        "content": "<p>well, on a reference I am biased of course but I think Eike Ritter's on his own on \"Characterizing Explicit Substitutions that preserve termination\" <a href=\"https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.49.4329&amp;rep=rep1&amp;type=pdf\">https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.49.4329&amp;rep=rep1&amp;type=pdf</a> might be a good read. <br>\nand it had never occurred to me to think of explicit subs and NbE together or in the same context(daily use of the word), but indeed, now that you mentioned it does make some sense.</p>",
        "id": 250136651,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1629474939
    },
    {
        "content": "<p>Thanks, that's a nice paper!  It's phrased in terms of strong normalization too, but after reading I see the two perspectives aren't necessarily that different: we can (partially) describe a \"sensible strategy\" for normalization by restricting the rewrite rules it is allowed to use.</p>",
        "id": 250157955,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629485544
    },
    {
        "content": "<p>The first paragraph also connects explicit substitutions to environment machines, which are I think also related to NbE.</p>",
        "id": 250158060,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629485619
    },
    {
        "content": "<p>Sorry I see this a bit late, but I'd like to add something concerning explicit substitutions (after thanking Valeria for her talk, which I saw only today!).</p>\n<p>It is true that weak normalization is the fundamental normalization property, both from the viewpoint of theory (cut-elimination, consistency of the underlying logical system, etc.) and practice (programming languages, abstract machines, etc.).  However, the extra generality of so-called \"calculi\", as opposed to programming languages with a fixed reduction strategy, has an important foundational role, in particular because it provides the means of studying strategies themselves and state/organize results about them and about their relationship.  In these \"strategyless\" calculi, strong normalization is very natural and it is normal to perceive its failure (or the failure of preserving it) as a sign that something is wrong.  (Incidentally, there's even a conjecture by Barendregt, Geuvers and Klop stating that, within the world of PTSs (pure type systems), there's no difference between weak and strong normalization: a PTS is either strongly normalizing, or it has terms having no normal form.  IIRC, this has been proved for a relatively wide range of PTSs, but the general statement is still open).</p>\n<p>With 30 years of hindsight, I think that trying to \"fix\" explicit substitution (ES) systems so that they preserve SN was not a \"wrong goal\", because it ended up pushing the development of better behaved ES calculi in <em>all</em> respects, not just SN.  Valeria did not mention it because she focused on a different direction, but a lot has happened since Delia Kesner's 2008 paper cited in the talk.  In particular, around 2010 Delia herself and Beniamino Accattoli introduced the <em>linear substitution calculus</em> (LSC), which I find a true turning point in the theory of ESs.  (The geneology of this calculus is a bit complex: the LSC first appeared in an <a href=\"https://drive.google.com/open?id=1LaiJu6uSbOiDCunSdCZGZwqkGzfoGhFB\">RTA 2012 paper</a> by Beniamino alone, but its development started jointly with Delia for a work they published later, with other people, in <a href=\"https://drive.google.com/open?id=1gC-xmqMH6bHzkYIGs7Ir9afWp5v75NF_\">POPL 2014</a>.  Also, the LSC improves on a previous proposal independently made a few years earlier by Robin Milner).  As I see it, the LSC is based on two fundamental ideas:</p>\n<ol>\n<li><em>explicit substitutions in the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus come from linear logic:</em> if you write down a term calculus for the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mo>⊸</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{\\multimap,!\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mrel amsrm\">⊸</span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mclose\">!}</span></span></span></span> fragment of ILL, however you do it, you're going to see let binders pop up, and these behave very much like explicit substitutions, in the sense that normalization needs commuting conversions.  Now, if you take Girard's (call-by-name) embedding of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus in ILL, you see that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction decomposes exactly along the lines of what an ES calculus would do, with the explicit substitutions corresponding to the let binders for exponentials.  While I think that this had been noticed immediately after the introduction of linear logic, Delia and Beniamino took it a step further and <em>designed</em> an ES calculus (the <em>structural <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus</em>, a precursor to the LSC) by mimicking the behavior of ILL terms which are in the image of Girard's embedding.  The upshot is that, since Girard's embedding preserves SN, so does the structural <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus: linear logic is the \"right\" way of implementing explicit substitutions.</li>\n<li><em>Explicit substitutions should behave like boxes in proof nets:</em> the let binders mentioned above correspond to what are known as \"exponential boxes\" in proof nets.  Cut-elimination in proof nets has the amazing property (from the rewriting viewpoint) that <em>it does not need commuting conversions</em>.  In terms of explicit substitutions, this means that ESs should not need to \"move\" through a term in order to be applied, one should be able to apply them just where they are created.  Rewriting should happen \"remotely\" or, as they say, \"at a distance\".  Beniamino and Delia noticed that there's a consistent way of generalizing redexes in a term calculus with ESs (no need for proof nets!) so that they are transparent to the presence of ESs.  Combine this with the above idea (that ESs should behave like in linear logic, i.e., be \"linear\", substituting one occurrence at a time) and you obtain the LSC.</li>\n</ol>\n<p>The LSC is extremely simple (the usual syntax: variables, abstraction, application and ESs; only 3 rewriting rules, or even 2 if you can do away with garbage collection) and has spectacular rewriting properties (of course it preserves SN, but that's the least of it).  Its best quality, as far as I am concerned, is that you do not need to be a rewriting expert (I certainly am not) to appreciate its usefuless!  In particular, there are two areas in which it found important applications:</p>\n<ul>\n<li><strong>abstract machines:</strong> with Beniamino and Pablo Barenbaum, <a href=\"https://drive.google.com/open?id=1QZIFiYAyTwimeWC3pgNkBg80fnWiNHxS\">we showed</a> how the LSC may be related in a very sharp way to a host of abstract machines, for any reduction strategy you can think of (call by name, call by value, call by need).  Each strategy in the LSC \"distills\" an abstract machine, in the sense that the rewriting rules of the LSC are in bijection with the actual computational transitions of the machines, while the \"administrative\" transitions (needed by the machine to navigate through the term in search for the next redex) sort of \"evaporate\" and become structural equivalences in the LSC (they relate syntactically different terms which are behaviorally equal).  In particular, the LSC gives the slickest formulation of (weak) call-by-need I am aware of.  With other collaborators, Beniamino has gone much further in this direction.</li>\n<li><strong>complexity:</strong> for decades, people had been wondering whether <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction is a reasonable cost model, meaning: if I have a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> deciding a language <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>⊆</mo><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><msup><mo stretchy=\"false\">}</mo><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">L\\subseteq\\{0,1\\}^\\ast</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\"><span class=\"mclose\">}</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>, and I show that, for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>∈</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">n\\in\\mathbb N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo>∈</mo><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><msup><mo stretchy=\"false\">}</mo><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">w\\in\\{0,1\\}^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\"><span class=\"mclose\">}</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mtext> </mtext><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">M\\,w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> reduces to its normal form in less than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">p(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> head reduction steps, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> is a polynomial, have I shown that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>∈</mo><mi mathvariant=\"sans-serif\">P</mi></mrow><annotation encoding=\"application/x-tex\">L\\in\\mathsf{P}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathsf\">P</span></span></span></span>? (Deterministic polynomial time).  Most were convinced that the answer was \"no\", because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction may make an arbitrary number of duplications in just one step.  In particular, there are examples of sequences of terms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>M</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">M_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, of size <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>, normalizing to a term of constant size (e.g. a variable) in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> head reduction steps but such that the size of the terms encountered along the head reduction itself is <em>exponential</em> in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>.  Suprisingly, Beniamino Accattoli and Ugo Dal Lago <a href=\"https://www.google.com/url?q=https%3A%2F%2Flmcs.episciences.org%2F1627%2Fpdf&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHDV7AjgdKL0DuIpcJJVLb9FbJ1Cg\">showed that the answer is in fact \"yes\"</a>, and their proof uses the LSC in a crucial way, in particular its capability of succinctly expressing computation thanks to sharing (jokingly, one could say that, without ESs, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-terms are a very inefficient representation of themselves :-) ).</li>\n</ul>\n<p>From the categorical viewpoint, the LSC is a blank sheet: no one has looked at it from that perspective yet!  Personally, I see it more as a particularly useful example of the \"rewriting at-a-distance\" methodology, which may have nice applications for describing the internal logic of categories with \"positive\" constructors (tensor, coproduct, linear logic exponential...).</p>\n<p>Apologies for the overly long post, but if someone here is interested in explicit substitutions, I thought that they might find this supplementary perspective interesting!</p>",
        "id": 250553132,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1629841272
    },
    {
        "content": "<p>Thanks for the discussion <span class=\"user-mention\" data-user-id=\"276839\">@Damiano Mazza</span> ! yes, the previous time I gave this talk I spoke straight after Beniamino in a meeting organized by Mauricio Ayala Rincon, so I did mention our different motivations and  I mentioned  his  and Hugo's \"cost model\", which is indeed a nice and pleasant surprise. But indeed  what I find surprising is that no one looked at the LSC calculus or any other ES calculi using categorical tools, apart from us! this is the reason why I wanted to talk about it in the colloquium. the connection to implicitly computational complexity (ICC) is interesting, but I haven't got a categorical angle on it. (yet, perhaps.)</p>\n<blockquote>\n<p>From the categorical viewpoint, the LSC is a blank sheet: no one has looked at it from that perspective yet! Personally, I see it more as a particularly useful example of the \"rewriting at-a-distance\" methodology, which may have nice applications for describing the internal logic of categories with \"positive\" constructors (tensor, coproduct, linear logic exponential...).</p>\n</blockquote>\n<p>well, some of us would like to see \"rewriting\" also as category theory. in my case along the lines of Barney Hilken's \"Towards a proof theory of rewriting: the simply typed 2λ-calculus\". and the notion of positive/negative constructors I find it not very clear. but sure, I think this alternative perspective is  very welcome!</p>",
        "id": 250564648,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1629848690
    },
    {
        "content": "<p>Thanks very much <span class=\"user-mention\" data-user-id=\"276839\">@Damiano Mazza</span>, that's fascinating and added a whole lot to my reading list.  Is there any connection between the LSC and Lamping's so-called \"optimal\" reduction method for lambda-calculus, which proceeds by graph rewriting and I believe is also closely connected to linear logic?</p>",
        "id": 250575316,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629860278
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276656\">Valeria de Paiva</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Valeria.20de.20Paiva.3A.20.22Categorical.20Explicit.20Substitutions.22/near/250564648\">said</a>:</p>\n<blockquote>\n<p>what I find surprising is that no one looked at the LSC calculus or any other ES calculi using categorical tools, apart from us!</p>\n</blockquote>\n<p>Yes, the problem is that, as you know better than me, the world of programming languages is (mistakenly, I think) split in \"semantic-minded\" and \"syntactic-minded\" people.  Those who do rewriting theory strongly tend to belong to the second group, and since the equation \"categories = semantics\" is widely held to be true (which is, in my opinion, another misconception), rewriting people have a tendency to stay away from categories.  This is why I deeply appreciate the kind of work you have presented!  It points to the fact that categorical tools can be useful for rewriting too.  In that case, if rewriting theorists don't go to categories, categories will end up going to them :-)</p>\n<blockquote>\n<p>some of us would like to see \"rewriting\" also as category theory. in my case along the lines of Barney Hilken's \"Towards a proof theory of rewriting: the simply typed 2λ-calculus\". and the notion of positive/negative constructors I find it not very clear.</p>\n</blockquote>\n<p>I am \"some of us\"! :-)  Hilken's approach (initially advocated by Seely) that rewriting happens in the second dimension of a 2-categorical framework is fully exploited in my work (with my former Ph.D. students Luc Pellissier and Pierre Vial) on <a href=\"https://lipn.univ-paris13.fr/~mazza/papers/IntersectionTypes.pdf\">a general explanation of intersection types</a>.  Admittedly, though, this idea that \"rewriting = 2-arrows\" for the moment is more of a working hypothesis than an actual, fully-formed theory.  (I'll ping <span class=\"user-mention\" data-user-id=\"383799\">@Tom Hirschowitz</span> on this: he has thought a lot about the question and, more generally, about categorical approaches to defining the syntax of programming languages, he recently made some advances on this and may have something interesting to say).</p>\n<p>In fact, it seems plausible that rewriting theory (which is more than just the rewriting rules) takes place <em>from</em> dimension 2 <em>upwards</em> in a higher categorical framework.  The 3-arrows would be \"standardization paths\" (ways of transforming rewriting sequences into \"well behaved\" ones, which are often studied in rewriting theory) and (invertible) 4-cells too seem to have a meaning in terms of rewriting (ask Paul-André Melliès :-) ).  What's missing, I think, is a good understanding of where this higher-categorical structure comes from.  In \"nice\" programming languages and logical systems, the rewriting rules usually result from orienting equalities coming from categorical structures, but since these structures are \"just\" 1-categorical, they say nothing about the induced rewriting theory.  It would be nice to say, for example, that the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus is the free <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>-category (or, perhaps, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">∞</span></span></span></span>-category) with such and such property/structure, so that the property/structure itself automatically induces all the higher arrows corresponding to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction and its associated rewriting theory (notice that <em>strict</em> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>-categories should be enough for rewriting, so there is no question as to what these are precisely).  I remember that Eric Finster <a href=\"https://chocola.ens-lyon.fr/events/seminaire-2019-10-17-1/talks/finster/\">was doing something of this sort</a> for multiplicative linear logic, using an opetopic approach, but I don't know how far he managed to go.</p>\n<p>A naive observation is that, in simple cases (e.g. propositional connectives), the 2-arrows corresponding to reduction rules are generated by a weakening of the isomorphism defining the connective in a multicategorical setting.  For example, implication is defined by the (natural) iso</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo separator=\"true\">,</mo><mi>A</mi><mo separator=\"true\">;</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>≅</mo><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo separator=\"true\">;</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal C(\\Gamma,A;B)\\cong\\mathcal C(\\Gamma;A\\to B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mopen\">(</span><span class=\"mord\">Γ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mopen\">(</span><span class=\"mord\">Γ</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span></p>\n<p>(where I am writing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>A</mi><mi>n</mi></msub><mo separator=\"true\">;</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal C(A_1,\\ldots,A_n;B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span> for the homset of a cartesian multicategory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span>).  Now, if we go up one level, and consider <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Cat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68611em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Cat</span></span></span></span></span>-enriched multicategories, the iso may be weakened into an adjunction (with some extra compatibility properties), with the functor going in the forward direction (the one \"introducing the connective\", left to right in the above iso) being the right adjoint.  If you look at the counit of this adjunction, it's exactly <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction, whereas the unit is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">\\eta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span></span></span></span>-expansion.  This works with every propositional connective (including those of linear logic, if the multicategory is just symmetric), except that, in some cases, the forward functor is the <em>left</em> adjoint.  I wrote this up with a bit more detail in Sect. 1.1.5 of <a href=\"https://lipn.univ-paris13.fr/~mazza/papers/Habilitation.pdf\">my habilitation thesis</a>.  Notice that the multicategorical setting simplifies Seely's original approach, which resorts to <a href=\"https://ncatlab.org/nlab/show/lax+2-adjunction\">lax 2-adjunctions</a> and requires the simultaneous presence of products (which, as you said, people do not necessarily want to be \"forced upon\" them).  This is another advantage of using multicategories, as <span class=\"user-mention\" data-user-id=\"276777\">@Mike Shulman</span>  was pointing out above.</p>\n<p>The right adjoint/left adjoint distinction matches the standard classification of logical connectives as \"negative\" and \"positive\", respectively.  It also corresponds to the distinction, well-known in the proof theory of linear logic, of those connectives whose right rule (resp. left rule) is reversible in sequent calculus.  This is what I was alluding to when I spoke of \"positive constructor\".  For reasons that I do not fully understand, positive connectives are \"messy\" in terms of rewriting: in term calculi, they are usually handled by means of \"let\" binders, inducing all those annoying commutation rules (\"commuting conversions\").  These may be eliminated by appealing to the \"rewriting at-a-distance\" methodology of the LSC, which is a great benefit, because I don't think that commuting conversions are going to get any satisfactory categorical explanation, as they are not computational in nature, they are just artefacts of (a certain treatment of) the syntax.</p>",
        "id": 250597527,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1629883905
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Valeria.20de.20Paiva.3A.20.22Categorical.20Explicit.20Substitutions.22/near/250575316\">said</a>:</p>\n<blockquote>\n<p>Is there any connection between the LSC and Lamping's so-called \"optimal\" reduction method for lambda-calculus, which proceeds by graph rewriting and I believe is also closely connected to linear logic?</p>\n</blockquote>\n<p>No, there is no direct connection.  Lamping's <em>sharing graphs</em> implement <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction as a local process, duplicating terms \"piece by piece\" (so the intermediate steps do not correspond to any term at all; in fact, not even normal forms do!), whereas the LSC works by a parsimonious form of \"traditional\", non-local duplication.</p>\n<p>Now, it is plausible that one may concoct a term calculus isomorphic to sharing graphs using the same \"rewriting at-a-distance\" methodology of the LSC.  But it would yield something entirely different.  In fact, the difference is so radical that, contrarily to ordinary <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction, counting reduction steps in sharing graphs is <em>not</em> a reasonable cost measure, <a href=\"https://dl.acm.org/doi/10.1006/inco.2001.2869\">as shown long ago</a> by Andrea Asperti and Harry Mairson.  The failure is actually catastrophic: there is a non-elementary gap (meaning, not bounded by any tower of exponentials of fixed height!) between optimal reduction and Turing machines.  Although I do not fully understand the details of Asperti and Mairson's paper, I think that what's going on is that, as I mentioned above, normalization in sharing graphs does not reach an \"honest\" normal form: the normal form of a sharing graph which is the image of a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is, in general, not the image of the normal form of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>, but a highly compressed form of it.  What Asperti and Mairson show is that the decompression operation is not elementary recursive.  The LSC does not have this problem because, in its syntax, one may judiciously decompress terms as it is needed (but not more, otherwise the exponential explosion in the size of terms would affect it too), and the resulting normal form is the \"true\" normal form (the normal terms of the LSC are exactly the normal plain <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-terms).</p>",
        "id": 250599704,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1629885412
    },
    {
        "content": "<p>Thanks!  It's intriguing, then, that there are <em>two</em> different applications of linear logic to lambda-calculus reduction.</p>",
        "id": 250622539,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629899412
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276839\">@Damiano Mazza</span>  What paper would you recommend to read first as an introduction to LSC?</p>",
        "id": 250628258,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629901844
    },
    {
        "content": "<p>Also, I wonder whether you are aware of any work explicitly relating ES to NbE?</p>",
        "id": 250634909,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629904900
    },
    {
        "content": "<p>Not sure what I understand what's going on here, but there's a whole section in Andreas' Habilitation: <a href=\"https://www.cse.chalmers.se/~abela/habil.pdf\">https://www.cse.chalmers.se/~abela/habil.pdf</a></p>",
        "id": 250641370,
        "sender_full_name": "Cody Roux",
        "timestamp": 1629907775
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276030\">@Cody Roux</span> If you mean section 3.5, it seems to be just about putting explicit substitutions in the syntax that is being normalized, rather than relating the NbE algorithm itself to ES rewriting as I suggested further up in this thread (that's what I meant to be asking about).</p>",
        "id": 250662507,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629916985
    },
    {
        "content": "<p>So do you want an NbE that evaluates terms up-to ES reductions, or...?</p>",
        "id": 250674674,
        "sender_full_name": "Cody Roux",
        "timestamp": 1629921841
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Valeria.20de.20Paiva.3A.20.22Categorical.20Explicit.20Substitutions.22/near/250628258\">said</a>:</p>\n<blockquote>\n<p>What paper would you recommend to read first as an introduction to LSC?</p>\n</blockquote>\n<p>This question is harder to answer than what it should be :-)  A survey paper would be great, but unfortunately there's none at the moment.  So I'm going to go ahead with a shameless self-promotion and suggest our <a href=\"https://drive.google.com/file/d/1QZIFiYAyTwimeWC3pgNkBg80fnWiNHxS/view\">ICFP 2014 paper</a> on the LSC and abstract machines.  I really think it's  is a good starting point because it presents several subcalculi/strategies of the LSC, so it offers a fairly broad picture of what can be done with it.  Just skip all the technical details about the machines (which are, like, 3/4 of the paper).  Also, that paper comes with a <a href=\"https://www.youtube.com/watch?v=3k9UlpgXt0M\">video</a> of the 20-minute talk I gave back then, in which I stress the linear-logical roots of the LSC in a way that is not done in any paper I am aware of (including our own!).</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"3k9UlpgXt0M\" href=\"https://www.youtube.com/watch?v=3k9UlpgXt0M\"><img src=\"https://uploads.zulipusercontent.net/868c51c40f3bfb0553b02ed60ecc44c052b46c99/68747470733a2f2f692e7974696d672e636f6d2f76692f336b39556c70675874304d2f64656661756c742e6a7067\"></a></div><p>On the downside, our ICFP 2014 paper has basically no result about the rewriting theory of the LSC itself.  Those may be found in Beniamino's <a href=\"https://drive.google.com/file/d/1LaiJu6uSbOiDCunSdCZGZwqkGzfoGhFB/view\">RTA 2012 paper</a>, which is where the LSC was first introduced (in Sect. 7), but it's probably too technical to be a first introduction.  I know that Beniamino gave several excellent talks on the LSC, but unfortunately none seems to have been recorded and made available on the web :-(  If I find one, I'll point it out here.</p>",
        "id": 250676938,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1629922869
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Valeria.20de.20Paiva.3A.20.22Categorical.20Explicit.20Substitutions.22/near/250634909\">said</a>:</p>\n<blockquote>\n<p>Also, I wonder whether you are aware of any work explicitly relating ES to NbE?</p>\n</blockquote>\n<p>No, I am not.   If you do find anything, please let me know.  Maybe it'll be the time I finally understand NbE! :-)</p>",
        "id": 250677120,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1629922956
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Valeria.20de.20Paiva.3A.20.22Categorical.20Explicit.20Substitutions.22/near/250622539\">said</a>:</p>\n<blockquote>\n<p>It's intriguing, then, that there are <em>two</em> different applications of linear logic to lambda-calculus reduction.</p>\n</blockquote>\n<p>Well, the situation is something like this:</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">b</mi><mi mathvariant=\"normal\">d</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">l</mi><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">u</mi><mi mathvariant=\"normal\">l</mi><mi mathvariant=\"normal\">u</mi><mi mathvariant=\"normal\">s</mi></mrow><mo>⟶</mo><mrow><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">C</mi></mrow><mo>⟶</mo><mrow><mi mathvariant=\"normal\">P</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">f</mi><mi mathvariant=\"normal\">N</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">s</mi></mrow><mo>⇢</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">h</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">g</mi><mi mathvariant=\"normal\">G</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">h</mi><mi mathvariant=\"normal\">s</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathrm{LambdaCalculus} \\longrightarrow \\mathrm{LSC} \\longrightarrow \\mathrm{ProofNets} \\dashrightarrow \\mathrm{SharingGraphs}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.70544em;vertical-align:-0.011em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">LambdaCalculus</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟶</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69433em;vertical-align:-0.011em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">LSC</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟶</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">ProofNets</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⇢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">SharingGraphs</span></span></span></span></span></p>\n<p>where each item is a category whose objects are terms (or nets/graphs) and whose arrows are reduction sequences (so they are all free categories).  The arrows are functors, while the dashed arrow is not, it's just a function from objects to objects, but with some kind of simulation property, modulo that \"decompression\" I was talking about previously.</p>\n<p>In fact, if you equip <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{LSC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">LSC</span></span></span></span></span> with non-identity isomorphisms corresponding to structural equivalence (along the lines of our ICFP 2014 paper), and if you are careful with how you formulate proof nets (for one thing, they should be intuitionistic), then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">C</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"normal\">P</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">f</mi><mi mathvariant=\"normal\">N</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">s</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathrm{LSC}\\rightarrow\\mathrm{ProofNets}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">LSC</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">ProofNets</span></span></span></span></span> is an equivalence (it should be possible to do things so that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">P</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">f</mi><mi mathvariant=\"normal\">N</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">s</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{ProofNets}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">ProofNets</span></span></span></span></span> is the skeleton of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{LSC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">LSC</span></span></span></span></span>, that's the whole idea of proof nets).</p>\n<p>What I was suggesting is that you could probably use \"rewriting at a distance\" to replace sharing graphs with an equivalent term calculus <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">h</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">g</mi><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">s</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{SharingTerms}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">SharingTerms</span></span></span></span></span>, and you would get</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">b</mi><mi mathvariant=\"normal\">d</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">l</mi><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">u</mi><mi mathvariant=\"normal\">l</mi><mi mathvariant=\"normal\">u</mi><mi mathvariant=\"normal\">s</mi></mrow><mo>⟶</mo><mrow><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">C</mi></mrow><mo>⇢</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">h</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">g</mi><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">s</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathrm{LambdaCalculus} \\longrightarrow \\mathrm{LSC} \\dashrightarrow \\mathrm{SharingTerms}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.70544em;vertical-align:-0.011em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">LambdaCalculus</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟶</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">LSC</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⇢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">SharingTerms</span></span></span></span></span></p>\n<p>So the two applications you are talking about (if I understand correctly) result from the existence of the first functor, for one, and the composition of that functor with the optimal reduction map, for the other.</p>",
        "id": 250680568,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1629924686
    },
    {
        "content": "<p>Of course the functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">b</mi><mi mathvariant=\"normal\">d</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">l</mi><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">u</mi><mi mathvariant=\"normal\">l</mi><mi mathvariant=\"normal\">u</mi><mi mathvariant=\"normal\">s</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">C</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathrm{LambdaCalculus}\\to\\mathrm{LSC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">LambdaCalculus</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">LSC</span></span></span></span></span> is very special.  It maps every object to \"itself\", because each <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-term is in particular a term of the LSC.  It is trivially faithful but it is certainly not full as I stated things, because there's lots of reduction sequences in LSC which differ just by the order in which ES rules substituting on different occurrences of the same variable are applied, and these should all be equated. The functor just picks one particular order.  It would be interesting to see if, once the category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{LSC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">LSC</span></span></span></span></span> is properly formulated, the functor actually becomes fully faithful (intuitively, it seems like it should be).</p>",
        "id": 250682647,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1629925563
    },
    {
        "content": "<p>Unfortunately, though, the good properties of the LSC do not seem to be expressible in terms of the functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">b</mi><mi mathvariant=\"normal\">d</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">l</mi><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">u</mi><mi mathvariant=\"normal\">l</mi><mi mathvariant=\"normal\">u</mi><mi mathvariant=\"normal\">s</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">C</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathrm{LambdaCalculus}\\to\\mathrm{LSC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">LambdaCalculus</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">LSC</span></span></span></span></span>.  For example, it is unclear how one would state preservation of strong normalization (some kind of op-lifting property?).  So maybe this is more of a way of visualizing the situation than anything of actual technical value.</p>",
        "id": 250683754,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1629926029
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276030\">@Cody Roux</span> what I originally said was:</p>\n<blockquote>\n<p>Another odd thought I had today is that explicit substitutions seem a little bit related to normalization by evaluation.  If we think of the \"evaluation in an environment\" step of NbE as pushing a multiple explicit substitution through a term, and give rules saying that it gets stuck when it hits an abstraction and doesn't go further in until the abstraction is applied, at which point it gets augmented by the term being substituted (which could be a variable at readback time).</p>\n</blockquote>",
        "id": 250683991,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629926150
    },
    {
        "content": "<p>This connection seems even stronger with LSC, where the original ES rule for pushing substitutions inside abstractions, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>t</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">[</mo><mi>y</mi><mo>↦</mo><mi>u</mi><mo stretchy=\"false\">]</mo><mo>⇝</mo><mi>λ</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>t</mi><mo stretchy=\"false\">[</mo><mi>y</mi><mo>↦</mo><mi>u</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\"> (\\lambda x. t)[y \\mapsto u] \\leadsto \\lambda x. t[y\\mapsto u]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⇝</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mclose\">]</span></span></span></span> is replaced by the rule for \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction at a distance\" <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>t</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">[</mo><mover accent=\"true\"><mi>y</mi><mo>⃗</mo></mover><mo>↦</mo><mover accent=\"true\"><mi>u</mi><mo>⃗</mo></mover><mo stretchy=\"false\">]</mo><mi>v</mi><mo>⇝</mo><mi>t</mi><mo stretchy=\"false\">[</mo><mi>x</mi><mo>↦</mo><mi>v</mi><mo separator=\"true\">,</mo><mover accent=\"true\"><mi>y</mi><mo>⃗</mo></mover><mo>↦</mo><mover accent=\"true\"><mi>u</mi><mo>⃗</mo></mover><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(\\lambda x.t)[\\vec{y}\\mapsto \\vec{u}] v \\leadsto t[x\\mapsto v, \\vec{y}\\mapsto \\vec{u}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mopen\">[</span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.17994em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">u</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.20772em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class=\"mclose\">]</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⇝</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9084399999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.17994em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">u</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.20772em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>.</p>",
        "id": 250684414,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629926323
    },
    {
        "content": "<p>That is, a substituted lambda <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>t</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">[</mo><mover accent=\"true\"><mi>y</mi><mo>⃗</mo></mover><mo>↦</mo><mover accent=\"true\"><mi>u</mi><mo>⃗</mo></mover><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(\\lambda x.t)[\\vec{y}\\mapsto \\vec{u}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mopen\">[</span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.17994em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">u</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.20772em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>, which if I understand correctly doesn't reduce further in LSC until it is applied, seems closely analogous to the \"defunctionalized closures\" that appear as the result of evaluating a lambda in some environment in NbE.</p>",
        "id": 250684642,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629926414
    },
    {
        "content": "<p>How much of the LSC has been formalized in a proof assistant? I'd be curious to see how much pain the various things that are hand-waved away in the usual paper presentations cause.</p>",
        "id": 250687592,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1629928034
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296322\">Jacques Carette</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Valeria.20de.20Paiva.3A.20.22Categorical.20Explicit.20Substitutions.22/near/250687592\">said</a>:</p>\n<blockquote>\n<p>How much of the LSC has been formalized in a proof assistant? I'd be curious to see how much pain the various things that are hand-waved away in the usual paper presentations cause.</p>\n</blockquote>\n<p>I'm going to ask Beniamino about this, I honestly don't know.</p>\n<p>My knowledge of proof assistants is very limited, but one time I did team up with a Coq expert in my lab (Micaela Mayero, who works on formalizing real numbers, floating point arithmetic, correctness of programs for numerical analysis, etc., so very far from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus and rewriting) and supervised an undergrad project in which a couple of students formalized (in Coq) the proof of the so-called IE property (implicit-explicit) of the LSC, something that implies preservation of strong normalization via a general, abstract argument due to Delia Kesner (Valeria briefly mentioned this in her talk).  On paper, the proof is a couple of pages long, including the preliminary definitions.  I'm not sure it was much harder than formalizing an average rewriting result about the pure <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus (Micaela certainly wasn't shocked by the amount of work it took).</p>\n<p>I remember that some inductions, intuitively trivial on paper, did become a bit tricky to formalize because of the non-locality of reduction rules in the LSC (e.g. the fact that a redex in the LSC has the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>M</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">[</mo><mo>−</mo><mo stretchy=\"false\">]</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">(\\lambda x.M)[-]N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span><span class=\"mopen\">[</span><span class=\"mord\">−</span><span class=\"mclose\">]</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mo>−</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[-]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">−</span><span class=\"mclose\">]</span></span></span></span> is an arbitrarily long sequence of explicit substitutions).  But I don't think it would be anything scary for someone used to formalizing programming languages.</p>",
        "id": 250724664,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1629955964
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276839\">Damiano Mazza</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Valeria.20de.20Paiva.3A.20.22Categorical.20Explicit.20Substitutions.22/near/250682647\">said</a>:</p>\n<blockquote>\n<p>It would be interesting to see if, once the category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{LSC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">LSC</span></span></span></span></span> is properly formulated, the functor actually becomes fully faithful (intuitively, it seems like it should be).</p>\n</blockquote>\n<p>I said something very silly here, sorry.  The functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">b</mi><mi mathvariant=\"normal\">d</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">l</mi><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">u</mi><mi mathvariant=\"normal\">l</mi><mi mathvariant=\"normal\">u</mi><mi mathvariant=\"normal\">s</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">C</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathrm{LambdaCalculus}\\to\\mathrm{LSC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">LambdaCalculus</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">LSC</span></span></span></span></span> <em>cannot</em> be full, because of the presence of reduction sequences in the LSC that are not mere simulations of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reductions, of course.  For example, in the LSC we can do call-by-need, which does not correspond to any reduction strategy in the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus.</p>",
        "id": 250725102,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1629956342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Valeria.20de.20Paiva.3A.20.22Categorical.20Explicit.20Substitutions.22/near/250634909\">said</a>:</p>\n<blockquote>\n<p>Also, I wonder whether you are aware of any work explicitly relating ES to NbE?</p>\n</blockquote>\n<p>It is well-known that ES are related to abstract machines, so I looked for a relationship between abstract machines and NbE.   I found <a href=\"https://tidsskrift.dk/brics/article/download/21783/19214\">this paper</a>.  In Sect. 2.1, they start from a call-by-name \"evaluator\" and, via successive steps (closure conversion, CPS, defunctionalization), derive the Krivine abstract machine from it.  In Sect. 2.2, they start from a call-by-value machine (the CEK), apply (the inverse of) those steps in reverse order, and obtain an \"evaluator\" for call-by-value.  In the rest of the paper, they do the same for other machines.</p>\n<p>Now, I am not familiar enough with NbE to be sure that the \"evaluators\" they talk about are actually implementing NbE.  It looks like they do, as <a href=\"https://arxiv.org/pdf/2009.06984.pdf\">this other paper</a> seems to confirm: it cites the first paper and explicitly claims that the transformations of that paper extract \"NbE functions\" from abstract machines.</p>\n<p>So NbE and ES may actually be related after all, by means of this two-way transformation and the correspondence of ES with abstract machines.  But maybe I'm wrong.</p>",
        "id": 250729314,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1629959579
    },
    {
        "content": "<p>Thanks!  More good reading.</p>",
        "id": 250981113,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630091661
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276839\">@Damiano Mazza</span>, I've taken the liberty of adding some of your remarks to the nLab page on <a href=\"https://ncatlab.org/nlab/show/explicit+substitution\">explicit substitutions</a>, so that they won't be lost in this conversation history.  Please edit further if you like!</p>",
        "id": 250983974,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630092956
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276839\">Damiano Mazza</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Valeria.20de.20Paiva.3A.20.22Categorical.20Explicit.20Substitutions.22/near/250729314\">said</a>:</p>\n<blockquote>\n<p>Now, I am not familiar enough with NbE to be sure that the \"evaluators\" they talk about are actually implementing NbE.  It looks like they do, as <a href=\"https://arxiv.org/pdf/2009.06984.pdf\">this other paper</a> seems to confirm: it cites the first paper and explicitly claims that the transformations of that paper extract \"NbE functions\" from abstract machines.</p>\n</blockquote>\n<p>On a quick glance, this looks right to me.  It seems the significant difference here is that a mere \"evaluator\", which the first paper shows to correspond to the KAM, implements <em>weak</em> (head) reduction (not going under lambdas).   Whereas \"normalization by evaluation\" is a method for <em>strong</em> reduction (including going under lambdas), and this second paper shows it to correspond similarly to an abstract machine \"KN\" for strong reduction.</p>",
        "id": 250992603,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630096934
    },
    {
        "content": "<p>I'm surprised at how many of these papers about abstract machines use de Bruijn indices (or levels) literally.  It makes them very hard for me to read.  I was pleased that your ICPF paper \"Distilling abstract machines\" not only used named variables but was explicit about how <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span>-equivalence is implemented in the machines.  Do you know of any papers describing an abstract machine for strong reduction that use named variables?</p>",
        "id": 250992922,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630097076
    },
    {
        "content": "<p>well, we have also a paper \"On Explicit Substitution and Names \" presented at ICALP'97. which is about having both names and de Bruijn variables, both typed and untyped lambda-calculus, calculus for type theory vs calculus for implementations <a href=\"https://www.researchgate.net/publication/2505679_On_Explicit_Substitutions_and_Names\">https://www.researchgate.net/publication/2505679_On_Explicit_Substitutions_and_Names</a></p>",
        "id": 250994668,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630097965
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276839\">@Damiano Mazza</span>  said:</p>\n<blockquote>\n<p>With 30 years of hindsight, I think that trying to \"fix\" explicit substitution (ES) systems so that they preserve SN was not a \"wrong goal\", because it ended up pushing the development of better behaved ES calculi in all respects, not just SN.</p>\n</blockquote>\n<p>well, I do think it was the wrong goal, because as you said my direction is different:  all this so-called 'better behaved' ES calculi have no semantics, so they are not better behaved in my books! Syntax is an unruly beast, clever people will do all sorts of weird things with it. We use categorical semantics to make sure that we're not creating monsters.</p>",
        "id": 251007518,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630105469
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276839\">@Damiano Mazza</span> said</p>\n<blockquote>\n<p>Cut-elimination in proof nets has the amazing property (from the rewriting viewpoint) that it does not need commuting conversions.</p>\n</blockquote>\n<p>indeed, this is one reason why Girard created proof nets. But I do not agree with</p>\n<blockquote>\n<p>Explicit substitutions should behave like boxes in proof nets: </p>\n</blockquote>\n<p>because I do not think you need to use a specific proof system (proof nets) to reason about syntax in general. You should be able to stick to lambda-calculus, if you prefer. Or sequent calculus or Natural Deduction or deep inference; whatever floats your boat really. in my case, category theory is the preferred semantics.  and so I'm very happy to hear that</p>\n<blockquote>\n<p>I am \"some of us\"! :-) </p>\n</blockquote>\n<p>Yay! Thanks for the several suggestions of  avenues to pursue!</p>",
        "id": 251010341,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630107618
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Valeria.20de.20Paiva.3A.20.22Categorical.20Explicit.20Substitutions.22/near/250992922\">said</a>:</p>\n<blockquote>\n<p>Do you know of any papers describing an abstract machine for strong reduction that use named variables?</p>\n</blockquote>\n<p>There's a whole line of work by Beniamino Accattoli and coauthors on machines for strong reduction, none of which uses de Bruijn indices (he's a rather fierce opponent of them :-) ).  The starting point was <a href=\"https://drive.google.com/file/d/1uAwUdYaMH-aNcPdoBOjuAT3mdBp7H-Sl/view\">our paper</a> on an abstract machine for leftmost-outermost reduction (which may be seen as a global-environment version of Crégut's \"KN\" machine mentioned above), and then there are machines for <a href=\"https://drive.google.com/file/d/16HEorzyV3RpPCdtUqtD_g891PQPPKFPU/view\">strong useful reduction</a> and <a href=\"https://drive.google.com/file/d/1IMPe6LO1dVZhLxSTW96aARy3PHbHWxYC/view\">strong call by value</a>.  The development of a machine for strong call by need, which, morally, would be an abstraction of what Coq does, is still underway (as far as I know).  There's also a <a href=\"https://drive.google.com/file/d/1lx9EczOJLy__2xd9MHDAKwPRV5azCIxZ/view\">nice paper</a> comparing \"global environment\" to \"local environment\" machines, for weak as well as for strong evaluation.  The upshot is that the latter, although a bit more complex to formulate, are more efficient for weak reduction, but the advantage disappears for strong reduction, where they are asymptotically equivalent.</p>",
        "id": 251038209,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1630137427
    },
    {
        "content": "<p>All of these machines \"distill\" to a strong reduction strategy of the LSC, in a way which asymptotically preserves complexity, so, for many purposes, studying them or the corresponding LSC strategy is essentially the same thing.</p>",
        "id": 251038578,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1630137810
    },
    {
        "content": "<p>Thanks all for the nice discussion and to <span class=\"user-mention\" data-user-id=\"276839\">@Damiano Mazza</span> for pinging me!</p>\n<ul>\n<li>The rewriting-at-a-distance methodology has a little-known precursor called destruct-time <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus, see, e.g., the (app) rule in Fig. 2 of <a href=\"https://www.cl.cam.ac.uk/~pes20/jfp2008.pdf\">Sewell et al.</a></li>\n<li>About entry points to LSC: Beniamino gave a very nice <a href=\"https://drops.dagstuhl.de/opus/volltexte/2019/10508/\">invited talk</a> at FSCD '19.</li>\n<li>A slight correction to one of <span class=\"user-mention\" data-user-id=\"276656\">@Valeria de Paiva</span>'s claims: one of Delia Kesner's many calculi with explicit substitutions is covered in <a href=\"https://dl.acm.org/doi/10.1145/3371099\">Reduction monads and their signatures</a> (and <span class=\"user-mention\" data-user-id=\"276696\">@Ambroise</span>'s <a href=\"https://github.com/amblafont/thesis/raw/master/main.pdf\">thesis</a>).</li>\n<li>I don't have much to add to <span class=\"user-mention\" data-user-id=\"276839\">@Damiano Mazza</span>'s excellent exposition, as my recent work focuses on going beyond rewriting to more general operational semantics (e.g., covering languages in which evaluation may not occur anywhere in the term).</li>\n</ul>",
        "id": 251208239,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1630318219
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"383799\">@Tom Hirschowitz</span>!  I didn't know that invited paper by Beniamino, it really is a great entry point to the LSC (certainly much better than our ICFP 2014 paper, which, in comparison, is way too technical and biased towards abstract machines).</p>",
        "id": 251216742,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1630323835
    },
    {
        "content": "<p>Thanks   <span class=\"user-mention\" data-user-id=\"383799\">@Tom Hirschowitz</span>  for the extra information!</p>\n<blockquote>\n<ul>\n<li>A slight correction to one of <span class=\"user-mention silent\" data-user-id=\"276656\">Valeria de Paiva</span>'s claims: one of Delia Kesner's many calculi with explicit substitutions is covered in <a href=\"https://dl.acm.org/doi/10.1145/3371099\">Reduction monads and their signatures</a> (and <span class=\"user-mention silent\" data-user-id=\"276696\">Ambroise</span>'s <a href=\"https://github.com/amblafont/thesis/raw/master/main.pdf\">thesis</a>).</li>\n</ul>\n</blockquote>\n<p>It's good to see some initial semantics for a variant of explicit substitutions  in Dec 2019!  <br>\nBut no mention of the old work and no ability to deal with dependent type theory--if I'm reading it right.<br>\nI only looked at Ambroise Lafont's thesis slides in <a href=\"https://raw.githubusercontent.com/amblafont/these-slides/master/slides.pdf\">https://raw.githubusercontent.com/amblafont/these-slides/master/slides.pdf</a> so far. Meanwhile our approach deals with Calculus of Constructions, modal type theory, linear type and lambda sigma.</p>",
        "id": 251243579,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630336028
    },
    {
        "content": "<p>If I can go back to the original subject of your talk, <span class=\"user-mention\" data-user-id=\"276656\">@Valeria de Paiva</span>, and ask a dumb question: in what sense are the indexed-category models more closely related to <em>explicit</em> substitutions than other models such as CCCs?  In both cases there is an operation in the categorical semantics, call it cartesian restriction or composition, that corresponds to substitution in the syntax, and I don't understand how either form of semantics can \"see\" whether the substitution is explicit or implicit.</p>",
        "id": 251246735,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630337304
    },
    {
        "content": "<p>not a dumb question at all. and I'm getting out of my comfort zone here, but indeed you do have  mechanisms in the indexed category model to track composition and application of substitutions. these are different operations denoted by \";\" (for composition of substitutions) and * for application of a substitution to a term, so the syntax (and the abstract machine) can see whether a substitution is indeed explicit or not. </p>\n<p>the point is always to make the correspondence between the syntax and cat semantics the most explanatory that we can. <br>\nI thought the bit in the paper about intensional notions of substitution would appeal to you, as we say</p>\n<blockquote>\n<p>The situation would be analogous to the intensionality of function spaces: In the same way as t wo functions are not<br>\nintensionally equal if they produce the same result when applied to the same arguments, two substitutions are not intensionally equal if applied to the same variable they produce the same result.</p>\n</blockquote>",
        "id": 251253456,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630340113
    },
    {
        "content": "<p>I don't see how separating the <em>operations</em> of composition and substitution has anything to do with whether those operations are explicit or implicit.</p>",
        "id": 251261860,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630343664
    },
    {
        "content": "<p>Put differently, in an explicit substitution calculus the terms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo stretchy=\"false\">[</mo><mi>x</mi><mo>↦</mo><mi>N</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">M[x\\mapsto N]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">]</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo stretchy=\"false\">⟨</mo><mi>x</mi><mo>↦</mo><mi>N</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">M\\langle x\\mapsto N\\rangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">⟩</span></span></span></span> are distinct.  Are there corresponding <em>distinct</em> objects in the indexed-category semantics?</p>",
        "id": 251261868,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630343667
    },
    {
        "content": "<p>Put differently again, ordinary categorical semantics is already quotiented by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction.  An ES calculus augments the terms with extra constructors, but also augments the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction with new rewrites that get rid of those extra constructors.  So how can its semantics be any different?</p>",
        "id": 251261995,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630343723
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo stretchy=\"false\">[</mo><mi>x</mi><mo>↦</mo><mi>N</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">M[x\\mapsto N]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">]</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo stretchy=\"false\">⟨</mo><mi>x</mi><mo>↦</mo><mi>N</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">M\\langle x\\mapsto N\\rangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">⟩</span></span></span></span> are distinct.  <br>\nAre you writing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo stretchy=\"false\">[</mo><mi>x</mi><mo>↦</mo><mi>N</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">M[x\\mapsto N]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">]</span></span></span></span> for the implicit substitution? if so, It's not part of the calculus, right? hence it's not in the model.</p>\n<p>composition of explicit subs happens in the base category, while application of a subst to a term happens in the fibres, so two different cats.</p>",
        "id": 251270689,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630347352
    },
    {
        "content": "<p>Let me put the question in different terms.  If I understand correctly (and by that I mean both Mike's question and Valeria's talk, so I could be doubly wrong :-) ), if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a closed normal form, then the interpretation of both <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo stretchy=\"false\">⟨</mo><mi>x</mi><mo>↦</mo><mi>M</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">x\\langle x\\mapsto M\\rangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">⟩</span></span></span></span> and of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> itself are arrows in the fiber above (the interpretation of) the empty context.  Now, since these two terms rewrite one into the other, these interpretations must actually coincide.  Right?</p>",
        "id": 251293013,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1630356643
    },
    {
        "content": "<p>Right! in the empty context you only do what you can do in CCCs. There, on the fibre over 1,  you can recover all your traditional CCC modelling,  you don't lose anything that you had before. but you do have all your other fibres, right?</p>",
        "id": 251294315,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630357232
    },
    {
        "content": "<p>If that's the case, then I think I understand a bit better what's going on in this categorical semantics.  The difference with respect to an ordinary categorical model of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus is that we are explicitly interpreting substitutions: they are arrows of a base category, whose objects are contexts.  Composition in the base category, like Valeria said, is composition of substitutions.</p>\n<p>The arrows in the fiber above a context are terms with free variables corresponding to that context.  A substitution <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi><mo>:</mo><mi mathvariant=\"normal\">Γ</mi><mo>→</mo><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma:\\Gamma\\to\\Delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Δ</span></span></span></span> induces a map from terms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> with free variables in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Δ</span></span></span></span> to terms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">M\\sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span> with free variables in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Γ</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">M\\sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> to which the substitution <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span> has actually been applied, <em>not</em> the term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo stretchy=\"false\">⟨</mo><mi>σ</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">M\\langle\\sigma\\rangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mclose\">⟩</span></span></span></span> containing an explicit substitution.  Well, I mean, it is <em>also</em> that term, because they have the same interpretation, but I hope you see what I want to say.  For example, the substitution <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><mi>x</mi><mo>↦</mo><mi>M</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">\\langle x\\mapsto M\\rangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">⟩</span></span></span></span> maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>.</p>\n<p>Now, if I am not mistaken, this means that while this semantics certainly gives categorical status to the <em>operation of substitution</em>, it is still the ordinary, \"implicit\" notion of substitution that we are talking about here.  Of course, as Mike was pointing out, it is difficult to imagine something different because calculi with explicit substitutions have exactly the same normal forms as calculi without them, so their categorical semantics cannot be different.  Going back to what we were saying before about categories and rewriting, I think that only an explicit treatment of reductions (perhaps as higher arrows) can show the difference between something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo stretchy=\"false\">⟨</mo><mi>x</mi><mo>↦</mo><mi>M</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">x\\langle x\\mapsto M\\rangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">⟩</span></span></span></span>.</p>",
        "id": 251295742,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1630357880
    },
    {
        "content": "<p>In particular, although it is of course interesting to have pinned down what substitution is categorically, I do not see how this treatment may be helpful in <em>designing</em> calculi with explicit substitutions, in the sense of guiding us towards the \"right\" reduction rules, because these are invisible in the semantics.  Or am I missing something?</p>",
        "id": 251296304,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1630358151
    },
    {
        "content": "<p>Yes, <span class=\"user-mention\" data-user-id=\"276839\">@Damiano Mazza</span>, that's exactly what I was saying.  Thanks for putting it more explicitly.</p>",
        "id": 251301289,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630360703
    },
    {
        "content": "<p>I think you're missing <span class=\"user-mention\" data-user-id=\"276839\">@Damiano Mazza</span>  that you can also pinpoint in the semantics where there are  syntax design choices that you should consider and where they don't make sense. This is what I meant by category theory  as a debugging tool for syntax. and sure, having a theory of reductions that can be higher-order would be great, but the level we have them is already a compromise!</p>",
        "id": 251308171,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630364620
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276656\">Valeria de Paiva</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Valeria.20de.20Paiva.3A.20.22Categorical.20Explicit.20Substitutions.22/near/251243579\">said</a>:</p>\n<blockquote>\n<p>But no mention of the old work[...].  [N]o ability to deal with dependent type theory--if I'm reading it right.<br>\n[...] Meanwhile our approach deals with Calculus of Constructions, modal type theory, linear type and lambda sigma.</p>\n</blockquote>\n<p>Well, that's a bit tough: Section 1.1 is devoted to related work. Maybe it was aggressive to say I was correcting your claim, not at all my intention, sorry about that if it's the case!</p>\n<p>The two lines of work are indeed only loosely connected, for two main reasons. </p>\n<ul>\n<li>\n<p>If I understand correctly, you consider languages one at a time, and for each language you carefully design a category of models, which you try to make as canonical and legit as possible. (This is what you mean by \"avoid creating monsters\".) And in all cases, you use the same kind of categorical structures, which gives unity to (this part of) your work. Is this more or less right? <span class=\"user-mention\" data-user-id=\"276696\">@Ambroise</span> et al., on the other hand, do not worry about creating monsters: they propose a notion of signature for specifying programming languages -- and some signatures certainly do create monsters.</p>\n</li>\n<li>\n<p>Moreover, you're right that linearity and type dependency are not covered by their framework (neither is simple typing, for that matter, but that has been done now). The point here is that the linguistic focus is different: you seem to be mainly interested in logical calculi (and indeed you mention implementation of proof assistants during the talk), while <span class=\"user-mention\" data-user-id=\"276696\">@Ambroise</span> et al. are interested in programming languages. Typically, this means languages where reductions may not occur anywhere in the term. </p>\n</li>\n</ul>\n<p>That said, it is certainly desirable to find notions of signatures covering both wild programming languages and logical calculi, including type dependency and linearity! E.g., it would be nice to be able to specify the ML language with a signature, including polymorphic types and the module language. I don't know how to do this for now. Maybe <span class=\"user-mention\" data-user-id=\"358258\">@Daniel Gratzer</span> and  <span class=\"user-mention\" data-user-id=\"297784\">@Jonathan Sterling</span> do?</p>",
        "id": 251337325,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1630390598
    },
    {
        "content": "<p>Ok, thanks everyone for helping me understand!  At this point, I think it's worth observing that the indexed category semantics is not particularly tied to the original <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda\\sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">λσ</span></span></span></span>-calculus approach to explicit substitutions (ES).  It applies just as well (or so it seems to me) to any ES calculus which is consistent with equivalences such as</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo stretchy=\"false\">⟨</mo><mi>x</mi><mo>↦</mo><mi>N</mi><mo stretchy=\"false\">⟩</mo><mo stretchy=\"false\">⟨</mo><mi>y</mi><mo>↦</mo><mi>P</mi><mo stretchy=\"false\">⟩</mo><mo>≡</mo><mi>M</mi><mo stretchy=\"false\">⟨</mo><mi>x</mi><mo>↦</mo><mi>N</mi><mo stretchy=\"false\">⟨</mo><mi>y</mi><mo>↦</mo><mi>P</mi><mo stretchy=\"false\">⟩</mo><mo stretchy=\"false\">⟩</mo><mspace width=\"1em\"/><mtext>if </mtext><mi>y</mi><mtext> is not free in </mtext><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M\\langle x\\mapsto N\\rangle\\langle y\\mapsto P\\rangle\\equiv M\\langle x\\mapsto N\\langle y\\mapsto P\\rangle\\rangle\\quad\\text{if }y\\text{ is not free in }M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">⟩</span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">⟩</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">⟩⟩</span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord text\"><span class=\"mord\"> is not free in </span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span><br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo stretchy=\"false\">⟨</mo><mi>x</mi><mo>↦</mo><mi>N</mi><mo stretchy=\"false\">⟩</mo><mo stretchy=\"false\">⟨</mo><mi>y</mi><mo>↦</mo><mi>P</mi><mo stretchy=\"false\">⟩</mo><mo>≡</mo><mi>M</mi><mo stretchy=\"false\">⟨</mo><mi>y</mi><mo>↦</mo><mi>P</mi><mo stretchy=\"false\">⟩</mo><mo stretchy=\"false\">⟨</mo><mi>x</mi><mo>↦</mo><mi>N</mi><mo stretchy=\"false\">⟩</mo><mspace width=\"1em\"/><mtext>if </mtext><mi>y</mi><mtext> is not free in </mtext><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M\\langle x\\mapsto N\\rangle\\langle y\\mapsto P\\rangle\\equiv M\\langle y\\mapsto P\\rangle\\langle x\\mapsto N\\rangle\\quad\\text{if }y\\text{ is not free in }N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">⟩</span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">⟩</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">⟩</span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">⟩</span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord text\"><span class=\"mord\"> is not free in </span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></p>\n<p>(I haven't checked exactly which equivalences are needed, but the above certainly are, because they result from the assumption that substitutions form a finite product category).</p>\n<p>By \"consistent\" I do not mean that the ES calculus must implement those equivalences as rewriting.  For example, the LSC does not, but it is compatible with them (they are included in so-called \"structural congruence\").  So I have to correct my previous statement that the LSC has no categorical semantics: it does, at least in the sense of indexed categories! :-)</p>",
        "id": 251340002,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1630392672
    },
    {
        "content": "<p>Going back to references and formalization, I asked Beniamino and he confirms that:</p>\n<ul>\n<li><a href=\"https://drive.google.com/file/d/1Ig9Rpv0kjKtJlwEObZBQoGyQ5iJkkVq3/view\">his invited paper</a> to FSCD 2019, previously mentioned by Tom, is the best entry point.  He also suggests <a href=\"https://drive.google.com/file/d/186p9cil5tDDhIInxi20zwRa0EHP4LcdI/view\">the slides</a> of a graduate course he taught, although of course they are less self-explanatory and less self-contained (they occasionally refer to other parts of the course).</li>\n<li>Not much has been done in terms of formalizing the LSC.  Apart from my personal (very limited) experience in Coq, he knows of another LSC-related formalization, concerning Milner's translation of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus in the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span>-calculus (<a href=\"https://drive.google.com/file/d/1wz--uuwHF1OHN8casyup0Yx07mOvNb-v/view\">this paper</a> explains what this has to do with the LSC).  This formalization is done in <a href=\"https://abella-prover.org/examples/index.html\">Abella</a>.  It's hard to compare with what one would need to do in, say, Coq, but again, the difficulties do not seem exceptional.</li>\n</ul>",
        "id": 251342112,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1630394144
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"383799\">@Tom Hirschowitz</span> In my experience the distinction between PL’s (that allow reduction only in some places) and type theories (that allow reduction everywhere) is more a methodological difference than a technical one. There is a somewhat reliable way to turn a “PL” in that sense into a congruent rewriting theory (and hence an equational theory): reformulate the PL as some machine calculus for which reductions are better understood. The implicit evaluation order of the PL becomes explicit… This is what I understand to be the “french style”, currently embodied in the work of Guillaume M-M and others. The limitations of this approach really only seem to arise when considering true nondeterminism and concurrency, but i am reluctant to see these as rewrites/equations anyway. </p>\n<p>For this reason, I have at least in my own work been quite comfortable abandoning evaluation order / operational semantics until I absolutely need it.</p>",
        "id": 251378985,
        "sender_full_name": "Jon Sterling",
        "timestamp": 1630414425
    },
    {
        "content": "<p>And of course, Levy’s call by push value is the beginning of this approach for me… I have been using that a lot lately to demolish evaluation order.</p>",
        "id": 251379199,
        "sender_full_name": "Jon Sterling",
        "timestamp": 1630414513
    },
    {
        "content": "<p>hi,</p>\n<blockquote>\n<p>Well, that's a bit tough: Section 1.1 is devoted to related work</p>\n</blockquote>\n<p>sometimes it's difficult to write what we mean. I meant 'no mention of <em>our</em> old work', not  non-mention of any  related work. Since I thought ours was the only model of explicit substitutions so far, it would make sense to google \"(categorical) model of explicit substitution\" and see what came up. But indeed, easier said than done, I'm totally guilty of not checking too. </p>\n<p>And no worries about correcting my claim: @Ambroise's work is certainly a counterexample to what I thought. While I do agree that </p>\n<blockquote>\n<p>The two lines of work are indeed only loosely connected</p>\n</blockquote>\n<p>@Ambroise's work is not what I think of, when I say \"categorical semantics\".</p>\n<blockquote>\n<p>And in all cases, you use the same kind of categorical structures, which gives unity to (this part of) your work. Is this more or less right?</p>\n</blockquote>\n<p>exactly! </p>\n<blockquote>\n<p>E.g., it would be nice to be able to specify the ML language with a signature, including polymorphic types and the module language. I don't know how to do this for now. </p>\n</blockquote>\n<p>By ML  you do mean  Standard ML the Milner, Gordon, et al  programming language <a href=\"https://en.wikipedia.org/wiki/ML_(programming_language)\">https://en.wikipedia.org/wiki/ML_(programming_language)</a>, correct? <br>\n I believe that Ritter did System F in his master's thesis \"eine kategorielle maschine fur den polymorphen lambda kalkul\" (but I don't read German).  also ML polymorphism is not the same as System F polymorphism, but still, it's a start.</p>",
        "id": 251409007,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630425231
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276839\">@Damiano Mazza</span> said</p>\n<blockquote>\n<p>(I haven't checked exactly which equivalences are needed, but the above certainly are, because they result from the assumption that substitutions form a finite product category).</p>\n</blockquote>\n<p>well, they form a finite product category in the case of the simply typed lambda-calculus . if you want to do linear lambda-calculus you need a tensor, not products, ie linear-handling-categories.</p>",
        "id": 251409877,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630425529
    },
    {
        "content": "<p>btw. As mike pointed out, every categorical model is a model of explicit substitution. So it is a little hard to know what it means for something to be the ‘only’ or the ‘first’. But maybe i am confused in the same way some other commenters were.</p>",
        "id": 251412763,
        "sender_full_name": "Jon Sterling",
        "timestamp": 1630426570
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276656\">Valeria de Paiva</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Valeria.20de.20Paiva.3A.20.22Categorical.20Explicit.20Substitutions.22/near/251409007\">said</a>:</p>\n<blockquote>\n<p>@Ambroise's work is not what I think of, when I say \"categorical semantics\".</p>\n</blockquote>\n<p>I agree with this.</p>\n<p>And on the other hand, your model is not what I think of when I say \"categorical operational semantics\". The thing generated by <span class=\"user-mention\" data-user-id=\"276696\">@Ambroise</span>'s signature is something like a graph internal to some category of modules. (Hence, to comment on <span class=\"user-mention\" data-user-id=\"297784\">@Jonathan Sterling</span>'s later post, the signatures and graphs with and without explicit substitutions are definitely distinct!)</p>\n<p>So in a sense you were right to ignore <span class=\"user-mention\" data-user-id=\"276696\">@Ambroise</span>'s work, <span class=\"user-mention\" data-user-id=\"276696\">@Ambroise</span> was right not to cite yours, and I was the only one wrong, as often, to talk before thinking hard enough.</p>\n<blockquote>\n<p>By ML  you do mean  Standard ML the Milner, Gordon, et al  programming language <a href=\"https://en.wikipedia.org/wiki/ML_(programming_language)\">https://en.wikipedia.org/wiki/ML_(programming_language)</a>, correct? <br>\n I believe that Ritter did System F in his master's thesis \"eine kategorielle maschine fur den polymorphen lambda kalkul\" (but I don't read German).  also ML polymorphism is not the same as System F polymorphism, but still, it's a start.</p>\n</blockquote>\n<p>Yes, I meant that ML. I agree that it's a start, and I also think Don Sannella had something about this question. But we're still quite far from a notion of signature that would be sufficiently expressive to generate ML, right?</p>",
        "id": 251415959,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1630427902
    },
    {
        "content": "<p>Can't find Sannella's account... Who was it then?</p>",
        "id": 251504284,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1630474340
    },
    {
        "content": "<p>Sorry, <span class=\"user-mention\" data-user-id=\"383799\">@Tom Hirschowitz</span> I don't know.</p>",
        "id": 251733315,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630596318
    }
]