[
    {
        "content": "<p>Thursday the 2nd of September, 17:00 UTC</p>\n<p><em>Abstract:</em><br>\nUniFormal is the idea of representing all aspects of knowledge uniformly, including narration, deduction, computation, and databases. Moreover, it means to abstract from the multitude of individual systems, which not only often focus on just one aspect but are doing so in mutually incompatible ways, thus creating a universal framework of formal knowledge.</p>\n<p>MMT is a concrete representation language to that end. It systematically abstracts from assumptions typically inherent in the syntax and semantics of concrete systems, and focuses on language-independence, modularity, and system interoperability. While constantly evolving in order to converge towards UniFormal, its design and implementation have become very mature. It is now a readily usable high-level platform for the design, analysis, and implementation of formal systems.</p>\n<p>This talk gives an overview of the current state of MMT, its existing successes and its future challenges.</p>\n<p>Zoom: <a href=\"https://topos-institute.zoom.us/j/5344862882\">https://topos-institute.zoom.us/j/5344862882</a><br>\nYouTube: <a href=\"https://youtu.be/uJ3psQ-Dkpw\">https://youtu.be/uJ3psQ-Dkpw</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"uJ3psQ-Dkpw\" href=\"https://youtu.be/uJ3psQ-Dkpw\"><img src=\"https://uploads.zulipusercontent.net/32d88f372d4d6436f310a449771542202e5e08a5/68747470733a2f2f692e7974696d672e636f6d2f76692f754a337073512d446b70772f64656661756c742e6a7067\"></a></div>",
        "id": 250814646,
        "sender_full_name": "Tim Hosgood",
        "timestamp": 1630001079
    },
    {
        "content": "<p>A reminder, this is in less than two hours, unless I made a big mistake in my hour calculations. (OTH delighted to discover after <span class=\"user-mention\" data-user-id=\"276037\">@Jade Master</span> 's talk that everyone else also feels paranoid about getting the times wrong!)</p>",
        "id": 251733576,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630596423
    },
    {
        "content": "<p>the countdown timer on the webpage should help to solve this problem somewhat! <a href=\"https://topos.site/topos-colloquium/\">https://topos.site/topos-colloquium/</a></p>",
        "id": 251746020,
        "sender_full_name": "Tim Hosgood",
        "timestamp": 1630601117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276656\">Valeria de Paiva</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Florian.20Rabe.3A.20.22MMT.3A.20A.20UniFormal.20approach.20to.20.5B.2E.2E.2E.5D.22/near/251733576\">said</a>:</p>\n<blockquote>\n<p>A reminder, this is in less than two hours, unless I made a big mistake in my hour calculations. (OTH delighted to discover after <span class=\"user-mention silent\" data-user-id=\"276037\">Jade Master</span> 's talk that everyone else also feels paranoid about getting the times wrong!)</p>\n</blockquote>\n<p>Yes! time zones are very confusing to me.</p>",
        "id": 251756096,
        "sender_full_name": "Jade Master",
        "timestamp": 1630604867
    },
    {
        "content": "<p>I'm glad you can just google things like \"6 pm UTC in California\" or \"10 pm California in England\".   However, if you're asking not about today but the future, you need to beware changes due to daylight savings time!</p>",
        "id": 251756811,
        "sender_full_name": "John Baez",
        "timestamp": 1630605133
    },
    {
        "content": "<p>I like subscribing to the researchseminars . org, which sticks it right into my google calendar, though I've been burned by this before. If it's not available, when I go to make a calendar event, I change the timezone for the event itself, and then set the time as it's presented in it's local time. For myself, I think this is the method least likely to screw up.</p>",
        "id": 251757614,
        "sender_full_name": "Joe Moeller",
        "timestamp": 1630605394
    },
    {
        "content": "<p>Hi.  I just watched on Youtube.  It's a very interesting though very challenging project.  I know from browsing major (at least operating system) widely used software projects like the Linux kernel that there is an enormous amount of code to detect what version or quirk an external component (hardware or software or firmware), and either adapt to it or fail with an incompatibility warning.  The Linux kernel build system also uses a wide-ranging configuration user input system that restricts or automatically makes future configuration choices based on what was inputted or automatically made before.  Developers must maintain their subsystems' configuration script in addition to its code.  Configuration responses are often implemented  by conditional inclusion of code.   Such systems evolved out of a long lineage of beginning with build step economizers (Unix make was probably the first general tool for this, in the Java world, this kind of tool is called ant.) and continuing with combinations of tools such as GNU autotools.  </p>\n<p>So I would think that surveying such technologies and corresponding software engineering research (not just C/Linux and GNU!) may give some clues for your project.  Particularly what to do about users making inconsistent choices of things to combine.</p>\n<p>However, after looking at the MTT web site I now understand (perhaps) that the various formalizations and their implementations are recoded.  In which case no interface is used to externally supplied systems.</p>",
        "id": 251925752,
        "sender_full_name": "Seth Chaiken",
        "timestamp": 1630694850
    },
    {
        "content": "<p>Just watched the video.  I'm very much in sympathy with the idea of doing all the peripheral stuff \"once and for all\"; it's been a frustration for me for a long time that every new type theory seems to have to be implemented from the ground up.  However, what I really want when I'm experimenting with a new type theory is a proof assistant for it, so it's disappointing to me to hear you say that MMT is not a proof assistant.  But you did mention that you have a general algorithm for type inference and solving implicit arguments.  What in particular do you have in mind that's lacking when you say that MMT is not a proof assistant?  If I have a new type theory that I want to play around with, and I implement it in MMT and try to use MMT as a proof assistant, what will I feel is missing as compared to using a \"real\" proof assistant?  Is it methods for progressive construction of terms, like tactics in Coq or holes in Agda?</p>",
        "id": 251937522,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630700858
    },
    {
        "content": "<p>Hmm, actually, is Florian on this Zulip?  I don't see him on the users list.</p>",
        "id": 251937832,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630701000
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"432267\">@Seth Chaiken</span>  and <span class=\"user-mention\" data-user-id=\"276777\">@Mike Shulman</span>  I do not think that Florian Rabe subscribes to this zulip. I can send him email, but so can you, it might make more sense. His email is on his webpage <a href=\"https://kwarc.info/people/frabe/\">https://kwarc.info/people/frabe/</a>. his talk is part of the Topos Institute discussion on formalization of mathematics that so far encompassed Larry Paulson's and Kevin Buzzard's talks. We plan to continue the series.</p>",
        "id": 251938404,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630701283
    },
    {
        "content": "<p>but trying to answer your question <span class=\"user-mention\" data-user-id=\"276777\">@Mike Shulman</span> , yes tactics would be missing.  but also the big libraries of basic facts to build from. As Florian says, unlike the guys of Lean, he's not interested in building libraries, as he prefers to build agnostic infra-structure. Florian gave another cool talk at Andrej Bauer's \"Every proof assistant\" series,  <a href=\"https://vimeo.com/421123419\">https://vimeo.com/421123419</a> last year</p>",
        "id": 251941631,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630702994
    },
    {
        "content": "<p>Thanks, I watched that talk too and came away with the same questions.  I don't think the missing libraries of basic facts are relevant for my use case, where I have a <em>new</em> type theory that I want to experiment with, so there's no chance anyone could have built a library of facts about it already in any case.  So would you say that tactics/holes are all that's missing?  (Of course, Agda does okay without tactics.)</p>",
        "id": 251942161,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630703297
    },
    {
        "content": "<p>well, this is <em>not</em> my expertise, but I believe that apart from tactics/tacticals (or whatever plays this role), maybe one  would still be missing unit-tests-like stuff. (I'm saying that bc this is what I wanted to create when trying to have a proof assistant for LinLogic, and I then used Girard's translation on usual intuitionistic prop theorems ). but maybe this is so obvious that you didn't think it needed mentioning...</p>",
        "id": 251944005,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630704320
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276656\">@Valeria de Paiva</span>  Thanks!</p>",
        "id": 251949958,
        "sender_full_name": "Seth Chaiken",
        "timestamp": 1630708063
    },
    {
        "content": "<p>That's so far from obvious (to me) that I don't even know what you mean.  (-:</p>",
        "id": 251955738,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630712564
    },
    {
        "content": "<p>Do you mean MMT wouldn't come with tests verifying that your representation of your new type theory is correct?</p>",
        "id": 251955778,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630712618
    },
    {
        "content": "<p>Also, if I email Florian, where can I point him to get a working invitation to join the Zulip?</p>",
        "id": 251956100,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630712920
    },
    {
        "content": "<p>Fresh invite links appear in <a href=\"#narrow/stream/229122-general.3A-meta/topic/invite.20link\">this thread</a>.</p>",
        "id": 251956729,
        "sender_full_name": "Evan Patterson",
        "timestamp": 1630713589
    },
    {
        "content": "<p>well, say you want to eventually (only eventually) machine learn the theorems of your new shiny type theory. Wouldn't you need to have these unit-test-like things (actually I only mentioned the positive ones) but you need both,  for  what you want your type theory to say and what you actually want it NOT to say?</p>",
        "id": 251957688,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630714404
    },
    {
        "content": "<p>Still, because of your question Mike, I decided to watch W. Bowman's  talk  on Cur.  he seems to want many more things. He says: \" We evaluate this design [of a non-devious proof assistant] by building a proof assistant that features a small dependent type theory as the core language  and implementing the following extensions in small user-defined libraries:</p>\n<ol>\n<li>pattern matching for inductive types, </li>\n<li>dependently typed staged meta-programming, </li>\n<li>a tactic language, and </li>\n<li>BNF and inference-rule notation for inductive type definitions. <br>\n(<a href=\"https://www.williamjbowman.com/resources/cur.pdf\">https://www.williamjbowman.com/resources/cur.pdf</a>) clearly the proof assistant designers want many more things...</li>\n</ol>",
        "id": 251958189,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630714873
    },
    {
        "content": "<p>Is there something about MMT that would prevent you from writing unit tests for a type theory implemented therein?</p>",
        "id": 251962034,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630718709
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276656\">Valeria de Paiva</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Florian.20Rabe.3A.20.22MMT.3A.20A.20UniFormal.20approach.20to.20.5B.2E.2E.2E.5D.22/near/251958189\">said</a>:</p>\n<blockquote>\n<p>I decided to watch W. Bowman's  talk  on Cur.</p>\n</blockquote>\n<p>Which talk is that?  Was it in \"Every proof assistant\"?</p>",
        "id": 251962106,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630718773
    },
    {
        "content": "<blockquote>\n<p>Is there something about MMT that would prevent you from writing unit tests for a type theory implemented therein?</p>\n</blockquote>\n<p>No, there's nothing that prevents you from writing these things in MMT! but this is how I understood Florian: he wished to have the time to make MMT a proof assistant, but since he doesn't, he'd prefer to work on the infrastructure than to work on the niceties of  making it work as a proof assistant. YMMV</p>",
        "id": 251964642,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630721680
    },
    {
        "content": "<p>and yes, it's another talk in the \"Every proof assistant series\",  <a href=\"https://vimeo.com/432569820\">https://vimeo.com/432569820</a>.</p>",
        "id": 251964689,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630721746
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"438119\">@Florian Rabe</span></p>",
        "id": 252179482,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630936745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Florian.20Rabe.3A.20.22MMT.3A.20A.20UniFormal.20approach.20to.20.5B.2E.2E.2E.5D.22/near/251937522\">said</a>:</p>\n<blockquote>\n<p>it's disappointing to me to hear you say that MMT is not a proof assistant.  But you did mention that you have a general algorithm for type inference and solving implicit arguments.  What in particular do you have in mind that's lacking when you say that MMT is not a proof assistant?  If I have a new type theory that I want to play around with, and I implement it in MMT and try to use MMT as a proof assistant, what will I feel is missing as compared to using a \"real\" proof assistant?  Is it methods for progressive construction of terms, like tactics in Coq or holes in Agda?</p>\n</blockquote>\n<p>I agree. I also want it to do more automated proving, and the only hold-up is available resources to add it.</p>\n<p>You can already do decent proofs in MMT by writing the proof terms manually.  Agda-like holes and interactive term completion are available too.<br>\nBut MMT still lacks automated proof search and user-defined tactics.</p>",
        "id": 252180190,
        "sender_full_name": "Florian Rabe",
        "timestamp": 1630937058
    },
    {
        "content": "<p>So is the experience significantly worse in MMT than in Agda, then?  Agda doesn't have tactics, and I've never used any automated proof search therein.</p>",
        "id": 252180730,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630937298
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Florian.20Rabe.3A.20.22MMT.3A.20A.20UniFormal.20approach.20to.20.5B.2E.2E.2E.5D.22/near/251942161\">said</a>:</p>\n<blockquote>\n<p>I don't think the missing libraries of basic facts are relevant for my use case, where I have a <em>new</em> type theory that I want to experiment with, so there's no chance anyone could have built a library of facts about it already in any case. </p>\n</blockquote>\n<p>Indeed, so far MMT has mostly been used to</p>\n<ul>\n<li>experiment with new type theories</li>\n<li>do a formalization where it's not clear at the beginning which type theory will be needed or where a custom type theory is needed</li>\n<li>do formalizations that span multiple type theories</li>\n</ul>\n<p>For deep libraries (i.e, large developments in a fixed type theory), more proof automation would help a lot.<br>\nWe're working on that, but we currently don't have funding to prioritize it.</p>",
        "id": 252181093,
        "sender_full_name": "Florian Rabe",
        "timestamp": 1630937486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Florian.20Rabe.3A.20.22MMT.3A.20A.20UniFormal.20approach.20to.20.5B.2E.2E.2E.5D.22/near/251962034\">said</a>:</p>\n<blockquote>\n<p>Is there something about MMT that would prevent you from writing unit tests for a type theory implemented therein?</p>\n</blockquote>\n<p>I'm not sure what you mean by unit tests. But I suspect there's nothing preventing it.</p>",
        "id": 252181391,
        "sender_full_name": "Florian Rabe",
        "timestamp": 1630937642
    },
    {
        "content": "<p>If writing in MMT is not that different from writing in Agda without fancy features, then maybe you shouldn't sell it short by saying that it's not a proof assistant!  Indeed, there's other experimental software that is even less fully featured than Agda that people don't hesitate to call proof assistants.</p>",
        "id": 252182024,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630937915
    },
    {
        "content": "<p>I have a couple of other questions that I was waiting for you to show up to ask, <span class=\"user-mention\" data-user-id=\"438119\">@Florian Rabe</span> .  I don't understand why you needed to back off an extra step from a logical framework and implement multiple different LFs.  Can you give an example of a theory that you weren't able to implement in ordinary LF?  In my experience a dependently typed LF is very flexible.</p>",
        "id": 252182316,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630938066
    },
    {
        "content": "<p>The primary sorts of theories that I've had trouble representing in an ordinary LF are modal and substructural ones.  Is that what you had in mind?  Some of your slides gave the impression that you needed a separate LF for almost every substantial object theory, and the theories of most existing proof assistants are not modal or substructural.</p>",
        "id": 252182558,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630938187
    },
    {
        "content": "<p>Separately, I'd also like to know whether you've implemented any modal or substructural theories in MMT?</p>",
        "id": 252182617,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630938225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Florian.20Rabe.3A.20.22MMT.3A.20A.20UniFormal.20approach.20to.20.5B.2E.2E.2E.5D.22/near/252182316\">said</a>:</p>\n<blockquote>\n<p>I have a couple of other questions that I was waiting for you to show up to ask, <span class=\"user-mention silent\" data-user-id=\"438119\">Florian Rabe</span> .  I don't understand why you needed to back off an extra step from a logical framework and implement multiple different LFs.  Can you give an example of a theory that you weren't able to implement in ordinary LF?  In my experience a dependently typed LF is very flexible.</p>\n</blockquote>\n<p>Generally speaking, there are certain features, where if the logical framework doesn't already support it, it gets very awkward to formalize it.<br>\nBinding is one such feature, and LF has it. So representing binders is elegant in LF.</p>\n<p>Examples of such features that LF doesn't have are rewriting, soft typing, subtyping, undefinedness, or records.<br>\nYou can encode these in LF, but it requires encoding artifacts. For example, one can use explicit injection functions to encode subtyping.<br>\nThat usually only works in toy examples, and if you try to process an entire proof assistant library, the encoding artifacts grow out of hand.</p>\n<p>Here are some examples of general features beyond LF that people have added (not necessarily to build logical frameworks but also to just prototype type theories):</p>\n<ul>\n<li>type theory modulo rewriting</li>\n<li>proof irrelevance</li>\n<li>polymorphism</li>\n<li>universe hierarchy</li>\n<li>predicate subtypes (and thus undecidable typing)</li>\n<li>hard-coding certain equational theories (e.g., a fixed monoid)</li>\n</ul>\n<p>The Italian group around LLFP has also done extensive work on extensions of LF.<br>\nI've implemented LLFP in MMT as well.</p>\n<p>This paper has some examples: <a href=\"https://kwarc.info/people/frabe/Research/MR_prototyping_19.pdf\">https://kwarc.info/people/frabe/Research/MR_prototyping_19.pdf</a></p>\n<p>Here are some examples of concrete logics where an encoding in plain LF was not feasible:</p>\n<ul>\n<li>Coq: The typing rules of Coq (especially regarding induction) are too complex to formalize in LF.</li>\n<li>PVS: We needed record types, predicate subtypes, and a highly idiosyncratic kind of includes between theories</li>\n<li>Mizar: To formalize typed reasoning in untyped set theory elegantly,  a single predicate subtype \"Elem A = type of all x:set suchthat x in A\" is needed sooner or later.</li>\n</ul>\n<p>You can find more on this in <a href=\"https://kwarc.info/people/frabe/Research/KR_oafexp_20.pdf\">https://kwarc.info/people/frabe/Research/KR_oafexp_20.pdf</a> (JAR 2021).</p>",
        "id": 252185536,
        "sender_full_name": "Florian Rabe",
        "timestamp": 1630939537
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Florian.20Rabe.3A.20.22MMT.3A.20A.20UniFormal.20approach.20to.20.5B.2E.2E.2E.5D.22/near/252182558\">said</a>:</p>\n<blockquote>\n<p>The primary sorts of theories that I've had trouble representing in an ordinary LF are modal and substructural ones.  Is that what you had in mind?  Some of your slides gave the impression that you needed a separate LF for almost every substantial object theory, and the theories of most existing proof assistants are not modal or substructural.</p>\n</blockquote>\n<p>Those are also difficult. We've done experiments, and it's not always obvious, which extra features come in handy:</p>\n<ul>\n<li>I formalized linear logic via Pfenning's take on resource semantics. That required a hard-coded monoid for the worlds.</li>\n<li>Dennis Müller formalized explicit contexts (as lists of propositions) with primitive rules for pattern-matching and map over those lists in order to enable more direct formalizations of modal logics.</li>\n</ul>",
        "id": 252186070,
        "sender_full_name": "Florian Rabe",
        "timestamp": 1630939745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Florian.20Rabe.3A.20.22MMT.3A.20A.20UniFormal.20approach.20to.20.5B.2E.2E.2E.5D.22/near/252182617\">said</a>:</p>\n<blockquote>\n<p>Separately, I'd also like to know whether you've implemented any modal or substructural theories in MMT?</p>\n</blockquote>\n<p>Modal logics via Hilbert calculi and Kripke models work nicely in plain LF. <br>\nFor more natural deduction-style calculi, see the experiment above.</p>\n<p>Substructural logics have not been a priority. I did the experiment above as a one-off, and it works quite well.<br>\nBut there are other routes that could be taken, including special rules for checking occurrences of variables.<br>\nI think LLFP can also be applied to substructural logics and those solutions would carry over to the implementation of LLFP in MMT mentioned above, but I haven't looked into that.</p>",
        "id": 252186538,
        "sender_full_name": "Florian Rabe",
        "timestamp": 1630939926
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"438119\">@Florian Rabe</span> Thanks!  I'll have a look at those papers.  If many or most object theories require their own customized LF, what is the advantage of including a framework level at all?  Couldn't you just use the \"meta-meta-language\" in which you describe the logical frameworks to describe the object theories directly?</p>",
        "id": 252189743,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630941267
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Florian.20Rabe.3A.20.22MMT.3A.20A.20UniFormal.20approach.20to.20.5B.2E.2E.2E.5D.22/near/252189743\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"438119\">Florian Rabe</span> If many or most object theories require their own customized LF, what is the advantage of including a framework level at all?  Couldn't you just use the \"meta-meta-language\" in which you describe the logical frameworks to describe the object theories directly?</p>\n</blockquote>\n<p>Good question. Logical frameworks (of some sort) are without alternative for meta-reasoning about the languages and are more trustworthy for proof checking.<br>\nIf one only wants rapid prototyping, one can indeed skip the framework and do it directly in MMT.</p>\n<p>Often in practice, MMT we use a mixed approach: logical framework as an intermediate level where possible, direct MMT-level rules where necessary.<br>\nFor example, for Coq, we declared the syntax in LF except for induction, and skipped LF for the induction-related expressions.</p>",
        "id": 252459952,
        "sender_full_name": "Florian Rabe",
        "timestamp": 1631108093
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"438119\">@Florian Rabe</span> is the new formal underpinning of Scala3 (e.g. <a href=\"https://arxiv.org/pdf/1904.07298.pdf\">here</a>) going to help  MMT?</p>",
        "id": 252480383,
        "sender_full_name": "Henry Story",
        "timestamp": 1631114638
    },
    {
        "content": "<p>Hmm.  Is it that because the logical framework is simpler than the object-theory, it's easier to establish metatheoretically that its raw syntax is meaningful, and then you can work within the meaningful syntax of the framework to establish the meaning of the object theory?</p>",
        "id": 252480449,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1631114650
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281126\">Henry Story</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Florian.20Rabe.3A.20.22MMT.3A.20A.20UniFormal.20approach.20to.20.5B.2E.2E.2E.5D.22/near/252480383\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"438119\">Florian Rabe</span> is the new formal underpinning of Scala3 (e.g. <a href=\"https://arxiv.org/pdf/1904.07298.pdf\">here</a>) going to help  MMT?</p>\n</blockquote>\n<p>1) Regarding the question of representing a rule in a logical framework vs. implementing it directly in MMT: I suspect if you can't represent a rule R elegantly in a logical framework, writing the specification for a Scala implementation of R will also be difficult. So formal Scala won't help as much.</p>\n<p>2) Regarding the meta-theory of the (a) general algorithms implemented in MMT as well as (b) the rules for LF, which must be implemented in MMT to get off the ground: Formal Scala might allow verifying the behavior of MMT's type reconstruction algorithm.</p>\n<p>An alternative route for (2b) is to specify those relatively simple rules in LF itself and compile them to Scala code in order to bootstrap MMT's type checking rules.</p>",
        "id": 252534866,
        "sender_full_name": "Florian Rabe",
        "timestamp": 1631135960
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Florian.20Rabe.3A.20.22MMT.3A.20A.20UniFormal.20approach.20to.20.5B.2E.2E.2E.5D.22/near/252480449\">said</a>:</p>\n<blockquote>\n<p>Hmm.  Is it that because the logical framework is simpler than the object-theory, it's easier to establish metatheoretically that its raw syntax is meaningful, and then you can work within the meaningful syntax of the framework to establish the meaning of the object theory?</p>\n</blockquote>\n<p>I'm not sure what you mean.</p>",
        "id": 252535017,
        "sender_full_name": "Florian Rabe",
        "timestamp": 1631136020
    },
    {
        "content": "<p>I'm trying to understand your statement that</p>\n<blockquote>\n<p>Logical frameworks (of some sort) are without alternative for meta-reasoning about the languages and are more trustworthy for proof checking.</p>\n</blockquote>\n<p>The \"alternative\" under consideration would be to implement an object language directly in MMT.  Why is that not an \"alternative\" for meta-reasoning about the language, and why is it less trustworthy for proof checking?  My guess was that since the core constructs of MMT are less structured, it's harder to formally prove things about a language implemented directly in terms of them; so you want to only do that for as simple a language as possible, namely the logical framework, and then the step from the logical framework to the more complicated object theory is easier because the logical framework is more structured (e.g. intrinsically well-typed).</p>",
        "id": 252551101,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1631144962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Florian.20Rabe.3A.20.22MMT.3A.20A.20UniFormal.20approach.20to.20.5B.2E.2E.2E.5D.22/near/252551101\">said</a>:</p>\n<blockquote>\n<p>I'm trying to understand your statement that</p>\n<blockquote>\n<p>Logical frameworks (of some sort) are without alternative for meta-reasoning about the languages and are more trustworthy for proof checking.</p>\n</blockquote>\n<p>The \"alternative\" under consideration would be to implement an object language directly in MMT.  Why is that not an \"alternative\" for meta-reasoning about the language, and why is it less trustworthy for proof checking?  My guess was that since the core constructs of MMT are less structured, it's harder to formally prove things about a language implemented directly in terms of them; so you want to only do that for as simple a language as possible, namely the logical framework, and then the step from the logical framework to the more complicated object theory is easier because the logical framework is more structured (e.g. intrinsically well-typed).</p>\n</blockquote>\n<p>Yes. Implementing a language in MMT requires writing little snippets of Scala code (one for each typing rule).<br>\nEven though a small fragment [*] of Scala is sufficient for that, any meta-reasoning would have to reason about Scala code.</p>\n<p>Notably the fragment is a bit bigger than one might expect: In practice, the code should include at least commands for logging and error reporting.</p>",
        "id": 253067511,
        "sender_full_name": "Florian Rabe",
        "timestamp": 1631529214
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"438119\">@Florian Rabe</span>.  Are your logical frameworks sufficiently expressive to encode the normalization algorithm of object-languages without needing to descend to Scala code again?  How does that work?  Most logical frameworks I've seen can encode the equality judgment of object-languages, or perhaps some small- or big-step operational semantics relation, but I never thought of being able to extract an actual implementation of a normalization algorithm from such an encoding without additional coding.</p>",
        "id": 253103578,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1631545000
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Florian.20Rabe.3A.20.22MMT.3A.20A.20UniFormal.20approach.20to.20.5B.2E.2E.2E.5D.22/near/253103578\">said</a>:</p>\n<blockquote>\n<p>Thanks <span class=\"user-mention silent\" data-user-id=\"438119\">Florian Rabe</span>.  Are your logical frameworks sufficiently expressive to encode the normalization algorithm of object-languages without needing to descend to Scala code again?  How does that work?  Most logical frameworks I've seen can encode the equality judgment of object-languages, or perhaps some small- or big-step operational semantics relation, but I never thought of being able to extract an actual implementation of a normalization algorithm from such an encoding without additional coding.</p>\n</blockquote>\n<p>This is not so much an MMT question but a logical framework question. If you have such a logical framework, it should be straightforward to prototype it in MMT</p>\n<p>If you want to extract externally runnable code, it depends on the similarities/differences between</p>\n<ul>\n<li>how the logical framework represents the algorithm</li>\n<li>what programming language you want to extract to</li>\n</ul>\n<p>For example:</p>\n<ul>\n<li>LF uses relational programming (Prolog-style but with dependent types) to represent the algorithms. So if you want to extract to anything but a relational programming language, you'd still have to code up a substantial transformation that becomes part of your trusted code base.</li>\n<li>Delfin extends LF with functional programming, which makes extracting to functional languages easy.</li>\n</ul>\n<p>In any case, the extractor could be implemented as an MMT exporter.</p>",
        "id": 254019974,
        "sender_full_name": "Florian Rabe",
        "timestamp": 1632129804
    },
    {
        "content": "<p>I'm not talking about extraction to runnable code (sorry that I confused things by using the word \"extract\"), I'm talking about normalization in the proof assistant in the process of typechecking.  It's an MMT question because I'm saying that I <em>don't</em> know how to do such things with LFs, while you said that MMT encodes all object-languages with LFs.</p>",
        "id": 254064314,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1632150227
    },
    {
        "content": "<p>Forgot to notify <span class=\"user-mention\" data-user-id=\"438119\">@Florian Rabe</span> on that reply.</p>",
        "id": 254078121,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1632155449
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/269484-seminar.3A-Topos.20Colloquium/topic/Florian.20Rabe.3A.20.22MMT.3A.20A.20UniFormal.20approach.20to.20.5B.2E.2E.2E.5D.22/near/254064314\">said</a>:</p>\n<blockquote>\n<p>I'm not talking about extraction to runnable code (sorry that I confused things by using the word \"extract\"), I'm talking about normalization in the proof assistant in the process of typechecking.  It's an MMT question because I'm saying that I <em>don't</em> know how to do such things with LFs, while you said that MMT encodes all object-languages with LFs.</p>\n</blockquote>\n<p>I now think you mean executing the algorithms specified in the logical framework from within the logical framework.<br>\nMost logical frameworks allow specifying the algorithm but a meta-level/extra-linguistic step is needed to trigger it.<br>\nFor example, Twelf allows the user to run an algorithm specified as a logic program in LF - but the command to run is sent interactively by the user.</p>\n<p>This is mostly a logical framework--design issue: Most frameworks need the distinction between object and meta-level to distinguish the function space of the framework, which is used to represent binding via HOAS, from the function space in which syntax-driven algorithms like normalization live.</p>\n<p>MMT has no problem representing any solution to that issue. But it doesn't automatically solve that issue either.</p>",
        "id": 254689550,
        "sender_full_name": "Florian Rabe",
        "timestamp": 1632483335
    }
]