[
    {
        "content": "<p>Hello, I and <span class=\"user-mention\" data-user-id=\"276048\">@Mike Stay</span> wrote a paper: <a href=\"https://arxiv.org/abs/2102.04672\">https://arxiv.org/abs/2102.04672</a></p>",
        "id": 225786149,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612923091
    },
    {
        "content": "<p>Native Type Theory is a method of generating logical type systems for a broad class of languages, to provide a shared framework of higher-order reasoning for the many languages and structures used in software.</p>",
        "id": 225786274,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612923211
    },
    {
        "content": "<p>The idea is very simple - a programming language can be modelled as a theory, and its presheaves form a topos. The internal language of this topos is an intuitive and expressive type theory in which we have total expression of the structure and behavior of terms.</p>",
        "id": 225786406,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612923345
    },
    {
        "content": "<p>In the paper we outline the construction as a functor from \"higher-order algebraic theories\" to \"(nice) dependent type theories\". We give the basics of the type system, and some first applications.</p>",
        "id": 225786529,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612923481
    },
    {
        "content": "<p>The construction is probably closer to implementation than it may seem. The formal specification community has used K Framework to write languages such as C, Java, and Python as higher-order algebraic theories (with rewriting); and native type systems are the same kind as that of Coq.</p>",
        "id": 225786837,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612923740
    },
    {
        "content": "<p>So, we are now looking to make it happen. If you are interested, just let me know.</p>",
        "id": 225786942,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612923859
    },
    {
        "content": "<p>It would be great to use this space for thoughts about the paper, exploring applications, and anything else.</p>",
        "id": 225786960,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612923880
    },
    {
        "content": "<p>If suddenly every programming language had an expressive logic built-in, what kind of things would you want to do? How do you think this could affect the practice of programming?</p>",
        "id": 225787683,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612924578
    },
    {
        "content": "<p>A motivating example we like is searching codebases --- we imagine querying on GitHub \"programs that implement this algorithm under these conditions\" and pulling up all results to compare, plug and play.</p>",
        "id": 225787863,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612924791
    },
    {
        "content": "<p>That's really cool work! Kudos!</p>",
        "id": 225806686,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1612946226
    },
    {
        "content": "<p>In Proposition 26, L and R have the same domain and codomain; which one is the wrong way around?</p>",
        "id": 225815342,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1612951634
    },
    {
        "content": "<p>(sorry, that wasn't the most constructive remark <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> )<br>\nI have more interesting questions now that I've read the paper a little more closely. First, I'll summarise what I understand from the paper:<br>\nYou start with a certain notion of higher-order algebraic theory (I haven't studied HOL deeply enough to know whether your \"base types exponentiable to order n\" notion is equivalent to the more familiar one in terms of quantification over subobjects etc, but I can ignore that for now). You construct the syntactic category in a standard way, then note that it can be characterised by its canonical identity-on-objects functor from the free such category, so you can hide the syntax. Since the structure in these categories is defined in terms of limits and exponentials, which are preserved by the Yoneda embedding, you can pass to the presheaf topos without losing anything. Then you extract a type theory for the topos, most of the ingredients of which seem fairly standard.</p>\n<p>So now I wonder:</p>\n<ol>\n<li>(Most important) Is this extension conservative? If I prove a theorem which can be stated in the language of the original higher-order algebraic theory using the native type theory for the presheaf topos, is it provable in the original theory? I expect the answer is yes, but checking this is so amounts to verifying that passing to the native type theory isn't adding anything unexpected to the logic.</li>\n<li>The notion of theory morphism in the category of higher-order algebraic theories is not especially well-motivated, and it is not clear how it results in functoriality of P:HOAT^op -&gt; CCT when the latter is equipped with (co)continuous logical functors as its morphisms. Why is the subobject classifier or any non-representable exponential object preserved by composition with a cartex functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span>?</li>\n<li>Assuming that the preceding point all works out fine, it still seems unfortunate that you choose such restricted morphisms in the codomain. An ordinary (first-order) algebraic theory is <em>classified</em> by the topos of presheaves over its syntactic site, which means that its Set-models (or indeed its models in any Grothendieck topos E) correspond to the geometric morphisms from Set to that topos (resp. from E to that topos). To obtain the models of the higher-order theories you describe, it suffices to consider geometric morphisms whose inverse image functors preserve the defining exponentials. In particular, a locally connected geometric morphism which is not atomic (inverse image functor is cartesian-closed but not logical) would produce a model.</li>\n</ol>\n<p>It's plausible that you won't care much about the details I'm pointing to above, since the many examples illustrate that you have thought hard enough about your set-up to know it does what you want it to, which is to say produce rich, typed languages for a suitably large class of theories, implementable using tools which already exist, and useably functorial. I'm looking at this purely from the categorical logic perspective that is accessible to me. In any case, taking my critical hat off, I'm happy to see toposes emerging in a new way in computer science, and hope applying this stuff will lead to new insights!</p>",
        "id": 225842163,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1612966858
    },
    {
        "content": "<p>Question in a completely different direction: so programming languages are really bad, in the sense that their type theory is quite degenerate, in a wide variety of ways. [From Java getting variance of arrays wrong to Haskell's type system being inconsistent as a logic.]  How does this \"show up\" in this construction? i.e. what are the symptoms that one started with a 'bad' language in the induced native type theory?  I'm interested in seeing how this \"shows up\" in all steps of the construction, not just in the end.</p>",
        "id": 225843173,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1612967248
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277473\">Morgan Rogers (he/him)</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/225815342\">said</a>:</p>\n<blockquote>\n<p>In Proposition 26, L and R have the same domain and codomain; which one is the wrong way around?</p>\n</blockquote>\n<p>L is the wrong way around. Thanks! I don't know how that happened.</p>",
        "id": 225896254,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612986267
    },
    {
        "content": "<p>Thanks for your thoughts, Morgan. Yes, we need to check for conservativity. I do not have much intuition for this --- it seems as though the native type system is so much more expressive than the original theory that there would surely be new provable facts, but I'm not sure. The logic of toposes has been thoroughly studied; I imagine someone has asked whether the presheaf construction is conservative. If anyone knows a reference, it would be appreciated.</p>",
        "id": 225896899,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612986531
    },
    {
        "content": "<p>Well, the Yoneda embedding is fully faithful.  What more conservativity than that would you ask for?</p>",
        "id": 225897262,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1612986703
    },
    {
        "content": "<p>Ah, okay. But when you step outside of the image, like taking a coequalizer, and you prove that a term is of this type, is that not \"proving something that isn't provable in the theory\"?</p>",
        "id": 225897793,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612986973
    },
    {
        "content": "<p>Usually in logic a bigger theory is a \"conservative\" extension of a smaller one if anything that can be <em>stated</em> in the smaller theory and <em>proved</em> in the bigger theory can actually be proved in the smaller theory.</p>",
        "id": 225898135,
        "sender_full_name": "John Baez",
        "timestamp": 1612987158
    },
    {
        "content": "<p>Ah yes, okay great.</p>",
        "id": 225898180,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612987181
    },
    {
        "content": "<p>If something can't even be <em>stated</em> in the smaller theory, then of course the smaller theory has no hope of proving it.</p>",
        "id": 225898187,
        "sender_full_name": "John Baez",
        "timestamp": 1612987186
    },
    {
        "content": "<p>In this case it's not even entirely clear to me what it means for the smaller theory to \"prove\" something, since it's just a (higher-order) algebraic theory without an associated \"logic\".</p>",
        "id": 225898382,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1612987269
    },
    {
        "content": "<p>For example in nonstandard analysis we add new infinitesimals to the real numbers and new rules for working with them, but it's a conservative extension, which is reassuring, because it means anything we can <em>state</em> about plain old real numbers and <em>prove</em> using nonstandard analysis could actually be proved using the ordinary axioms for real numbers.</p>",
        "id": 225898403,
        "sender_full_name": "John Baez",
        "timestamp": 1612987277
    },
    {
        "content": "<p>The theory's logic is equational logic in (nth-order) simply-typed lambda calculus.</p>",
        "id": 225898808,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612987446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/225898382\">said</a>:</p>\n<blockquote>\n<p>In this case it's not even entirely clear to me what it means for the smaller theory to \"prove\" something, since it's just a (higher-order) algebraic theory without an associated \"logic\".</p>\n</blockquote>\n<p>Well, some composites of morphisms can equal some other morphism.   And then your remark about Yoneda fully faithful embedding comes into play: if the analogous fact holds in the presheaf category, it held already in the original category.    </p>\n<p>(You know all this, I'm just saying it for the sake of the universe at large.)</p>",
        "id": 225898813,
        "sender_full_name": "John Baez",
        "timestamp": 1612987448
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275899\">Christian Williams</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/225898808\">said</a>:</p>\n<blockquote>\n<p>The theory's logic is equational logic in (nth-order) simply-typed lambda calculus.</p>\n</blockquote>\n<p>Yes, I'd say that counts as a \"logic\".  I'm very generous about what counts as a logic.</p>",
        "id": 225898990,
        "sender_full_name": "John Baez",
        "timestamp": 1612987522
    },
    {
        "content": "<p>So, Morgan's concern is answered. I should've mentioned it in the paper, but the discussion here will make a better draft.</p>",
        "id": 225899051,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612987545
    },
    {
        "content": "<p>To expand further on <span class=\"user-mention\" data-user-id=\"275920\">@John Baez</span>'s comment (with the same caveat), seeing propositions as types, one would expect the \"correct\" generalisation of conservativity to demonstrate a bijective correspondence from every term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mi>t</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma \\vdash t : A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> in the new theory, to one <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><msup><mi>t</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo>:</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma \\vdash t' : A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> in the original theory, which corresponds precisely to the inclusion being fully faithful.</p>",
        "id": 225899243,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1612987613
    },
    {
        "content": "<p>Oh right, of course equational logic is a logic.</p>",
        "id": 225899578,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1612987749
    },
    {
        "content": "<p>And there's even the null logic where you can't say or prove anything!   <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 225899853,
        "sender_full_name": "John Baez",
        "timestamp": 1612987873
    },
    {
        "content": "<p>I use that one myself sometimes.</p>",
        "id": 225899923,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612987903
    },
    {
        "content": "<p>As for point #2, ultimately the definition of theory morphism does not play much role in functoriality, because it is just a certain kind of cartex functor, and we're basically just including HOAT into Cat. My understanding is that precomposition is a classic example of a logical functor, which should preserve everything in sight.</p>",
        "id": 225900145,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612987990
    },
    {
        "content": "<p>For point #3, I don't fully understand what you're saying. I get that there is a connection to the classifying topos, but I don't have any use for it in mind. What we care about for this paper are morphisms between <em>type theories</em>, which need to preserve all of that structure. But if you expand on what you're saying I can understand better.</p>",
        "id": 225900487,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612988149
    },
    {
        "content": "<blockquote>\n<p>My understanding is that precomposition is a classic example of a logical functor, which should preserve everything in sight.</p>\n</blockquote>\n<p>By the way: if that's true, let's add it as an example to <a href=\"https://ncatlab.org/nlab/show/logical+functor#examples\">logical functor</a>.   Maybe it's hiding in the stuff before the examples?</p>",
        "id": 225900617,
        "sender_full_name": "John Baez",
        "timestamp": 1612988206
    },
    {
        "content": "<p>Jacques, thanks for your thoughts. The formal verification community has used K Framework to specify many real-world languages: <a href=\"https://github.com/kframework\">https://github.com/kframework</a>. They are basically higher-order algebraic theories with rewriting. So the fact that some popular languages don't have much in the way of type systems is reflected in their representation simply as sorted theories. But from the construction, they get a dependent type theory that's as rich as the one used in Coq.</p>",
        "id": 225900848,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612988299
    },
    {
        "content": "<p>Well, Haskell has quite a lot in terms of a type system... But perhaps I am not asking the right question. It's not clear what the difference is between Haskell's type system (a variant of System F, if I remember well) and the type system that this construction gives it. Is there a way to understand that?</p>\n<p>But still, odd languages like C, which make it legal to lie to the compiler (they call it 'casting'),  the operational semantics ends up untyped. Yes, there is a 'core language' that's decently behaved, but that's not what most people use. So the question is, when the operational semantics allows you to collapse everything, what does the construction do with that?</p>\n<p>Note that being able to specify a language (which indeed has been done in K, but in many other systems too) doesn't mean that what's specified isn't degenerate.  There are many very complicated ways to 'specify' the empty set too... [I'm being colourful here, not facetious].</p>\n<p>So I guess I have 3 questions:</p>\n<ol>\n<li>if you start with something very well-behaved, like say Martin-Loef type theory, what do you get using your construction?</li>\n<li>if you start with something well-behaved but with a naturally weak type system (like simply-typed lambda calculus), what do you get?</li>\n<li>if you start with something really awful (like the fully untyped lambda calculus, or worse, something entirely inconsistent), what do you get?</li>\n</ol>\n<p>I think you've partially answered the second question: you get a dependently-typed system.</p>",
        "id": 225904976,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1612989991
    },
    {
        "content": "<p>As I understand it, you start with a simple type theory (with possibly higher-order operators), and then extend it to a dependent type theory. There is no attempt to restrict to well-behaved languages. So (1) isn't valid, because the original language has to be simple. If you start with (2), you get a variant of MLTT (namely, the internal language of a presheaf topos). If you start with (3), you get an inconsistent language.</p>",
        "id": 225906585,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1612990641
    },
    {
        "content": "<p>What do we mean by inconsistent here?</p>",
        "id": 225907904,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612991199
    },
    {
        "content": "<p>In the sense of <a href=\"https://en.wikipedia.org/wiki/Curry%27s_paradox\">Curry's paradox</a>, for instance.</p>",
        "id": 225908849,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1612991612
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/225897262\">said</a>:</p>\n<blockquote>\n<p>Well, the Yoneda embedding is fully faithful.  What more conservativity than that would you ask for?</p>\n</blockquote>\n<p>Although it was straightforward, I'm glad that it ended up being discussed <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 225915132,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1612994219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275899\">Christian Williams</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/225900145\">said</a>:</p>\n<blockquote>\n<p>As for point #2, ultimately the definition of theory morphism does not play much role in functoriality, because it is just a certain kind of cartex functor, and we're basically just including HOAT into Cat. My understanding is that precomposition is a classic example of a logical functor, which should preserve everything in sight.</p>\n</blockquote>\n<p>The definition of theory morphism for HOATs does include a cartex functor, but it also includes a relation and a mapping of signatures. Is \"a relation of orders <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>:</mo><msub><mi>n</mi><mn>1</mn></msub><mo>→</mo><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">i:n_1 \\to n_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>\" in Definition 12 just saying that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">n_1 \\leq n_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>? Is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">T</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><msub><mi>T</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>τ</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{T}_i(f)(T_1,\\tau_1)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">T</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.1132em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">T_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> as a category? If so, is this supposed to follow from Proposition 10 (there's a missing reference in the proof of that Proposition, btw)? If not, why does composition with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> give a functor between the presheaf categories?</p>",
        "id": 225917403,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1612994799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275899\">Christian Williams</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/225900487\">said</a>:</p>\n<blockquote>\n<p>What we care about for this paper are morphisms between <em>type theories</em>, which need to preserve all of that structure.</p>\n</blockquote>\n<p>That's only true if you want the morphisms to preserve everything on the nose, which might not actually be what you want, considering that you're building these native type theories to extend a strictly smaller class of theories. For example, a functor which is merely cartesian-closed will preserve all of the types coming from the original HOAT, even if it doesn't preserve the extra types which were added in the process of passing to the presheaf topos and extracting the native type theory.<br>\nThe point I was trying to make originally is that if you do end up caring about the models of these theories (or if someone else does because they're interested in HOATs for another reason), choosing a class of morphisms between HOATs large enough to recover \"models as induced geometric morphisms\" could be neat.</p>",
        "id": 225919107,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1612995267
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277473\">Morgan Rogers (he/him)</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/225917403\">said</a>:</p>\n<blockquote>\n<p>The definition of theory morphism for HOATs does include a cartex functor, but it also includes a relation and a mapping of signatures. Is \"a relation of orders <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>:</mo><msub><mi>n</mi><mn>1</mn></msub><mo>→</mo><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">i:n_1 \\to n_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>\" in Definition 12 just saying that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">n_1 \\leq n_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>? Is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">T</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><msub><mi>T</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>τ</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{T}_i(f)(T_1,\\tau_1)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">T</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.1132em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">T_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> as a category? If so, is this supposed to follow from Proposition 10 (there's a missing reference in the proof of that Proposition, btw)? If not, why does composition with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> give a functor between the presheaf categories?</p>\n</blockquote>\n<p>Good point. You're right, this needs to be made explicit. There is a canonical map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo>→</mo><msub><mi mathvariant=\"double-struck\">T</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><msub><mi>T</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>τ</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T_1\\to \\mathbb{T}_i(f)(T_1,\\tau_1)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">T</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.1132em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> (the opcartesian morphism), and this modified presheaf construction precomposes with the composite <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo>→</mo><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">T_1\\to T_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 225936016,
        "sender_full_name": "Christian Williams",
        "timestamp": 1613005215
    },
    {
        "content": "<p>As for the point about models, I think I understand and I agree. The precise structures involved are subject to some change as needed.</p>",
        "id": 225939549,
        "sender_full_name": "Christian Williams",
        "timestamp": 1613008531
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275899\">Christian Williams</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/225900145\">said</a>:</p>\n<blockquote>\n<p>My understanding is that precomposition is a classic example of a logical functor, which should preserve everything in sight.</p>\n</blockquote>\n<p>It took me until this morning to remember why this isn't accurate. An arbitrary functor between categories induces <a href=\"https://ncatlab.org/nlab/show/essential+geometric+morphism#RelationToSiteMorphisms\">an essential geometric morphism</a> between the corresponding presheaf categories. You may have been thinking of composition with a morphism in a topos, aka a <a href=\"https://ncatlab.org/nlab/show/base+change#GeometricMorphism\">base change geometric morphism</a>, which does have logical inverse image functor.<br>\nIn order to show that (or whether) the functors you describe do produce logical functors, there is non-trivial work to do.</p>",
        "id": 225966461,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1613035986
    },
    {
        "content": "<p>I hope that's helped. Thanks for taking all my comments on board in such good faith <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 225966664,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1613036109
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277473\">Morgan Rogers (he/him)</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/225966461\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"275899\">Christian Williams</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/225900145\">said</a>:</p>\n<blockquote>\n<p>My understanding is that precomposition is a classic example of a logical functor, which should preserve everything in sight.</p>\n</blockquote>\n<p>It took me until this morning to remember why this isn't accurate. An arbitrary functor between categories induces <a href=\"https://ncatlab.org/nlab/show/essential+geometric+morphism#RelationToSiteMorphisms\">an essential geometric morphism</a> between the corresponding presheaf categories. You may have been thinking of composition with a morphism in a topos, aka a <a href=\"https://ncatlab.org/nlab/show/base+change#GeometricMorphism\">base change geometric morphism</a>, which does have logical inverse image functor.<br>\nIn order to show that (or whether) the functors you describe do produce logical functors, there is non-trivial work to do.</p>\n</blockquote>\n<p>I felt embarrassed that I didn't know whetherthe inverse image along an arbitrary functor is a logical functor between their presheaf categories.  I knew it produced an essential geometric morphism.  </p>\n<p>So when do they give logical functors?   Hardly ever?  (Obviously equivalences do.)     Often?</p>",
        "id": 226021918,
        "sender_full_name": "John Baez",
        "timestamp": 1613062462
    },
    {
        "content": "<p>The canonical projection from a Grothendieck construction (so, the relevant kind of fibration) is an example of a functor which produces an étale geometric morphism (a localic geometric morphism with logical inverse image functor), since those correspond to the canonical gms from slice toposes over presheaves over the codomain.</p>",
        "id": 226022564,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1613062723
    },
    {
        "content": "<p>Generally speaking, the inverse image functor of an essential geometric morphism does inherit some properties from the functor generating it. You can use the <a href=\"https://ncatlab.org/nlab/show/Frobenius+reciprocity#InCategoryTheory\">Frobenius reciprocity</a> condition to work out how far cartex functors induce cartesian-closed inverse image functors, but I see no reason why subobject classifiers should be respected by these functors.</p>",
        "id": 226023273,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1613063003
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277473\">Morgan Rogers (he/him)</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/226022564\">said</a>:</p>\n<blockquote>\n<p>The canonical projection from a Grothendieck construction (so, the relevant kind of fibration) is an example of a functor which produces an étale geometric morphism</p>\n</blockquote>\n<p>That would be the Grothendieck construction on a functor to <em>Set</em>, i.e. a <em>discrete</em> fibration, right?</p>",
        "id": 226100341,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1613108457
    },
    {
        "content": "<p>In general, a geometric morphism whose inverse image functor is logical is called <a href=\"https://ncatlab.org/nlab/show/atomic+geometric+morphism\">atomic</a>.  I don't know an exact characterization of the functors between small categories that produce atomic geometric morphisms, but they're more general than the etale ones.  For instance, the functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi>G</mi><mo>→</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">BG\\to 1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> has this property, for any group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>.</p>",
        "id": 226100360,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1613108518
    },
    {
        "content": "<p>Wrote a first blog post, about the language of a topos. <a href=\"https://golem.ph.utexas.edu/category/2021/02/native_type_theory.html\">https://golem.ph.utexas.edu/category/2021/02/native_type_theory.html</a></p>",
        "id": 227059050,
        "sender_full_name": "Christian Williams",
        "timestamp": 1613788893
    },
    {
        "content": "<p>comments and questions are welcome.</p>",
        "id": 227059649,
        "sender_full_name": "Christian Williams",
        "timestamp": 1613789563
    },
    {
        "content": "<p>The presentation of dependent type theory is nice, I think <span class=\"user-mention\" data-user-id=\"309257\">@Jason Erbele</span> would benefit from reading it after the discussion in <a class=\"stream\" data-stream-id=\"229199\" href=\"/#narrow/stream/229199-learning.3A-questions\">#learning: questions</a> yesterday. The monoid example you give is appealing, but it's a bit scary that in the presentation of \"the type of monoids\",<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">M</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">d</mi></mrow><mo>:</mo><mo>=</mo><mi mathvariant=\"normal\">Σ</mi><mi>M</mi><mo>:</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">Σ</mi><mi>m</mi><mo>:</mo><msup><mi>M</mi><mn>2</mn></msup><mo>→</mo><mi>M</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">Σ</mi><mi>e</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>M</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Monoid}:= \\Sigma M:\\mathrm{Set}.\\Sigma m:M^2\\to M.\\Sigma e:1\\to M...</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">M</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">n</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">i</span><span class=\"mord mathrm\">d</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Σ</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">t</span></span><span class=\"mord\">.</span><span class=\"mord\">Σ</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord\">.</span><span class=\"mord\">Σ</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span></span></span></span><br>\nyou have to index over the universe, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">t</span></span></span></span></span>, of basic types. You say that the rich language of dependent types is available in any topos, but this particular example is not expressible in the topos of sets (unless you get into the universe business) because it's not indexed over a type! It's still a conceptually good example for illustrating dependent types, just beware of the dragons <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 227080766,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1613814676
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/226100360\">said</a>:</p>\n<blockquote>\n<p>In general, a geometric morphism whose inverse image functor is logical is called <a href=\"https://ncatlab.org/nlab/show/atomic+geometric+morphism\">atomic</a>.  I don't know an exact characterization of the functors between small categories that produce atomic geometric morphisms, but they're more general than the etale ones.  For instance, the functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi>G</mi><mo>→</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">BG\\to 1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> has this property, for any group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>.</p>\n</blockquote>\n<p>I forgot to actually post this comment: the étale morphisms are exactly the localic atomic morphisms, and these do correspond exactly to the discrete fibrations. Also, any group homomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>→</mo><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">G \\to H</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span>, viewed as a functor, induces an atomic geometric morphism, and the hyperconnected-localic factorisation of that morphism corresponds to the surjection-injection factorisation of the homomorphism; the morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><msup><mi>G</mi><mrow><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">p</mi></mrow></msup><mo separator=\"true\">,</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><mo stretchy=\"false\">]</mo><mo>→</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">[G^{\\mathrm{op}},\\mathrm{Set}] \\to \\mathrm{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">o</span><span class=\"mord mathrm mtight\">p</span></span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">t</span></span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">t</span></span></span></span></span> is the special case of this for the unique morphism to the trivial group.</p>",
        "id": 227081452,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1613815546
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277473\">Morgan Rogers (he/him)</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/227080766\">said</a>:</p>\n<blockquote>\n<p>this particular example is not expressible in the topos of sets (unless you get into the universe business)</p>\n</blockquote>\n<p>Well, the simplest solution is to get into the universe business.  All (Grothendieck) toposes have universes as soon as the ambient set theory does.</p>",
        "id": 227100837,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1613837218
    },
    {
        "content": "<p>Anyway, the indexing is meta-theoretic no? The same way any LCCC has dependent types without needing universes</p>",
        "id": 227101498,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1613837842
    },
    {
        "content": "<p>I wasn't saying that the presentation didn't make sense, just that it wasn't \"in the language of the topos\" without some caveats.</p>",
        "id": 227101575,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1613837892
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"341237\">Fawzi Hreiki</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/227101498\">said</a>:</p>\n<blockquote>\n<p>Anyway, the indexing is meta-theoretic no? The same way any LCCC has dependent types without needing universes</p>\n</blockquote>\n<p>Indexing lets you get as far as saying what it means to be a monoid <em>over a given set</em>, but you can't collect up all the monoids (over different sets) without a universe (or maybe existential types).</p>",
        "id": 227101835,
        "sender_full_name": "James Wood",
        "timestamp": 1613838162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/227100837\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"277473\">Morgan Rogers (he/him)</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/227080766\">said</a>:</p>\n<blockquote>\n<p>this particular example is not expressible in the topos of sets (unless you get into the universe business)</p>\n</blockquote>\n<p>Well, the simplest solution is to get into the universe business.  All (Grothendieck) toposes have universes as soon as the ambient set theory does.</p>\n</blockquote>\n<p>Sure, and that can work for Christian's project since he's currently looking specifically at presheaf toposes, but none of the dependent type theory outside of that example in the blog post is foundation-dependent as far as I can tell, so going to the trouble of invoking universes seems a bit much.</p>",
        "id": 227102334,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1613838684
    },
    {
        "content": "<p>I think people should get over the idea that there's anything \"much\" about universes.  (-:</p>",
        "id": 227108069,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1613844886
    },
    {
        "content": "<p>There's nothing special about presheaf toposes, by the way; sheaf toposes have universes too.</p>",
        "id": 227108117,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1613844954
    },
    {
        "content": "<p>(As long as the metatheory does.)</p>",
        "id": 227108122,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1613844959
    },
    {
        "content": "<p>yes, good points, thanks.</p>",
        "id": 227131937,
        "sender_full_name": "Christian Williams",
        "timestamp": 1613869956
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276048\">@Mike Stay</span> had a really good response on the blog post, and I just wanted to share it here as well. I don't yet have the real-world programming background to give very many compelling applications of native types, but Mike certainly does, and here's an example.</p>\n<p><a href=\"https://golem.ph.utexas.edu/category/2021/02/native_type_theory.html#c059431\">https://golem.ph.utexas.edu/category/2021/02/native_type_theory.html#c059431</a></p>",
        "id": 227214700,
        "sender_full_name": "Christian Williams",
        "timestamp": 1613963528
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"275899\">@Christian Williams</span>: this sentence in the abstract of <a href=\"https://arxiv.org/abs/2103.01189\">David Spivak's new paper</a> seems at least slightly relevant to your interest in native types via topos theory and also \"coalgebras for dynamics\":</p>\n<blockquote>\n<p>Finally, we review the fact that the category p-Coalg of dynamical systems on any p∈Poly forms a topos, and consider the logical propositions that can be stated in its internal language.</p>\n</blockquote>",
        "id": 228456288,
        "sender_full_name": "John Baez",
        "timestamp": 1614708126
    },
    {
        "content": "<p>Hi all, here is the second post <a href=\"https://golem.ph.utexas.edu/category/2021/03/native_type_theory_part_2.html\">Native Type Theory: Part 2</a>. We present higher-order algebraic theories, the kind of categories which represent languages from which we build native type systems.</p>",
        "id": 231228147,
        "sender_full_name": "Christian Williams",
        "timestamp": 1616346363
    },
    {
        "content": "<p>In Part 3 (coming soon), we explore the native type system -- the internal language of the presheaf topos -- of a concurrent language.</p>",
        "id": 231228156,
        "sender_full_name": "Christian Williams",
        "timestamp": 1616346377
    },
    {
        "content": "<p>Which concurrent language is this?</p>",
        "id": 231244971,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1616365175
    },
    {
        "content": "<p>The <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding=\"application/x-tex\">\\rho</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">ρ</span></span></span></span>-calculus. It's the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span>-calculus, plus operators which control the distinction between data and code.</p>",
        "id": 231249683,
        "sender_full_name": "Christian Williams",
        "timestamp": 1616370863
    },
    {
        "content": "<p>links to references are in the blog post.</p>",
        "id": 231249691,
        "sender_full_name": "Christian Williams",
        "timestamp": 1616370896
    },
    {
        "content": "<p>Did you see the comment I made on Part 1 about 3 weeks ago?  Type theory is at the edge of my understanding, so I had some fairly basic questions about what's going on.</p>",
        "id": 231403377,
        "sender_full_name": "Jason Erbele",
        "timestamp": 1616457743
    },
    {
        "content": "<p>Here is Jason's comment:</p>\n<p><a href=\"https://golem.ph.utexas.edu/category/2021/02/native_type_theory.html#c059457\">https://golem.ph.utexas.edu/category/2021/02/native_type_theory.html#c059457</a></p>\n<p>I hope <span class=\"user-mention\" data-user-id=\"275899\">@Christian Williams</span> or someone answers it!</p>",
        "id": 231420775,
        "sender_full_name": "John Baez",
        "timestamp": 1616473987
    },
    {
        "content": "<p>ah, sorry! yes, I can answer tomorrow.</p>",
        "id": 231431301,
        "sender_full_name": "Christian Williams",
        "timestamp": 1616484798
    },
    {
        "content": "<p>There's some nice slides by Jeremy Avigad that somewhat justify the use of dependent (or indexed) types of this sort all over the place in mathematics. I think these are they <a href=\"https://www.andrew.cmu.edu/user/avigad/Talks/fields_type_theory.pdf\">https://www.andrew.cmu.edu/user/avigad/Talks/fields_type_theory.pdf</a></p>",
        "id": 231492695,
        "sender_full_name": "Cody Roux",
        "timestamp": 1616514339
    },
    {
        "content": "<p>But examples abound! One example is the definition of a category! Usually you have objects <code>A, B</code> and then for each pair of objects, you have an <em>indexed family</em> <code>Hom(A, B)</code>. Obviously you could have one big set <code>Hom</code> and then functions <code>dom, codom : Hom -&gt; Obj</code> but the other way is how we <em>actually think about things</em>. I think this is why it is claimed to be \"natural\".</p>",
        "id": 231492971,
        "sender_full_name": "Cody Roux",
        "timestamp": 1616514432
    },
    {
        "content": "<p>Thanks! That's perfect. <span class=\"user-mention\" data-user-id=\"309257\">@Jason Erbele</span></p>",
        "id": 231561939,
        "sender_full_name": "Christian Williams",
        "timestamp": 1616543827
    },
    {
        "content": "<p>also I <a href=\"https://golem.ph.utexas.edu/category/2021/02/native_type_theory.html#c059573\">responded to your question</a></p>",
        "id": 231562043,
        "sender_full_name": "Christian Williams",
        "timestamp": 1616543890
    },
    {
        "content": "<p>Here is <a href=\"https://golem.ph.utexas.edu/category/2021/03/native_type_theory_part_3_1.html\">Native Type Theory : Part 3</a>.</p>\n<p>We take a concurrent language called the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding=\"application/x-tex\">\\rho</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">ρ</span></span></span></span>-calculus, represented as a second-order algebraic theory with rewriting, and embed it into the category of presheaves. The internal language of the presheaf topos is the <em>native type system</em> of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding=\"application/x-tex\">\\rho</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">ρ</span></span></span></span>-calculus, and we explore this highly rich and expressive system.</p>",
        "id": 232369203,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617075631
    },
    {
        "content": "<p><a href=\"/user_uploads/21317/ejXAt8TMGagaO9bePu3ZX0-P/phiT.png\">phiT.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/ejXAt8TMGagaO9bePu3ZX0-P/phiT.png\" title=\"phiT.png\"><img src=\"/user_uploads/21317/ejXAt8TMGagaO9bePu3ZX0-P/phiT.png\"></a></div>",
        "id": 232369256,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617075695
    },
    {
        "content": "<p>Given a theory, the all-powerful Yoneda embedding gives us a rich environment in which to reason about the structure and behavior of terms in the language. That's the whole idea of native type theory; it's extremely simple in theory, but potentially extremely useful in practice.</p>",
        "id": 232369449,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617075853
    },
    {
        "content": "<p>I've included more pictures in the last two posts, so hopefully that makes them more engaging. I can include more here to help conversation. Mainly I'm just happy to hear your thoughts.</p>",
        "id": 232369605,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617075981
    },
    {
        "content": "<p>Wow you're churning this out quickly</p>",
        "id": 232412337,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1617105265
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"275899\">@Christian Williams</span> </p>\n<p>I had a couple of questions about the beginning of the paper:</p>\n<p>Q1: On p2 you said</p>\n<p>\"In Hoare logic [18], assertions are predicates on the valuation of a memory heap. The triples <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>φ</mi><mo stretchy=\"false\">}</mo><mi>C</mi><mo stretchy=\"false\">{</mo><mi>ψ</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{φ\\}C\\{ψ\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">φ</span><span class=\"mclose\">}</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mopen\">{</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span><span class=\"mclose\">}</span></span></span></span>, which express that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">φ</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">φ</span></span></span></span> holds and command <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> is applied then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding=\"application/x-tex\">ψ</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span></span></span></span> holds, are modelled as the preimage <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>F</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F^{-1}(C)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span>\"</p>\n<p>What actually is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> and how does its preimage  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>F</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F^{-1}(C)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span> model <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>φ</mi><mo stretchy=\"false\">}</mo><mi>C</mi><mo stretchy=\"false\">{</mo><mi>ψ</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{φ\\}C\\{ψ\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">φ</span><span class=\"mclose\">}</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mopen\">{</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span><span class=\"mclose\">}</span></span></span></span>? I'm confused because how can the preimage know about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">φ</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">φ</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding=\"application/x-tex\">ψ</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span></span></span></span>?</p>\n<p>Q2: On p1 you mentioned a \"rely-guarantee\" operator. I know about the rely-guarantee quintuples <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>r</mi><mo separator=\"true\">,</mo><mi>φ</mi><mo stretchy=\"false\">}</mo><mi>C</mi><mo stretchy=\"false\">{</mo><mi>g</mi><mo separator=\"true\">,</mo><mi>ψ</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{r,φ\\}C\\{g,ψ\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">φ</span><span class=\"mclose\">}</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mopen\">{</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span><span class=\"mclose\">}</span></span></span></span> that generalise Hoare triples to concurrency and are interpreted roughly as \"if the program is executed in a state satisfying <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">φ</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">φ</span></span></span></span> then while the environment satisfies <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> the program will satisfy <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> and then (possibly) terminate in state satisfying <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding=\"application/x-tex\">ψ</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span></span></span></span>\". How could this quintiple formulation be interpreted in Native Type Theory?</p>\n<p>EDIT: I guess the answer to my Q1 may be in the cited reference \"Functors are Type Refinement Systems\". I scanned over that now but it seems I don't know enough type theory to understand it. Q3: Can you please recommend a reference to get up to speed with the type theory needed to understand that and your paper? (I am ok with basic category theory but I never studied type theory).</p>\n<p>Thank you.</p>",
        "id": 232599671,
        "sender_full_name": "Naso",
        "timestamp": 1617200453
    },
    {
        "content": "<p>Hi Nasos, thanks for the questions. For Q1, I mean to say the preimage of some command <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> is the <em>set</em> of all such triples. The fiber over each object in the base is the poset of predicates <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">\\varphi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">φ</span></span></span></span>, and the fiber over each morphism would be this set of triples.</p>\n<p>For Q2, the term \"rely-guarantee\" was provided by <span class=\"user-mention\" data-user-id=\"276048\">@Mike Stay</span>. I don't know about its various uses; here it only means that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi><mo>⊸</mo><mi>ψ</mi></mrow><annotation encoding=\"application/x-tex\">\\varphi\\multimap \\psi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7443em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">φ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span></span></span></span> is the set of all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f:A\\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>⇒</mo><mi>ψ</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\varphi(a)\\Rightarrow \\psi(f(a))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">φ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span>. So \"relying\" on an input of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">\\varphi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">φ</span></span></span></span>, we can \"guarantee\" an output of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding=\"application/x-tex\">\\psi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span></span></span></span>. That's all we mean there.</p>\n<p>As for how this quintuple could be interpreted in NTT, that's a good question. I need to think about it.</p>",
        "id": 232630756,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617211262
    },
    {
        "content": "<p>The main reference for the type theory is Jacobs' <a href=\"https://people.mpi-sws.org/~dreyer/courses/catlogic/jacobs.pdf\">Categorical Logic and Type Theory</a>. It is about how fibrations model many kinds of languages, where the fiber over a context are the types and terms one can derive in that context.</p>",
        "id": 232631536,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617211546
    },
    {
        "content": "<p>Hope this helps; I can provide more information. Thanks for the questions.</p>",
        "id": 232631584,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617211563
    },
    {
        "content": "<p>In Q1 Nasos asked \"what is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span>?\"   Can you say what is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span>?</p>",
        "id": 232639492,
        "sender_full_name": "John Baez",
        "timestamp": 1617214554
    },
    {
        "content": "<p>I got the \"rely-guarantee\" terminology from Caires, who said <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi><mo>⊳</mo><mi>ψ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi \\rhd \\psi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin amsrm\">⊳</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span></span></span></span> is the type of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span>-calculus processes that when run in parallel with a process of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">ϕ</span></span></span></span>, the pair necessarily eventually evolves to a process of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding=\"application/x-tex\">\\psi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span></span></span></span>.</p>",
        "id": 232647402,
        "sender_full_name": "Mike Stay",
        "timestamp": 1617217675
    },
    {
        "content": "<p>sorry, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>:</mo><mi>E</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">F:E\\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is an arbitrary functor in <a href=\"http://noamz.org/papers/funts.pdf\">Functors are type refinement systems</a> (Mellies/Zeilberger). they give a syntax for functors, which is most interesting and useful when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> is a monoidal closed bifibration. a main example they use is Hoare/separation logic.</p>",
        "id": 232652828,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617219728
    },
    {
        "content": "<p>I want to share more examples of the expressiveness of native type theory.</p>",
        "id": 232940184,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617391075
    },
    {
        "content": "<p>The main language from the paper is the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding=\"application/x-tex\">\\rho</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">ρ</span></span></span></span>-calculus, which is presented as follows.</p>",
        "id": 232940253,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617391106
    },
    {
        "content": "<p><a href=\"/user_uploads/21317/q-SSCzNcZAb5lzzFRdtkt0yz/rho-calculus.png\">rho-calculus.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/q-SSCzNcZAb5lzzFRdtkt0yz/rho-calculus.png\" title=\"rho-calculus.png\"><img src=\"/user_uploads/21317/q-SSCzNcZAb5lzzFRdtkt0yz/rho-calculus.png\"></a></div>",
        "id": 232940274,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617391122
    },
    {
        "content": "<p>This looks like a lot, but you can just focus on a couple chunks.</p>",
        "id": 232940373,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617391190
    },
    {
        "content": "<p><a href=\"/user_uploads/21317/byppC9nb_gszy5-RJ_EYsTT3/rho-calculus_1.png\">rho-calculus_1.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/byppC9nb_gszy5-RJ_EYsTT3/rho-calculus_1.png\" title=\"rho-calculus_1.png\"><img src=\"/user_uploads/21317/byppC9nb_gszy5-RJ_EYsTT3/rho-calculus_1.png\"></a></div>",
        "id": 232940432,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617391206
    },
    {
        "content": "<p>Here are the constructors.</p>",
        "id": 232940505,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617391246
    },
    {
        "content": "<p><a href=\"/user_uploads/21317/H0-KeXPy4EfkqRC5Sg5390Zx/rho-calculus_3.png\">rho-calculus_3.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/H0-KeXPy4EfkqRC5Sg5390Zx/rho-calculus_3.png\" title=\"rho-calculus_3.png\"><img src=\"/user_uploads/21317/H0-KeXPy4EfkqRC5Sg5390Zx/rho-calculus_3.png\"></a></div>",
        "id": 232940538,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617391261
    },
    {
        "content": "<p>Here are the main rules.</p>",
        "id": 232940560,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617391267
    },
    {
        "content": "<p>It is a concurrent language, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mi mathvariant=\"normal\">∣</mi><mo>−</mo></mrow><annotation encoding=\"application/x-tex\">-\\vert -</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">−</span><span class=\"mord\">∣</span><span class=\"mord\">−</span></span></span></span> is parallel composition of processes. When there are two processes which input and output on the same name (channel) in parallel, they can <em>communicate</em> : the output sends a process, it is packaged up as a message using the reference operator \"@\", and it is substituted for the free name in the input process.</p>",
        "id": 232940803,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617391401
    },
    {
        "content": "<p>That's really the core of the whole language. In general, processes are just huge parallels of outputs and inputs on different channels, and computation progresses by communication.</p>",
        "id": 232940846,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617391438
    },
    {
        "content": "<p>So, I'm happy to talk more about this but I wanted to give an example. The native type system of this language is very rich.</p>",
        "id": 232940984,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617391485
    },
    {
        "content": "<p>In this theory, we have a graph of processes and rewrites between them <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo separator=\"true\">,</mo><mi>t</mi><mo>:</mo><mi>E</mi><mo>→</mo><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">s,t:E\\to P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.80952em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span>. All rewrites are generated from the basic communication rule, plus some rules at the bottom of that bigger presentation above, which allows for rewrites to happen inside parallels.</p>",
        "id": 232941100,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617391548
    },
    {
        "content": "<p>This graph is the space of all possible computations that can occur in this language. Using native type theory, we can study and explore this space effectively.</p>",
        "id": 232941199,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617391582
    },
    {
        "content": "<p>In particular, suppose we have a type of process <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi><mo>:</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mo>−</mo><mo separator=\"true\">,</mo><mi>P</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mrow><mi mathvariant=\"sans-serif\">P</mi><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">p</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\varphi : T(-,P)\\to \\mathsf{Prop}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">φ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">P</span><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">r</span><span class=\"mord mathsf\">o</span><span class=\"mord mathsf\">p</span></span></span></span></span>. This is a sieve in the theory, a type of process closed under substitution, which satisfies some property.</p>",
        "id": 232941375,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617391692
    },
    {
        "content": "<p>For example, this could be the type for \"liveness and safety\", <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">□</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mi>n</mi><mo stretchy=\"false\">(</mo><mi>α</mi><mo separator=\"true\">,</mo><mi>N</mi><mi mathvariant=\"normal\">.</mi><mi>P</mi><mo stretchy=\"false\">)</mo><mo>∧</mo><mi mathvariant=\"normal\">¬</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">¬</mi><mi>α</mi><mo separator=\"true\">,</mo><mi>N</mi><mi mathvariant=\"normal\">.</mi><mi>P</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\square (in(\\alpha, N.P) \\land \\neg in(\\neg \\alpha, N.P))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord amsrm\">□</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">¬</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord\">¬</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> : the type of process which always inputs on a set of channels <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span>, and never inputs on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\neg \\alpha</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">¬</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span>.</p>",
        "id": 232941551,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617391803
    },
    {
        "content": "<p>So given two such types of processes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi><mo separator=\"true\">,</mo><mi>ψ</mi><mo>:</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mo>−</mo><mo separator=\"true\">,</mo><mi>P</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mrow><mi mathvariant=\"sans-serif\">P</mi><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">p</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\varphi,\\psi: T(-,P)\\to \\mathsf{Prop}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">φ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">P</span><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">r</span><span class=\"mord mathsf\">o</span><span class=\"mord mathsf\">p</span></span></span></span></span>, we could filter to the subgraph of all computations whose source is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">\\varphi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">φ</span></span></span></span> and whose target is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding=\"application/x-tex\">\\psi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span></span></span></span>.</p>",
        "id": 232941751,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617391903
    },
    {
        "content": "<p>This is constructed by the composite <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mo>−</mo><mo separator=\"true\">,</mo><mi>E</mi><mo stretchy=\"false\">)</mo><mover><mo stretchy=\"true\">→</mo><mpadded lspace=\"0.3em\" width=\"+0.6em\"><mrow><mo stretchy=\"false\">⟨</mo><mi>s</mi><mo separator=\"true\">,</mo><mi>t</mi><mo stretchy=\"false\">⟩</mo></mrow></mpadded></mover><mi>T</mi><mo stretchy=\"false\">(</mo><mo>−</mo><mo separator=\"true\">,</mo><mi>P</mi><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup><mover><mo stretchy=\"true\">→</mo><mpadded lspace=\"0.3em\" width=\"+0.6em\"><mrow><mi>φ</mi><mo>×</mo><mi>ψ</mi></mrow></mpadded></mover><msup><mrow><mi mathvariant=\"sans-serif\">P</mi><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">p</mi></mrow><mn>2</mn></msup><mover><mo stretchy=\"true\">→</mo><mpadded lspace=\"0.3em\" width=\"+0.6em\"><mo lspace=\"0em\" rspace=\"0em\">∧</mo></mpadded></mover><mrow><mi mathvariant=\"sans-serif\">P</mi><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">p</mi></mrow></mrow><annotation encoding=\"application/x-tex\">T(-,E)\\xrightarrow{\\langle s,t\\rangle} T(-,P)^2\\xrightarrow{ \\varphi\\times \\psi} \\mathsf{Prop}^2\\xrightarrow{\\land} \\mathsf{Prop}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.397em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel x-arrow\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.147em;\"><span style=\"top:-3.322em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight x-arrow-pad\"><span class=\"mord mtight\"><span class=\"mopen mtight\">⟨</span><span class=\"mord mathnormal mtight\">s</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mclose mtight\">⟩</span></span></span></span><span class=\"svg-align\" style=\"top:-2.689em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"hide-tail\" style=\"height:0.522em;min-width:1.469em;\"><svg height=\"0.522em\" preserveAspectRatio=\"xMaxYMin slice\" viewBox=\"0 0 400000 522\" width=\"400em\"><path d=\"M0 241v40h399891c-47.3 35.3-84 78-110 128 -16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20  11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7  39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85 -40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5 -12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67  151.7 139 205zm0 0v40h399900v-40z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.010999999999999899em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3581079999999999em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel x-arrow\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1081079999999999em;\"><span style=\"top:-3.322em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight x-arrow-pad\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">φ</span><span class=\"mbin mtight\">×</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">ψ</span></span></span></span><span class=\"svg-align\" style=\"top:-2.689em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"hide-tail\" style=\"height:0.522em;min-width:1.469em;\"><svg height=\"0.522em\" preserveAspectRatio=\"xMaxYMin slice\" viewBox=\"0 0 400000 522\" width=\"400em\"><path d=\"M0 241v40h399891c-47.3 35.3-84 78-110 128 -16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20  11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7  39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85 -40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5 -12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67  151.7 139 205zm0 0v40h399900v-40z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.010999999999999899em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.205332em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">P</span><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">r</span><span class=\"mord mathsf\">o</span><span class=\"mord mathsf\">p</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8984479999999999em;\"><span style=\"top:-3.1473400000000002em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel x-arrow\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0108920000000001em;\"><span style=\"top:-3.322em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight x-arrow-pad\"><span class=\"mord mtight\"><span class=\"mord mtight\">∧</span></span></span></span><span class=\"svg-align\" style=\"top:-2.689em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"hide-tail\" style=\"height:0.522em;min-width:1.469em;\"><svg height=\"0.522em\" preserveAspectRatio=\"xMaxYMin slice\" viewBox=\"0 0 400000 522\" width=\"400em\"><path d=\"M0 241v40h399891c-47.3 35.3-84 78-110 128 -16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20  11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7  39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85 -40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5 -12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67  151.7 139 205zm0 0v40h399900v-40z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.010999999999999899em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">P</span><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">r</span><span class=\"mord mathsf\">o</span><span class=\"mord mathsf\">p</span></span></span></span></span>.</p>",
        "id": 232941961,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617392037
    },
    {
        "content": "<p>Hence we can use the type \"computations which start with property <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">\\varphi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">φ</span></span></span></span> and end with security property <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding=\"application/x-tex\">\\psi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span></span></span></span>.\"</p>",
        "id": 232942111,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617392116
    },
    {
        "content": "<p>Moreover, focusing on the one main rewrite rule of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding=\"application/x-tex\">\\rho</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">ρ</span></span></span></span> calculus, we can filter computations by specifying exactly how communication should happen.</p>",
        "id": 232942257,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617392228
    },
    {
        "content": "<p>We can say \"give me all computations where the output process is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">\\varphi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">φ</span></span></span></span> and the input process is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding=\"application/x-tex\">\\psi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span></span></span></span>, and also the data that is being sent is of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span>.\"</p>",
        "id": 232942387,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617392293
    },
    {
        "content": "<p>and much more. Native types can provide highly expressive and fine-grained specification of the space of communication happening on networks running on the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding=\"application/x-tex\">\\rho</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">ρ</span></span></span></span>-calculus.</p>",
        "id": 232942493,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617392371
    },
    {
        "content": "<p>I can draw up some pictures of this example to make it more clear and vivid. Please let me know any questions or thoughts.</p>",
        "id": 232942587,
        "sender_full_name": "Christian Williams",
        "timestamp": 1617392417
    },
    {
        "content": "<p>New version of the paper: <a href=\"/user_uploads/21317/WvCuMsE9KzUSa6htquOuIu8E/Native-Type-Theory.pdf\">Native-Type-Theory.pdf</a>. (will be on the arXiv Wednesday)</p>",
        "id": 238194045,
        "sender_full_name": "Christian Williams",
        "timestamp": 1620673035
    },
    {
        "content": "<p>The story has gotten simpler and better. Our theories are \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-theories with equality\", meaning cartesian closed categories with finite limits. This expands the expressiveness, and allows the construction to be 2-functorial.</p>",
        "id": 238194301,
        "sender_full_name": "Christian Williams",
        "timestamp": 1620673131
    },
    {
        "content": "<p>Nice</p>",
        "id": 238226924,
        "sender_full_name": "Jade Master",
        "timestamp": 1620689167
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275899\">Christian Williams</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/238194301\">said</a>:</p>\n<blockquote>\n<p>The story has gotten simpler and better. Our theories are \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-theories with equality\", meaning cartesian closed categories with finite limits. This expands the expressiveness, and allows the construction to be 2-functorial.</p>\n</blockquote>\n<p>Ah, very good. Remind me what you had before?</p>",
        "id": 238228197,
        "sender_full_name": "Jon Sterling",
        "timestamp": 1620690042
    },
    {
        "content": "<p>we were using \"higher-order algebraic theories\", developed by <span class=\"user-mention\" data-user-id=\"276092\">@Nathanael Arkor</span> and Dylan McDermott generalizing Fiore and Mahmoud's <a href=\"https://arxiv.org/abs/1308.5409\">second-order algebraic theories</a>.</p>",
        "id": 238233516,
        "sender_full_name": "Christian Williams",
        "timestamp": 1620693082
    },
    {
        "content": "<p>these are very nice because they correspond to monads, and the strength of these monads with respect to \"substitution monoidal structure\" provides a formal categorical method of variable binding and capture-avoiding substitution. <a href=\"https://www.cl.cam.ac.uk/~mpf23/talks/ICMS2007.pdf\">Fiore slides</a></p>",
        "id": 238233681,
        "sender_full_name": "Christian Williams",
        "timestamp": 1620693228
    },
    {
        "content": "<p>but we were not using these ideas in the native types construction, so we decided to simplify and work with CCCs.</p>",
        "id": 238233752,
        "sender_full_name": "Christian Williams",
        "timestamp": 1620693255
    },
    {
        "content": "<p>OK cool, thanks! Fiore &amp; Mahmoud's stuff, and what came after, is very very elegant --- but I too have found in practice that it ends up being easiest for my intended applications to just work with either CCCs or LCCCs.</p>",
        "id": 238236894,
        "sender_full_name": "Jon Sterling",
        "timestamp": 1620695867
    },
    {
        "content": "<p>Does anyone understand the link between this native type theory approach and gluing? I'm kind of asking while <span class=\"user-mention\" data-user-id=\"297784\">@Jonathan Sterling</span> is around in the hope that he would <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span> . Indeed, gluing looks a bit like a restriction of native type theory to closed terms, and predicates with a fixed arity. So, e.g., is there a sense in which native type theory embeds most forms of gluing? Or, for a more negative question, does native type theory make as much computational sense as gluing does (through realisability)?</p>",
        "id": 238256054,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1620712857
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"383799\">Tom Hirschowitz</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/238256054\">said</a>:</p>\n<blockquote>\n<p>Does anyone understand the link between this native type theory approach and gluing? I'm kind of asking while <span class=\"user-mention silent\" data-user-id=\"297784\">Jonathan Sterling</span> is around in the hope that he would <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span> . Indeed, gluing looks a bit like a restriction of native type theory to closed terms, and predicates with a fixed arity. So, e.g., is there a sense in which native type theory embeds most forms of gluing? Or, for a more negative question, does native type theory make as much computational sense as gluing does (through realisability)?</p>\n</blockquote>\n<p>I would say that these are diferent constructions, but the topos of presheaves on a language often serves as an <em>input</em> to a gluing construction --- for instance, this is how we proved normalization for cubical type theory. My idea from a few years ago, which thankfully panned out, was that we could obliterate all the complexities of Tait-computability arguments for type theories and programming languages by first turning a PL into a topos (whose internal language Christian is calling its \"native type theory\"), and then gluing this topos onto another topos that models whatever semantic thing I want to prove.</p>\n<p>Taking presheaves on your syntactic category gives you a type theory that extends your existing language and speaks only of notions that make sense for open terms and are closed under substitution. But many statements <em>about</em> a language are not of this form: they may be statements about closed terms, or they may be statements about open terms but stable only under some substitutions, etc...</p>\n<p>In this case you can consider a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">D</mi><mo>→</mo><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{D}\\to \\mathcal{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span> into the syntactic category where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">D</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{D}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> captures the shape of the contexts and substitutions you are going to be invariant under, and then take presheaves on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">D</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{D}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>. The result may not embed your language anymore (indeed, I guess it does not embed it unless <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">D</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{D}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> is a dense subcategory of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span>), but it will be a place where various important notions <em>about</em> your language can be stated. But now you need to connect these things to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span>! And that is what Artin gluing is for. In particular, you can embed your language into the Artin gluing of the inverse image to the induced essential morphism of topoi <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi mathvariant=\"script\">C</mi><mo stretchy=\"true\">undefined</mo></mover><mo>→</mo><mover accent=\"true\"><mi mathvariant=\"script\">D</mi><mo stretchy=\"true\">undefined</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\widehat{\\mathcal{C}}\\to\\widehat{\\mathcal{D}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.92333em;vertical-align:0em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.92333em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span><span class=\"svg-align\" style=\"width:calc(100% - 0.16668em);margin-left:0.16668em;top:-3.6833299999999998em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span style=\"height:0.24em;\"><svg width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.92333em;vertical-align:0em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.92333em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">D</span></span><span class=\"svg-align\" style=\"width:calc(100% - 0.11112em);margin-left:0.11112em;top:-3.6833299999999998em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span style=\"height:0.24em;\"><svg width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span></span></span></span>. This is what Johnstone calls the \"closed mapping cylinder\"; it is important to note that this is not usually an instance of sconing in the geometrical sense except in a few special cases, so it is unfortunate that this terminology has become so popular.</p>\n<p>For intuitions, if you are studying closed terms, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">D</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{D}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> is the terminal category and the structure map sends <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∗</mo></mrow><annotation encoding=\"application/x-tex\">*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.46528em;vertical-align:0em;\"></span><span class=\"mord\">∗</span></span></span></span> to the empty context; in this case, the glued topos gives you an internal language that has the original \"native type theory\" as a <em>open</em>-modal subuniverse, and set theory as a complemetnary <em>closed</em>-modal subuniverse. On the other hand, if you are studying open terms up to renamings (but not substitutions), then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">D</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{D}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> is a category of formal contexts and renamings and the structure map decodes these into actual contexts and actual substitutions.</p>",
        "id": 238256589,
        "sender_full_name": "Jon Sterling",
        "timestamp": 1620713279
    },
    {
        "content": "<p>The pertinent part of our paper on <a href=\"http://www.jonmsterling.com/pdfs/cubical-norm.pdf\">normalization for cubical type theory</a> is Section IV (\"The Computability Topos\"). Unfortunately the exposition is very terse because of LICS length restrictions.</p>\n<p>My thesis will be coming out soon, and there will be a much more leisurely introduction to these ideas.</p>",
        "id": 238257040,
        "sender_full_name": "Jon Sterling",
        "timestamp": 1620713691
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"297784\">@Jonathan Sterling</span> Thanks, this is very helpful! Looking forward to your thesis then. (I watched your talk at Augusta, which was also very helpful, but not quite enough for me to fully get how things work.)</p>",
        "id": 238259466,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1620715676
    },
    {
        "content": "<p>I couldn't resist and had a look at Section IV. It's actually quite readable, at least superficially. Congratulations for making such difficult material accessible!  </p>\n<p>What exactly is the scope of this technique? Until now, if I understand correctly, it has only been applied in this form to \"congruent\" languages, i.e., ones in which rewrite rules may be applied anywhere in the program --- that's rather informal, please don't hesitate to complain. </p>\n<p>On the other hand, techniques like <a href=\"https://www.fing.edu.uy/~amiquel/intro-krivine.pdf\">classical realisability</a> kind of do similar things by hand.</p>\n<p>Any guess on how easy it would be to apply it to, e.g., languages in the sense of <a href=\"https://era.ed.ac.uk/bitstream/handle/1842/215/Math_Op_Sem.pdf\">bialgebraic semantics</a> or <a href=\"https://hal.archives-ouvertes.fr/hal-02338144/file/LIPIcs-FSCD-2020-12.pdf\">transition monads</a>?</p>",
        "id": 238283047,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1620728404
    },
    {
        "content": "<p>Of course, another framework for the congruent case is <span class=\"user-mention\" data-user-id=\"398565\">@Marcelo Fiore</span> and <span class=\"user-mention\" data-user-id=\"277754\">@Philip Saville</span> 's <a href=\"https://link.springer.com/chapter/10.1007%2F978-3-030-45231-5_15\">bicategorical construction</a>.</p>",
        "id": 238283598,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1620728662
    },
    {
        "content": "<p>Indeed, this method really only shines right now on languages that can be phrased as equational theories (for instance, by means of a congruent rewriting system or otherwise). I have been exploring lately what it looks like for languages where you have actual transitions that are not equational (in the sense of not being congruent, or in the sense of not being deterministic) --- such things can be expressed, but here one is likely to just be reconstructing standard operational arguments in a slightly nicer way, rather than demolishing them <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 238310212,
        "sender_full_name": "Jon Sterling",
        "timestamp": 1620740968
    },
    {
        "content": "<p>This sounds cool! Everything lies in the \"slightly\", which I suspect I'd find understated. What puzzles me at the moment is how you can tune the granularity, e.g., how you avoid being too intentional in the glued topos. Not exactly sure what I'm talking about here, but probably if you start with a syntactic category modulo rewriting, then individuals in the glued logic are only considered equivalent up to rewriting, right? Or can gluing make them equivalent up to something coarser like some contextual equivalence?</p>",
        "id": 238336560,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1620749890
    },
    {
        "content": "<p>I have not explored trying to quotient by contextual equivalence, but generally I think this is a bad idea, because contextual equivalence is not modular. On the other hand, it is possible to use the gluing argument (modulo rewriting only) to establish contextual equivalences.</p>",
        "id": 238340166,
        "sender_full_name": "Jon Sterling",
        "timestamp": 1620751329
    },
    {
        "content": "<p>With that said, I think it is a very interesting question to try and phrase \"respect for contextual equivalence\" as perhaps some kind of orthogonality or lifting property in the gluing topos, and then one could investigate what connectives preserve this property! But I haven't thought about it. Perhaps this is something for you to try :)</p>",
        "id": 238340277,
        "sender_full_name": "Jon Sterling",
        "timestamp": 1620751384
    },
    {
        "content": "<p>Maybe! The learning curve looks a bit frightening, but I might get to it at some point.</p>",
        "id": 238341156,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1620751741
    },
    {
        "content": "<p>great idea, to capture a certain shapes of contexts and substitutions you'd like to study. I'll have to think more about what this \"closed mapping cylinder\" is like. thanks for the overview.</p>",
        "id": 238347650,
        "sender_full_name": "Christian Williams",
        "timestamp": 1620752752
    },
    {
        "content": "<p>as for your subsequent discussion, I don't even know how rewriting comes into this picture at all. but I should mention, the idea of representing operational semantics using internal graphs in a theory is very expressive. it is not restricted to languages with congruent rewriting systems.</p>",
        "id": 238348150,
        "sender_full_name": "Christian Williams",
        "timestamp": 1620752926
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"275899\">@Christian Williams</span>. Regarding rewriting, I got the -- apparently wrong -- impression that your framework used a notion of signature close to higher-order rewriting systems to generate languages. But yes, I agree with you that internal graphs are expressive, that's more or less what we use in transition monads. But then, what do you do exactly?</p>\n<p>If you mod out by the graph (i.e., consider edges as equations), then that's probably too coarse in a few relevant examples, e.g., non-deterministic languages. Right?</p>\n<p>If you retain the graph as a (proof-relevant) predicate in the logic, then (and this gets close to my earlier question about granularity) aren't you worryingly fine? E.g., in good old <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus your logic isn't even invariant under <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction. Would you agree that this at least begs some discussion? Can gluing rectify this in some way?</p>",
        "id": 238480656,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1620828954
    },
    {
        "content": "<p>sorry, I'm not sure what you mean. the logic is very fine-grained, yes, but there should be ways to tune it... can you explain this desired beta invariance?</p>",
        "id": 238511501,
        "sender_full_name": "Christian Williams",
        "timestamp": 1620840015
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"383799\">@Tom Hirschowitz</span> wrote:</p>\n<blockquote>\n<p>If you mod out by the graph (i.e., consider edges as equations), then that's probably too coarse in a few relevant examples, e.g., non-deterministic languages. Right?</p>\n</blockquote>\n<p>Yes.   The pi calculus, one of the main examples in Christian's paper, is a perfect example of this.  That's one of the main reasons Mike and Christian brought graphs into the game.</p>",
        "id": 238519438,
        "sender_full_name": "John Baez",
        "timestamp": 1620843135
    },
    {
        "content": "<blockquote>\n<p>If you retain the graph as a (proof-relevant) predicate in the logic, then (and this gets close to my earlier question about granularity) aren't you worryingly fine? </p>\n</blockquote>\n<p>What does \"worryingly fine\" mean here, exactly?    </p>\n<p>Are you saying that two lambda-terms differing by just <a href=\"https://wiki.haskell.org/Beta_reduction\">beta-reduction</a> count as distinct in Mike and Christian's setup applied to the lambda-calculus?    I guess that's right if we model beta-reduction as an edge of a graph.   </p>\n<p>Is that bad?</p>",
        "id": 238519893,
        "sender_full_name": "John Baez",
        "timestamp": 1620843348
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/238519893\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>If you retain the graph as a (proof-relevant) predicate in the logic, then (and this gets close to my earlier question about granularity) aren't you worryingly fine? </p>\n</blockquote>\n<p>What does \"worryingly fine\" mean here, exactly?    </p>\n<p>Are you saying that two lambda-terms differing by just <a href=\"https://wiki.haskell.org/Beta_reduction\">beta-reduction</a> count as distinct in Mike and Christian's setup applied to the lambda-calculus?    I guess that's right if we model beta-reduction as an edge of a graph.   </p>\n<p>Is that bad?</p>\n</blockquote>\n<p>The \"Is that bad?\" thing is, I would say, one of the most important and deepest questions we have to deal with in PL (and type theory) right now... It's certainly the case that not modding out by beta-reductions is the source of 95% of the complexity in metatheoretic arguments for type theory and programming languages (those scary papers that have 200 pages of inductions), but there are many cases where you can't seem to mod out --- as you and Tom have pointed out, non-determinism is one of them.</p>\n<p>My experience is that there is not usually a legitimate purpose (in the sense of being motivated by theorems that are of broad interest) to distinguishing beta redexes from their contracta, but that there are a variety of reductions (even deterministic ones) that probably we should distinguish because we have useful models that distinguish them. This arises, in particular, with recursive types and the so-called \"unfold-fold\" transitions.</p>",
        "id": 238554823,
        "sender_full_name": "Jon Sterling",
        "timestamp": 1620859187
    },
    {
        "content": "<p>You're right, <span class=\"user-mention\" data-user-id=\"275920\">@John Baez</span> and <span class=\"user-mention\" data-user-id=\"275899\">@Christian Williams</span>,  I'm not sure what I'm saying here. I guess it depends what you're planning to do with this native type theory. E.g., could you define some legitimate behavioural equivalence and prove some of its properties?</p>",
        "id": 238585682,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1620886324
    },
    {
        "content": "<p>I would augment <span class=\"user-mention\" data-user-id=\"297784\">@Jonathan Sterling</span> 's response regarding <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction in the following way: it makes little sense to regard two terms seen as <em>values</em> as different if they only differ by a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction. But it makes a lot of sense to view two terms seen as <em>computations</em> as different in that same case. </p>\n<p>So if computation is merely an ends to a means, then ignoring its process is fine.</p>\n<p>When doing meta-programming of all sorts, often the main point is to shift computation around. One of the things we often want to do in meta-computation is to shift <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-redexes from run-time to compile-time. So staging really cares a lot. One of the most basic things you keep track of in a partial evaluator is whether something is known to be a value (and thus it can be freely duplicated) or not (and so should be let-bound).</p>\n<p>So in 1-stage PL seen as black-boxes for getting work done, indeed, we don't care. In other cases? I'd say we care a lot!</p>",
        "id": 238618104,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1620911203
    },
    {
        "content": "<p>I roughly understand what Jacques is saying and this is why I <em>like</em> working with graphs as Christian and Mike are doing: it's a way to treat terms as computations.</p>",
        "id": 238652780,
        "sender_full_name": "John Baez",
        "timestamp": 1620926784
    },
    {
        "content": "<p>I feel ultimately it is a question of what you are trying to study. If you are trying to study the results of those computations, then it is going to be a major waste of time to differentiate between the different steps. If you are studying the steps themselves, then obviously we need to look at those directly! One methodological remark I would like to point out is, however, that in practice a mix of the two approaches is what is usually needed for most applications.</p>\n<p>There is a reason, for instance, that while some people may be interested in studying the transition from <code>fst(a,b)</code> to <code>a</code>, nobody is interested in studying the transition from <code>\\x.M(x)</code> to <code>\\y.M(y)</code>, etc. (Well, I may exaggerate when I say \"nobody\", but I hope my point is made that we are dealing with a spectrum, and where we end up on that spectrum can be determined by the applications we have in mind.)</p>",
        "id": 238655949,
        "sender_full_name": "Jon Sterling",
        "timestamp": 1620928361
    },
    {
        "content": "<p>I guess I'd like an approach that lets you include something resembling 2-morphisms between all these syntactically different terms - even the ones \"nobody is interested in\" - and then lets you easily mod out by any 2-morphisms you don't happen to be interested in right now.</p>",
        "id": 238656249,
        "sender_full_name": "John Baez",
        "timestamp": 1620928506
    },
    {
        "content": "<p>In pure math, at least, it's generally easier to \"mod out\" when you decide you're uninterested in something you were paying attention to, than to \"un-mod out\" when you decide you're interested in something you were ignoring.</p>",
        "id": 238656489,
        "sender_full_name": "John Baez",
        "timestamp": 1620928624
    },
    {
        "content": "<p>I like the 2-categoric approach too (and you get interesting stuff when you go beyond 2-categories too!). I think there is room for a bit of controversy, however, about whether some of these things should be dealt with by non-identity cells: for instance, there is a question of whether terms are graphs with distinguished back-edges denoting variable binding sites, or if they are strings. You could consider the string presentation and then add a lot of 2-cells that express the fact that adding parentheses around certain sub-strings is a no-op... And indeed, you can mod out by these if you consider them unimportant. But at some point you have to ask, why am I talking about strings in the first place? Maybe terms are actually graphs... In which case these 2-cells for dropping parentheses really don't make any sense...</p>",
        "id": 238656788,
        "sender_full_name": "Jon Sterling",
        "timestamp": 1620928760
    },
    {
        "content": "<p>In the end, as I say, it must keep coming down to whether you haev an interesting theorem to prove that would depend on being able to see (e.g.) the parentheses. If you do, then I really welcome the integration of them into some higher structure that can then be modded out later if one wishes to access a higher level of abstraction. But if you don't, then we shouldn't be doing it... Various low-level representations of things did not fall from the sky: human beings invented them. So categorification has to take into account not only what exists, but also what the intention was behind what exists.</p>",
        "id": 238657037,
        "sender_full_name": "Jon Sterling",
        "timestamp": 1620928858
    },
    {
        "content": "<p>Yes, I'm just a mathematician, so I don't know much about what syntax computer scientists actually care about, and I don't actually have any interesting theorems to prove on this subject; I just want to be able to describe whatever is going on without being <em>forced</em> to identify things that don't look equal to me.</p>",
        "id": 238657906,
        "sender_full_name": "John Baez",
        "timestamp": 1620929235
    },
    {
        "content": "<p>So, my humble job would be merely to provide tools...</p>",
        "id": 238664069,
        "sender_full_name": "John Baez",
        "timestamp": 1620932198
    },
    {
        "content": "<p>If you are mainly providing tools to be used by others, then I hope you will take our advice as to will and will not be useful to us ;-) But I do appreciate the distinction you are making and am, as always, very excited to see what you come up with.</p>",
        "id": 238683224,
        "sender_full_name": "Jon Sterling",
        "timestamp": 1620940834
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"297784\">Jonathan Sterling</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/238656788\">said</a>:</p>\n<blockquote>\n<p>I like the 2-categoric approach too (and you get interesting stuff when you go beyond 2-categories too!). I think there is room for a bit of controversy, however, about whether some of these things should be dealt with by non-identity cells: for instance, there is a question of whether terms are graphs with distinguished back-edges denoting variable binding sites, or if they are strings. You could consider the string presentation and then add a lot of 2-cells that express the fact that adding parentheses around certain sub-strings is a no-op... And indeed, you can mod out by these if you consider them unimportant. But at some point you have to ask, why am I talking about strings in the first place? Maybe terms are actually graphs... In which case these 2-cells for dropping parentheses really don't make any sense...</p>\n</blockquote>\n<p>I don't understand what you're saying about terms as graphs or strings; to me a term is just its abstract syntax tree. as for the 2-categorical aspect, John and I considered enriched theories for languages with rewriting; but only more recently I realized that these only work for <em>congruent</em> rewriting systems, not more general operational semantics. though maybe that's enough for many applications you care about.</p>",
        "id": 238685638,
        "sender_full_name": "Christian Williams",
        "timestamp": 1620942178
    },
    {
        "content": "<p>More generally in the discussion, this is why I think it's significant that native type theory combines reasoning about both structure and behavior. If the type system of the presheaf topos is initially too fine-grained for your purposes, we can restrict to subsystems which only make certain distinctions. We can quotient and reason up to behavioral equivalence.</p>",
        "id": 238686007,
        "sender_full_name": "Christian Williams",
        "timestamp": 1620942404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"297784\">Jonathan Sterling</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/238683224\">said</a>:</p>\n<blockquote>\n<p>If you are mainly providing tools to be used by others, then I hope you will take our advice as to will and will not be useful to us ;-) </p>\n</blockquote>\n<p>That makes plenty of sense.  I was trying to weasel out of this responsibility but I didn't really give the true reason.  The real reason is that it's <span class=\"user-mention\" data-user-id=\"275899\">@Christian Williams</span> and <span class=\"user-mention\" data-user-id=\"276048\">@Mike Stay</span> who are taking the lead on of this project, with me just providing a bit of category-theoretic assistance as Christian's thesis advisor.   So  I hope you keep talking about these issues, but I'll let them focus on the \"practical\" issues while I focus on the math questions that come up.</p>",
        "id": 238692281,
        "sender_full_name": "John Baez",
        "timestamp": 1620945916
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275899\">Christian Williams</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/238685638\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"297784\">Jonathan Sterling</span> <a href=\"#narrow/stream/258900-practice.3A-our.20papers/topic/Native.20Type.20Theory/near/238656788\">said</a>:</p>\n<blockquote>\n<p>I like the 2-categoric approach too (and you get interesting stuff when you go beyond 2-categories too!). I think there is room for a bit of controversy, however, about whether some of these things should be dealt with by non-identity cells: for instance, there is a question of whether terms are graphs with distinguished back-edges denoting variable binding sites, or if they are strings. You could consider the string presentation and then add a lot of 2-cells that express the fact that adding parentheses around certain sub-strings is a no-op... And indeed, you can mod out by these if you consider them unimportant. But at some point you have to ask, why am I talking about strings in the first place? Maybe terms are actually graphs... In which case these 2-cells for dropping parentheses really don't make any sense...</p>\n</blockquote>\n<p>I don't understand what you're saying about terms as graphs or strings; to me a term is just its abstract syntax tree. as for the 2-categorical aspect, John and I considered enriched theories for languages with rewriting; but only more recently I realized that these only work for <em>congruent</em> rewriting systems, not more general operational semantics. though maybe that's enough for many applications you care about.</p>\n</blockquote>\n<p>I don't care about terms, there are many possible representations --- I was just giving some examples of why it might not be obvious in principle that it is good to treat certain things as non-identity cells.</p>\n<p>Your point about congruence is quite apt... The ironic thing is, I think that the place where we most need to bring high-powered category theory to bear is in figuring out what is going on with the non-congruent rewriting systems that appear in most current-day PL work.  History has shown that a more careful analysis of these systems (as in the work of Paul Blain Levy and many others) leads to (1) isolating universal properties for connectives that appeared not to have universal properties, and (2) replacing incongruent rewriting systems with congruent ones --- or at least, decomposing the incongruent part of the rewriting system from the congruent part. </p>\n<p>And I agree with you that having a single language in which you can do both kinds of reasoning is very good, which is why I am such a fan of the lightweight way that you integrate rewriting into your framework.</p>",
        "id": 238757774,
        "sender_full_name": "Jon Sterling",
        "timestamp": 1620994894
    },
    {
        "content": "<p>Paul Blain-Levy addresses this in his lambda calculus course by working over 'binding diagrams' (<a href=\"https://www.cs.bham.ac.uk/~pbl/mgsall.pdf\">https://www.cs.bham.ac.uk/~pbl/mgsall.pdf</a> section 7) instead of terms-quotiented-by-alpha-equivalence, to give a concrete example</p>",
        "id": 239063318,
        "sender_full_name": "Nick Hu",
        "timestamp": 1621246203
    }
]