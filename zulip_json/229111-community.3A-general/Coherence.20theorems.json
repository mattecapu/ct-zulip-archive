[
    {
        "content": "<p>Hello everyone. I am wondering if there is a standard reference for the equivalence between different statements of the coherence theorem for monoidal categories (or for other algebraic theories) (<a href=\"https://ncatlab.org/nlab/show/coherence+theorem+for+monoidal+categories\">https://ncatlab.org/nlab/show/coherence+theorem+for+monoidal+categories</a>). In particular for the fact that the statement \"every diagram in a freely generated monoidal category made up of associators and unitors commutes\" implies the statement \"every monoidal category is monoidally equivalent to a strict monoidal category\".</p>",
        "id": 197724117,
        "sender_full_name": "Rafaël Bocquet",
        "timestamp": 1589563266
    },
    {
        "content": "<p>(I have a proof, I am mainly looking for references that I can cite)<br>\nMost of the proofs that I find instead prove the second statement directly by the means of a representation theorem.</p>",
        "id": 197725037,
        "sender_full_name": "Rafaël Bocquet",
        "timestamp": 1589563694
    },
    {
        "content": "<p>I don't know all the best references here.  I forget how much Mac Lane actually did.</p>",
        "id": 197745149,
        "sender_full_name": "John Baez",
        "timestamp": 1589572570
    },
    {
        "content": "<p>as far as I'm aware there isn't a standard reference for this direction of the argument. (As I guess you've seen already, it's not in the usual places, eg Mac Lane's book, his <em>Natural associativity and commutativity</em> paper or the Mac Lane-Pare paper on coherence for bicategories, while the Kelly/Power/Joyal/Street/etc approaches deal with the representation theorem approach.) </p>\n<p>Out of interest: what's your approach for proving the equivalence version from the 'all diagrams commute' statement? I can see how to show the free monoidal category (on, say, a set) is monoidally equivalent to a free strict monoidal category, but I can't see how to do it for an arbitrary monoidal category...</p>",
        "id": 197761945,
        "sender_full_name": "Philip Saville",
        "timestamp": 1589583778
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277754\">Philip Saville</span> <a href=\"#narrow/stream/229111-general/topic/Coherence.20theorems/near/197761945\">said</a>:</p>\n<blockquote>\n<p>as far as I'm aware there isn't a standard reference for this direction of the argument. (As I guess you've seen already, it's not in the usual places, eg Mac Lane's book, his <em>Natural associativity and commutativity</em> paper or the Mac Lane-Pare paper on coherence for bicategories, while the Kelly/Power/Joyal/Street/etc approaches deal with the representation theorem approach.) </p>\n<p>Out of interest: what's your approach for proving the equivalence version from the 'all diagrams commute' statement? I can see how to show the free monoidal category (on, say, a set) is monoidally equivalent to a free strict monoidal category, but I can't see how to do it for an arbitrary monoidal category...</p>\n</blockquote>\n<p>well, for me the standard references for this  were Mints and Soloviev, as described in Phil Scott's \"Some aspects of categories in Computer Science\", Handbook of Algebra, edited by M. Hazewinkel. (I've typed Mints coherence category in Google)</p>",
        "id": 197971054,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1589823751
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277754\">Philip Saville</span> <a href=\"#narrow/stream/229111-general/topic/Coherence.20theorems/near/197761945\">said</a>:</p>\n<blockquote>\n<p>Out of interest: what's your approach for proving the equivalence version from the 'all diagrams commute' statement? I can see how to show the free monoidal category (on, say, a set) is monoidally equivalent to a free strict monoidal category, but I can't see how to do it for an arbitrary monoidal category...</p>\n</blockquote>\n<p>The fact that all diagrams commute can be used to prove that the free monoidal category generated by a set of objects, a family of morphisms and a family of equalities between morphisms is equivalent to the free strict monoidal category on the same data. It may seem weird to include equalities between morphisms in the generating data, but the idea is that monoidal categories are presented by a generalized algebraic theory with 3 sorts, for objects, morphisms and equalities between morphisms.<br>\nThe proof that I know then constructs a suitable quotient of the freely generated monoidal category, using the fact that every diagram commutes to make sure that the choices of representative do not matter. This quotient is a retract of the corresponding free strict monoidal category (and is probably even isomorphic to it).</p>\n<p>By the small object argument, every monoidal category is equivalent to some freely generated monoidal category.  By combining these results, we get from any weak monoidal category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span></span>, a zigzag of monoidal equivalences <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi><mo>←</mo><mrow><mi mathvariant=\"sans-serif\">F</mi><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">e</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">)</mo><mo>→</mo><msub><mrow><mi mathvariant=\"sans-serif\">F</mi><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">e</mi></mrow><mi>s</mi></msub><mo stretchy=\"false\">(</mo><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal{C} \\leftarrow \\mathsf{Free}(\\mathcal{C}) \\rightarrow \\mathsf{Free}_s(\\mathcal{C})</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">←</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">F</span><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">r</span><span class=\"mord mathsf\">e</span><span class=\"mord mathsf\">e</span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">F</span><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">r</span><span class=\"mord mathsf\">e</span><span class=\"mord mathsf\">e</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span><span class=\"mclose\">)</span></span></span></span>.</p>\n<p>I'm not sure, but I think that in the case of monoidal categories, every monoidal category is a retract of a freely generated one. This would implies that all units of the adjunction between monoidal categories and strict monoidal categories are monoidal equivalences, not only the units for the freely generated monoidal categories.</p>",
        "id": 198235207,
        "sender_full_name": "Rafaël Bocquet",
        "timestamp": 1589997808
    },
    {
        "content": "<p>As I know it, the idea is to set up a monoidal equivalence between  your given monoidal category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> and the strict monoidal category of cliques <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>→</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">F[1] \\to M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span>,  as described <a href=\"https://ncatlab.org/nlab/show/clique\">here</a> in the nLab, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">F[1]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> is essentially discrete by Mac Lane's theorem. I think the same technique is described in Geometry of Tensor Calculus by Joyal and Street (although it might be Braided Tensor Categories).</p>",
        "id": 198237208,
        "sender_full_name": "Todd Trimble",
        "timestamp": 1589998694
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"277427\">@Rafaël Bocquet</span> interesting, thank you! </p>\n<p>Also, <span class=\"user-mention\" data-user-id=\"277611\">@Todd Trimble</span>  is right - Joyal &amp; Street sketch an argument using cliques in Generalised Tensor Calculus I (thanks Todd for the pointer, I'd not seen that paper before). </p>\n<p>It turns out there's more ways to prove this result than I had thought. To me it seems harder to go this way --- from <br>\n\"all diagrams commute\" to \"every X is equivalent to a strict X\" --- than the reverse, and I suspect the disparity grows as the structure gets richer. Are there any particular reasons (beside technical interest) for choosing this route?</p>",
        "id": 198326330,
        "sender_full_name": "Philip Saville",
        "timestamp": 1590070977
    },
    {
        "content": "<p>Most coherence theorems are not of the \"all diagrams commute\" sort, and they usually wind up giving procedures for deciding which diagrams commute in free structures. Understanding the free structures is often a necessary preamble before saying \"every X is equivalent to a strictish X\": it's not necessarily known in advance what strict/semistrict/strictish should mean, or whether that way of thinking about a coherence theorem is appropriate.</p>",
        "id": 198328485,
        "sender_full_name": "Todd Trimble",
        "timestamp": 1590072058
    },
    {
        "content": "<p>I'm proving the equivalence of different dependent type theories, and in that setting going through the route of representation theorems (which are a way to use the fact that some things are already known to be strict/coherent, such as the associativity of function composition) is not possible (as far as I know).</p>",
        "id": 198332700,
        "sender_full_name": "Rafaël Bocquet",
        "timestamp": 1590073948
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"277611\">@Todd Trimble</span> Thanks for the reference!</p>",
        "id": 198332836,
        "sender_full_name": "Rafaël Bocquet",
        "timestamp": 1590074007
    },
    {
        "content": "<p>both good points! Having just looked at some of these proofs, I could add that you also get a more concrete description of the strictification, and so of the normal / canonical forms for that structure.</p>\n<p>(My ulterior motive is that I have an \"every X is equivalent to a stricter X\" result via Yoneda and a \"free X is coherent\" result proven in a completely different way, and I'm wondering what new things I can get by using the latter to prove a strictification result for all Xs without going via Yoneda.)</p>",
        "id": 198338009,
        "sender_full_name": "Philip Saville",
        "timestamp": 1590076456
    }
]