[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276777\">@Mike Shulman</span>, <span class=\"user-mention\" data-user-id=\"276633\">@Mitchell Riley</span>: I am trying to familiarise myself with your approach in <em>A Fibrational Framework for Substructural and Modal Logics</em> and I was wondering whether you would be happy to answer a couple of questions here? I'm not sure whether Zulip feels too informal for this sort of thing; let me know if you don't think this is an appropriate medium!<br>\nOne question I had to begin with, to get a better understanding of the scope of this framework: are there any examples of substructural logics or related systems that this framework is <em>unable</em> to capture (at least in the form presented in the extended version of the paper)? It certainly seems to capture lots of useful examples, and I find it hard to tell what it does not cover (without considering, say, dependency, which I understand you are also currently working on).</p>",
        "id": 193930308,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1586885020
    },
    {
        "content": "<p>I'm not entirely familiar with that work, but I'm not sure whether it would handle a calculus of sensitivity analysis, as seen in <em><a href=\"https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.226.2729\" title=\"https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.226.2729\">Distance makes the types grow stronger</a></em>.</p>",
        "id": 193934671,
        "sender_full_name": "James Wood",
        "timestamp": 1586887013
    },
    {
        "content": "<p>But maybe this could be done via (ℝ-many) modalities.</p>",
        "id": 193935175,
        "sender_full_name": "James Wood",
        "timestamp": 1586887243
    },
    {
        "content": "<p>I'm curious about this too, last summer I had asked Dan Licata and Mitchell whether one can use the structural transformations to express (graded) modalities that distribute over or cancel each other, but we never followed through.</p>",
        "id": 193936442,
        "sender_full_name": "vikraman",
        "timestamp": 1586887895
    },
    {
        "content": "<p>oh mitchell riley is here?! i completely missed that</p>",
        "id": 193970298,
        "sender_full_name": "sarahzrf",
        "timestamp": 1586908242
    },
    {
        "content": "<p>Unfortunately I'm not familiar enough with the variety of substructural logics in the literature to really answer that question.  One obvious answer is that it doesn't cover \"classical\" systems whose judgments have multiple conclusions as well as multiple antecedents, but that's really just a different class of theory (or \"3-theory\") analogous to dependent types.  Given people's ingenuity in inventing weird type systems, I'd be surprised if there isn't some \"intuitionistic\" substructural logic not covered by our framework, but Dan or Mitchell could hopefully answer that better.</p>",
        "id": 193974516,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1586912622
    },
    {
        "content": "<p>Maybe one way to describe the \"3-theory\" that we're in is that, when you erase all the annotations, you end up with an underlying ordinary structural type theory. And the annotations just restrict you from using certain things in certain places. Perhaps focused logics are an example of something with an underlying structural type theory, but with weird enough rules that they don't fit?</p>",
        "id": 194242746,
        "sender_full_name": "Mitchell Riley",
        "timestamp": 1586994737
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281583\">James Wood</span> <a href=\"#narrow/stream/229952-theory.3A-type.20theory/topic/substructural.20logics/near/193935175\" title=\"#narrow/stream/229952-theory.3A-type.20theory/topic/substructural.20logics/near/193935175\">said</a>:</p>\n<blockquote>\n<p>But maybe this could be done via (ℝ-many) modalities.</p>\n</blockquote>\n<p>I think you're right... It looks like the way to do it would be a mode <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>,  a tensor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊗</mo><mo>:</mo><mo stretchy=\"false\">(</mo><mi>p</mi><mo separator=\"true\">,</mo><mi>p</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">\\otimes : (p, p) \\to p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">p</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span>'s worth of mode morphisms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo>:</mo><mi>p</mi><mo>→</mo><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">r : p \\to p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>. There would have to be a bunch of equations relating these things, e.g. composition of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span> morphisms should correspond to addition, and we would need a kind of contraction <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>+</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>⇒</mo><mi>r</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>s</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(r+s)(x) \\Rightarrow r(x) \\otimes s(x)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">)</span></span></span></span>. We would have 2-cells <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo>⇒</mo><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">r \\Rightarrow s</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span> whenever <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo>≥</mo><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">r \\geq s</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span>, which would let us get their variable rule and weakening.</p>\n<p>Then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding=\"application/x-tex\">\\otimes</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊗</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo stretchy=\"false\">!</mo><mi>r</mi></msub></mrow><annotation encoding=\"application/x-tex\">!_r</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mclose\"><span class=\"mclose\">!</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> are the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">F</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{F}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">F</span></span></span></span></span> types for the mode terms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding=\"application/x-tex\">\\otimes</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊗</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span></span></span></span>. I am not so sure how the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">&amp;</mi></mrow><annotation encoding=\"application/x-tex\">\\&amp;</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">&amp;</span></span></span></span> type fits though... In a footnote they suggest that a version of BI might make <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">&amp;</mi></mrow><annotation encoding=\"application/x-tex\">\\&amp;</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">&amp;</span></span></span></span> better behaved, perhaps there ought to be a second kind of context 'tensor' for it.</p>",
        "id": 194243003,
        "sender_full_name": "Mitchell Riley",
        "timestamp": 1586994958
    },
    {
        "content": "<p>There's also a bit of wiggle room in what you mean by \"fit\".  Some examples require more violence than others to shoehorn them into the framework.  (-:</p>",
        "id": 194243781,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1586995541
    },
    {
        "content": "<p>Hmm… I was trying to think of examples that may not necessary have an underlying cartesian context. For example, maybe something like fixed-length contexts or bounded-length contexts (e.g. single-variable contexts). Could these be expressed in the framework?</p>",
        "id": 194243783,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1586995544
    },
    {
        "content": "<p>Or nonempty contexts, say.</p>",
        "id": 194243859,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1586995575
    },
    {
        "content": "<p>Single-variable contexts should work: just give the underlying object in the mode theory no monoidal structure.  And nonempty contexts should work by giving it a semimonoidal structure (no unit), while dually subsingleton contexts should work by giving it a unit morphism but no multiplication.  I'm not sure what other kinds of fixed- or bounded-length contexts mean; for instance, if all contexts have length <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">\\le 2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> then what happens when you try to cut two judgments whose contexts both have length 2?</p>",
        "id": 194243962,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1586995682
    },
    {
        "content": "<p>If your source theory just disallows such cuts, then you might be able to encode it in the framework by just ignoring the results of such cuts (i.e. they're not in the image of the translation).</p>",
        "id": 194244007,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1586995727
    },
    {
        "content": "<p>That's true: you'd have to permit a simultaneous substitution kind of cut, rather than single-variable (if it could work at all).</p>",
        "id": 194244160,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1586995852
    }
]