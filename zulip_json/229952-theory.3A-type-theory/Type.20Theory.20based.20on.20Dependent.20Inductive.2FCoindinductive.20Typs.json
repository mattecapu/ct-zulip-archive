[
    {
        "content": "<p>Has anyone internalized (no pun intended) this paper: <a href=\"https://arxiv.org/abs/1605.02206\">https://arxiv.org/abs/1605.02206</a>? Basically it's a type theory that <em>defines</em> function types as a particular inductive, and has normalization as a by-product. I've been thinking this is possible for a while now, so I'm excited to understand what makes it tick, and whether this general approach can be applied to other type theories.</p>",
        "id": 202127673,
        "sender_full_name": "Cody Roux",
        "timestamp": 1593197466
    },
    {
        "content": "<p>I haven't seen that paper, but I'm familiar with another one that can define functions. It's more like System F_ω, though.</p>",
        "id": 202128252,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593197756
    },
    {
        "content": "<p>I guess the setting I'm familiar with is rather different, though. It doesn't attempt to have strong normalization, I think, and defining functions as 'data' would be kind of wrong. They are codata (that gives the correct evaluation strategy).</p>",
        "id": 202128874,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593198061
    },
    {
        "content": "<p>Co-inductive, sure. What's the other paper?</p>",
        "id": 202129130,
        "sender_full_name": "Cody Roux",
        "timestamp": 1593198219
    },
    {
        "content": "<p>Compiling with Classical Connectives.</p>",
        "id": 202129167,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593198237
    },
    {
        "content": "<p>It is also different from this paper in that it has multiple things on the right of the turnstile, and (co)constructors can have arbitrarily many things to the left and right of the turnstile.</p>",
        "id": 202129265,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593198287
    },
    {
        "content": "<p>Ugh classical logic. Thanks for the reference though! I really do enjoy this \"function spaces are nothing special\" philosophy.</p>",
        "id": 202129511,
        "sender_full_name": "Cody Roux",
        "timestamp": 1593198405
    },
    {
        "content": "<p>It is not just classical logic.</p>",
        "id": 202129549,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593198430
    },
    {
        "content": "<p>It is more like 'classical' linear logic, but it isn't linear, it has polarity shifts instead.</p>",
        "id": 202129588,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593198458
    },
    {
        "content": "<p>And the polarity shifts correspond to evaluation strategies that make the reduction behavior unambiguous.</p>",
        "id": 202129739,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593198535
    },
    {
        "content": "<p>So, e.g. <code>A + B</code> is not the same as <code>A ⅋ B</code>, because the evaluation strategy is different, and <code>A</code> and <code>B</code> cannot even be the same in either case, because <code>+</code> requires <code>A</code> and <code>B</code> to be positive, while for <code>⅋</code> they must be negative.</p>",
        "id": 202130235,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593198787
    },
    {
        "content": "<p>And <code>⅋</code> is defined in a similar way to functions if you use the calculus for arbitrary (co)data definitions. It is the codata type with a destructor like <code>A ⅋ B ⊢ A,B</code> I think. Functions are like <code>A , A → B ⊢ B</code>, but you could use a <code>¬</code> codata type to mediate between the difference.</p>",
        "id": 202131018,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593199179
    },
    {
        "content": "<p>I guess I should say (since it's probably not obvious), the similarity between the two is that <code>⅋</code> is a codata type with one destructor with two parameters, both negative. <code>→</code> is a codata type with one destructor with two parameters, one positive and one negative.</p>",
        "id": 202132304,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593199830
    },
    {
        "content": "<p>I think the original question is still a good one: has anyone formalized either of those approaches?</p>",
        "id": 202136762,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1593202179
    },
    {
        "content": "<p>I saw a few formalizations in Coq of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi><mover accent=\"true\"><mi>μ</mi><mo>~</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\mu\\tilde{\\mu}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8622999999999998em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">μ</span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6678599999999999em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">μ</span></span></span><span style=\"top:-3.35em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.22222em;\"><span class=\"mord\">~</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span></span></span> that are related to this point of view (the development of <a href=\"https://arxiv.org/pdf/1908.09123.pdf\">this paper</a> for instance -- <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>μ</mi><mo>~</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\tilde{\\mu}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8622999999999998em;vertical-align:-0.19444em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6678599999999999em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">μ</span></span></span><span style=\"top:-3.35em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.22222em;\"><span class=\"mord\">~</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span></span></span> gives you let-binding as well as pattern-matching, whereas <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">μ</span></span></span></span> provides some way to sequence contexts, as well as copattern-matching).<br>\n I have yet to read in details the paper above, but I think one annoying point is the treatment of universes. Sure you can provide Inductive-recursive models of universes but I don't think there is any such \"symmetric\" presentation of type theory incorporating the universes well (I would love to be proven wrong though).</p>",
        "id": 202139401,
        "sender_full_name": "Kenji Maillard",
        "timestamp": 1593203661
    },
    {
        "content": "<p>Yeah, I'm not really sure how to handle dependent types, because they're kind of inherently biased toward terms.</p>",
        "id": 202139669,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593203854
    },
    {
        "content": "<p>Whereas the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi><mover accent=\"true\"><mi>μ</mi><mo>~</mo></mover></mrow><annotation encoding=\"application/x-tex\">μ \\tilde μ</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8622999999999998em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">μ</span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6678599999999999em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathdefault\">μ</span></span><span style=\"top:-3.35em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.22222em;\"><span class=\"mord\">~</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span></span></span> stuff wants to put terms, coterms and cuts on more equal footing.</p>",
        "id": 202140214,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593204216
    },
    {
        "content": "<p>(Assuming it's like the paper I mentioned above, which does have those operations.)</p>",
        "id": 202140289,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593204248
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277270\">Dan Doel</span> <a href=\"#narrow/stream/229952-theory.3A-type.20theory/topic/Type.20Theory.20based.20on.20Dependent.20Inductive.2FCoindinductive.20Typs/near/202132304\">said</a>:</p>\n<blockquote>\n<p>I guess I should say (since it's probably not obvious), the similarity between the two is that <code>⅋</code> is a codata type with one destructor with two parameters, both negative. <code>→</code> is a codata type with one destructor with two parameters, one positive and one negative.</p>\n</blockquote>\n<p>That's cool, but I have very bad intuition about this. Is there a \"standard\" PL construct of type <code>⅋</code>?</p>",
        "id": 202147962,
        "sender_full_name": "Cody Roux",
        "timestamp": 1593209013
    },
    {
        "content": "<p>I don't know. It probably won't look very nice, because the way a lot of stuff is presented means that use of <code>⅋</code> is necessarily obscured. It is a type that is natural when you are about to manipulate continuations as easily as values, but most things are designed so that continuations are implicit, to limit what you can do with them.</p>\n<p>A value  <code>p : A ⅋ B</code> is something you can supply with two continuations, so in some ways you can think of it as something where you can do <code>match p with { L a -&gt; ... ; R b -&gt; ... }</code>. In a linear setting, I think the expectation you should have is that <em>both</em> branches run (instead of <code>A + B</code>, where only one runs). In a non-linear setting, this is relaxed, but still multiple branches may run, and some branches may run multiple times, I think (and this is contrary to <code>A + B</code> where again one branch runs exactly once).</p>\n<p>So, <code>A ⅋ B</code> is kind of like the \"devil's bargain\" interpretation of excluded middle. But the important part is that the calculus is structured so that this computational behavior is not conflated with the type <code>A + B</code>. The latter is intrinsically call-by-value, so its values are actually reduced values that actually look like <code>L x</code> or <code>R y</code>, and it makes no sense for the \"devil's bargain\" to be <em>values</em> of that type. By contrast, <code>A ⅋ B</code> is inherently call-by-name, so its values can have non-trivial computational behavior.</p>\n<p>Some of this can be seen in <code>A → B = ¬ A ⅋ B</code>. To call the function I think we must do <code>match f with { L k → jump k x ; R b → b }</code>. The first branch is, I think, run as many times as the argument is referred to directly in the body of the function. This may actually be 0 times, even, but I think it may be multiple times as well, although it isn't doing any significant computation here (because <code>¬</code> just turns a call-by-value type into call-by-name). The second branch is evaluated with the result of the function. But actually <code>B</code> is call-by-name because <code>⅋</code> requires its sub-expressions to be so, so how many times we go through the second branch might depend on how many times we use the name of this overall expression. So in some sense, even \"standard\" call-by-name scenarios are doing something a lot like the bargain, jumping back to the same place over and over. It just isn't presented that way.</p>",
        "id": 202158286,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593217396
    },
    {
        "content": "<p>In the calculus from the paper I mentioned, function values look like <code>λ[x,α]. c</code>, where <code>x</code> is the argument, and <code>α</code> is the return continuation, and <code>c</code> says how they should be used together. So, like, the identity function is <code>λ[x,α]. &lt;x|α&gt;</code>. Function continuations are like <code>[x,α]</code>, which is like 'pushing <code>x</code> onto the stack <code>α</code>.' And values of <code>A ⅋ B</code> are like <code>λ[α,β]. c</code>, while continuations are like <code>[α,β]</code>. Values of <code>A + B</code> are like <code>L x</code> and <code>L y</code>, and continuations are like <code>case { L x. c1 ; R y. c2 }</code>.  So there is more obvious distinction in the syntax than I used above, but I'm not sure how to maintain that in world where you are required to only talk about terms.</p>",
        "id": 202158960,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593218277
    },
    {
        "content": "<p>Cool, thanks for the clarification Dan! This makes <em>some</em> sense.</p>",
        "id": 202165715,
        "sender_full_name": "Cody Roux",
        "timestamp": 1593229417
    },
    {
        "content": "<p>Is it fair to say that a function in this kind of calculus can be made to go in two ways: either providing some input or requesting some output? I think this is how I'd make sense of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊸</mo><mi>B</mi><mo>≅</mo><msup><mi>B</mi><mtext>⊥</mtext></msup><mo>⊸</mo><msup><mi>A</mi><mtext>⊥</mtext></msup></mrow><annotation encoding=\"application/x-tex\">A ⊸ B ≅ B^⊥ ⊸ A^⊥</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">⊥</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">⊥</span></span></span></span></span></span></span></span></span></span></span> (both of them being equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mtext>⊥</mtext></msup><mtext>⅋</mtext><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A^⊥ ⅋ B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">⊥</span></span></span></span></span></span></span></span><span class=\"mord\">⅋</span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>).</p>",
        "id": 202180164,
        "sender_full_name": "James Wood",
        "timestamp": 1593255475
    },
    {
        "content": "<p>I'm not sure what you mean exactly. I guess I wouldn't say that for linear logic, because the idea is those aren't 'two modes' at all, they're just two equivalent ways of looking at the same thing, which is that there is an 'input pipe' for an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> and an 'output pipe' for a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, and things may happen in any order/simultaneously up to data dependencies. Unless you mean that 'an input pipe for an input pipe is an output pipe'. But it might be better to to think of putting an adapter on the output of a function than the function having multiple modes for that.</p>\n<p>In Compiling with Classical Connectives it is more complicated, because negation mediates between evaluation strategies, and so there are multiple negations. If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> is call-by-value, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">¬A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">¬</span><span class=\"mord mathdefault\">A</span></span></span></span> is call-by-name, but if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is call-by-name, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">¬B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">¬</span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is not even well formed. Instead you have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊖</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">\\ominus B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊖</span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> which is call-by-value.</p>\n<p>This has connections with different ways of viewing continuations. If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> is call-by-value, then its values are like trees built out of 'constructors'. Then values of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">¬A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">¬</span><span class=\"mord mathdefault\">A</span></span></span></span> are, I think, suspended computations waiting on an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> value to proceed. Continuations/covalues of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">¬A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">¬</span><span class=\"mord mathdefault\">A</span></span></span></span> are just wrapped values of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>.</p>\n<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is call-by-name, then its <em>values</em> are already suspended computations, and its continuations are like trees of 'observations' or instructions to perform on a corresponding computation. So the roles of value and continuation are kind of swapped from above. Then a value of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊖</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">\\ominus B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊖</span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is like a captured tree/stack representation of a continuation. And a continuation of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊖</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">\\ominus B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊖</span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is a suspended computation waiting to be matched up with one of these captured stacks.</p>\n<p>So, then, if you think about all this, you should hopefully be able to work out that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mo>⊖</mo><mi>B</mi><mo>≅</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">¬ \\ominus B \\cong B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">¬</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊖</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊖</mo><mi mathvariant=\"normal\">¬</mi><mi>A</mi><mo>≅</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">\\ominus ¬ A \\cong A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊖</span><span class=\"mord\">¬</span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>, and that this has something to do with inserting/removing some wrappers that kind of make my description of the 'trees' and such overly naive. <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> And I think functions still don't run in 'two modes' per se, it's probably more like snapping adapters on either side.</p>\n<p>(There are even more complications that I haven't mentioned yet, but I think they're not actually relevant for this example.)</p>",
        "id": 202194642,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593276248
    },
    {
        "content": "<p>This kind of shows you the bias toward values of a lot of type theory. The call-by-value stuff is inductive, and is thought of as concrete(-ish), well-founded trees. But that is describing its values. Coinductive stuff has concrete trees, too, but as the continuations, which you can't really access in type theory. But you can define an inductive type that essentially the same as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊖</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">\\ominus B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊖</span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>. So you might not be really losing out on anything in absolute terms, but it is somewhat obscured.</p>",
        "id": 202195291,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593277213
    },
    {
        "content": "<p>Hmm, actually, maybe my description wasn't overly naive, too. I guess the point of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi></mrow><annotation encoding=\"application/x-tex\">¬</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">¬</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊖</mo></mrow><annotation encoding=\"application/x-tex\">\\ominus</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊖</span></span></span></span> is that they dualize things in a way that matches up the 'simple' parts. So, a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">¬A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">¬</span><span class=\"mord mathdefault\">A</span></span></span></span> continuation is concrete presuming that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> values are concrete, and a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊖</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">\\ominus B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊖</span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> value is concrete presuming that a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> continuation is concrete. And <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A → B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> continuations are concrete because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> values are concrete, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> continuations are concrete (push a concrete value on a concrete stack). It is probably the 'additional complications' that make the description naive.</p>",
        "id": 202196151,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593278583
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276030\">@Cody Roux</span> I think one way to think about this, based on my rambling above, is that the calculus actually explicitly talks about (suspended) computations and concrete trees at <em>every</em> type. When you do this, functions are definable because it is just one type where the values are suspended computations, and the continuations are concrete trees.</p>\n<p>But in a lot of type theory, they only want to talk about values, and moreover, they almost exclusively want to talk about types where the values are the concrete trees (bias toward induction). Then functions are the one exception, and all of the 'suspended computation' stuff gets dumped into its values. Then all of the difficulty of normalization, extensionality, etc. gets presented as being about functions, because that is the one 'escape hatch' type used to embed all the computational behavior. When other M-types are included, they also inherit some difficulties, because of the value bias (their values are suspended computations, which want extensionality, rather than trees, which are content with intensionality).</p>",
        "id": 202198051,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593281325
    },
    {
        "content": "<p>In CwCC, computations <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><mi>e</mi><mi mathvariant=\"normal\">∣</mi><mi>T</mi><mo>:</mo><mi>s</mi><mi mathvariant=\"normal\">∣</mi><mi>α</mi><mo stretchy=\"false\">⟩</mo><mo>:</mo><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\"> \\langle e | T:s | α\\rangle : Γ ⊢ Δ</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord mathdefault\">e</span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span><span class=\"mclose\">⟩</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Δ</span></span></span></span> are their own thing to talk about. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">e</span></span></span></span> is a term of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span> is the evaluation strategy of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span></span></span></span> is a co-term of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">Γ</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Γ</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">Δ</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Δ</span></span></span></span> classify the free variables used in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">e</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span></span></span></span>. Then normalization is clearly about that, not about function values.</p>",
        "id": 202199258,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593283158
    }
]