[
    {
        "content": "<p>Hi all,</p>\n<p>For the final lesson of the course, I'll be going over <strong>monads</strong> and their algebras, and why they come in handy for typing data in neural networks.  </p>\n<p>The time is <strong>Monday November 7th, 4PM UTC.</strong> The Zoom link is here: <a href=\"https://uva-live.zoom.us/j/83816139841\">https://uva-live.zoom.us/j/83816139841</a><br>\nSlides are here: <a href=\"https://docs.google.com/presentation/d/1TBEaz-S5Zq42nDlkJVxDUBIyJ16rK9sD\">https://docs.google.com/presentation/d/1TBEaz-S5Zq42nDlkJVxDUBIyJ16rK9sD</a></p>\n<p>This lecture will help explain the use of monads in <a href=\"https://arxiv.org/abs/2203.15544\">Graph Neural Networks are Dynamic Programmers</a> (Dudzik and Veličković, NeurIPS 2022)</p>\n<p>See you all soon!<br>\nAndrew</p>",
        "id": 308274451,
        "sender_full_name": "Andrew Dudzik",
        "timestamp": 1667752499
    },
    {
        "content": "<p>The youtube link is <a href=\"https://youtu.be/y16JDvRi8GU\">https://youtu.be/y16JDvRi8GU</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"y16JDvRi8GU\" href=\"https://youtu.be/y16JDvRi8GU\"><img src=\"https://uploads.zulipusercontent.net/4de4e94f52e3cc0407142056bfd15970ba5a7e5c/68747470733a2f2f692e7974696d672e636f6d2f76692f7931364a447652693847552f64656661756c742e6a7067\"></a></div>",
        "id": 308381061,
        "sender_full_name": "Pim de Haan",
        "timestamp": 1667825214
    },
    {
        "content": "<p>Does anyone has a good reference for monads (or cat theory in general) uses in functional programming?</p>",
        "id": 308443627,
        "sender_full_name": "Alberto Colombo",
        "timestamp": 1667844200
    },
    {
        "content": "<p>someone has already recommended it but in case you didn't catch it you can get \"category theory for programmers\" by Bartosz Milewski</p>",
        "id": 308445060,
        "sender_full_name": "Jethro Djan",
        "timestamp": 1667844733
    },
    {
        "content": "<p>I also like \"Learning functional programming\" by Jack Wedman. Chapter 3 has some info on monads translate practically in FP</p>",
        "id": 308445996,
        "sender_full_name": "Jethro Djan",
        "timestamp": 1667845052
    },
    {
        "content": "<p>Hey I came across a cool workshop/conference on the use of monads in probability/statistics if anyone here wants to learn more stuff :P <a href=\"https://www.youtube.com/watch?v=3Da88Tgw_rM&amp;list=PLaILTSnVfqtIebAXFOcee9MvAyBwhIMyr&amp;index=1\">https://www.youtube.com/watch?v=3Da88Tgw_rM&amp;list=PLaILTSnVfqtIebAXFOcee9MvAyBwhIMyr&amp;index=1</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"3Da88Tgw_rM\" href=\"https://www.youtube.com/watch?v=3Da88Tgw_rM&amp;list=PLaILTSnVfqtIebAXFOcee9MvAyBwhIMyr&amp;index=1\"><img src=\"https://uploads.zulipusercontent.net/18eb027f07511082f23d10218ab3a4bad4a8592d/68747470733a2f2f692e7974696d672e636f6d2f76692f33446138385467775f724d2f64656661756c742e6a7067\"></a></div>",
        "id": 308488504,
        "sender_full_name": "Sichu Lu",
        "timestamp": 1667861642
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"553308\">@Andrew Dudzik</span> , I have a question regarding your talk. In the title you mention LSTMs, but they didn't really come back in the talk. I'm wondering how RNNs fit in the picture of list algebras.<br>\nIt seems like a RNN is like a general map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>R</mi><mo stretchy=\"false\">]</mo><mo>→</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">[R] \\to R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, but for this to be a proper algebra, it needs to be  composed of binary monoid multiplications <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>×</mo><mi>R</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R \\times R \\to R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, which is not what an RNN does, as it tracks a hidden state while processing the list. Is there an elegant way of adding a hidden state to the setup, so we can see an RNN as a monoid? Thanks!</p>",
        "id": 308531604,
        "sender_full_name": "Pim de Haan",
        "timestamp": 1667892990
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"543609\">@Sichu Lu</span> I believe you asked about  higher dimensional generalizations of algebras of a monad. Perhaps actegories are that. Here's a <a href=\"https://arxiv.org/abs/2203.16351\">survey</a> on those by <span class=\"user-mention\" data-user-id=\"275932\">@Matteo Capucci (he/him)</span> and <span class=\"user-mention\" data-user-id=\"276875\">@Bruno Gavranovic</span> .</p>",
        "id": 308534964,
        "sender_full_name": "Pim de Haan",
        "timestamp": 1667894809
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281702\">Pim de Haan</span> <a href=\"#narrow/stream/347879-workshop.3A-Categories-for-AI/topic/Week.205.3A.20Monads/near/308531604\">said</a>:</p>\n<blockquote>\n<p>Hi <span class=\"user-mention silent\" data-user-id=\"553308\">Andrew Dudzik</span> , I have a question regarding your talk. In the title you mention LSTMs, but they didn't really come back in the talk. I'm wondering how RNNs fit in the picture of list algebras.<br>\nIt seems like a RNN is like a general map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>R</mi><mo stretchy=\"false\">]</mo><mo>→</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">[R] \\to R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, but for this to be a proper algebra, it needs to be  composed of binary monoid multiplications <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>×</mo><mi>R</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R \\times R \\to R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, which is not what an RNN does, as it tracks a hidden state while processing the list. Is there an elegant way of adding a hidden state to the setup, so we can see an RNN as a monoid? Thanks!</p>\n</blockquote>\n<p>Thanks, I intended to bring this up but it got lost in the mix.</p>\n<p>I think we can model a hidden state by a module for a monoid, i.e. an algebra <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> for the writer monad <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>×</mo><mo>−</mo></mrow><annotation encoding=\"application/x-tex\">A \\times -</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is the monoid of updates.  Then we have an action <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>×</mo><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">A\\times M \\to M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>.</p>\n<p>So we think of the input to an RNN a monoid given by a list type and the hidden state as a representation for it.  Let me know if I'm overlooking any details.</p>",
        "id": 308540548,
        "sender_full_name": "Andrew Dudzik",
        "timestamp": 1667897334
    },
    {
        "content": "<p>Indeed, I think that would be an encoding RNN (using the terminology of <a href=\"https://colah.github.io/posts/2015-09-NN-Types-FP/\">this</a> blog post).<br>\nGetting a full encoding-decoding RNN takes a bit more work.</p>",
        "id": 308554652,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1667902691
    },
    {
        "content": "<p>Thanks, that makes sense! <br>\nThen is there an elegant way of thinking about the fold map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>A</mi><mo stretchy=\"false\">]</mo><mo>×</mo><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">[A] \\times M \\to M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>?</p>",
        "id": 308558919,
        "sender_full_name": "Pim de Haan",
        "timestamp": 1667904308
    },
    {
        "content": "<p>So let's use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> as above for the type of inputs, and let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> be a monoid we use to handle updates.  I think we should have a set map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">R\\to A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>, which is equivalent to a monoid map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>R</mi><mo stretchy=\"false\">]</mo><mo>→</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">[R]\\to A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>, that interprets inputs as updates.  This is basically giving a presentation of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> as a set of generators.</p>\n<p>This separates things into two concerns: 1) What is the structure of the \"update algebra\"? and 2) Which module/representation of that algebra are we using?  So for example, in the special case of invertible updates, this is like giving a presentation of a group and asking about its representations. (though if we want to work over vector spaces we should expand our group to a Hopf algebra)</p>",
        "id": 308562100,
        "sender_full_name": "Andrew Dudzik",
        "timestamp": 1667905652
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 308572521,
        "sender_full_name": "Pim de Haan",
        "timestamp": 1667909861
    },
    {
        "content": "<p>Indeed, I think there's a general pattern hiding in initial algebras / final coalgebras that describes the structurally recursive nature of many neural networks.<br>\nFor the encoding RNN, as you say, we need a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>×</mo><mi>S</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">f : X \\times S \\to S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> that takes an input, a state and produces a new state. Together with an initial state <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub><mo>:</mo><mn>1</mn><mo>→</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">s_0 : 1 \\to S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> this forms a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><msub><mi>s</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">]</mo><mo>:</mo><mn>1</mn><mo>+</mo><mi>X</mi><mo>×</mo><mi>S</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">[s_0, f] : 1 + X \\times S \\to S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> which can be thought of as the algebra for the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>+</mo><mi>X</mi><mo>×</mo><mo>−</mo><mo>:</mo><mi mathvariant=\"script\">C</mi><mo>→</mo><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">1 + X \\times - : \\mathcal{C} \\to \\mathcal{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span> endofunctor.  <br>\nThen the <em>initial</em> algebra of it describes lists, i.e. a map that takes any number of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>'s and recursively feeds them into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>. <a href=\"/user_uploads/21317/1DkQsh_G1cfzWsWlsj8hxiAL/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/1DkQsh_G1cfzWsWlsj8hxiAL/image.png\" title=\"image.png\"><img src=\"/user_uploads/21317/1DkQsh_G1cfzWsWlsj8hxiAL/image.png\"></a></div><p>In a dual way, we can get decoding RNNs by using final coalgebras. By following the description in the blog post, this arises out of the endofunctor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi><mo>×</mo><mo>−</mo><mo>:</mo><mi mathvariant=\"script\">C</mi><mo>→</mo><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">Y \\times - : \\mathcal{C} \\to \\mathcal{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span>, giving us streams.</p>\n<p>With general RNNs it gets a bit tricky, since they <em>don't</em> arise as a composition of these two concepts like the blog post suggests. But it can still be done using the Kleisli category of the state monad.</p>",
        "id": 308771252,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1667995060
    },
    {
        "content": "<p>Of course, what we also want is for each of these individual maps to be <em>parametric</em>, i.e. take the same parameter at every time step. This takes special care in unpacking and making sure it does what we want, but can essentially be handled using the  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">P</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">r</mi><mi mathvariant=\"bold\">a</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Para}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Para</span></span></span></span></span> construction (<a href=\"https://arxiv.org/abs/2103.01931\">paper</a>).</p>",
        "id": 308771756,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1667995238
    },
    {
        "content": "<p>It's worth adding for pedagogical purposes that \"algebras for an endofunctor\" and \"algebras for a monad\" mean slightly different things, as the latter has coherence axioms while the former doesn't. (this is one of many reasons I don't like the term \"algebras\" in this context)</p>\n<p>But the two definitions are related: an algebra for an endofunctor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"monospace\">T</mi></mrow><annotation encoding=\"application/x-tex\">\\mathtt{T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord mathtt\">T</span></span></span></span> is equivalently an algebra for the free monad generated by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"monospace\">T</mi></mrow><annotation encoding=\"application/x-tex\">\\mathtt{T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord mathtt\">T</span></span></span></span>.</p>",
        "id": 308775693,
        "sender_full_name": "Andrew Dudzik",
        "timestamp": 1667996769
    }
]