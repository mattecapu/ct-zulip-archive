[
    {
        "content": "<p>Hi everyone.  I'd like to share an idea I've been excited about recently.</p>\n<p>The idea is that single object proarrow equipments (from the double categorical perspective) are an algebra of 'concurrent resource transformations' in the same way that monoidal categories are an algebra of 'resource transformations'. </p>\n<p>I've written a short (not very technical) paper explaining how this is so. Its been rejected from one conference, and I'm going to submit an ever shorter version to another, but I have a feeling that the idea is going to wind up as a small part of a larger paper, instead of being presented on its own. </p>\n<p>I think some of you might be interested, so I'll link the preprint of the short paper here: <a href=\"https://arxiv.org/abs/2010.08233\">https://arxiv.org/abs/2010.08233</a></p>\n<p>(I know its got a few typos in. I've fixed them locally, but won't update the arxiv version just yet).</p>",
        "id": 224330358,
        "sender_full_name": "Chad Nester",
        "timestamp": 1611843111
    },
    {
        "content": "<p>I'd love to talk about this, so please don't be shy about questions / comments / connections.</p>",
        "id": 224330570,
        "sender_full_name": "Chad Nester",
        "timestamp": 1611843199
    },
    {
        "content": "<p>(I hope this stream is still alive! <span aria-label=\"skull and crossbones\" class=\"emoji emoji-2620\" role=\"img\" title=\"skull and crossbones\">:skull_and_crossbones:</span>)</p>",
        "id": 224331558,
        "sender_full_name": "Chad Nester",
        "timestamp": 1611843643
    },
    {
        "content": "<p>Cool! It seems to me like you are using double categories to represent concurrency with multiple agents, where the corners represent passing or receiving a resource from another agent. Is this how you think of it <span class=\"user-mention\" data-user-id=\"276114\">@Chad Nester</span></p>",
        "id": 224342867,
        "sender_full_name": "Jade Master",
        "timestamp": 1611848116
    },
    {
        "content": "<p>I wonder if there are concurrent process languages, like the pi-calculus for example which could be modeled in this framework</p>",
        "id": 224343426,
        "sender_full_name": "Jade Master",
        "timestamp": 1611848311
    },
    {
        "content": "<p>That's basically right, yes!</p>",
        "id": 224344202,
        "sender_full_name": "Chad Nester",
        "timestamp": 1611848532
    },
    {
        "content": "<p>I'm not necessarily thinking of each cell as an \"agent\" (I don't really know what that means, so I could be wrong here), but I think that what distinguishes a concurrent system from, say, one in which processes unfold in parallel, is that the material histories of its components are interleaved.</p>",
        "id": 224344912,
        "sender_full_name": "Chad Nester",
        "timestamp": 1611848803
    },
    {
        "content": "<p>The corners make it possible to represent this interleaving, while still being able to separate out the individual components.</p>",
        "id": 224345050,
        "sender_full_name": "Chad Nester",
        "timestamp": 1611848877
    },
    {
        "content": "<p>(Exactly as you say, the corners allow something like \"sending\" and \"receiving\" of resources.)</p>",
        "id": 224345206,
        "sender_full_name": "Chad Nester",
        "timestamp": 1611848936
    },
    {
        "content": "<p>Regarding things like the pi-calculus, I've been thinking of this more as a way to \"situate\" process calculi in the material world than as a process calculus in its own right.</p>",
        "id": 224346149,
        "sender_full_name": "Chad Nester",
        "timestamp": 1611849308
    },
    {
        "content": "<p>... I realise that's a bit cryptic. (There's a draft paper about this but it's too young right now!)</p>",
        "id": 224346200,
        "sender_full_name": "Chad Nester",
        "timestamp": 1611849331
    },
    {
        "content": "<p>For example, it would be nice if we could write down biological processes in some calculus, and then have them generate 'resource transformations' explaining, say, how the biomolecules involved have changed (the \"material history\" part) as they unfold. I think we need both perspectives (process calculus + material effects) to get a satisfying account.</p>",
        "id": 224346870,
        "sender_full_name": "Chad Nester",
        "timestamp": 1611849597
    },
    {
        "content": "<p>What's the difference between \"biological processes\" and \"how the molecules have changed\"?  Is the former a more abstract description that doesn't talk about molecules?</p>",
        "id": 224347966,
        "sender_full_name": "John Baez",
        "timestamp": 1611849867
    },
    {
        "content": "<p>(I'm really interested in these biological questions.  Are you?)</p>",
        "id": 224348026,
        "sender_full_name": "John Baez",
        "timestamp": 1611849891
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/Proarrow.20Equipments.20in.20Concurrency/near/224348026\">said</a>:</p>\n<blockquote>\n<p>(I'm really interested in these biological questions.  Are you?)</p>\n</blockquote>\n<p>Extremely. Although It's more of a hobby at the moment.</p>",
        "id": 224348300,
        "sender_full_name": "Chad Nester",
        "timestamp": 1611849990
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/Proarrow.20Equipments.20in.20Concurrency/near/224347966\">said</a>:</p>\n<blockquote>\n<p>What's the difference between \"biological processes\" and \"how the molecules have changed\"?  Is the former a more abstract description that doesn't talk about molecules?</p>\n</blockquote>\n<p>I would say that how the molecules change is an important aspect of these processes, but not the only one. We also need to capture the way in which the parts of a system constrain each other.</p>",
        "id": 224348605,
        "sender_full_name": "Chad Nester",
        "timestamp": 1611850112
    },
    {
        "content": "<p>... I'm not terribly happy with that answer</p>",
        "id": 224348774,
        "sender_full_name": "Chad Nester",
        "timestamp": 1611850177
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276114\">Chad Nester</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/Proarrow.20Equipments.20in.20Concurrency/near/224348605\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/Proarrow.20Equipments.20in.20Concurrency/near/224347966\">said</a>:</p>\n<blockquote>\n<p>What's the difference between \"biological processes\" and \"how the molecules have changed\"?  Is the former a more abstract description that doesn't talk about molecules?</p>\n</blockquote>\n<p>I would say that how the molecules change is an important aspect of these processes, but not the only one. We also need to capture the way in which the parts of a system constrain each other.</p>\n</blockquote>\n<p>Me, <span class=\"user-mention\" data-user-id=\"282822\">@fosco</span> and <span class=\"user-mention\" data-user-id=\"281862\">@Daniele Palombi</span> have another perspective on this, coming from the work of Rosen, and this is what we based the ManaNets paper on. Biological processes are a bunch of chemical reactions such that:</p>\n<ul>\n<li>Some reactions require some metabolytes to happen</li>\n<li>These metabolytes degrade over time</li>\n<li>These metabolytes are produced by other reactions in the process, so that the system kinda self-sustains.</li>\n</ul>",
        "id": 224349008,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1611850270
    },
    {
        "content": "<p>The emphasis here is on the fact that the real difference between \"chemistry\" and \"life\" is that life arranges chemical reactions so that they repair themselves.</p>",
        "id": 224349096,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1611850311
    },
    {
        "content": "<p>We're throwing quite a lot of stuff at this problem now, mana nets was a thing, we have another description in terms of fixed point theorems that we'll release at some point I hope. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 224349216,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1611850351
    },
    {
        "content": "<p>In any case, back to the original issue: I am not a fan of describing concurrent processes in terms of messages. There are very deep reasons for this, but in a nutshell: A concurrent system is made of two layers:</p>\n<ul>\n<li>A network layer, where messages get exchanged. The network can also dynamically change in time, and you should also take into account things like latencies etc to model race conditions.</li>\n<li>A local layer, that is, the computation that each machine executes locally.<br>\nAll the frameworks I've seen so far either ignore the network layer (e.g. lambda calculus, FSMs) or ignore the local layer (e.g. pi calculus, Petri nets). We won't go anywhere until we merge the two approaches into a unique condition. I've tried to do so using sheaves for two years and with the help of many people (lately mainly <span class=\"user-mention\" data-user-id=\"275932\">@Matteo Capucci (he/him)</span> ), but it's effing hard, and I'm not anymore convinced that sheaves are the right way to tackle this. If someone is interested in pursuing this line of research, or to suggest any possible mathematical tool to model this, please let me know, I'm -&gt;Super&lt;- interested in this.</li>\n</ul>",
        "id": 224349809,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1611850572
    },
    {
        "content": "<p>When you try to get deeper into this you realize that this problem is \"slimy\". Everywhere you turn there's something that evades you, or that you aren't modelling.. In the end, it's very difficult to come up with a model that formalizes this correctly while being manageable enough to crunch some numbers.</p>",
        "id": 224350094,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1611850662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276114\">Chad Nester</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/Proarrow.20Equipments.20in.20Concurrency/near/224350028\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> I think this might be close to what I mean by \"situating\" process calculi.</p>\n</blockquote>\n<p>In this respect, I agree that you could see this as a bunch of process calculi happening locally, and coordinated by a network layer. Still, very difficult to properly frame it</p>",
        "id": 224350331,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1611850731
    },
    {
        "content": "<p>(sorry I deleted that message!)</p>",
        "id": 224350376,
        "sender_full_name": "Chad Nester",
        "timestamp": 1611850745
    },
    {
        "content": "<p>no worries xD</p>",
        "id": 224350388,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1611850749
    },
    {
        "content": "<p>Just to give an estimate of how hard this is: You network may not be (usually it is not) stable even vertex-wise: New nodes can join/ef off the protocol ad libitum</p>",
        "id": 224350575,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1611850810
    },
    {
        "content": "<p>I agree that that's a slippery problem. I'm certainly not claiming to have solved it!</p>",
        "id": 224354390,
        "sender_full_name": "Chad Nester",
        "timestamp": 1611852311
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/224350094\">said</a>:</p>\n<blockquote>\n<p>When you try to get deeper into this you realize that this problem is \"slimy\". Everywhere you turn there's something that evades you, or that you aren't modelling. In the end, it's very difficult to come up with a model that formalizes this correctly while being manageable enough to crunch some numbers.</p>\n</blockquote>\n<p>Hey, biology is slimy.    If life were simple to describe, other life would emerge that would take advantage of this simplicity to eat it up.</p>",
        "id": 224356078,
        "sender_full_name": "John Baez",
        "timestamp": 1611852604
    },
    {
        "content": "<p>Every possible loophole or \"leaky abstraction\" gets exploited.</p>",
        "id": 224356189,
        "sender_full_name": "John Baez",
        "timestamp": 1611852643
    },
    {
        "content": "<p>Hi Chad,<br>\nReally cool paper! Can't wait to hear/read more about this!</p>",
        "id": 224359906,
        "sender_full_name": "Daniele Palombi",
        "timestamp": 1611854094
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/224349809\">said</a>:</p>\n<blockquote>\n<p>In any case, back to the original issue: I am not a fan of describing concurrent processes in terms of messages. There are very deep reasons for this, but in a nutshell: A concurrent system is made of two layers:</p>\n<ul>\n<li>A network layer, where messages get exchanged. The network can also dynamically change in time, and you should also take into account things like latencies etc to model race conditions.</li>\n<li>A local layer, that is, the computation that each machine executes locally.<br>\nAll the frameworks I've seen so far either ignore the network layer (e.g. lambda calculus, FSMs) or ignore the local layer (e.g. pi calculus, Petri nets). We won't go anywhere until we merge the two approaches into a unique condition. I've tried to do so using sheaves for two years and with the help of many people (lately mainly <span class=\"user-mention silent\" data-user-id=\"275932\">Matteo Capucci (he/him)</span> ), but it's effing hard, and I'm not anymore convinced that sheaves are the right way to tackle this. If someone is interested in pursuing this line of research, or to suggest any possible mathematical tool to model this, please let me know, I'm -&gt;Super&lt;- interested in this.</li>\n</ul>\n</blockquote>\n<p>I suppose that I don't entirely understand this distinction. I would say that Petri nets can do both, either model the computations on a specific machine or model the coordination between machines. Similarly, FSM's can also model on both levels. Is your point that they don't model at both levels at the same time? If so there are various ways to make Petri nets Hierarchical which I think you might already be aware of... .</p>",
        "id": 224368004,
        "sender_full_name": "Jade Master",
        "timestamp": 1611857265
    },
    {
        "content": "<p>In some sense open Petri nets can model this type of hierarchy, each open Petri net can represent an individual machine which can be joined along various message passing channels to form the larger system. There are also elementary object systems which I am personally a fan of.</p>",
        "id": 224368399,
        "sender_full_name": "Jade Master",
        "timestamp": 1611857449
    },
    {
        "content": "<p>I'll reply to this soon-ish, today I'm out of the games, not feeling well</p>",
        "id": 224368430,
        "sender_full_name": "fosco",
        "timestamp": 1611857462
    },
    {
        "content": "<p>...oh, well, I can copypaste a message that I sent on the ACT4E zulip channel</p>",
        "id": 224368833,
        "sender_full_name": "fosco",
        "timestamp": 1611857637
    },
    {
        "content": "<p>My interest in Rosen's work can be summarised in the fact that some of the properties of living systems that Rosen tried to express in categorical language can indeed be expressed as such, just relying not on 1-categories, but on 2- or bi-categories. (This is where some form of proarrow-equipmentish-calculus could turn out to be useful)</p>\n<p>It was an intuition of Cǎzǎnescu and Baianu that a category of (M,R)-systems can be expressed as a category of automata in a cartesian closed category. I suspect one can extract a more faithful description of (M,R)-systems by performing the same categorical construction of Cǎzǎnescu-Baianu but in a linearly distributive category. After all, chemical reactions are linear. (I found there's already a very enticing paper on a \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus for chemical reactions\", weeks ago, but in the end I didn't enter the white rabbit hole).</p>\n<p>Another compelling connection I've found is with untyped <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus: when interpreted in cartesian closed categories, (M,R)-systems tend to generate <a href=\"https://ncatlab.org/nlab/show/reflexive+object\">reflexive objects</a>, i.e. types <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> that are isomorphic to their type of endofunction <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mi>A</mi></msup></mrow><annotation encoding=\"application/x-tex\">A^A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">A</span></span></span></span></span></span></span></span></span></span></span>. This is not by chance, and it's a feature of \"equations\" in a cartesian closed category that is tightly linked to Lawvere's fixed point theory in a CCC, in a way I'm trying to understand better: in fact, I've found that to every \"admissible\" (M,R)-system (with respect to a notion of \"admissibility\" that Rosen never spells out in a comprehensible manner, at least for a mathematician <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> ) one can associate a system of \"type equations\"</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">{</mo><mtable columnalign=\"left left\" columnspacing=\"1em\" rowspacing=\"0.3599999999999999em\"><mtr><mtd><mstyle displaystyle=\"false\" scriptlevel=\"0\"><mrow><msub><mi>F</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo><mo>≅</mo><msub><mi>X</mi><mn>1</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle displaystyle=\"false\" scriptlevel=\"0\"><mi><mi mathvariant=\"normal\">⋮</mi><mpadded height=\"+0em\" voffset=\"0em\"><mspace height=\"1.5em\" mathbackground=\"black\" width=\"0em\"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle displaystyle=\"false\" scriptlevel=\"0\"><mrow><msub><mi>F</mi><mi>k</mi></msub><mo stretchy=\"false\">(</mo><msub><mi>X</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo>≅</mo><msub><mi>X</mi><mi>k</mi></msub></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding=\"application/x-tex\">\\begin{cases} F_1(X_1)\\cong X_1\\\\  \\vdots \\\\  F_k(X_k)\\cong X_k \\end{cases}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:4.811999999999999em;vertical-align:-2.1559999999999997em;\"></span><span class=\"minner\"><span class=\"mopen\"><span class=\"delimsizing mult\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.6500200000000005em;\"><span style=\"top:-1.8999899999999998em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎩</span></span></span><span style=\"top:-1.89499em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎪</span></span></span><span style=\"top:-2.18999em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎪</span></span></span><span style=\"top:-2.20499em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎪</span></span></span><span style=\"top:-3.15001em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎨</span></span></span><span style=\"top:-4.2950099999999996em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎪</span></span></span><span style=\"top:-4.59001em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎪</span></span></span><span style=\"top:-4.60501em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎪</span></span></span><span style=\"top:-4.90002em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎧</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.15002em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.656em;\"><span style=\"top:-5.335500000000001em;\"><span class=\"pstrut\" style=\"height:3.6875em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.4035em;\"><span class=\"pstrut\" style=\"height:3.6875em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\">⋮</span><span class=\"mord rule\" style=\"border-right-width:0em;border-top-width:1.5em;bottom:0em;\"></span></span></span></span><span style=\"top:-1.9635000000000002em;\"><span class=\"pstrut\" style=\"height:3.6875em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.1559999999999997em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> </p>\n<p>whose solutions will be the \"stable states\" of the (M,R)-system. [Insert here related work by Leinster]</p>\n<p>I would also like to get rid of the cartesian closed assumption and interpret (M,R)-systems in some kind of bicategory modeled on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">P</mi><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">f</mi></mrow><annotation encoding=\"application/x-tex\">\\sf Prof</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">P</span><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">r</span><span class=\"mord mathsf\">o</span><span class=\"mord mathsf\" style=\"margin-right:0.06944em;\">f</span></span></span></span></span> (the equipment of profunctors); most of the definitions in Rosen-Louie are inherently relational/profunctorial, and in fact some ugly uniqueness that Rosen is forced to require because he's working in the category of sets can be more elegantly avoided passing to the bicategory of relations; again, this is something that Louie sketched, but -afaicu- didn't fully exploit (mostly because he didn't know anything about the internal language of bicategories of profunctors, I guess?)</p>",
        "id": 224369645,
        "sender_full_name": "fosco",
        "timestamp": 1611857957
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276037\">Jade Master</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/224368004\">said</a>:</p>\n<blockquote>\n<p>I suppose that I don't entirely understand this distinction. I would say that Petri nets can do both, either model the computations on a specific machine or model the coordination between machines. Similarly, FSM's can also model on both levels. Is your point that they don't model at both levels at the same time? If so there are various ways to make Petri nets Hierarchical which I think you might already be aware of... .</p>\n</blockquote>\n<p>I work on a system that generates traces of communicating “threads of execution”, some of which is open sourced <a href=\"https://github.com/auxoncorp/modality-probe\">here</a>. The distinction, to me, w/r/t the “levels” is that depending on how we structure the trace data, we get one version where we see things as independent agents or actors with points of synchronization, I call this the timeline view. Something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">Timelines</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">HashMap</span><span class=\"o\">&lt;</span><span class=\"n\">ProcessId</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">Event</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Or in a graph view where the notion of “threads of execution” are erased; usually represented in the usual node and edge list way. I say this all to say that we <em>can</em> model both, just not at the same time.</p>",
        "id": 224379486,
        "sender_full_name": "dan pittman",
        "timestamp": 1611861955
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284213\">dan pittman</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/224379486\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276037\">Jade Master</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/224368004\">said</a>:</p>\n<blockquote>\n<p>I suppose that I don't entirely understand this distinction. I would say that Petri nets can do both, either model the computations on a specific machine or model the coordination between machines. Similarly, FSM's can also model on both levels. Is your point that they don't model at both levels at the same time? If so there are various ways to make Petri nets Hierarchical which I think you might already be aware of... .</p>\n</blockquote>\n<p>I work on a system that generates traces of communicating “threads of execution”, some of which is open sourced <a href=\"https://github.com/auxoncorp/modality-probe\">here</a>. The distinction, to me, w/r/t the “levels” is that depending on how we structure the trace data, we get one version where we see things as independent agents or actors with points of synchronization, I call this the timeline view. Something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">Timelines</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">HashMap</span><span class=\"o\">&lt;</span><span class=\"n\">ProcessId</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">Event</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Or in a graph view where the notion of “threads of execution” are erased; usually represented in the usual node and edge list way. I say this all to say that we <em>can</em> model both, just not at the same time.</p>\n</blockquote>\n<p>Interesting. Do you think that your system would benefit from modeling both at the same time?</p>",
        "id": 224385437,
        "sender_full_name": "Jade Master",
        "timestamp": 1611864413
    },
    {
        "content": "<p>Maybe? Our commercial offering does analysis against these graphs, things like satisfiability  &amp;c, and depending on which form the particular analysis at hand needs, we build one graph type or the other. This seems fine from an engineering standpoint because we're going to optimize the structure of the data as needed anyway, but in terms of having a cohesive way to express to a user what her system did, I'd say that'd be <em>very</em> interesting. I probably can't hang with most of the CT in this paper, but I'm going to give it a read anyway, for sure—if only to see what intuitions shake out.</p>",
        "id": 224386894,
        "sender_full_name": "dan pittman",
        "timestamp": 1611865147
    },
    {
        "content": "<p>(btw, Auxon looks cool <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span>)</p>",
        "id": 224387350,
        "sender_full_name": "Eric Forgy",
        "timestamp": 1611865398
    },
    {
        "content": "<p>Petri nets can represent concurrency well, but they are nowhere close to representing what I'm talking about. Few reasons for this:</p>",
        "id": 224404912,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1611873690
    },
    {
        "content": "<ul>\n<li>You can use Petri nets to represent local, multi-threaded computation. This works reasonably well.</li>\n<li>You can use Petri nets to represent information flow in a network. This works really not well, mainly because the network varies dynamically, and also because to be of any practical use you cannot model message passing as a point-to-point event. Messages on real network get broadcasted, that is, send to many machines at the same time. Representing this by adding a lot of transitions around that copy resources is not going to fly.</li>\n<li>Representing both things at the same time requires some level of hiearchy, but in this framework you want the places of a net to be Petri nets themselves. This is not exactly what the literature has been doing so far.</li>\n</ul>",
        "id": 224405171,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1611873863
    },
    {
        "content": "<p>By the way, my sheaf-theoretic approach to this problem (that went nowhere) was mainly motivated by point 2 above: Nearly all examples of connectivity/compositionality in ACT are point to point. This includes open petri nets, wiring diagrams, string diagrams, quantum stuff. I don't think this approach is really insightful in describing big networks of computers and P2P protocols, that work on completely different assumptions.</p>",
        "id": 224405289,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1611873942
    },
    {
        "content": "<p>For instance, if I request a file in a P2P network I'm sending a message around saying \"hey, who has this file?\" Every machine having it will maybe reply to me. Others will just discard the message. The message is broadcasted around until the network is saturated. In this case describing things as a sequence of point-to-point communication just makes things murky.</p>",
        "id": 224405471,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1611874035
    },
    {
        "content": "<p>There are a ton of protocols - heavily used ones - that work this way (parse what matters to you, discard the rest), e.g. MQTT or the CAN bus. These are easier to describe because they are not decentralized.</p>",
        "id": 224405582,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1611874087
    },
    {
        "content": "<p>What I'm saying is that from an engineering perspective the idea of compositionality as \"the act of composing two systems\" won't fly if the system described is really big. I was thinking about writing a non-technical paper about this for the next ACT, and submitting it as non-proceeding. \"compositionality for big systems\" is definitely something we will have to think about a few years from now <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 224405894,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1611874295
    },
    {
        "content": "<p>Fab you keep describing my future PhD thesis, I'm starting to think you are me from the future <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> in that case I have some questions</p>",
        "id": 224406101,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1611874415
    },
    {
        "content": "<p>What I mean is, we ask the same questions and poke the same holes; not that I currently have answers</p>",
        "id": 224406182,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1611874446
    },
    {
        "content": "<p>A thought I had somewhen last week, since we often spoke about sheaves in this context. Sheaves might not be the right tools for this job, at least not naively, because sheaves talk about <em>local</em> things. As soon as you want to be able to talk about non-local phenomena (see mana nets) you gotta abandon the sheaf condition.<br>\nImplicitly, I also realized this when I gave <a href=\"https://github.com/mattecapu/fantastic-sheaves\">my talk about sheaves</a> and I described cohomology of behaviour as the cohomology of the <em>augmented</em> Cech complex. In layman terms, this means not taking separation and glueing for granted by measuring their failures as well.</p>",
        "id": 224406480,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1611874656
    },
    {
        "content": "<p>This conversation is motivating me to write a blog post about elementary object systems <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 224407269,
        "sender_full_name": "Jade Master",
        "timestamp": 1611875102
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275932\">Matteo Capucci (he/him)</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/224406101\">said</a>:</p>\n<blockquote>\n<p>Fab you keep describing my future PhD thesis, I'm starting to think you are me from the future <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> in that case I have some questions</p>\n</blockquote>\n<p>We should start talking about this stuff again at some point. Atm I'm really working on too many different things, but I hope to be able to get back to the stuff I wrote above in the future.</p>",
        "id": 224408153,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1611875679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/224408153\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"275932\">Matteo Capucci (he/him)</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/224406101\">said</a>:</p>\n<blockquote>\n<p>Fab you keep describing my future PhD thesis, I'm starting to think you are me from the future <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> in that case I have some questions</p>\n</blockquote>\n<p>We should start talking about this stuff again at some point. Atm I'm really working on too many different things, but I hope to be able to get back to the stuff I wrote above in the future.</p>\n</blockquote>\n<p>Same... I feel like a week enclosed in a constrained space without other projects to bring about would greatly benefit these thoughts... but pandemic</p>",
        "id": 224436436,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1611903458
    },
    {
        "content": "<p>T_T</p>",
        "id": 224450053,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1611914432
    },
    {
        "content": "<p>I'm catching up here. great paper! the drawings and explanations are nice.</p>",
        "id": 224618129,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612060759
    },
    {
        "content": "<p>at first I thought that Tile Logic could be related <a href=\"https://www.researchgate.net/publication/2498696_Tile_Logic_for_Synchronized_Rewriting_of_Concurrent_Systems\">https://www.researchgate.net/publication/2498696_Tile_Logic_for_Synchronized_Rewriting_of_Concurrent_Systems</a><br>\nbut they seem to be different.</p>",
        "id": 224618195,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612060881
    },
    {
        "content": "<p>it seems like you started with wondering \"how can we break up these string diagrams into distinct processes?\" and found this nice proarrow \"corner\" structure as a result. how did you get into this?</p>",
        "id": 224618303,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612061061
    },
    {
        "content": "<p>I'm definitely wondering how the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span>-calculus might relate to this, but I've come to see that its categorical semantics is pretty elusive. (mainly from what makes it so expressive, the idea of binding on a channel, which enables dynamic network topology)</p>",
        "id": 224618382,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612061211
    },
    {
        "content": "<p>so a square represents a process with top input, bottom output, and sides allow passing of resources. this is very intuitive. but it's a bit funny how this \"left and right\" come into play; on the surface one might think you can share resources with arbitrary processes in the system. but I suppose it's somehow significant that the horizontal monoid is noncommutative, giving some kind of order to the parallel processes. probably if I knew more about interleaving this would be clear.</p>",
        "id": 224618643,
        "sender_full_name": "Christian Williams",
        "timestamp": 1612061734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275899\">Christian Williams</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/224618303\">said</a>:</p>\n<blockquote>\n<p>it seems like you started with wondering \"how can we break up these string diagrams into distinct processes?\" and found this nice proarrow \"corner\" structure as a result. how did you get into this?</p>\n</blockquote>\n<p>I was reading about limits in double categories and figured we could probably use the extra dimension to make the string diagrams from <a href=\"https://arxiv.org/abs/math/0703713\">https://arxiv.org/abs/math/0703713</a> a bit more reasonable. I started with many more assumptions, but slowly realized that I could get rid of all of them!</p>",
        "id": 224700880,
        "sender_full_name": "Chad Nester",
        "timestamp": 1612170869
    },
    {
        "content": "<p>... It doesn't really connect back up to the 'logic of message passing' as I'd initially hoped (at least, not yet), but I like the result.</p>",
        "id": 224700924,
        "sender_full_name": "Chad Nester",
        "timestamp": 1612170901
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275899\">Christian Williams</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/224618129\">said</a>:</p>\n<blockquote>\n<p>I'm catching up here. great paper! the drawings and explanations are nice.</p>\n</blockquote>\n<p>Thanks!</p>",
        "id": 224701154,
        "sender_full_name": "Chad Nester",
        "timestamp": 1612171079
    },
    {
        "content": "<p>RE Tile logic, as far as I can tell it's completely different. I had a look at some of the papers on it, but it didn't seem like they were trying to do the same thing.</p>",
        "id": 224701266,
        "sender_full_name": "Chad Nester",
        "timestamp": 1612171131
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275899\">Christian Williams</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/224618643\">said</a>:</p>\n<blockquote>\n<p>so a square represents a process with top input, bottom output, and sides allow passing of resources. this is very intuitive. but it's a bit funny how this \"left and right\" come into play; on the surface one might think you can share resources with arbitrary processes in the system. but I suppose it's somehow significant that the horizontal monoid is noncommutative, giving some kind of order to the parallel processes. probably if I knew more about interleaving this would be clear.</p>\n</blockquote>\n<p>I've managed to convince myself that the \"left and right\" thing is pretty natural. I think you're talking about what I would call the 'vertical monoid' (occupying the left and right boundaries), in which case the noncommutativity comes from not being able to give something away before you have it (in general, anyway).</p>",
        "id": 224702165,
        "sender_full_name": "Chad Nester",
        "timestamp": 1612171719
    },
    {
        "content": "<p>More visually, the noncommutativity comes from being able to bend wires 'down', but not 'up'. Since we're thinking of events as unfolding from top to bottom, this is like insisting that we must have a thing in order to use it.</p>",
        "id": 224703000,
        "sender_full_name": "Chad Nester",
        "timestamp": 1612172229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284213\">dan pittman</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/224386894\">said</a>:</p>\n<blockquote>\n<p>Our commercial offering does analysis against these graphs, things like satisfiability  &amp;c, and depending on which form the particular analysis at hand needs, we build one graph type or the other. This seems fine from an engineering standpoint because we're going to optimize the structure of the data as needed anyway, but in terms of having a cohesive way to express to a user what her system did, I'd say that'd be <em>very</em> interesting. I probably can't hang with most of the CT in this paper, but I'm going to give it a read anyway, for sure—if only to see what intuitions shake out.</p>\n</blockquote>\n<p>I'd be pretty interested to hear your thoughts about this. I mostly talk to theoreticians but I'd be happy if my work was helping people outside of my bubble. Feel free to message me if you get stuck with the paper!</p>",
        "id": 224704854,
        "sender_full_name": "Chad Nester",
        "timestamp": 1612173388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/224349809\">said</a>:</p>\n<blockquote>\n<p>In any case, back to the original issue: I am not a fan of describing concurrent processes in terms of messages. There are very deep reasons for this, but in a nutshell: A concurrent system is made of two layers:</p>\n<ul>\n<li>A network layer, where messages get exchanged. The network can also dynamically change in time, and you should also take into account things like latencies etc to model race conditions.</li>\n<li>A local layer, that is, the computation that each machine executes locally.<br>\nAll the frameworks I've seen so far either ignore the network layer (e.g. lambda calculus, FSMs) or ignore the local layer (e.g. pi calculus, Petri nets). We won't go anywhere until we merge the two approaches into a unique condition. I've tried to do so using sheaves for two years and with the help of many people (lately mainly <span class=\"user-mention silent\" data-user-id=\"275932\">Matteo Capucci (he/him)</span> ), but it's effing hard, and I'm not anymore convinced that sheaves are the right way to tackle this. If someone is interested in pursuing this line of research, or to suggest any possible mathematical tool to model this, please let me know, I'm -&gt;Super&lt;- interested in this.</li>\n</ul>\n</blockquote>\n<p>\"Concurrency\" is a pretty overloaded term, but in programming it usually means local computation, and what you get by adding various network effects (dynamic topology, partitions, crashes/byzantine behaviour etc) is usually grouped under the term \"distributed systems\". The border between the two is of course pretty fuzzy because of stuff like weak memory models, where each CPU core and its cache is essentially a separate agent which must negotiate with others, which sometimes introduces some bizzare side-effects in the execution.</p>",
        "id": 230960222,
        "sender_full_name": "Alex Gryzlov",
        "timestamp": 1616115808
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276037\">Jade Master</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/224368004\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/224349809\">said</a>:</p>\n<blockquote>\n<p>In any case, back to the original issue: I am not a fan of describing concurrent processes in terms of messages. There are very deep reasons for this, but in a nutshell: A concurrent system is made of two layers:</p>\n<ul>\n<li>A network layer, where messages get exchanged. The network can also dynamically change in time, and you should also take into account things like latencies etc to model race conditions.</li>\n<li>A local layer, that is, the computation that each machine executes locally.<br>\nAll the frameworks I've seen so far either ignore the network layer (e.g. lambda calculus, FSMs) or ignore the local layer (e.g. pi calculus, Petri nets). We won't go anywhere until we merge the two approaches into a unique condition. I've tried to do so using sheaves for two years and with the help of many people (lately mainly <span class=\"user-mention silent\" data-user-id=\"275932\">Matteo Capucci (he/him)</span> ), but it's effing hard, and I'm not anymore convinced that sheaves are the right way to tackle this. If someone is interested in pursuing this line of research, or to suggest any possible mathematical tool to model this, please let me know, I'm -&gt;Super&lt;- interested in this.</li>\n</ul>\n</blockquote>\n<p>I suppose that I don't entirely understand this distinction. I would say that Petri nets can do both, either model the computations on a specific machine or model the coordination between machines. Similarly, FSM's can also model on both levels. Is your point that they don't model at both levels at the same time? If so there are various ways to make Petri nets Hierarchical which I think you might already be aware of... .</p>\n</blockquote>\n<p>Sorry I'm late on this one, but I don't understand either, in a different way: I would say that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span>-calculus also does both. Obviously, messages implement the network layer, but the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span>-calculus is also Turing complete (there are quite a few faithful translations from the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus out there), so it may also represent the local layer. Am I missing something?</p>",
        "id": 230981142,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1616134738
    },
    {
        "content": "<p>No, you are totally right. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span> calculus, being turing complete, can represent any computation _in terms of messages_, and that's my point! What I mean is that networks and local computations, in my opinion, are conceptually very different. Networks are best explained using messages, local computations using stuff like lambda calculus. All the models I've seen so far throw everything in the same bucket: pi calculus describes everything in terms of messages for instance, which makes it cumbersome to do some of the things that lambda calculus does easily. lambda calculus does not have a notion of message or channel, and so network models become difficult to express in that framework. All these models are pretty extreme, meaning that you are looking at everything using the same conceptual filter.</p>",
        "id": 231015673,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1616157502
    },
    {
        "content": "<p>In ordinary infrastructure we have a network layer and a local layer. These are both ultimately the same if you describe them as \"electrons going around\" but really have much much different conceptual flavors, and all the models I've seen so far discard one of these flavors to favor the other. I don't think this makes real justice to the task of describing what things like consensus protocols are</p>",
        "id": 231015803,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1616157590
    },
    {
        "content": "<p>So, Ideally, I would like something that has enough depth so that we can talk about networks and local computations using different dictionaries, but in a way so that these different dictionaries end up being compatible. BTW, my work with <span class=\"user-mention\" data-user-id=\"275932\">@Matteo Capucci (he/him)</span> on this has stalled for now, saying something meaningful ended up proving much harder than we expected.</p>",
        "id": 231015995,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1616157685
    },
    {
        "content": "<p>Maybe, to clarify, try to invert things: As (I think) Samson Abramsky once asked, \"which function does the Internet compute?\"<br>\nTheoretically, you _could_ come up with something a program for a Turing machine that computes the internet. You can for sure because of Turing completeness. We all know that this approach won't fly tho. <br>\nI think pi calculus didn't really become popular among programmers for a similar reason: It is great to model messaging infrastructure, but it is incredibly cumbersome for modelling task that are menial in other languages. All in all I think all these paradigms fall short of something when you employ them to model mixed systems where local computations, messaging and (maybe) data storage/retrieve are all happening at the same time.</p>",
        "id": 231016671,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1616158020
    },
    {
        "content": "<p>Aha, this is starting to make sense to me. Are you looking for something like Leroy's <a href=\"https://xavierleroy.org/bibrefs/Leroy-modular-modules.html\">modular module system</a>, but for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span>-calculus? Explicitly, are you attempting to view <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span>-calculus as a language fragment, interacting with another, more local fragment, in a way that is perhaps parametric in the latter? </p>\n<p>In passing, <span class=\"user-mention\" data-user-id=\"385613\">@Clovis Eberhart</span>, <span class=\"user-mention\" data-user-id=\"302916\">@Thomas Seiller</span>,  and I did some <a href=\"https://lmcs.episciences.org/4069\">work</a> on a sheaf-based model for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span>-calculus, in case you're interested. There, the sheaf condition says that the future behaviour of each node in the network from some point in time should depend only on its own history, which in particular entails that each node behaves independently from others.</p>",
        "id": 231017348,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1616158363
    },
    {
        "content": "<p>So, I didn't look at calculi, the approach we were taking was mainly semantic. This is basically due to the fact that I (and I guess Matteo) know categories better than I know calculi. But yes, I think we are basically saying the same thing</p>",
        "id": 231017970,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1616158655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/224349809\">said</a>:</p>\n<blockquote>\n<p>In any case, back to the original issue: I am not a fan of describing concurrent processes in terms of messages. There are very deep reasons for this, but in a nutshell: A concurrent system is made of two layers:</p>\n<ul>\n<li>A network layer, where messages get exchanged. The network can also dynamically change in time, and you should also take into account things like latencies etc to model race conditions.</li>\n<li>A local layer, that is, the computation that each machine executes locally.<br>\nAll the frameworks I've seen so far either ignore the network layer (e.g. lambda calculus, FSMs) or ignore the local layer (e.g. pi calculus, Petri nets). We won't go anywhere until we merge the two approaches into a unique condition. I've tried to do so using sheaves for two years and with the help of many people (lately mainly <span class=\"user-mention silent\" data-user-id=\"275932\">Matteo Capucci (he/him)</span> ), but it's effing hard, and I'm not anymore convinced that sheaves are the right way to tackle this. If someone is interested in pursuing this line of research, or to suggest any possible mathematical tool to model this, please let me know, I'm -&gt;Super&lt;- interested in this.</li>\n</ul>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"276438\">@Fabrizio Genovese</span>  Have you looked into Milner's later work on \"bigraphs\"? They were created to subsume process calculi and have exactly the two layers you describe: A DAG to represent locality, and a graph to represent network connections.</p>",
        "id": 231025800,
        "sender_full_name": "Jake Gillberg",
        "timestamp": 1616162103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/231015995\">said</a>:</p>\n<blockquote>\n<p>So, Ideally, I would like something that has enough depth so that we can talk about networks and local computations using different dictionaries, but in a way so that these different dictionaries end up being compatible. BTW, my work with <span class=\"user-mention silent\" data-user-id=\"275932\">Matteo Capucci (he/him)</span> on this has stalled for now, saying something meaningful ended up proving much harder than we expected.</p>\n</blockquote>\n<p>Sounds like you're looking for models that combine shared-state and message-passing concurrency, so some recent dist-systems literature on state machine replication could be relevant here, e.g. <a href=\"https://www.cs.technion.ac.il/~erez/Papers/rdma-podc18.pdf\">Aguilera, Ben-David, Calciu, Guerraoui, Petrank, Toueg, [2018] \"Passing Messages while Sharing Memory\"</a></p>",
        "id": 231039556,
        "sender_full_name": "Alex Gryzlov",
        "timestamp": 1616166997
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"383799\">Tom Hirschowitz</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/231017348\">said</a>:</p>\n<blockquote>\n<p>Aha, this is starting to make sense to me. Are you looking for something like Leroy's <a href=\"https://xavierleroy.org/bibrefs/Leroy-modular-modules.html\">modular module system</a>, but for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span>-calculus? Explicitly, are you attempting to view <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span>-calculus as a language fragment, interacting with another, more local fragment, in a way that is perhaps parametric in the latter? </p>\n<p>In passing, <span class=\"user-mention silent\" data-user-id=\"385613\">Clovis Eberhart</span>, <span class=\"user-mention silent\" data-user-id=\"302916\">Thomas Seiller</span>,  and I did some <a href=\"https://lmcs.episciences.org/4069\">work</a> on a sheaf-based model for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span>-calculus, in case you're interested. There, the sheaf condition says that the future behaviour of each node in the network from some point in time should depend only on its own history, which in particular entails that each node behaves independently from others.</p>\n</blockquote>\n<p>Game-semantical models also seem to be tied to module systems, and there has been some separate work on GS for both <a href=\"http://www2.tcs.ifi.lmu.de/~schoepp/Docs/modules_tr.pdf\">modules</a> and <a href=\"https://arxiv.org/abs/1304.4159\">distributed execution</a>.</p>",
        "id": 231041659,
        "sender_full_name": "Alex Gryzlov",
        "timestamp": 1616167872
    },
    {
        "content": "<p>So, my main idea/hope was this: Sheaves are a way to globally organize a bunch of local information. Here, if I take \"local information\" to be what happens on a single machine, the it should be possible to express this local vs global thing using the language of sheaves. One would organize a bunch of machines into a (pre)sheaf, which would represent the act of consistently organizing those machines (by sharing messages and resources). We tried to investigate this point of view for quite a while but got absolutely nothing out of it, so I am afraid I cannot be more precise as of now...</p>",
        "id": 231046808,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1616169752
    },
    {
        "content": "<p>So, I'm also late on this one <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span><br>\n<span class=\"user-mention\" data-user-id=\"276114\">@Chad Nester</span> are your cornerings related to <em>connections</em> in double cats, in the sense of Brown-Mosa? I guess they did connections only for symmetric double cats, but this should be easy to extend to your non-symmetric case?</p>",
        "id": 231313183,
        "sender_full_name": "Uli Fahrenberg",
        "timestamp": 1616421188
    },
    {
        "content": "<p>My understanding of the terminological situation is that \"proarrow equipment\", \"connection structure\",  \"companion and conjoint structure\", and \"framed bicategory\" can all be construed to mean the same thing (I would love to be corrected). This thing is the same as having \"corners\", which I personally find to be much saner terminology in light of the string diagrams.</p>",
        "id": 231314770,
        "sender_full_name": "Chad Nester",
        "timestamp": 1616421772
    },
    {
        "content": "<p>The main reason I've used symmetric monoidal categories here is that the \"crossing cells\" in the free cornering arise from the braidings.</p>",
        "id": 231315092,
        "sender_full_name": "Chad Nester",
        "timestamp": 1616421894
    },
    {
        "content": "<p>I expect that \"has crossing cells\" is nearly the same thing as \"is a monoidal double category\" in the single-object case, so you can probably get rid of the assumption of symmetry and just ask for it to be a monoidal double category directly.</p>",
        "id": 231315298,
        "sender_full_name": "Chad Nester",
        "timestamp": 1616421966
    },
    {
        "content": "<p>Ah I see that you're actually asking something different. Give me a minute!</p>",
        "id": 231315417,
        "sender_full_name": "Chad Nester",
        "timestamp": 1616422018
    },
    {
        "content": "<p>Following appendix A of Mike Shulman's <a href=\"http://www.tac.mta.ca/tac/volumes/20/18/20-18abs.html\">paper</a> on framed bicategories, it looks like the connection structure of Brown-Mosa was in fact only conjoint structure, in the special case of double categories that are edge symmetric.</p>",
        "id": 231316738,
        "sender_full_name": "Chad Nester",
        "timestamp": 1616422547
    },
    {
        "content": "<p>So the analogue of connection structure in that sense should be the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∘</mo></mrow><annotation encoding=\"application/x-tex\">\\circ</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.44445em;vertical-align:0em;\"></span><span class=\"mord\">∘</span></span></span></span>-corner structure. (or possibly the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∙</mo></mrow><annotation encoding=\"application/x-tex\">\\bullet</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.44445em;vertical-align:0em;\"></span><span class=\"mord\">∙</span></span></span></span>-corner structure, I get confused about this sometimes).</p>",
        "id": 231316850,
        "sender_full_name": "Chad Nester",
        "timestamp": 1616422582
    },
    {
        "content": "<p>Ah thank you, also for the pointer to Mike's paper. I dabbled in those things some 15 years ago, I can see that my terminology is outdated <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 231597979,
        "sender_full_name": "Uli Fahrenberg",
        "timestamp": 1616574613
    },
    {
        "content": "<p>For anyone keeping tabs, a truncated version of this paper (no compact closed part) has been accepted for publication in a conference called COORDINATION. <span aria-label=\"surprise\" class=\"emoji emoji-1f62e\" role=\"img\" title=\"surprise\">:surprise:</span> <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 232820550,
        "sender_full_name": "Chad Nester",
        "timestamp": 1617309140
    },
    {
        "content": "<p>I made a few intentionally vague remarks in the discussion above about “situated” transition systems. There is now a <a href=\"https://arxiv.org/abs/2105.04355\">preprint</a> (of my ACT submission <span aria-label=\"sweat\" class=\"emoji emoji-1f613\" role=\"img\" title=\"sweat\">:sweat:</span>) that explains what I mean by this. The corner structure from the initial post in this thread is the key idea, so I think it makes sense to keep talking here.</p>\n<p>I’d love to hear any thoughts, and would be happy to respond to any questions.</p>",
        "id": 238267296,
        "sender_full_name": "Chad Nester",
        "timestamp": 1620720288
    },
    {
        "content": "<p>Very nice! I read the paper where you did the corner stuff using double categories with one object and it was nice</p>",
        "id": 238292233,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1620733225
    },
    {
        "content": "<p>I skimmed through this and I see that you are using that machinery to say things about transition systems. It is going to be an interesting read</p>",
        "id": 238292274,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1620733252
    },
    {
        "content": "<p>BTW, it is possible me, Fosco and Daniele have already an application for this stuff. We planned to submit to CALCO so we formalized things using different stuff and the deadline is too soon to change things now, but I'd be happy to see if with your work things can be made better. Maybe we can talk as soon as this hellish deadline season ends?</p>",
        "id": 238292454,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1620733357
    },
    {
        "content": "<p>Thanks. I'd certainly be interested in collaborating. No hurry though. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 238293246,
        "sender_full_name": "Chad Nester",
        "timestamp": 1620733792
    },
    {
        "content": "<p>I'd also read the first version and enjoyed it. The connection with transition systems in this one seems like a nice addition!  In particular it seems to give another really nice motivation for the distinction between the horizontal and vertical axes (which was the key conceptual contribution of the first version, if I understood correctly).</p>",
        "id": 238307567,
        "sender_full_name": "Robin Piedeleu",
        "timestamp": 1620740013
    },
    {
        "content": "<p>Thanks. I think that's a fair summary of the first part. The direction I'm hoping to go next uses techniques from your PhD thesis. <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 238315126,
        "sender_full_name": "Chad Nester",
        "timestamp": 1620742653
    },
    {
        "content": "<p>Cool! I suppose what I focused on in my thesis was a rather restricted subcategory of Span(Graph). I only skimmed the new version of your paper but could some of your situated transition systems be described concisely by Petri nets with boundaries or, conversely, couldn't Petri nets with boundaries be seen as generating free cornerings? This might provide a nice point of contact between the work on Petri nets as generators of free SMCs and the work on Petri nets with boundaries.</p>",
        "id": 238378797,
        "sender_full_name": "Robin Piedeleu",
        "timestamp": 1620765655
    },
    {
        "content": "<p>I confess to knowing essentially nothing about Petri nets. My understanding is that a Petri net is essentially a monoidal signature, with the places giving the atomic objects and the transitions giving the generating morphisms. Then the associated symmetric monoidal category is called the category of \"executions\" of the Petri net. I had a look at the decorated cospans version of open Petri nets, thinking it might be an instance of the corner structure, but as far as I can tell this isn't the case. Is there a different version of Petri nets with boundaries? </p>\n<p>A related question, open to anyone reading this: I'm under the impression that people don't usually impose equations on the monoidal signature associated with a Petri net. From the resource theory view of monoidal signatures this is extremely natural, which seems like an advantage. Am I wrong?</p>",
        "id": 238443988,
        "sender_full_name": "Chad Nester",
        "timestamp": 1620810626
    },
    {
        "content": "<p>I get the impression that the category of executions of a Petri net is usually treated more like a transition system, so maybe it would be a better fit with the existing literature to use them to define the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">s</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">a</mi><mi mathvariant=\"sans-serif\">n</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"sans-serif\">R</mi><mi mathvariant=\"sans-serif\">G</mi><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">a</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathsf{span(RGraph)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">span</span><span class=\"mopen\">(</span><span class=\"mord mathsf\">RGraph</span><span class=\"mclose\">)</span></span></span></span></span> part of a situated system. It seems plausible that the decorated cospan version of open Petri nets (or indeed, the version of open Petri nets in your thesis) would work well here.</p>",
        "id": 238444175,
        "sender_full_name": "Chad Nester",
        "timestamp": 1620810726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276114\">Chad Nester</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/238443988\">said</a>:</p>\n<blockquote>\n<p>I confess to knowing essentially nothing about Petri nets. My understanding is that a Petri net is essentially a monoidal signature, with the places giving the atomic objects and the transitions giving the generating morphisms. Then the associated symmetric monoidal category is called the category of \"executions\" of the Petri net. I had a look at the decorated cospans version of open Petri nets, thinking it might be an instance of the corner structure, but as far as I can tell this isn't the case. Is there a different version of Petri nets with boundaries? </p>\n</blockquote>\n<p>Yes, there is. The open Petri nets defined by people like <span class=\"user-mention\" data-user-id=\"281251\">@Pawel Sobocinski</span> ,  <span class=\"user-mention\" data-user-id=\"277342\">@Robin Piedeleu</span> , Fabio Gadducci and others from the school of Pisa generaly glue along transitions instead than on places</p>",
        "id": 238448395,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1620813204
    },
    {
        "content": "<p>This is very hand-wavy said this way, but if you wish this is a \"synchronous\" gluing, meaning that if a transition fires, the transition it is glued with has to fire as well. This definition is way more manageable in terms of studying the reachability relation of a net from its components, whereas gluing on places, albeit more intuitive, is problematic because it is asynchronous: When you put a token in a place, you never know which transition will use it, and when</p>",
        "id": 238448571,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1620813304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276114\">Chad Nester</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/238443988\">said</a>:</p>\n<blockquote>\n<p>A related question, open to anyone reading this: I'm under the impression that people don't usually impose equations on the monoidal signature associated with a Petri net. From the resource theory view of monoidal signatures this is extremely natural, which seems like an advantage. Am I wrong?</p>\n</blockquote>\n<p>Actually we do, depending on how you want to obtain categories from nets. In the paper <span class=\"user-mention\" data-user-id=\"275920\">@John Baez</span> , me, <span class=\"user-mention\" data-user-id=\"276037\">@Jade Master</span> and <span class=\"user-mention\" data-user-id=\"276777\">@Mike Shulman</span>  published recently, we show how if, say, you want to generate a symmetric monoidal category from a Petri net, you need to impose some equations</p>",
        "id": 238448720,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1620813381
    },
    {
        "content": "<p><a href=\"https://arxiv.org/abs/2101.04238\">https://arxiv.org/abs/2101.04238</a></p>",
        "id": 238448743,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1620813400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276114\">Chad Nester</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/238444175\">said</a>:</p>\n<blockquote>\n<p>I get the impression that the category of executions of a Petri net is usually treated more like a transition system, so maybe it would be a better fit with the existing literature to use them to define the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">s</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">a</mi><mi mathvariant=\"sans-serif\">n</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"sans-serif\">R</mi><mi mathvariant=\"sans-serif\">G</mi><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">a</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathsf{span(RGraph)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">span</span><span class=\"mopen\">(</span><span class=\"mord mathsf\">RGraph</span><span class=\"mclose\">)</span></span></span></span></span> part of a situated system. It seems plausible that the decorated cospan version of open Petri nets (or indeed, the version of open Petri nets in your thesis) would work well here.</p>\n</blockquote>\n<p>Here I don't think I agree, the most important thing of the category of executions of a Petri net is that it is monoidal, and as such you have an interchange law given by the functoriality of the tensor product. This basically models concurrency, that is, the idea that if two boxes (transitions) are causally independent, it doesn't matter which one comes first (which transition fires first)</p>",
        "id": 238448851,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1620813486
    },
    {
        "content": "<p>All in all, I think that the main way you can think of a Petri net is as a state machine where: </p>\n<ul>\n<li>You can be in more than one state at the same time (given by where are your tokens, in contrast with FSMs where you can be in one vertes of the graph at best)</li>\n<li>You can walk multiple paths of the graph at the same time</li>\n</ul>",
        "id": 238448943,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1620813557
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/238448720\">said</a>:</p>\n<blockquote>\n<p>Actually we do, depending on how you want to obtain categories from nets. In the paper <span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> , me, <span class=\"user-mention silent\" data-user-id=\"276037\">Jade Master</span> and <span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span>  published recently, we show how if, say, you want to generate a symmetric monoidal category from a Petri net, you need to impose some equations</p>\n</blockquote>\n<p>Do you impose the same equations every time in order to obtain the same categorical structure? The point I'm trying to make is that by imposing equations on my resource theory, I can insist that certain sequences of events have the same material effect (see the  part of the situated systems writeup about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"fraktur\">B</mi><mrow><mi mathvariant=\"sans-serif\">s</mi><mi mathvariant=\"sans-serif\">i</mi><mi mathvariant=\"sans-serif\">f</mi><mi mathvariant=\"sans-serif\">t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathfrak{B}_\\mathsf{sift}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84141em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathfrak\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathsf mtight\">sift</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and equality). It's \"user-facing\", in that if I want to use the machinery this is a parameter I can fiddle with.</p>",
        "id": 238450096,
        "sender_full_name": "Chad Nester",
        "timestamp": 1620814158
    },
    {
        "content": "<p>I'll look into Petri nets glued along transitions -- thanks!</p>",
        "id": 238450324,
        "sender_full_name": "Chad Nester",
        "timestamp": 1620814275
    },
    {
        "content": "<p>I know \"concurrency\" is a loaded word but I don't think that interchange / functoriality of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding=\"application/x-tex\">\\otimes</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊗</span></span></span></span> models it. I agree that it models a kind of <em>independence</em>, but I think this is a different thing.</p>",
        "id": 238450480,
        "sender_full_name": "Chad Nester",
        "timestamp": 1620814373
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/238448943\">said</a>:</p>\n<blockquote>\n<p>All in all, I think that the main way you can think of a Petri net is as a state machine where: </p>\n<ul>\n<li>You can be in more than one state at the same time (given by where are your tokens, in contrast with FSMs where you can be in one vertes of the graph at best)</li>\n<li>You can walk multiple paths of the graph at the same time</li>\n</ul>\n</blockquote>\n<p>I will have to think about this. It feels like a pretty strange way of putting things <span aria-label=\"dizzy\" class=\"emoji emoji-1f635\" role=\"img\" title=\"dizzy\">:dizzy:</span></p>",
        "id": 238451373,
        "sender_full_name": "Chad Nester",
        "timestamp": 1620814939
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276114\">Chad Nester</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/238451373\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/238448943\">said</a>:</p>\n<blockquote>\n<p>All in all, I think that the main way you can think of a Petri net is as a state machine where: </p>\n<ul>\n<li>You can be in more than one state at the same time (given by where are your tokens, in contrast with FSMs where you can be in one vertes of the graph at best)</li>\n<li>You can walk multiple paths of the graph at the same time</li>\n</ul>\n</blockquote>\n<p>I will have to think about this. It feels like a pretty strange way of putting things <span aria-label=\"dizzy\" class=\"emoji emoji-1f635\" role=\"img\" title=\"dizzy\">:dizzy:</span></p>\n</blockquote>\n<p>It is the most natural, Petri nets done categorically are the niche, not the other way around</p>",
        "id": 238454085,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1620816630
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276114\">Chad Nester</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/238450096\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/238448720\">said</a>:</p>\n<blockquote>\n<p>Actually we do, depending on how you want to obtain categories from nets. In the paper <span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> , me, <span class=\"user-mention silent\" data-user-id=\"276037\">Jade Master</span> and <span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span>  published recently, we show how if, say, you want to generate a symmetric monoidal category from a Petri net, you need to impose some equations</p>\n</blockquote>\n<p>Do you impose the same equations every time in order to obtain the same categorical structure? The point I'm trying to make is that by imposing equations on my resource theory, I can insist that certain sequences of events have the same material effect (see the  part of the situated systems writeup about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"fraktur\">B</mi><mrow><mi mathvariant=\"sans-serif\">s</mi><mi mathvariant=\"sans-serif\">i</mi><mi mathvariant=\"sans-serif\">f</mi><mi mathvariant=\"sans-serif\">t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathfrak{B}_\\mathsf{sift}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84141em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathfrak\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathsf mtight\">sift</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and equality). It's \"user-facing\", in that if I want to use the machinery this is a parameter I can fiddle with.</p>\n</blockquote>\n<p>The point is that you do this if you want to use Petri nets to present monoidal category. Traditionally, this is not what Petri nets are made for. You can do it in any case, I just don't think it is too interesting for people studying Petri nets</p>",
        "id": 238454165,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1620816685
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276114\">Chad Nester</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/238450480\">said</a>:</p>\n<blockquote>\n<p>I know \"concurrency\" is a loaded word but I don't think that interchange / functoriality of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding=\"application/x-tex\">\\otimes</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊗</span></span></span></span> models it. I agree that it models a kind of <em>independence</em>, but I think this is a different thing.</p>\n</blockquote>\n<p>There is much more to concurrency than this, clearly. Still, this is a pretty important property, it's not by chance that nearly all theories exhibiting some form of non-trivial causality are monoidal</p>",
        "id": 238454280,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1620816749
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276114\">Chad Nester</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/238443988\">said</a>:</p>\n<blockquote>\n<p>I had a look at the decorated cospans version of open Petri nets, thinking it might be an instance of the corner structure, but as far as I can tell this isn't the case. Is there a different version of Petri nets with boundaries? </p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"276438\">@Fabrizio Genovese</span> already answered some of your questions so I'll only try to develop a bit what I hinted at earlier and  answer this question of yours.  My vision may be extremely naive at this point because I've never worked properly on the Petri net-as-SMC view. More knowledgeable people in this area should definitely correct me if they think there's a fundamental obstacle to developing what I had in mind.</p>\n<p>If you only care about reachability, you can view a Petri net as just a collection transitions, i.e. of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>P</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|P|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord\">∣</span></span></span></span> dimensional <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>-vectors, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> is the set of places Then valid runs are sequences of points in the lattice <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">N</mi><mi>P</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb N^P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">P</span></span></span></span></span></span></span></span></span></span></span> such that, starting at any of them one can reach the next adding (i.e. firing) one of the transition to it.  </p>\n<p>But if you care about how you get from one state to another, you can also name your transitions and view them as a set of  generators of some SMC. Now instead of points in a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>P</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|P|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord\">∣</span></span></span></span>-dimensional lattice, each dimension is a generating object of the corresponding SMC and each transition a generating morphism. Instead of a sequence of points, a run is now a morphism of the free SMC on these generators. From the point of view of reachability, this is the same. But now you're keeping track of much more information in each run, namely how (with what combination of transitions) you transformed some resources (the objects of the category) into others, modulo the laws of SMCs which factor out irrelevant ordering of transitions that can be fired concurrently (this is the interchange law Fabrizio was talking about). </p>\n<p>Petri nets with boundaries are Petri nets  with potentially open transitions, which require synchronising with their environment to be fired. In some sense, they are orthogonal to the the Petri-net-as-SMC perspective. Together they form an SMC (this is different form how each standard Petri net can generate an SMC) and their semantics in all previous work I know of has been given in terms of sets and (so called additive) relations. But that's just an extension of the first perspective on Petri nets that I sketched above, to account for open transitions. If we wanted to keep track more precisely of how one gets from one state to another in Petri-net-as-SMC style we would need another dimension and your double-categorical framework seems like a natural candidate. </p>\n<p>When I first learnt about Petri nets-as-SMC, I knew about Petri nets with boundaries and wondered what sort of mathematical object these would generate but no real answer. Seeing your work, I conjectured above that cornerings could be it. Maybe cornerings are overkill and a simpler double-categorical structure is sufficient but one should definitely have some sort of correspondence between the objects in the vertical (resource) and horizontal (boundary) dimensions.</p>",
        "id": 238486279,
        "sender_full_name": "Robin Piedeleu",
        "timestamp": 1620830862
    },
    {
        "content": "<p>Hmm... now that I think about this idea on some small examples, there is a mismatch between the two notions so maybe something else is needed.</p>",
        "id": 238489033,
        "sender_full_name": "Robin Piedeleu",
        "timestamp": 1620831804
    },
    {
        "content": "<p>I'd like to hear more about gluing along transitions.</p>\n<ul>\n<li>Do they need to have the same input/output interface to allow gluing?</li>\n<li>Can the resulting nets be described by colimits of generating data?</li>\n</ul>\n<p>I assume that the reachability issues are analogous to the recent discussion on emergence.</p>\n<ul>\n<li>Is there an easy example to show how this approach ameliorates the problem?</li>\n<li>Can we construe this condition terms of fullness of the maps from the shared overlap into each component net (full on the poset reflection, if we only care about reachability)?</li>\n</ul>",
        "id": 238500680,
        "sender_full_name": "Spencer Breiner",
        "timestamp": 1620835654
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276114\">@Chad Nester</span> If you want to impose extra equations, of a more ad-hoc sort, on the free smc generated by a Petri net then I think the best way to do that is with semantics. I.e. you can impose equations by taking a symmetric monoidal functor into a category C where the equations you want to hold do hold.</p>",
        "id": 238505433,
        "sender_full_name": "Jade Master",
        "timestamp": 1620837474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/238448720\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276114\">Chad Nester</span> <a href=\"#narrow/stream/235484-theory.3A-concurrency/topic/proarrow.20equipments.20in.20concurrency/near/238443988\">said</a>:</p>\n<blockquote>\n<p>A related question, open to anyone reading this: I'm under the impression that people don't usually impose equations on the monoidal signature associated with a Petri net. From the resource theory view of monoidal signatures this is extremely natural, which seems like an advantage. Am I wrong?</p>\n</blockquote>\n<p>Actually we do, depending on how you want to obtain categories from nets. In the paper <span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> , me, <span class=\"user-mention silent\" data-user-id=\"276037\">Jade Master</span> and <span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span>  published recently, we show how if, say, you want to generate a symmetric monoidal category from a Petri net, you need to impose some equations.</p>\n</blockquote>\n<p>I'm not quite sure what that means, so I'll try to say it more carefully.    A Petri net generates a <em>free commutative monoidal category</em>.  This has extra equations as compared with a free symmetric strict monoidal category, since \"commutative\" says that all the symmetries, aka braidings, are identities:</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>B</mi><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow></msub><mo>=</mo><msub><mrow><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">d</mi></mrow><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\"> B_{x,y} = \\mathrm{id}_{x,y} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">y</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.980548em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">id</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">y</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<p>But those are the only extra equations we need to impose, to get the free commutative monoidal category from the free symmetric strict monoidal category.</p>",
        "id": 238520340,
        "sender_full_name": "John Baez",
        "timestamp": 1620843528
    },
    {
        "content": "<p>Chad wrote:</p>\n<blockquote>\n<p>I'm under the impression that people don't usually impose equations on the monoidal signature associated with a Petri net. From the resource theory view of monoidal signatures this is extremely natural, which seems like an advantage. Am I wrong?</p>\n</blockquote>",
        "id": 238520405,
        "sender_full_name": "John Baez",
        "timestamp": 1620843557
    },
    {
        "content": "<p>They often don't.   If one wanted to, one should really prove my conjecture:</p>\n<p><strong>Conjecture.</strong>   The category of commutative monoidal categories is monadic over Petri nets.</p>\n<p>In other words, the adjunction between free commutative monoidal categories and Petri nets gives a monad on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">P</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">i</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Petri}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Petri</span></span></span></span></span> whose Eilenberg-Moore category is equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">C</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">M</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">n</mi><mi mathvariant=\"sans-serif\">C</mi><mi mathvariant=\"sans-serif\">a</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{ComMonCat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">ComMonCat</span></span></span></span></span>.</p>",
        "id": 238520782,
        "sender_full_name": "John Baez",
        "timestamp": 1620843702
    },
    {
        "content": "<p>If we had this fact, we could describe <em>arbitrary</em> commutative monoidal categories in a \"generators and relations\" way, just like people do for groups: that is, describe an arbitrary one as an equalizer of free ones.</p>",
        "id": 238520944,
        "sender_full_name": "John Baez",
        "timestamp": 1620843795
    },
    {
        "content": "<p>If you don't like \"commutative monoidal categories\", the same issues show up for symmetric strict monoidal categories: in <a href=\"https://arxiv.org/abs/2101.04238\">our paper</a> we construct an adjunction between symmetric strict monoidal categories and a variant of Petri nets that we call <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Σ</mi></mrow><annotation encoding=\"application/x-tex\">\\Sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Σ</span></span></span></span>-nets.</p>",
        "id": 238521211,
        "sender_full_name": "John Baez",
        "timestamp": 1620843913
    },
    {
        "content": "<p>So again it would be nice to know if this adjunction is monadic, because that would instantly give us access to a lot of results about \"generators and relations\" descriptions of symmetric strict monoidal categories.</p>",
        "id": 238521310,
        "sender_full_name": "John Baez",
        "timestamp": 1620843956
    },
    {
        "content": "<p>I guess while I'm at it, I should advertise that <span class=\"user-mention\" data-user-id=\"278430\">@Brandon Coya</span> and Franciscus Rebro and I came up with a nice monadic adjunction between PROPs and certain \"signatures\", which allows us to get generators and relations descriptions of PROPs.  See:</p>\n<ul>\n<li><a href=\"https://arxiv.org/abs/1707.08321\">Props in network theory</a>, Appendix B.</li>\n</ul>",
        "id": 238521573,
        "sender_full_name": "John Baez",
        "timestamp": 1620844068
    },
    {
        "content": "<p>In practice people have been describing PROPs using generators and relations since the Late Bronze Age.   But our results justify this and - perhaps more importantly - give access to all sorts of nice results.   For example, if you take a PROP and throw in some extra relations, you get a new PROP and an epimorphism from the original PROP to this new one.      Or, if you thrown in some new generators, you get a new PROP and a <em>monomorphism</em> from the original PROP to the new one.</p>",
        "id": 238522253,
        "sender_full_name": "John Baez",
        "timestamp": 1620844299
    },
    {
        "content": "<p>My conjecture would imply some similar results for Petri nets.</p>",
        "id": 238522961,
        "sender_full_name": "John Baez",
        "timestamp": 1620844529
    },
    {
        "content": "<p>Thanks Robin, Jade, and John. I've been sick, hence the delayed response.</p>",
        "id": 239607765,
        "sender_full_name": "Chad Nester",
        "timestamp": 1621523275
    },
    {
        "content": "<p>I do prefer the symmetric version of all of this over the commutative one. Still I see why your conjecture is interesting.</p>",
        "id": 239608293,
        "sender_full_name": "Chad Nester",
        "timestamp": 1621523429
    },
    {
        "content": "<p>... for the time being I personally will  just keep working with arbitrary monoidal categories, often freely generated, but I'd be interested to hear about any developments.</p>",
        "id": 239610129,
        "sender_full_name": "Chad Nester",
        "timestamp": 1621524115
    },
    {
        "content": "<p>So: it turns out that the category of optics in a monoidal category is a full subcategory of the horizontal cells of the free cornering of that category (the free proarrow equipment constructed from it by adding corners).</p>",
        "id": 280974770,
        "sender_full_name": "Chad Nester",
        "timestamp": 1651561686
    },
    {
        "content": "<p>We've written a paper about this: <a href=\"#narrow/stream/258900-practice.3A-our-papers/topic/Cornering.20Optics/near/280974423\">https://categorytheory.zulipchat.com/#narrow/stream/258900-practice.3A-our-papers/topic/Cornering.20Optics/near/280974423</a></p>",
        "id": 280974784,
        "sender_full_name": "Chad Nester",
        "timestamp": 1651561699
    }
]