[
    {
        "content": "<p>I've seen category theory packages for Agda, Coq, to a point Haskell. They all seemed somewhat heavyweight and/or unsatisying, especially compared to what usually passes for \"trivial\" in category theory.</p>\n<p>Has there been a study of what kind of automated type inference is or isn't sufficient or necessary to trivialize the type-correct treatment of casual category theory notation?</p>",
        "id": 193849983,
        "sender_full_name": "Faré",
        "timestamp": 1586839392
    },
    {
        "content": "<p>Goal: be able to write something as succinct as is commonplace on this forum, and get a fully type-annotated term that makes sense in dependent type theory (or whatever is appropriate) with an appropriate level of generality.</p>",
        "id": 193850110,
        "sender_full_name": "Faré",
        "timestamp": 1586839567
    },
    {
        "content": "<p>(Or is that already trivial in Coq or Agda or Idris?)</p>",
        "id": 193850130,
        "sender_full_name": "Faré",
        "timestamp": 1586839594
    },
    {
        "content": "<p>Some of it may be the approach used. I haven't looked in a while, but the stuff in Agda I've seen is formalizing the symbolic reasoning of 'universal arrow' and diagram chasing type arguments. I'm not sure that's ever going to look nice, and most of the elegant arguments you see people use here aren't going to be like that.</p>",
        "id": 193850428,
        "sender_full_name": "Dan Doel",
        "timestamp": 1586840139
    },
    {
        "content": "<p>Like, it isn't even nice (if you ask me) in the category theory books that try to take that approach.</p>",
        "id": 193850490,
        "sender_full_name": "Dan Doel",
        "timestamp": 1586840184
    },
    {
        "content": "<p>There are various things lacking. One is that the theory implemented by most of today's MLTT-style proof assistants has a rather poor notion of equality for use in category theory. This forces us to be very explicit about equality, and adds difficulty to any reasoning or automation about equality. Apart from that, there is the orthogonal issue that in many cases, the proof engineering technology is still lacking. Often, we want to work up to easily checked equality, which is not offered out of the box (this is to say we want to work in a free structure, taking all of the equations the free structure gives for granted). This has been done for some instances, but seems to take a lot of work for each new bit of structure we introduce (and is typically rather uncompositional). For where it has been done, I like the way Conor McBride did it <a href=\"https://github.com/pigworker/CS410-18/blob/master/Lib/Cat/Solver.agda\" title=\"https://github.com/pigworker/CS410-18/blob/master/Lib/Cat/Solver.agda\">here</a>, where equational reasoning can be interspersed with automated steps.</p>",
        "id": 193861808,
        "sender_full_name": "James Wood",
        "timestamp": 1586851322
    },
    {
        "content": "<p>I know different ways of doing this : the first thing you can do, if you want to define categories in a proof assistant, is to rely on axiom K or UIP or something like that, that basically ensures proof irrelevance of everything you define. If you are not familiar with this construction, it says that whenever you have two terms of the same identity type, they are automatically equal (well to be precise, that's UIP, proof-irrelevance is a bit weaker, and axiom K a bit stronger). So basically the only thing that matters with equality types is if they are inhabited. In other words we only care to know <em>if</em> two things are equal and not <em>how</em> two things are equal. This matches well enough what most people encounter when doing category theory, and you can develop some category theory in this framework - but you will run into some problems quite quickly, in fact as soon as you want to talk about limits and colimits, since they are defined only up to isomorphism, so the simple sentence \"let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> be a category with finite limits\" is not at all easy to express, you have to give an explicit choice of a limit for each finite diagram, and keep track of these choices properly, it becomes a real mess.<br>\nAn option to solve this is the one of <em>univalent categories</em> as defined in HoTT, and here I will assume some familiarity with the language of HoTT. In univalent categories, you want an arbitrary type of objects, but really a set of morphism (meaning two morphisms can only be equal in at most one way - UIP for morphisms if you want), and then you throw in all the axioms of a category, plus univalence. Univalence states that the type of equality between two objects is equivalent to the type of isomorphisms between those objects. So in short, it is an axiomatisation of categories in which equality of objects is defined to be isomorphism. This makes the problem of choice of limits much better, since any two choices are isomorphic, and hence equal, so there is really just one choice.<br>\nTo my knowledge, these have been implemented in the UniMath library, but from my little experience with it, its use is still quite difficult</p>",
        "id": 193868393,
        "sender_full_name": "Thibaut Benjamin",
        "timestamp": 1586855081
    },
    {
        "content": "<p>I should also point out that you can formulate the \"internal language\" of categories in type theory. This is I think a bit different than what you are looking for, as it is a type theory in its own right, and not a development you would do internally to Coq or Agda, but it goes like this</p>\n<ul>\n<li>introduce a type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∙</mo></mrow><annotation encoding=\"application/x-tex\">\\bullet</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.44445em;vertical-align:0em;\"></span><span class=\"mord\">∙</span></span></span></span> which is always defined - a term of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∙</mo></mrow><annotation encoding=\"application/x-tex\">\\bullet</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.44445em;vertical-align:0em;\"></span><span class=\"mord\">∙</span></span></span></span> is an object of the category</li>\n<li>introduce a type constructor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>→</mo></mrow><annotation encoding=\"application/x-tex\">\\to</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">→</span></span></span></span>, which given two terms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">u</span></span></span></span> of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∙</mo></mrow><annotation encoding=\"application/x-tex\">\\bullet</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.44445em;vertical-align:0em;\"></span><span class=\"mord\">∙</span></span></span></span> lets you introduce the type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>→</mo><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">t\\to u</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">u</span></span></span></span>. A term of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>→</mo><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">t \\to u</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">u</span></span></span></span> is a morphism from the object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span></span></span></span> to the object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">u</span></span></span></span></li>\n<li>introduce a constructor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">d</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{id}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">i</span><span class=\"mord mathrm\">d</span></span></span></span></span>, which given a term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span></span></span></span> of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∙</mo></mrow><annotation encoding=\"application/x-tex\">\\bullet</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.44445em;vertical-align:0em;\"></span><span class=\"mord\">∙</span></span></span></span> spits out a term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">d</mi></mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{id}(t)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">i</span><span class=\"mord mathrm\">d</span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">t</span><span class=\"mclose\">)</span></span></span></span> of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>→</mo><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t\\to t</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span></span></span></span></li>\n<li>introduce a constructor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">p</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{comp}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">c</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">p</span></span></span></span></span> which given two terms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span></span></span></span> of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>→</mo><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">t\\to u</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">u</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo>→</mo><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">u\\to v</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">u</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span></span></span></span> spits out a term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>f</mi><mi>g</mi></mrow><annotation encoding=\"application/x-tex\"> comp f g</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span></span></span></span> of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>→</mo><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">t \\to v</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span></span></span></span></li>\n<li>these satisfy the equalities <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">p</mi></mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">p</mi></mrow><mi>f</mi><mi>g</mi><mo stretchy=\"false\">)</mo><mi>h</mi><mo>≡</mo><mi mathvariant=\"normal\">f</mi><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">p</mi></mrow><mi>g</mi><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{comp} (\\mathrm{comp} f g) h \\equiv \\mathrm f (\\mathrm{comp} g h)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">c</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">p</span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">c</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">p</span></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mord mathdefault\">h</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathrm\" style=\"margin-right:0.07778em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">c</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">p</span></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\">h</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">p</mi></mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">d</mi></mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>≡</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{comp} (\\mathrm{id}(t), f) \\equiv f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">c</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">p</span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">i</span><span class=\"mord mathrm\">d</span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">t</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">p</mi></mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo separator=\"true\">,</mo><mrow><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">d</mi></mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>≡</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{comp}(f,\\mathrm{id}(u)) \\equiv f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">c</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">p</span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">i</span><span class=\"mord mathrm\">d</span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">u</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span></span></span></span>.<br>\nAnything that you can define in a category, you can define it type theoretically in this type theory. But you wouldn't go very far, as it only axiomatize one category, there is no functor, no adjoint functor... You could probably define what is a monad as being an operation on the syntax, but that seems like it's making things more complicated instead of making them simpler.</li>\n</ul>\n<p>There may be a way to axiomatize the category of categories as a type theory, and really do actual category theory with a suitable type theory, but I am not aware of it</p>",
        "id": 193879409,
        "sender_full_name": "Thibaut Benjamin",
        "timestamp": 1586861489
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"279935\">Thibaut Benjamin</span> <a href=\"#narrow/stream/229952-theory.3A-type.20theory/topic/cats.20in.20types/near/193879409\" title=\"#narrow/stream/229952-theory.3A-type.20theory/topic/cats.20in.20types/near/193879409\">said</a>:</p>\n<blockquote>\n<p>There may be a way to axiomatize the category of categories as a type theory, and really do actual category theory with a suitable type theory, but I am not aware of it</p>\n</blockquote>\n<p>I think the relevant keyword is “directed type theory”.</p>",
        "id": 193880383,
        "sender_full_name": "James Wood",
        "timestamp": 1586862147
    },
    {
        "content": "<p>It might help if <span class=\"user-mention\" data-user-id=\"276178\">@Faré</span> could give examples of what seemed \"heavyweight and/or unsatisfying\".</p>",
        "id": 193883674,
        "sender_full_name": "Reid Barton",
        "timestamp": 1586864230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281583\">James Wood</span> <a href=\"#narrow/stream/229952-theory.3A-type.20theory/topic/cats.20in.20types/near/193880383\" title=\"#narrow/stream/229952-theory.3A-type.20theory/topic/cats.20in.20types/near/193880383\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"279935\">Thibaut Benjamin</span> <a href=\"#narrow/stream/229952-theory.3A-type.20theory/topic/cats.20in.20types/near/193879409\" title=\"#narrow/stream/229952-theory.3A-type.20theory/topic/cats.20in.20types/near/193879409\">said</a>:</p>\n<blockquote>\n<p>There may be a way to axiomatize the category of categories as a type theory, and really do actual category theory with a suitable type theory, but I am not aware of it</p>\n</blockquote>\n<p>I think the relevant keyword is “directed type theory”.</p>\n</blockquote>\n<p>Thanks, I looked this up and found a paper \"2 dimensional directed type theory\" by Licata and Harper, it seems to do the job indeed. Most of the result are thouhg point towards directed homotopy type theory, that would give a type theory whose types are <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,1)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-categories. That is probably too much compared to the initial question. I will try to check this \"2-dimensional\" case, I didn't know about it</p>",
        "id": 193884807,
        "sender_full_name": "Thibaut Benjamin",
        "timestamp": 1586864997
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276480\">@Reid Barton</span> I am unhappily not sophisticated enough to give a good answer, but the treatment of equality, of quotients, etc., seems particularly heavyweight, e.g. involving setoids everywhere. Maybe that's now solved in Cubical Agda, HoTT Coq, etc.</p>",
        "id": 193899918,
        "sender_full_name": "Faré",
        "timestamp": 1586872453
    },
    {
        "content": "<p>Ah yes, the explicit setoids are somewhat tolerable at best. But in a system with quotients (like Lean, or I think they can be encoded similarly in Coq) there's no need to work with these \"setoid-enriched\" categories.</p>",
        "id": 193910601,
        "sender_full_name": "Reid Barton",
        "timestamp": 1586876463
    },
    {
        "content": "<p>In fact I gave up on Agda for formalization of mathematics long ago (before HoTT was really a thing, I think) for precisely this reason of needing setoids in category theory.</p>",
        "id": 193911166,
        "sender_full_name": "Reid Barton",
        "timestamp": 1586876680
    },
    {
        "content": "<p>Yeah, there's a history of a huge gap there in (intensional) type theory, and even though there have been ideas of how to plug it for a long time, they haven't been implemented in most systems.</p>",
        "id": 193912852,
        "sender_full_name": "Dan Doel",
        "timestamp": 1586877336
    },
    {
        "content": "<p>The homotopy inspired version might end up being better than any of the rest, though, so it's nice that that one's actually getting implemented. <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 193913711,
        "sender_full_name": "Dan Doel",
        "timestamp": 1586877688
    },
    {
        "content": "<p>This issue was one of the main motivations for me to start working on <a href=\"https://github.com/WhatisRT/meta-cedille\" title=\"https://github.com/WhatisRT/meta-cedille\">meta-cedille</a>. I recently gave a demo about it, where I demonstrated the possibility to work and reason in an internal logic that has been formalized in the type theory. There is still some work to be done to reason nicely within categories, but all of that can be done by the user (i.e. no need to change the system). It can also replace types with setoids without syntactic overhead and I see no reason why you shouldn't be able to do cubical or something in there as well (again, with out syntactic overhead and without changing the underlying system), so multiple of the paths that are proposed here are possible in there.</p>",
        "id": 194282097,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1587031959
    },
    {
        "content": "<p>The talk I gave is linked on the wiki there</p>",
        "id": 194282247,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1587032059
    }
]