[
    {
        "content": "<p>Maybe you all know this already, but there is an account on how the CCC model of lambda calculus was used for actual implementation: Cousineau, Curien, Mauny: The Categorical Abstract Machine.  Science of Computer Programming 8 (1987) pp.173-202</p>",
        "id": 191945881,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585255277
    },
    {
        "content": "<p>Huwig, Poigne. \"A note on the inconsistencies caused by fixpoints in a cartesian closed category\" <a href=\"https://doi.org/10.1016/0304-3975(90)90165-E\" title=\"https://doi.org/10.1016/0304-3975(90)90165-E\">https://doi.org/10.1016/0304-3975(90)90165-E</a></p>\n<p>Prop 2. Let C be a Cartesian closed category with fixpoints and an initial object. Then C is inconsistent.</p>",
        "id": 192502966,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585733658
    },
    {
        "content": "<p>^^ I am frequently missing a discussion of fixpoints when people discuss e.g. \"the category of Haskell types\". As a functional programmer, I'd clearly like to have product types, sum types and fixpoints, it looks harmless to admit the initial object as the \"empty sum type\".</p>",
        "id": 192507672,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585736434
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276009\">Burak Emir</span> <a href=\"#narrow/stream/229450-functional-programming/topic/stream.20events/near/192502966\" title=\"#narrow/stream/229450-functional-programming/topic/stream.20events/near/192502966\">said</a>:</p>\n<blockquote>\n<p>Huwig, Poigne. \"A note on the inconsistencies caused by fixpoints in a cartesian closed category\" <a href=\"https://doi.org/10.1016/0304-3975(90)90165-E\" title=\"https://doi.org/10.1016/0304-3975(90)90165-E\">https://doi.org/10.1016/0304-3975(90)90165-E</a></p>\n<p>Prop 2. Let C be a Cartesian closed category with fixpoints and an initial object. Then C is inconsistent.</p>\n</blockquote>\n<p>This is very different to the commonplace initial algebra-final coalgebra constructions I know of. In other words, considering a fixpoint operator on morphisms in a CCC is very different to initial objects/final objects in categories of algebras/coalgebras over an endofunctor.</p>",
        "id": 192508186,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585736779
    },
    {
        "content": "<p>Similarly in Haskell you have fixed points of endofunctors  (whose initial algebra and final coalgebra coincide btw), but I imagine you are aware of the fact.</p>",
        "id": 192508316,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585736880
    },
    {
        "content": "<p>in haskell you don't have an initial object</p>",
        "id": 192527345,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585747896
    },
    {
        "content": "<p><code>undefined</code> inhabits every type, and you can distinguish <code>const 3</code> from <code>const 4</code> by applying them to <code>undefined</code> no matter the domain</p>",
        "id": 192527474,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585747947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276072\">sarahzrf</span> <a href=\"#narrow/stream/229450-functional-programming/topic/stream.20events/near/192527474\" title=\"#narrow/stream/229450-functional-programming/topic/stream.20events/near/192527474\">said</a>:</p>\n<blockquote>\n<p><code>undefined</code> inhabits every type, and you can distinguish <code>const 3</code> from <code>const 4</code> by applying them to <code>undefined</code> no matter the domain</p>\n</blockquote>\n<p>Yes I was being fast and loose, which is morally correct.</p>",
        "id": 192533794,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585750350
    },
    {
        "content": "<p>that's not how it works</p>",
        "id": 192533882,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585750397
    },
    {
        "content": "<p>stop using that phrase until youve actually read the paper</p>",
        "id": 192533917,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585750412
    },
    {
        "content": "<p>unless you have, in which case sorry</p>",
        "id": 192533927,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585750417
    },
    {
        "content": "<p>actually sorry regardless that's pretty obnoxious :|</p>",
        "id": 192534124,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585750483
    },
    {
        "content": "<p>people just. cite that paper all the time in places where it really doesn't apply</p>",
        "id": 192534196,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585750507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276072\">sarahzrf</span> <a href=\"#narrow/stream/229450-functional-programming/topic/stream.20events/near/192534124\" title=\"#narrow/stream/229450-functional-programming/topic/stream.20events/near/192534124\">said</a>:</p>\n<blockquote>\n<p>actually sorry regardless that's pretty obnoxious :|</p>\n</blockquote>\n<p>Sheeeesh that was intense!</p>",
        "id": 192535111,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585750851
    },
    {
        "content": "<p>ahhhh i meant <em>I</em> was being obnoxious!!</p>",
        "id": 192535644,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585751068
    },
    {
        "content": "<p>Apology accepted, but I absolutely do not retract my statement. The paper I have read, at the same time I can never claim that my comprehension of it (or anything else) is 100% accurate. But regardless, from my understanding of haskell, I have absolutely no issue with treating it as an order-enriched category where you get the coincidence I mentioned, fully aware of the (sad) reality...</p>",
        "id": 192535677,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585751086
    },
    {
        "content": "<p>I know, don't worry :).</p>",
        "id": 192535702,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585751095
    },
    {
        "content": "<p>\"treating it as an order-enriched category\"—you mean placing the PER from that paper on the hom-sets?</p>",
        "id": 192535937,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585751177
    },
    {
        "content": "<p>(took me a second to parse since i dont usually think about PERs as orderings)</p>",
        "id": 192535961,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585751190
    },
    {
        "content": "<p>if that <em>is</em> what you mean, then it's still not obvious to me what's going on</p>",
        "id": 192536203,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585751303
    },
    {
        "content": "<p>what category are you enriching over, exactly? im not sure i've worked with a standard category whose objects are sets equipped w/ PERs</p>",
        "id": 192536248,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585751327
    },
    {
        "content": "<p>the most obvious thing would be, i guess, functions which need to respect the PER, but what about the category where the morphisms don't need to be defined outside of the PER's set of reflexive elements?</p>",
        "id": 192536367,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585751383
    },
    {
        "content": "<p>^these are actual questions im asking, not me trying to poke holes</p>",
        "id": 192536387,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585751391
    },
    {
        "content": "<p>anyway, formalities aside, it seems to me that at this point you're basically subquotienting the category to get a different one, which looks just like a total language</p>",
        "id": 192536672,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585751513
    },
    {
        "content": "<p>but at that point you don't have fixed points anymore, so...</p>",
        "id": 192536776,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585751543
    },
    {
        "content": "<p>what was the topic of discussion again? :)</p>",
        "id": 192536822,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585751566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276072\">sarahzrf</span> <a href=\"#narrow/stream/229450-functional-programming/topic/stream.20events/near/192535937\" title=\"#narrow/stream/229450-functional-programming/topic/stream.20events/near/192535937\">said</a>:</p>\n<blockquote>\n<p>\"treating it as an order-enriched category\"—you mean placing the PER from that paper on the hom-sets?</p>\n</blockquote>\n<p>Yeah, I left that quite hanging. And true, I'm making quite a few jumps ahead.</p>",
        "id": 192536942,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585751616
    },
    {
        "content": "<p>srsly tho, if the original point was \"having fixed points and an initial object → trivial\", but you can only recover an initial object by switching to fast-and-loose mode, then there's no point in switching to fast-and-loose mode for this, because the point of fast-and-loose mode is forgetting about the properties that let you have fixed points!</p>",
        "id": 192537211,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585751714
    },
    {
        "content": "<p>I like to take (the ideal) haskell as the Kleisli category of the Maybe (or \"lift\" or \"error\" monad). The hom-sets of this category come with a partial order. So, by results in (<a href=\"https://arxiv.org/pdf/0710.2505.pdf\" title=\"https://arxiv.org/pdf/0710.2505.pdf\">https://arxiv.org/pdf/0710.2505.pdf</a>), their initial and final coalgebras coincide.</p>",
        "id": 192537425,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585751796
    },
    {
        "content": "<p>that monad is only the same as Maybe classically &gt;.&gt;</p>",
        "id": 192538075,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585752050
    },
    {
        "content": "<p>ok im being pedantic</p>",
        "id": 192538085,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585752057
    },
    {
        "content": "<p>I agree :)</p>",
        "id": 192538099,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585752062
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275900\">Stelios Tsampas</span> <a href=\"#narrow/stream/229450-functional-programming/topic/stream.20events/near/192537425\" title=\"#narrow/stream/229450-functional-programming/topic/stream.20events/near/192537425\">said</a>:</p>\n<blockquote>\n<p>I like to take (the ideal) haskell as the Kleisli category of the Maybe (or \"lift\" or \"error\" monad). The hom-sets of this category come with a partial order. So, by results in (<a href=\"https://arxiv.org/pdf/0710.2505.pdf\" title=\"https://arxiv.org/pdf/0710.2505.pdf\">https://arxiv.org/pdf/0710.2505.pdf</a>), their initial and final coalgebras coincide.</p>\n</blockquote>\n<p>This forces Haskell to be strict, though. You need the monad on both inputs and outputs to deal with laziness.</p>",
        "id": 192538294,
        "sender_full_name": "Andrew Hirsch",
        "timestamp": 1585752151
    },
    {
        "content": "<p>I mean, for a lot of programs, strictness versus laziness doesn't matter for correctness reasoning, as long as you're not dealing with infinite data structures.</p>",
        "id": 192538469,
        "sender_full_name": "Andrew Hirsch",
        "timestamp": 1585752225
    },
    {
        "content": "<p>But OTOH, Haskell programs often deal with infinite data structures.</p>",
        "id": 192538551,
        "sender_full_name": "Andrew Hirsch",
        "timestamp": 1585752244
    },
    {
        "content": "<p>Haskell's initial and final coalgebras still coincide, though.</p>",
        "id": 192541617,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585753377
    },
    {
        "content": "<p>You need to use different domain-ish models, though. Not just flat domains.</p>",
        "id": 192541714,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585753414
    },
    {
        "content": "<p>Although the harder part, in my experience, is getting people to agree that e.g. ML's initial and final coalgebras coincide, which is also the case.</p>",
        "id": 192542004,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585753535
    },
    {
        "content": "<p>Is it known for which subset of Haskell, Haskell is a category?  I am thinking of the discussion at <a href=\"http://math.andrej.com/2016/08/06/hask-is-not-a-category/\" title=\"http://math.andrej.com/2016/08/06/hask-is-not-a-category/\">http://math.andrej.com/2016/08/06/hask-is-not-a-category/</a> ... Is it enough to ban seq from Haskell?</p>",
        "id": 192542058,
        "sender_full_name": "Alexander Kurz",
        "timestamp": 1585753558
    },
    {
        "content": "<p>I think if you get rid of seq it might be a category, but a lot of constructions do not behave nicely, still.</p>",
        "id": 192542248,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585753613
    },
    {
        "content": "<p>Like, pairs are not products.</p>",
        "id": 192542289,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585753635
    },
    {
        "content": "<p>Can you observe that pairs are not products if you don't have seq though?</p>",
        "id": 192542364,
        "sender_full_name": "Max New",
        "timestamp": 1585753674
    },
    {
        "content": "<p>Yes, because pattern matching can tell the difference. You could fix that, too, but it's a separate thing.</p>",
        "id": 192542960,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585753874
    },
    {
        "content": "<p>Sums are not coproducts, also, and there's really no easy way to fix that.</p>",
        "id": 192543053,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585753898
    },
    {
        "content": "<p>For weird trivia, as I recall, in the predecessor to Haskell, Miranda, pattern matching <em>couldn't</em> tell the difference, but it also had seq to ruin it.</p>",
        "id": 192543435,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585754039
    },
    {
        "content": "<p>I thought either sums were coproducts or pairs were products? i.e. you can’t have both, but you could have one (depending on strict vs non-strict).</p>",
        "id": 192544152,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1585754221
    },
    {
        "content": "<p>you can have both but Haskell has neither because it's non-strictness is different from call-by-name lambda calculus</p>",
        "id": 192544243,
        "sender_full_name": "Max New",
        "timestamp": 1585754267
    },
    {
        "content": "<p>You could have products, but it requires case analysis on products to be \"irrefutable\".</p>",
        "id": 192544331,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585754294
    },
    {
        "content": "<p>So <code>case undefined of (_, _) -&gt; 3</code> should evaluate to <code>3</code>.</p>",
        "id": 192544375,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585754311
    },
    {
        "content": "<p>it makes sense if you think of having to implement pattern matching using projections</p>",
        "id": 192544489,
        "sender_full_name": "Max New",
        "timestamp": 1585754356
    },
    {
        "content": "<p>okay</p>",
        "id": 192544794,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1585754465
    },
    {
        "content": "<p>I was under the impression that <code>seq</code> was the obstruction to having a category and <code>undefined</code> was the obstruction to having nice structure; if you remove both, do you address the problems?</p>",
        "id": 192544871,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1585754494
    },
    {
        "content": "<p>If you could remove <code>undefined</code>, you wouldn't have to remove <code>seq</code> <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 192545130,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585754573
    },
    {
        "content": "<p>Do you mean <code>undefined</code> the named definition? Or get rid of its underlying meaning from the entire language?</p>",
        "id": 192545219,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585754605
    },
    {
        "content": "<p>The latter is a pretty significant change.</p>",
        "id": 192545261,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585754620
    },
    {
        "content": "<p>I think we should be clear that bottom is not just <code>undefined = undefined</code>, but all other forms of non-termination, including arbitrary fixpoints.</p>",
        "id": 192545406,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1585754664
    },
    {
        "content": "<p>maybe the question I really wanted to ask was: is there a nice categorical semantics for a lazy call-by-need calculus similar to Haskell?</p>",
        "id": 192545523,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1585754715
    },
    {
        "content": "<p>because you can have nice categorical models of calculi with fixed points, so that's not an insurmountable problem</p>",
        "id": 192545591,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1585754745
    },
    {
        "content": "<p>(maybe this means you don't have cartesian closure in the strictess sense, but you do have some weaker notion)</p>",
        "id": 192545751,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1585754795
    },
    {
        "content": "<p>Usually it is suggested that directed-complete partial orders are used. I think you could have Cartesian closure, but not coproducts.</p>",
        "id": 192546267,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585754994
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276916\">Andrew Hirsch</span> <a href=\"#narrow/stream/229450-functional-programming/topic/Hask/near/192538294\" title=\"#narrow/stream/229450-functional-programming/topic/Hask/near/192538294\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"275900\">Stelios Tsampas</span> <a href=\"#narrow/stream/229450-functional-programming/topic/stream.20events/near/192537425\" title=\"#narrow/stream/229450-functional-programming/topic/stream.20events/near/192537425\">said</a>:</p>\n<blockquote>\n<p>I like to take (the ideal) haskell as the Kleisli category of the Maybe (or \"lift\" or \"error\" monad). The hom-sets of this category come with a partial order. So, by results in (<a href=\"https://arxiv.org/pdf/0710.2505.pdf\" title=\"https://arxiv.org/pdf/0710.2505.pdf\">https://arxiv.org/pdf/0710.2505.pdf</a>), their initial and final coalgebras coincide.</p>\n</blockquote>\n<p>This forces Haskell to be strict, though. You need the monad on both inputs and outputs to deal with laziness.</p>\n</blockquote>\n<p>Yessss, but I felt <span class=\"user-mention\" data-user-id=\"276009\">@Burak Emir</span>'s issue was more about correctness/intution rather than Haskell's evaluation strategy.</p>",
        "id": 192546405,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585755037
    },
    {
        "content": "<p>... this all feels a little like logicians trying to work around Gödel: “but what if we get rid of this, but leave that?” <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 192546597,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1585755117
    },
    {
        "content": "<p>Alas, poor logicians! But that's what Agda went for, right? Let's just write an imperfect but consistent termination checker and let's roll with it :).</p>",
        "id": 192547606,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585755485
    },
    {
        "content": "<p>It's entirely possible to have a call-by-name typed lambda calculus with all fixed points that is cartesian closed (but no coproducts). Note that the difference between a call-by-name and a call-by-need language is not observable if your only effects are divergence and crash (which is what Haskell supports)</p>",
        "id": 192548989,
        "sender_full_name": "Max New",
        "timestamp": 1585756066
    },
    {
        "content": "<p>Hey Max :). And how do coproducts break the category? Or maybe you can give a reference instead :).</p>",
        "id": 192549904,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585756412
    },
    {
        "content": "<p>It seems to me that those who understand all of Haskell and Category Theory and Semantics do have a pretty good idea of which subsets of Haskell have which categorical properties. What disturbs me, is that this knowledge seems not be laid out anywhere in a format that is accessible to a wider community.</p>",
        "id": 192550368,
        "sender_full_name": "Alexander Kurz",
        "timestamp": 1585756576
    },
    {
        "content": "<p>Just reading through the comments here, suggests that there are lots of subtleties and secret knowledge but not a lot of hard mathematical results. For example, pairing not being product sounds strange to me.</p>",
        "id": 192550887,
        "sender_full_name": "Alexander Kurz",
        "timestamp": 1585756789
    },
    {
        "content": "<p>How important is it to have undefined in Haskell? I have only written very little Haskell, but I don't remember the need of undefined.</p>",
        "id": 192551008,
        "sender_full_name": "Alexander Kurz",
        "timestamp": 1585756823
    },
    {
        "content": "<p>If you want to get rid of undefined, you have to get rid of unrestricted general recursion.</p>",
        "id": 192551070,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585756856
    },
    {
        "content": "<p>Which is a huge change.</p>",
        "id": 192551092,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585756864
    },
    {
        "content": "<p>the inconsistency with coproducts is explained in that Huwig-Poigne note mentioned above</p>",
        "id": 192551190,
        "sender_full_name": "Max New",
        "timestamp": 1585756916
    },
    {
        "content": "<p>The results about lambda calculus are some of the oldest results in programming language semantics. I think Dana Scott's 1972 paper \"Continuous Lattices\" contains a model of typed lambda calculus with fixed points. These are perfectly \"hard\" mathematical results</p>",
        "id": 192551736,
        "sender_full_name": "Max New",
        "timestamp": 1585757129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277270\">Dan Doel</span> <a href=\"#narrow/stream/229450-functional-programming/topic/Hask/near/192551070\" title=\"#narrow/stream/229450-functional-programming/topic/Hask/near/192551070\">said</a>:</p>\n<blockquote>\n<p>If you want to get rid of undefined, you have to get rid of unrestricted general recursion.</p>\n</blockquote>\n<p>I will take your word for it. But I would like to know why getting rid of unrestricted general recursion is problematic for an everyday Haskell programmer.</p>",
        "id": 192552872,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585757630
    },
    {
        "content": "<p>If every program terminates, then your language is no longer Turing complete. Now, that doesn't have to be a problem - in program verification, I think it is pretty standard to talk about \"partial correctness\" which is \"correctness assuming that the program terminates\".</p>",
        "id": 192553082,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585757722
    },
    {
        "content": "<p>How many programs have you written in Agda?</p>",
        "id": 192553106,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585757739
    },
    {
        "content": "<p>me? zero : )</p>",
        "id": 192553183,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585757763
    },
    {
        "content": "<p>No, Stelios.</p>",
        "id": 192553204,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585757773
    },
    {
        "content": "<p>Anyhow, that is the problem. Have the everyday Haskell programmer use Agda instead. :)</p>",
        "id": 192553245,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585757795
    },
    {
        "content": "<p>I don't know, how many does one write after 2-3 years of usage?</p>",
        "id": 192553250,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585757799
    },
    {
        "content": "<p>I personally would have 0 problems with that.</p>",
        "id": 192553319,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585757830
    },
    {
        "content": "<p>I don't know. I've been using it much longer than that, and I think I have 0 programs written.</p>",
        "id": 192553320,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585757832
    },
    {
        "content": "<p>Haha OK, let's go by a 1000 programs then.</p>",
        "id": 192553395,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585757874
    },
    {
        "content": "<p>I have a very, very hard time coming up with a program showcasing that lack of Turing completeness, or general recursion, is a detrimental thing.</p>",
        "id": 192553592,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585757960
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275900\">Stelios Tsampas</span> <a href=\"#narrow/stream/229450-functional-programming/topic/Hask/near/192552872\" title=\"#narrow/stream/229450-functional-programming/topic/Hask/near/192552872\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"277270\">Dan Doel</span> <a href=\"#narrow/stream/229450-functional-programming/topic/Hask/near/192551070\" title=\"#narrow/stream/229450-functional-programming/topic/Hask/near/192551070\">said</a>:</p>\n<blockquote>\n<p>If you want to get rid of undefined, you have to get rid of unrestricted general recursion.</p>\n</blockquote>\n<p>I will take your word for it. But I would like to know why getting rid of unrestricted general recursion is problematic for an everyday Haskell programmer.</p>\n</blockquote>\n<p>You couldn't have both <code>length</code> and infinite lists--or at least the type accepted by <code>length</code> could not be the type of a list that is infinite. The language would just cease to be Haskell very quickly.</p>",
        "id": 192553635,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585757985
    },
    {
        "content": "<p>Like, there are all kinds of arbitrary annoyances in writing Agda programs in practice. You can't write <code>map</code> and <code>fold</code> separately a lot of the time, you have to write some combined thing so that the termination checker can see that it works.</p>",
        "id": 192553733,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585758026
    },
    {
        "content": "<p>Hehe, you could have length <em>and</em> infinite lists. Just not length <em>for</em> infinite lists ;).</p>",
        "id": 192553776,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585758048
    },
    {
        "content": "<p>So it actively prevents you from factoring your code in arbitrary useful ways.</p>",
        "id": 192553786,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585758051
    },
    {
        "content": "<p>You can (maybe) do better by using sized types, but then you have to plan ahead with everything or spend a lot of time adding them once you need them, and there's extra clutter.</p>",
        "id": 192554017,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585758151
    },
    {
        "content": "<p>Anyhow, the point is, there's no real language for doing this.</p>",
        "id": 192554084,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585758186
    },
    {
        "content": "<p>There are only toys.</p>",
        "id": 192554105,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585758195
    },
    {
        "content": "<p>This isn't about Agda specifically, right? And I don't see how general recursion is what prevents these problems from being solved in Agda.</p>",
        "id": 192554106,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585758197
    },
    {
        "content": "<p>Even if there was such a language it <em>would no longer be Haskell</em> and so by definition its users would not be Haskell programmers.</p>",
        "id": 192554139,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585758217
    },
    {
        "content": "<p>Yeah, that too.</p>",
        "id": 192554150,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585758225
    },
    {
        "content": "<p>In other words: the trouble with getting rid of non-termination in any language is not so much that one wants to write non-terminating programs, but that one doesn't want to be restricted to a general enough language where termination can be automatically checked and ensured. Those checks comes with constraints, hoops to jump through or simply limitations on what you can do (and a good part of Haskell programmers wants to violently argue that it is just BETTER AT EVERYTHING while being Turing complete... so it would clash with that).</p>",
        "id": 192554313,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585758297
    },
    {
        "content": "<p>Yeah. I don't think you can't get close enough to work in a total language. But we're not there yet. It's an open research problem.</p>",
        "id": 192554434,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585758356
    },
    {
        "content": "<p>That's why I find that paper valuable; I believe the beautiful Lambek &amp; Scott style CCC for a given simply-typed <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">λ</span></span></span></span> calculus does not go near fixpoints and non-termination.</p>",
        "id": 192554441,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585758360
    },
    {
        "content": "<p>... and I'd love if more people were aware of this. The denotational semantics with dcpo is something very different from the \"objects are types\".</p>",
        "id": 192554641,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585758438
    },
    {
        "content": "<p>If you're at all concerned with real-world programming, you most emphatically want nonterminating programs. In particular, you want to allow servers, drivers, and a lot of other real-world code which runs a polling loop. For a simple web server, it checks the queue of requests and, if there's a head, pops it and responds to it. Otherwise, it just loops.</p>",
        "id": 192555173,
        "sender_full_name": "Andrew Hirsch",
        "timestamp": 1585758642
    },
    {
        "content": "<p>If we're interested in giving semantics to real-world programs (which I am), we have to be able to talk about that server</p>",
        "id": 192555310,
        "sender_full_name": "Andrew Hirsch",
        "timestamp": 1585758703
    },
    {
        "content": "<p>That is a good point. I can imagine a monad-based approach where notions of well-foundedness are lifted in a real-world setting such as this. For example, you can have an event system where the server runs in the backgorund but each event handler is a well-founded, terminating program.</p>",
        "id": 192555850,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585758934
    },
    {
        "content": "<p>Right, a lot of the work in the FP community is in making real-world programs have nice mathematical structure like this. But that's a non-trivial refactoring of the program that a real-world Haskell programmer would write!</p>",
        "id": 192556065,
        "sender_full_name": "Andrew Hirsch",
        "timestamp": 1585759025
    },
    {
        "content": "<p>We should be careful not to fall into the trap that Conor McBride often warns about here. You _can_ write potentially nonterminating stuff in Agda and the like, you just have to be explicit about the _manner_ in which it doesn't terminate. There are a number of techniques for this sort of thing, which I won't go through. And for certainly nonterminating stuff, there's definitely plenty of work on \"coinduction\" in proof assistants and techniques for handling coinductive types. The problem isn't \"you can't write nonterminating stuff\" its \"when you write terminating stuff, you need to do so in a way that lets the termination checker see it terminates, and when you write certainly coinductive stuff, you need to be able to do so in a way that it can be checked to be productive (i.e. provably continue to produce output)\" etc</p>",
        "id": 192556080,
        "sender_full_name": "Gershom",
        "timestamp": 1585759034
    },
    {
        "content": "<p>But all this stuff about Agda is a distraction from the difficulty of writing \"in the total fragment of Haskell\" which is what \"categorists' informal Hask\" is.</p>",
        "id": 192556236,
        "sender_full_name": "Gershom",
        "timestamp": 1585759093
    },
    {
        "content": "<p>Yeah, if it were widely known that \"categorists' informal Hask\" is terminating, thus does not have general recursion and fixpoint combinators, this would certainly be a better state of affairs. If one wants to capture partial computation, the constructions needed are very different and it also has not much to do with the type theory / logic correspondence anymore.</p>",
        "id": 192556817,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585759355
    },
    {
        "content": "<p>As far as I know, producing models that are not just categorical but \"nice\" to category theorists of languages which are best modeled by domain theory (i.e. which can embed the untyped lambda calculus) remains an open research question, and it was one of the goals of the various sorts of synthetic and extended and axiomatic domain theories produced throughout the 80s. What you got (I believe, but I'm not an expert) was a lot of things which were categorically nice, and had some sort of nontermination, but didn't correspond to the way we want to compute. Scott's equilogical spaces are a favorite of mine in that regard.</p>",
        "id": 192556823,
        "sender_full_name": "Gershom",
        "timestamp": 1585759358
    },
    {
        "content": "<p>Yes, there was a survey...  let me dig it out. Dwight Spencer. A survey of categorical computation : fixed points, partiality, combinators, ... control? (edit: grammar)</p>",
        "id": 192557052,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585759461
    },
    {
        "content": "<p>That is where I got the Huwig Poigne reference from. Theorem 2.1 [HP86] A cartesian closed category with fixed points collapses to the trivial category 1 if it contains any of the following:<br>\nan initial object<br>\na boolean algebra (coproduct) object, 2 (= 1 + 1)<br>\nequalizers for any pair of morphisms<br>\na natural number object (NNO)</p>",
        "id": 192557453,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585759627
    },
    {
        "content": "<p>I don't think it makes sense to just write off any connection between type theory and logic and partial computation.</p>",
        "id": 192558000,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585759855
    },
    {
        "content": "<p>Ah, yes, let me add there are some purely categorical models for handling partiality and nontermination, but for reasons I don't recall, they're good settings for _studying_ such things or _representing_ such things, and more generally for considering computability, but not for \"programming languages taking semantics in.\" One is the line of work on \"realizability toposes\" which starts with hyland's effective topos and builds off of taking semantics in PCAs. The other is more recent work by Cockett &amp; co. on \"Turing categories\" which starts with a categorification of the idea of partial maps in terms of \"restriction categories\".</p>",
        "id": 192558090,
        "sender_full_name": "Gershom",
        "timestamp": 1585759895
    },
    {
        "content": "<p>PCA?</p>",
        "id": 192558196,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585759926
    },
    {
        "content": "<p>Partial Combinatory Algebras.</p>\n<p>I've asked some experts to explain to me the tradeoffs and differences between the above approaches a few times, but I'm afraid I've forgotten the details. I do recall that they really do look at \"different levels\" of the structure and so they aren't competing to do the same thing at all.</p>",
        "id": 192558310,
        "sender_full_name": "Gershom",
        "timestamp": 1585759975
    },
    {
        "content": "<p>For an example for earlier, though: there is a typical 4 line <code>quicksort</code> example on lists in Haskell used as an intro for newbies. And there is also an entire research paper by Conor McBride showing how to write the same example in a way so that a structural recursion checker would accept it.</p>",
        "id": 192558473,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585760038
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"277270\">@Dan Doel</span> I would agree, I personally justify to myself all the spare time that I sunk into type theory and logic that at the very least it would help create \"pockets/islands of correctness\" : ) I think a good deal of purely functional programming can serve as examples how to quickly and easily get correctness (I am not convinced that that extends to all Haskell).</p>",
        "id": 192558621,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585760093
    },
    {
        "content": "<p>There are probably better approaches than that paper, but it's not uncommon for people to write things in a way that is non-trivial to justify fully.</p>",
        "id": 192558844,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585760168
    },
    {
        "content": "<p>So Hask , the informal category of Haskell types, has</p>\n<ul>\n<li>as objects, the types</li>\n<li>as morphisms, the (monomorphic) terms of function type.</li>\n</ul>\n<p>where terms do not involve fixpoint operates and thus cannot express general recursion.</p>\n<p>It also doesn't explain the System F part, aka the polymorphic <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">λ</span></span></span></span> calculus.<br>\nWe somehow adding an object Foo[A] for every type A that satisfies the constraints.<br>\nThat then makes Hask not very Haskell specific (would work for any System F calculus).</p>",
        "id": 192560679,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585760795
    },
    {
        "content": "<p>People will usually try to call that \"total Hask\" or something, to indicate that they're aware of the issues. But also people can be very sloppy. There's also various richer models using fibers or indexing, pursued by Ghani, Johann, and others, which can handle indexed and non-regular types, etc.</p>",
        "id": 192561586,
        "sender_full_name": "Gershom",
        "timestamp": 1585761189
    },
    {
        "content": "<p>I don't think you can throw out all fixpoints.</p>",
        "id": 192561628,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585761212
    },
    {
        "content": "<p>The point of the 'fast and loose' stuff is basically that you can imagine you're working with something like System F and reason well enough for practical purposes, though.</p>",
        "id": 192561756,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585761260
    },
    {
        "content": "<p>Good point dan, we still need <em>some</em> form of total recursion otherwise we can't like induct over a list...</p>",
        "id": 192561820,
        "sender_full_name": "Gershom",
        "timestamp": 1585761306
    },
    {
        "content": "<p>Fold constants for every recursive data type?</p>",
        "id": 192561904,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585761346
    },
    {
        "content": "<p>I'm not sure it makes sense to try to define a syntactic thing for what people mean informally by \"Hask\".</p>",
        "id": 192563218,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585761948
    },
    {
        "content": "<p>I think people are often thinking about some informal semantics of the terms.</p>",
        "id": 192563690,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585762128
    },
    {
        "content": "<p>The purpose of the terms is to present the morphisms, not be them.</p>",
        "id": 192564138,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585762320
    },
    {
        "content": "<p>I thought the reason of being for Hask was that people want to grasp CT : )</p>",
        "id": 192565889,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585763077
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277270\">Dan Doel</span> <a href=\"#narrow/stream/229450-functional-programming/topic/Hask/near/192561756\" title=\"#narrow/stream/229450-functional-programming/topic/Hask/near/192561756\">said</a>:</p>\n<blockquote>\n<p>The point of the 'fast and loose' stuff is basically that you can imagine you're working with something like System F and reason well enough for practical purposes, though.</p>\n</blockquote>\n<p>There it is :).</p>",
        "id": 192567454,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585763754
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276009\">@Burak Emir</span>  I'd say it's quite the opposite.</p>",
        "id": 192568093,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585763903
    },
    {
        "content": "<p>Please explain - people do not want to grasp CT that is why there is Hask? <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 192568349,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585764011
    },
    {
        "content": "<p>I would say the motivation is to have a consistent, attractive, usable categorical framework that characterizes Haskell. Above all, it complements Haskell :).</p>",
        "id": 192568705,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585764150
    },
    {
        "content": "<p>So it's CT <em>for</em> Haskell, not Haskell used to understand CT.</p>",
        "id": 192568795,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585764190
    },
    {
        "content": "<p>Of course, anyone can have their own motivation for Hask. So I am expressing a (possible, I might be wrong) general sentiment, which I'm guessing you did as well. Don't let that discourage you from using Hask your way.</p>",
        "id": 192568977,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585764260
    },
    {
        "content": "<p>That is what I meant, too. Lots of folks who start with Haskell, then get curious about all cats.</p>",
        "id": 192569011,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585764278
    },
    {
        "content": "<p>Yeah, to some degree, what you come up with will depend on your goals.</p>",
        "id": 192569138,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585764337
    },
    {
        "content": "<p>So, for instance, complaints that \"Hask isn't a category\" don't make sense from the perspective, not of getting a rigorous categorical semantics of Haskell, but using Haskell as a close enough language to describe the actual content of categorical constructions.</p>",
        "id": 192569430,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585764451
    },
    {
        "content": "<p>Agree. I personally have not dealt with much Haskell for practical purposes, but enough exposure to PL theory. So I appreciate the Lambek &amp; Scott route to CCC a lot more... Call it \"from a pedagogical perspective\"</p>",
        "id": 192569562,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585764485
    },
    {
        "content": "<p>And maybe cartesian closed multi categories would be even better.</p>",
        "id": 192569617,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585764511
    },
    {
        "content": "<p>Haskell is something you can type into a computer and have it show you results, and it's close enough to something with actual categorical semantics that the difference doesn't matter for just fooling around with stuff.</p>",
        "id": 192569688,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585764545
    },
    {
        "content": "<p>And you can see how the Yoneda lemma actually works, even if technically it doesn't exactly work.</p>",
        "id": 192569923,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585764647
    },
    {
        "content": "<p>Yes, I must admit it's pretty unique in that way.</p>",
        "id": 192569943,
        "sender_full_name": "Burak Emir",
        "timestamp": 1585764658
    },
    {
        "content": "<p>You can also go backwards along that.</p>",
        "id": 192569947,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585764661
    },
    {
        "content": "<p>Some categorical facts map back into Haskell in ways that don't quite line up, but the difference doesn't really matter.</p>",
        "id": 192570018,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585764700
    },
    {
        "content": "<p>And if someone worked out all the gory details on a technically correct specification of what structure it actually is, it probably wouldn't make any difference to people just borrowing the close-enough ideas.</p>",
        "id": 192570366,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585764851
    }
]