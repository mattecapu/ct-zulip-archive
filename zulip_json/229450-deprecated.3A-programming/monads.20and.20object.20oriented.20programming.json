[
    {
        "content": "<p>Much of the nineties I spent writing object oriented code. I developed almost a mystical idea that the object oriented code I wrote was an aspect of the original object out there in the Universe. I wrote a few systems six, seven layers deep of objects. After a while the code seemed to self-organize out of complexity and I would check to see if the system already implemented features before I added them. At the time I was sure there was a CT connection. Is this what a monad is in software?</p>",
        "id": 194760010,
        "sender_full_name": "Daniel Geisler",
        "timestamp": 1587443579
    },
    {
        "content": "<p>not really</p>",
        "id": 194760950,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587445146
    },
    {
        "content": "<p>i'm not sure i see the category theory</p>",
        "id": 194760983,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587445202
    },
    {
        "content": "<p>OOP is mainly concerned about encapsulation and does not have a real notion of composition, IMHO. There are some attempts to base UML on category theory.</p>",
        "id": 194761645,
        "sender_full_name": "Johannes Drever",
        "timestamp": 1587446225
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"275946\">@Johannes Drever</span>  Can you elaborate on it not having a notion of composition? What about refactoring to break components into smaller more sophisticated systems?</p>",
        "id": 194761706,
        "sender_full_name": "Daniel Geisler",
        "timestamp": 1587446353
    },
    {
        "content": "<p>that's kind of a general programming thing, it's not really oop-specific</p>",
        "id": 194761858,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587446598
    },
    {
        "content": "<p>er, hold on, \"smaller more sophisticated systems\"?</p>",
        "id": 194761867,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587446630
    },
    {
        "content": "<p>that description sounds strange to me</p>",
        "id": 194761909,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587446645
    },
    {
        "content": "<p>Sophisticated is often smaller. Please note I was pounding large amounts of code at the time using multiple best practices including CASE tools. My experience is practical, not theoretical. I have more than once felt software systems come alive.</p>",
        "id": 194762691,
        "sender_full_name": "Daniel Geisler",
        "timestamp": 1587447772
    },
    {
        "content": "<p>im just unsure what you mean by \"sophisticated\"</p>",
        "id": 194762834,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587448013
    },
    {
        "content": "<p>usually i think of it as being roughly in opposition to \"simple\", and \"simple\" as being correlated with \"small\"</p>",
        "id": 194762865,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587448032
    },
    {
        "content": "<p>like, one major purpose of refactoring is to <em>reduce</em> complexity, no? and \"complex\" seems aligned with \"sophisticated\" to me</p>",
        "id": 194762916,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587448102
    },
    {
        "content": "<p>Sorry, I disagree. It doesn't go with my experience. That's OK. <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 194762978,
        "sender_full_name": "Daniel Geisler",
        "timestamp": 1587448204
    },
    {
        "content": "<p>i mean</p>",
        "id": 194762996,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587448237
    },
    {
        "content": "<p>i'm asking, which part of that do you disagree with?</p>",
        "id": 194763002,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587448244
    },
    {
        "content": "<p>Sorry, I'm moderately autistic. Can you elaborate on sophistication?</p>",
        "id": 194763101,
        "sender_full_name": "Daniel Geisler",
        "timestamp": 1587448398
    },
    {
        "content": "<p>i'm not sure what to say about it</p>",
        "id": 194763192,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587448561
    },
    {
        "content": "<p>if anything, i want to know what <em>you</em> mean by sophisticated</p>",
        "id": 194763231,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587448570
    },
    {
        "content": "<p>in this context</p>",
        "id": 194763236,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587448586
    },
    {
        "content": "<p>um, well, this is drifting off topic, it's not super important</p>",
        "id": 194763240,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587448610
    },
    {
        "content": "<p>Watch jewel like multilayered code where everything fits together in a wonderful fashion. Folks claimed they learned a lot about programming doing code reviews of my work. It is beautiful.  <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> If the beauty of the code blows people's mind's then it is sophisticated.</p>",
        "id": 194763338,
        "sender_full_name": "Daniel Geisler",
        "timestamp": 1587448789
    },
    {
        "content": "<p>ah</p>",
        "id": 194763855,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587449409
    },
    {
        "content": "<p>usually i think of \"sophisticated\" as meaning \"complex\"</p>",
        "id": 194763862,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587449421
    },
    {
        "content": "<p>or at least being similar in connotation</p>",
        "id": 194763878,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587449451
    },
    {
        "content": "<p>Sounds like I still don't know what a monad is. Back to the books.</p>",
        "id": 194763950,
        "sender_full_name": "Daniel Geisler",
        "timestamp": 1587449531
    },
    {
        "content": "<p>I'm mainly aware of monads in the context of FP, rather than OOP. In FP, monads can be used to contain state / side-effects. But OOP comes in many forms, so we'd need to specify what particular form of OOP  we're discussing first. E.g. are we talking class-based or prototype-based? Are interfaces / roles / traits involved?</p>",
        "id": 194764056,
        "sender_full_name": "Alexis Hazell",
        "timestamp": 1587449683
    },
    {
        "content": "<p>Bill Gates wrote 4K Basic when others thought there wasn't enough memory. Or Waz's floppy drive with half the normal chips. All surprisingly small. All sophisticated.</p>",
        "id": 194764694,
        "sender_full_name": "Daniel Geisler",
        "timestamp": 1587450411
    },
    {
        "content": "<p>it wouldntve occurred to me to describe them that way <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 194764842,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587450572
    },
    {
        "content": "<p>but it aint a formally defined term so im not gonna claim youre wrong!</p>",
        "id": 194764856,
        "sender_full_name": "sarahzrf",
        "timestamp": 1587450594
    },
    {
        "content": "<p>Complexity in software often arises from lots of interacting state. OOP usually involves objects with mutable state, making analysis of behaviour more difficult than if one 'quarantines' mutability and uses pure functions as much as possible.</p>",
        "id": 194765210,
        "sender_full_name": "Alexis Hazell",
        "timestamp": 1587451014
    },
    {
        "content": "<p>Maybe the moral of my story is if you are reading John Baez and programming, that your code could end up being CT flavored.</p>",
        "id": 194765646,
        "sender_full_name": "Daniel Geisler",
        "timestamp": 1587451477
    },
    {
        "content": "<p>Haskell is very CT-flavoured, so you don't need to be reading John's work to end up making use of CT concepts. :-) Monads and optics (e.g. lenses) play a central role.</p>",
        "id": 194766004,
        "sender_full_name": "Alexis Hazell",
        "timestamp": 1587451834
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"278736\">@Alexis Hazell</span>  thanks, now I have to download Haskell. <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 194766343,
        "sender_full_name": "Daniel Geisler",
        "timestamp": 1587452226
    },
    {
        "content": "<p>If you've not already seen it, you might be interested in this post on the n-Category Café blog: <a href=\"https://golem.ph.utexas.edu/category/2020/01/profunctor_optics_the_categori.html\" title=\"https://golem.ph.utexas.edu/category/2020/01/profunctor_optics_the_categori.html\">https://golem.ph.utexas.edu/category/2020/01/profunctor_optics_the_categori.html</a></p>",
        "id": 194766740,
        "sender_full_name": "Alexis Hazell",
        "timestamp": 1587452573
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276867\">Daniel Geisler</span> <a href=\"#narrow/stream/229450-practice.3A-programming/topic/monads.20and.20object.20oriented.20programming/near/194761706\" title=\"#narrow/stream/229450-practice.3A-programming/topic/monads.20and.20object.20oriented.20programming/near/194761706\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"275946\">Johannes Drever</span>  Can you elaborate on it not having a notion of composition? What about refactoring to break components into smaller more sophisticated systems?</p>\n</blockquote>\n<p><a href=\"http://dev.stephendiehl.com/fun/002_parsers.html\" title=\"http://dev.stephendiehl.com/fun/002_parsers.html\">Parser combinators</a> are a good example for composition. If you have a parser <code>a :: Parser Expr</code> and a parser <code>b :: Parser Expr</code> you can compose them and get another <code>a &lt;|&gt; b :: Parser Expr</code>.  The type system gives some guarantees, so a lot of reasoning can be offloaded to the compiler. </p>\n<p>Of course you can refactor code in OOP. But most OOP-language lack referential transparency which makes refactoring more difficult. Basically you have to manage a lot of coherence conditions in your head which might be taken care of the compiler and type system. </p>\n<p>And there is parametric polymorphism. In Haskell it is quite common to write functions with parametric polymorphism. In OOP it is the default that a functions is attached to a class and manages specifically the state that object. There are for sure some libraries which are polymorphic, such as <code>java.util.Collections</code>. But already the fact that it lives in package <code>util</code> shows that it is somehow second-class.</p>",
        "id": 194767268,
        "sender_full_name": "Johannes Drever",
        "timestamp": 1587453024
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276867\">Daniel Geisler</span> <a href=\"#narrow/stream/229450-practice.3A-programming/topic/monads.20and.20object.20oriented.20programming/near/194760010\" title=\"#narrow/stream/229450-practice.3A-programming/topic/monads.20and.20object.20oriented.20programming/near/194760010\">said</a>:</p>\n<blockquote>\n<p>Much of the nineties I spent writing object oriented code. I developed almost a mystical idea that the object oriented code I wrote was an aspect of the original object out there in the Universe. I wrote a few systems six, seven layers deep of objects. After a while the code seemed to self-organize out of complexity and I would check to see if the system already implemented features before I added them. At the time I was sure there was a CT connection. Is this what a monad is in software?</p>\n</blockquote>\n<p>Hello Daniel :). I guess there might be more than one ways to abstract stuff. One that I definitely recommend in t his case is the coalgebraic approach found in Jacobs' Introduction to Coalgebra book (<a href=\"http://www.cs.ru.nl/B.Jacobs/CLG/JacobsCoalgebraIntro.pdf\" title=\"http://www.cs.ru.nl/B.Jacobs/CLG/JacobsCoalgebraIntro.pdf\">http://www.cs.ru.nl/B.Jacobs/CLG/JacobsCoalgebraIntro.pdf</a>), Section 6.9. The key for this approach is that methods are a form of interaction, and hence observation, on a class (and of course observation is what coalgebras are about). But it gets more involved with the introduction of assertions as properties for classes.</p>",
        "id": 194809901,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1587479450
    },
    {
        "content": "<p>It’s hard to compare OOP and monads specifically. Monads are one tool in a toolbox, they’re great for expressing the sequencing of effects (including side effects like mutability, and some sorts of control flows, like exceptions and nondeterminacy and even continuations). Functions are of course the most essential part of a functional tooblox. And then with algebraic data types and other goodies you can express many other patterns, including not only monads but also recursion schemes and lenses. And the cherry on top is that typeclasses make it much more convenient. It’s like having a handle and a good organization scheme for your toolbox.</p>\n<p>OOP is what would happen if you took the whole toolbox and tried to smelt it together or something. It doesn’t neatly correspond to any single tool, since it mixes parts of other tools in weird ways: OOP classes can be used to represent types of (usually mutable!) data, but it’s also mixed together with functions, and those functions can have effects, and you literally cannot separate out the mutable state and potentially cyclic interactions amongst objects, unless you adhere to quasi-FP guidelines.</p>\n<p>What I love about FP is that you can tease apart these separate tools. (In fact, you’re encouraged or even forced to.) You can work in the StateT monad transformer and act as if you have mutable state (and you can use lenses to target specific portions of the state!), but you always know that the whole state you’re manipulating is contained in one gestalt and inert data object that you can pull out of the control flow at any time, so you can trivially do things like rolling back the state for failed transactions or whatnot.</p>\n<p>Anyways, it’s a little like comparing apples to trees, monads to OOP, but those are my first thoughts.</p>",
        "id": 194851347,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1587497853
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276424\">Rongmin Lu</span> <a href=\"#narrow/stream/229450-practice.3A-programming/topic/monads.20and.20object.20oriented.20programming/near/194887141\" title=\"#narrow/stream/229450-practice.3A-programming/topic/monads.20and.20object.20oriented.20programming/near/194887141\">said</a>:</p>\n<blockquote>\n<p>I think people had figured out the formal semantics of imperative programming early on, while functional programming had been substantially shaped by category theory itself.</p>\n</blockquote>\n<p>I've been keeping an eye out for historic papers on FP + CT for <a href=\"https://ncatlab.org/nlab/show/functional+programming\" title=\"https://ncatlab.org/nlab/show/functional+programming\">the nLab 'functional programming' page</a>, so if you know of any that should be added, please feel free to let me know. :-)</p>",
        "id": 194887906,
        "sender_full_name": "Alexis Hazell",
        "timestamp": 1587530437
    },
    {
        "content": "<p>I presume you mean \"the references on the Wikipedia page\", since the nLab itself is a wiki. :-) But if so, since nLab entries are supposed to be from the <a href=\"https://ncatlab.org/nlab/show/nPOV\" title=\"https://ncatlab.org/nlab/show/nPOV\">nPOV</a>, that nLab page should mainly be about the connections between FP and CT, not about FP in general, and I don't know which (if any) of those references discuss those connections.</p>",
        "id": 194913228,
        "sender_full_name": "Alexis Hazell",
        "timestamp": 1587551935
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276867\">Daniel Geisler</span> <a href=\"#narrow/stream/229450-practice.3A-programming/topic/monads.20and.20object.20oriented.20programming/near/194760010\" title=\"#narrow/stream/229450-practice.3A-programming/topic/monads.20and.20object.20oriented.20programming/near/194760010\">said</a>:</p>\n<blockquote>\n<p>Much of the nineties I spent writing object oriented code. I developed almost a mystical idea that the object oriented code I wrote was an aspect of the original object out there in the Universe. I wrote a few systems six, seven layers deep of objects. After a while the code seemed to self-organize out of complexity and I would check to see if the system already implemented features before I added them. At the time I was sure there was a CT connection. Is this what a monad is in software?</p>\n</blockquote>\n<p>Object-oriented programming is most closely connected with Lawvere theories and their variants.  Generic interfaces with purely functional methods are very nearly presentations of categories with finite products.  For example, here is a Java interface for a monoid:</p>\n<div class=\"codehilite\"><pre><span></span>interface Monoid&lt;M&gt; {\n  M mult(M a, M b);\n  M unit();\n}\n</pre></div>\n\n\n<p>This interface presents a cartesian category T whose objects are tuples of Ms and whose morphisms are given by all compositions of the built-in morphisms duplication and deletion and the morphisms mult and unit from the interface.</p>\n<p>Most OO languages don't allow you to enforce axioms as part of the type declaration, so instead of proofs, we resort to a comment on the interface and a test suite.  </p>\n<div class=\"codehilite\"><pre><span></span>// Valid implementations satisfy\n// associativity: for all a, b, c, mult(a, mult(b, c)) == mult(mult(a, b), c)\n// unitality: for all a, mult(unit(), a) == a == mult(a, unit())\ninterface Monoid&lt;M&gt; {\n  M mult(M a, M b);\n  M unit();\n}\n</pre></div>\n\n\n<p>This is a presentation of T modded out by associativity and unit laws; we call the resulting category Th(Mon), the \"Lawvere theory of monoids\".</p>\n<p>Implementations of this interface are the same as product-preserving functors from Th(Mon) to the category Set of sets and functions.</p>\n<div class=\"codehilite\"><pre><span></span>class Add implements Monoid&lt;Integer&gt; {\n  public Integer mult(Integer a, Integer b) {\n    return a + b;\n  }\n  public Integer unit() {\n    return 0;\n  }\n}\n</pre></div>\n\n\n<p>Note in this special case that we would usually call + \"addition\" instead of \"multiplication\", but we have to use the same method name as the interface.</p>\n<p>The functor presented by this code maps the object M to the set of integers.  Because the functor is product-preserving, it maps the tuple (M, M) to the tuple (Integer, Integer), and so on for all the other lengths.  It maps the formal morphism M mult(M a, M b) to the actual function Integer mult(Integer a, Integer b), etc.</p>\n<p>The category of product-preserving functors from Th(Mon) to Set and natural transformations between them is equivalent to the category Mon of monoids and monoid homomorphisms. </p>\n<p>Given any implementation X of Monoid&lt;M&gt;, we can forget the monoid structure and just consider the set of values of type X.  Similarly, given any monoid homomorphism, we can forget that it preserves multiplication and unit and consider it merely a function between two sets.  That operation is a \"forgetful functor\" U:Mon -&gt; Set.</p>\n<p>U has a left adjoint F:Set -&gt; Mon that picks out the \"free monoid\" on the given set, i.e. the set of strings on the alphabet S.  Every monoid is the free monoid on some generators modulo some equations.  For example, Add is the free monoid on the set of integers (whose elements are lists of integers) modulo the relation that a list is equivalent to the one-element list containing its sum.</p>\n<p>You get a monad by composing the free and forgetful functors, though it's not usually presented that way in OO programming languages.  Instead, a monad is a design pattern that's very similar to the interface for the monoid above.  Instead of being generic in a datatype M, it is generic in a generic M&lt;&gt;.  Java doesn't support this syntax, but Scala does.  If Java did, the interface for a monad would probably look something like this:</p>\n<div class=\"codehilite\"><pre><span></span>interface Monad&lt;M&lt;&gt;, X&gt; {\n  M&lt;X&gt; mult(M&lt;M&lt;X&gt;&gt; mmx);\n  M&lt;X&gt; unit(X x);\n}\n</pre></div>\n\n\n<p>Instead of mult taking two <em>instances</em> of a datatype M, mult now takes two <em>iterations</em> of a generic M on X.  Similarly, instead of unit taking zero <em>instances</em> of a datatype M, unit now takes zero <em>iterations</em> of a generic M on X.</p>\n<p>There are lots of different kinds of monads in use in OO languages.  Parallel programming, exceptions, parsers, futures/promises, communication streams, continuations, loggers, gatekeepers (for ocaps-style revocation), and many other language features are implementable as monads.  While OO languages tend to have specialized syntax for the most common of these, functional languages tend to support all monads with a common syntax, allowing programmers to extend the language with new monads while maintaining readability.</p>",
        "id": 194979530,
        "sender_full_name": "Mike Stay",
        "timestamp": 1587583602
    },
    {
        "content": "<p><a href=\"https://dev.to/amb007/comment/j23\">https://dev.to/amb007/comment/j23</a> I wonder if this is helpful</p>",
        "id": 197296772,
        "sender_full_name": "Aleksandar M. Bakic",
        "timestamp": 1589298591
    }
]