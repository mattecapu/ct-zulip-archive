[
    {
        "content": "<p>Hello people. I'm working on a type theory for a programming language I want to make based on linear logic and dependent types. As part of that, I'm considering adding an exponential modality similar to <code>!</code>/\"of course\" except without dereliction or promotion and with another rule instead which here I'll call \"read\". My problem is that I'm failing to figure out how to formulate this rule, so I'm hoping someone can help me...</p>\n<p>I'll describe my problem in more detail: The <code>!</code> modality has these three properties (in addition to promotion):</p>\n<ul>\n<li>weakening: <code>!A |- 1</code></li>\n<li>contraction: <code>!A |- !A × !A</code></li>\n<li>dereliction: <code>!A |- A</code></li>\n</ul>\n<p>However these can be formulated as right-rules for <code>?</code> as such:</p>\n<ul>\n<li>weakening</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><code>G |- D\n----\nG |- D, ?A\n</code></pre></div>\n<ul>\n<li>contraction</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><code>G |- D, ?A, ?A\n----\nG |- D, ?A\n</code></pre></div>\n<ul>\n<li>dereliction</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><code>G |- D, A\n----\nG |- D, ?A\n</code></pre></div>\n<p>The advantage of this formulation is that each rule has a single instance of <code>?A</code> on the right-hand side of the conclusion, which I think is necessary for cut-elimination and proof search.</p>\n<p>I'd like a type, which I'll call <code>Read(A)</code>, which has these 3 properties instead:</p>\n<ul>\n<li>weakening: <code>Read(A) |- 1</code></li>\n<li>contraction: <code>Read(A) |- Read(A) × Read(A)</code></li>\n<li>read: <code>A |- A × Read(A)</code></li>\n</ul>\n<p>But I'd like to formulate the read rule similarly to weakening and contraction such that it has a conclusion with a single instance of <code>Read(A)</code> or <code>¬Read(A)</code> to the right of the turnstile. I can't see a way to do this.</p>\n<p>My aim here is to end up with the following properties for <code>Read</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>Read(0) = 0\nRead(1) = 1\nRead(A + B) = Read(A) + Read(B)\nRead(A × B) = Read(A) × Read(B)\nRead(!A) = !A\nRead(Read(A)) = Read(A)\n</code></pre></div>\n<p>It seems like these properties should be necessary consequences of the read rule. For instance to prove <code>Read(0) |- 0</code> I should be able to use the fact that the only way to introduce <code>Read(0)</code> is via the rule <code>0 |- 0 × Read(0)</code>, implying there was a proof of <code>0</code> at some point. And since <code>0 |- 0 × 0</code> I should be able to \"look back\" to where there was a proof of <code>0</code>, duplicate that proof, and bring the duplicate forward to where it's needed. The same logic should apply to any type <code>X</code> which satisfies <code>X |- X × X</code>, which should all have the property that <code>Read(X) = X</code>.</p>\n<p>Is this reasoning sound? Or is there a way to formulate the read rule to make it sound and so that I still have cut-elimination?</p>\n<p>Thank you to anyone who can help me clarify my thoughts on this or who can link me to research exploring a similar idea :)</p>",
        "id": 227081420,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1613815490
    },
    {
        "content": "<p>To explain my motivation a bit: The type <code>!A</code> is a strictly positive / \"pure-data\" type in the sense that it can be freely copied and destroyed. The only way to create a <code>!A</code> is if it's possible to create an <code>A</code> out of strictly-positive pure-data, but once you have an <code>!A</code> you can freely extract as many <code>A</code>s out of it as you like. In this sense, <code>!A</code> can be read as \"I have a copyable <code>A</code>\". And <code>!A</code> behaves like a comonad.</p>\n<p>I'd like a similar kind of type which behaves more like a monad (though not quite like one) and can be read as \"I have a reference to an A\". <code>Read(A)</code>, like <code>!A</code>, can be freely copied and destroyed. The difference is that you can always create a <code>Read(A)</code> out of an <code>A</code> (though without consuming the <code>A</code>, which you still have to consume in parallel), but when you have a <code>Read(A)</code> you can only extract the positive/data component of the <code>A</code> out of it.</p>\n<p>I can then add dependent types to my linear-logic language by having the type of a term under a context <code>G</code> be checked under a context <code>Read(G)</code>. I might also redefine the promotion rule for <code>!</code> as being:</p>\n<div class=\"codehilite\"><pre><span></span><code>Read(G) |- A\n----\nRead(G) |- !A\n</code></pre></div>\n<p>Since <code>Read</code> behaves better than <code>!</code> w.r.t. context structure, in the sense that we have <code>Read(A × B) = Read(A) × Read(B)</code>.</p>",
        "id": 227082753,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1613817163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"320695\">Andrew Cann</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/Even.20more.20exponentials.20in.20linear.20logic/near/227081420\">said</a>:</p>\n<blockquote>\n<p>Hello people. I'm working on a type theory for a programming language I want to make based on linear logic and dependent types. As part of that, I'm considering adding an exponential modality similar to <code>!</code>/\"of course\" except without dereliction or promotion and with another rule instead which here I'll call \"read\". My problem is that I'm failing to figure out how to formulate this rule, so I'm hoping someone can help me...<br>\n[...]</p>\n<p>The advantage of this formulation is that each rule has a single instance of <code>?A</code> on the right-hand side of the conclusion, which I think is necessary for cut-elimination and proof search.</p>\n</blockquote>\n<p>Well, the traditional wisdom on that has been that you do want Natural Deduction (ND)  instead of sequent calculus for Curry-Howard, as you want to make more proofs equivalent. the sequent calculus is better for proof search, but it's too verbose, too many essentially the same proof are considered different proofs.  However there are serious problems when trying to make ND <em>multi-conclusion</em>, there are some books on the issues and possible solutions, starting with Kneale and Kneale (the math historians), CSLI's Ungar in the 80s and many others. So the idea of concentrating on ?A, instead of !A does not seem to me very promising, but of course you may be able to make progress in all of these different issues. But then what it would make sense to  ask is what is the categorical semantics of this not-quite-monad \"Read\". Because references (meaning \"pointers\") have also always been difficult to model. So, I'm always willing to discuss making LL into programming languages, I'm doing it and talking about it all the time and pleased to do so with new ideas, but hear I am not seeing a \"path to the sea\", perhaps yet.<br>\n*here</p>",
        "id": 227186856,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1613933909
    },
    {
        "content": "<blockquote>\n<p>Is this reasoning sound?</p>\n</blockquote>\n<p>Looking at this again, it's obviously not. I'm missing an axiom.</p>\n<p><span class=\"user-mention\" data-user-id=\"276656\">@Valeria de Paiva</span>:</p>\n<blockquote>\n<p>Well, the traditional wisdom on that has been that you do want Natural Deduction (ND) instead of sequent calculus for Curry-Howard</p>\n</blockquote>\n<p>The language I've got so far uses a natural-deduction style and it captures all of linear logic, plus another two modalities which I discussed <a href=\"#narrow/stream/233104-theory.3A-logic/topic/Exponential.20Modalities.20in.20Linear.20Logic.20.2F.20Type.20Theory\">here</a></p>\n<p>The basic idea is that there's two kinds of judgements, which I'll call \"terms\" and \"patterns\". A term judgement is of the form <code>G |- A</code> where <code>G</code> is a context (a multi-set of formulas) and <code>A</code> is a single formula. This is the same as the standard linear logic sequent it resembles. A pattern judgement is of the form <code>G |- A -| D</code> where <code>D</code> is another context. This is equivalent to the linear logic sequent <code>G |- A, tensor(D)</code> where <code>tensor(D)</code> means to combine all the formulas in <code>D</code> into a tensor.</p>\n<p>From here you can derive term and pattern rules for all the types in linear logic, and this is what you get:</p>\n<ul>\n<li><code>0</code> type (which I write <code>@[]</code>)</li>\n</ul>\n<p>(no term or pattern rule)</p>\n<ul>\n<li><code>⊤</code> type (which I write <code>#[]</code>)</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><code>----\nG |- []: #[]\n\n\n----\nG |- [] : #[] -| D\n</code></pre></div>\n<ul>\n<li><code>1</code> type (which I write <code>#()</code>)</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><code>----\n. |- () : #()\n\n\nG0 |- x: A -| .\nG1 |- y: Not(A) -| D\n----\nG0, G1 |- connect x = y : #() -| D\n</code></pre></div>\n<ul>\n<li><code>⊥</code> type (which I write <code>@()</code>)</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><code>G0 |- x : A\nG1 |- y : Not(A)\n----\nG0, G1 |- connect x = y : @()\n\n\n----\n. |- () : @() -| .\n</code></pre></div>\n<ul>\n<li>Sum types (which I write <code>@[left: A, .. B]</code>)</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><code>G |- a : A\n----\nG |- @left a : @[left: A, .. B]\n\n\nG |- a : A -| D\n----\nG |- @left a : @[left: A, .. B] -| D\n</code></pre></div>\n<ul>\n<li>With types (which I write <code>#[left: A, .. B]</code>)</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><code>G |- a : A\nG |- b : B\n----\nG |- [left = a, .. b] : #[left: A, .. B]\n\n\nG |- a : A -| D\nG |- b : B -| D\n----\nG |- [left = a, .. b] : #[left: A, .. B] -| D\n</code></pre></div>\n<ul>\n<li>Tensor types (which I write <code>#(left: A, .. B)</code>)</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><code>G0 |- a : A\nG1 |- b : B\n----\nG0, G1 |- (left = a, .. b) : #(left: A, .. B)\n\n\nG0 |- a : A\nG1 |- b : B -| D\n----\nG0, G1 |- (left = a) =&gt; b : #(left: A, .. B) -| D\n</code></pre></div>\n<ul>\n<li>Par types (which I write <code>@(left: A, .. B)</code>)</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><code>G0 |- a : A -| C\nG1, C |- b : B\n----\nG0, G1 |- (left = a) =&gt; b : @(left: A, .. B)\n\n\nG0 |- a : A -| D0\nG1 |- b : B -| D1\n----\nG0, G1 |- (left = a, .. b) : @(left: A, .. B) -| D0, D1\n</code></pre></div>\n<ul>\n<li>Of-course types (which I write <code>Copy(A)</code>)</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><code>Copy(G) |- a : A\n----\nCopy(G) |- copy a : Copy(A)\n\n\nCopy(G0) |- a : A -| C\nCopy(G1), C |- x : Bundle(B)\nCopy(G2) |- y : Copy(Not(B)) -| D\n----\nCopy(G0, G1, G2) |- srv(x = y) a : Copy(A) -| D\n</code></pre></div>\n<ul>\n<li>Why-not types (which I write <code>Bundle(A)</code>)</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><code>G0 |- x : T\nG1 |- y : Not(T)\n----\nG0, G1 |- x &lt;|&gt; y : Bundle(A)\n\n\nG |- a : A\n----\nG |- just a : Bundle(A)\n\n\nG0 |- x : Bundle(A) -| C\nG1, C |- y : Bundle(A)\n----\nG0, G1 |- &lt;.. x&gt; =&gt; y : Bundle(A)\n\n\n----\n. |- &lt;&gt; : Bundle(A) -| .\n\n\nG |- a : A -| D\n----\nG |- &lt;a&gt; : Bundle(A) -| D\n\n\nG0 |- x : Bundle(A) -| D0\nG1 |- y : Bundle(A) -| D1\n----\nG0, G1 |- &lt;.. x, .. y&gt; : Bundle(A) -| D0, D1\n</code></pre></div>\n<ul>\n<li><code>Set(A)</code> types (multi-sets of values)</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><code>----\n. |- &lt;&gt; : Set(A)\n\n\nG |- a : A\n----\nG |- &lt;a&gt; : Set(A)\n\n\nG0 |- x : Set(A)\nG1 |- y : Set(A)\n----\nG0, G1 |- &lt;.. x, .. y&gt; : Set(A)\n\n\nG0 |- x : T -| .\nG1 |- y : Not(T) -| D\n----\nG0, G1 |- x &lt;|&gt; y : Set(A) -| D\n\n\nG |- a : A -| D\n----\nG |- just a : Set(A) -| D\n\n\nG0 |- x : Set(A)\nG1 |- y : Set(A) -| D\n----\nG0, G1 |- &lt;.. x&gt; =&gt; y : Set(A) -| D\n</code></pre></div>\n<ul>\n<li><code>Srv(A)</code> types (the dual of <code>Set</code> types)</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><code>C |- a : A\n. |- x : Set(Not(B)) -| C\nG |- y : Srv(B)\n----\nG |- srv(x = y) a : Srv(A)\n\n\n. |- a : A -| Set(C)\n----\n. |- copy a : Srv(A) -| Set(C)\n</code></pre></div>\n<p>If I've done everything correctly then these rules should be equivalent to the original linear logic rules.</p>",
        "id": 227384813,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1614058433
    },
    {
        "content": "<p>An interesting thing about this is that the term/pattern rules for any type mirror the pattern/term rules of it's \"semi-dual\" (where I'm defining semi-dual to mean the type with all the multiplicative components inverted). For instance, if you take the term rule for par types and replace all the pattern premises with terms and all the term premises with patterns you get the pattern rule for tensor types, and vice-versa. I don't know if this has any deep significance, but it makes for a nice language since it means I can make pattern syntax be identical to term syntax (eg. any syntactic form that's usable in one position is usable in the other).</p>\n<blockquote>\n<p>references (meaning \"pointers\") have also always been difficult to model.</p>\n</blockquote>\n<p>I think I'm nearly there... The idea I'm going for is to add another 4 modalities, similar to the existing four but with opposite \"monadness\" (sort-of). The (co)weakening and (co)contraction rules then move to the new modalities and the rules for the original 4 modalities then get reformulated in terms of the new ones:</p>\n<div class=\"codehilite\"><pre><span></span><code>Read(G) |- A\n----\nRead(G) |- Copy(A)\n\n\nG |- CoRead(Bundle(A)), D\n----\nG |- Bundle(A), D\n\n\nG |- Extend(Set(A)), D\n----\nG |- Set(A), D\n\n\nCoExtend(B) |- A\n----\nCoExtend(B) |- Srv(A)\n</code></pre></div>\n<p>The problem I'm having is how to formulate the rules for these new modalities. (co)weakening and (co)contraction are easy but then I need another few axioms which give me the equivalences for <code>Read</code> that I listed in the OP, as well as similar equivalences for the other types.</p>",
        "id": 227386852,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1614060585
    }
]