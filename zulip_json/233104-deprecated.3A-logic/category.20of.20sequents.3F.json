[
    {
        "content": "<p>In learning about the sequent calculus, it struck me that that the identity inference rule (for any formula <code>A</code>, we have <code>A ⊢ A</code>) and cut rule (for any finite formula sequences  <code>Γ</code>, <code>Δ</code>, <code>Σ</code>,  and <code>Π</code> and formula <code>A</code>, if we have <code>Γ ⊢ Δ, A</code> and <code>A, Σ ⊢ Π</code> then we have <code>Γ, Σ ⊢ Δ, Π</code>) look something like identity and composition if you squint. Is there a category here? At first I was thinking the arrows would be any sequent, with the domain being the first formula on the LHS and the codomain being the last formula on the RHS, but then I'm not sure how to deal with sequents like <code>⊥ ⊢</code></p>",
        "id": 213151393,
        "sender_full_name": "Shea Levy",
        "timestamp": 1602594739
    },
    {
        "content": "<p>(ironically I'm learning about sequent calculus for a first-order formalization of category theory itself)</p>",
        "id": 213151463,
        "sender_full_name": "Shea Levy",
        "timestamp": 1602594773
    },
    {
        "content": "<p>Polycategories are to (sequent calculus, identity, cut) as multicategories are to (natural deduction, variable, simultaneous substitution), so that's probably a good point of comparison.</p>",
        "id": 213152263,
        "sender_full_name": "James Wood",
        "timestamp": 1602595135
    },
    {
        "content": "<p>Awesome, thank you!</p>",
        "id": 213152806,
        "sender_full_name": "Shea Levy",
        "timestamp": 1602595368
    },
    {
        "content": "<p>It must be extremely fiddly to prove, but I guess cut is associative with respect to the equational theory (of any reasonable logic).</p>",
        "id": 213153219,
        "sender_full_name": "James Wood",
        "timestamp": 1602595542
    },
    {
        "content": "<p>From <a href=\"https://ncatlab.org/nlab/show/polycategory#relation_to_properads_and_props\">https://ncatlab.org/nlab/show/polycategory#relation_to_properads_and_props</a> it looks like we can compose along any one object regardless of its position in the list, but in sequent calculus that requires exchange, right? Are there \"ordered\" polycategories?</p>",
        "id": 213156305,
        "sender_full_name": "Shea Levy",
        "timestamp": 1602596929
    },
    {
        "content": "<p>Sequent calculi would usually correspond to symmetric polycategories, which admit exchange.</p>",
        "id": 213157116,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1602597251
    },
    {
        "content": "<p>If you don't have exchange, then you consider ordinary/planar/nonsymmetric polycategories.</p>",
        "id": 213157179,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1602597282
    },
    {
        "content": "<p>Got it, thanks!</p>",
        "id": 213157236,
        "sender_full_name": "Shea Levy",
        "timestamp": 1602597304
    },
    {
        "content": "<p><del>the nlab page probably says this, but for the record, the \"structured category\" notion corresponding to symmetric polycats is gonna be <em>star-autonomous</em> categories</del></p>",
        "id": 213174474,
        "sender_full_name": "sarahzrf",
        "timestamp": 1602603529
    },
    {
        "content": "<p><del>that is to say: star-autonomous categories are to symmetric polycategories as symmetric monoidal categories are to symmetric multicategories</del></p>",
        "id": 213174580,
        "sender_full_name": "sarahzrf",
        "timestamp": 1602603566
    },
    {
        "content": "<p>oh wait sorry <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> i think that's actually wrong, ignore me</p>",
        "id": 213174792,
        "sender_full_name": "sarahzrf",
        "timestamp": 1602603632
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"351475\">Shea Levy</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/Category.20of.20sequents.3F/near/213151393\">said</a>:</p>\n<blockquote>\n<p>In learning about the sequent calculus, it struck me that that the identity inference rule (for any formula <code>A</code>, we have <code>A ⊢ A</code>) and cut rule (for any finite formula sequences  <code>Γ</code>, <code>Δ</code>, <code>Σ</code>,  and <code>Π</code> and formula <code>A</code>, if we have <code>Γ ⊢ Δ, A</code> and <code>A, Σ ⊢ Π</code> then we have <code>Γ, Σ ⊢ Δ, Π</code>) look something like identity and composition if you squint. Is there a category here? At first I was thinking the arrows would be any sequent, with the domain being the first formula on the LHS and the codomain being the last formula on the RHS, but then I'm not sure how to deal with sequents like <code>⊥ ⊢</code></p>\n</blockquote>\n<p>hi, this was the original insight of Lambek in <br>\nLambek, Joachim (1969). \"Deductive systems and categories I and  II. Standard constructions and closed categories\". Lecture Notes in Mathematics. 86. Berlin, Heidelberg: Springer Berlin Heidelberg. pp. 76–122. doi:10.1007/bfb0079385. ISBN 978-3-540-04605-9. ISSN 0075-8434.</p>",
        "id": 213198195,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1602614125
    },
    {
        "content": "<p>I think this is pretty much what categorical logic studies. Take a look at <span class=\"user-mention\" data-user-id=\"276777\">@Mike Shulman</span>'s <a href=\"http://mikeshulman.github.io/catlog/catlog.pdf\">http://mikeshulman.github.io/catlog/catlog.pdf</a> book.</p>",
        "id": 213299689,
        "sender_full_name": "Alex Gryzlov",
        "timestamp": 1602686832
    },
    {
        "content": "<p>What \"this\" are you referring to?</p>",
        "id": 213299908,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1602686917
    },
    {
        "content": "<p>categories that correspond to various proof systems (and vice versa)</p>",
        "id": 213299954,
        "sender_full_name": "Alex Gryzlov",
        "timestamp": 1602686942
    },
    {
        "content": "<p>The simplest case is just posets. Then you can interpret the objects as propositions and the morphisms as entailments</p>",
        "id": 213301014,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1602687393
    },
    {
        "content": "<p>The terminal object is truth, the initial object is falsity, product is and, sum is or, exponentiation is implication, etc</p>",
        "id": 213301118,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1602687450
    },
    {
        "content": "<p>To extend this you basically have two approaches - propositions as types, which is what is done with Lambda calculus and dependent type theory, or logic over a type theory which is what is done with hyperdoctrines</p>",
        "id": 213301353,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1602687559
    },
    {
        "content": "<p>The subobject fibration which sends each object to its poset of subjects is just a special case of this second approach</p>",
        "id": 213301498,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1602687603
    },
    {
        "content": "<p>Lawvere’s Adjointness in Foundations is a good early reference for this kind of thinking</p>",
        "id": 213301623,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1602687658
    },
    {
        "content": "<p>I guess this is still a work in progress - e.g. Chapter 3 seems to be missing ... (I would notice that, wouldn't I?)</p>",
        "id": 213327973,
        "sender_full_name": "Robert Seely",
        "timestamp": 1602697811
    },
    {
        "content": "<p>yeah, 5 and 6 are also not there</p>",
        "id": 213328498,
        "sender_full_name": "Alex Gryzlov",
        "timestamp": 1602698059
    },
    {
        "content": "<p>There are some updates in <a href=\"https://github.com/mikeshulman/catlog\">https://github.com/mikeshulman/catlog</a> which are not in the pdf (which seems to be from ~mid 2016), so I guess one should compile those tex files manually for the latest version</p>",
        "id": 213328938,
        "sender_full_name": "Alex Gryzlov",
        "timestamp": 1602698250
    },
    {
        "content": "<p>They're still excellent 'notes' regardless.</p>",
        "id": 213330390,
        "sender_full_name": "Dan Doel",
        "timestamp": 1602698884
    },
    {
        "content": "<p>Yeah they are great. I like that they're much more semantically oriented than the usual treatments.</p>",
        "id": 213345648,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1602707115
    },
    {
        "content": "<p>I'm glad y'all like them.  Sadly the unwritten chapter 3 is the one of relevance to the OP here though...</p>",
        "id": 213349554,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1602708987
    },
    {
        "content": "<p>By the way, I've built the latest version manually, if somebody wants it: <a href=\"/user_uploads/21317/f6QrcWYo5sPIJLQzDcuv0VL3/catlog.pdf\">catlog.pdf</a></p>",
        "id": 213574432,
        "sender_full_name": "Alex Gryzlov",
        "timestamp": 1602861600
    },
    {
        "content": "<p>It has some parts of chapter 3</p>",
        "id": 213574661,
        "sender_full_name": "Alex Gryzlov",
        "timestamp": 1602861707
    },
    {
        "content": "<p>Incidentally, if someone wants to see another classical-ish type theory with sequents, I'd recommend Compiling with Classical Connectives. It's a lot more complicated than just classical logic to keep things computationally well-behaved, though.</p>",
        "id": 213575971,
        "sender_full_name": "Dan Doel",
        "timestamp": 1602862346
    },
    {
        "content": "<p>I am now reading  <span class=\"user-mention\" data-user-id=\"276777\">@Mike Shulman</span> 's catlog.pdf at chapter 2 with remembering section 1.4 (referring the rule lists in p51).<br>\nI have a question around the rule <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><msub><mi>π</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><msub><mi>π</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo><mo>&gt;</mo><mtext>   </mtext><mo>≡</mo><mtext>  </mtext><mi>P</mi></mrow><annotation encoding=\"application/x-tex\"> &lt;π_1(P),π_2(P)&gt;\\ \\ \\  \\equiv \\ \\ P </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\"> </span><span class=\"mspace\"> </span><span class=\"mspace\"> </span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.46375em;vertical-align:0em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\"> </span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span>. <br>\nI would like to introduce this judgmental equality formally. <br>\nTo do that, I think of a category, but I could not construct a 2-morphism corresponding to the rule. </p>\n<p>So, my question is \"Is there a way of formalizing this rule in a category rather than in a multicategory introduced in chapter 2?\"</p>",
        "id": 229175006,
        "sender_full_name": "GhaS Shee",
        "timestamp": 1615111552
    },
    {
        "content": "<p>This rule (the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">\\eta</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span></span></span></span>-rule for products) corresponds to the uniqueness of the universal property of a binary product in a category. You can check that the morphisms represented by the LHS and by the RHS both satisfy the condition to be the mediating morphism for the product, implying their equality.</p>",
        "id": 229190222,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1615126091
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276092\">@Nathanael Arkor</span> <br>\nAh, thanks. exactly.</p>",
        "id": 229193817,
        "sender_full_name": "GhaS Shee",
        "timestamp": 1615129295
    }
]