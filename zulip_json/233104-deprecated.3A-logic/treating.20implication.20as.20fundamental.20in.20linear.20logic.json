[
    {
        "content": "<p>So far in the presentations of linear logic that I've seen, additive and multiplicative conjunction and disjunction are treated as fundamental and implication is defined in terms of those. In particular, so far all the presentations of linear lambda calculus that I've seen have (various linear forms of) lambda as a primitive, but also have primitives for conjunction and disjunction. That's different from other lambda calculi which often prefer to use lambda as a primitive, and define conjunction and disjunction with Church encoding, rather than have data types as a distinct primitive. (e.g. System F)</p>\n<p>Is it possible to have linear logic with implication as the foundation? In particular, is it possible to have a linear lambda calculus where the conjunction and disjunction forms are not primitve, but are recreated with (various linear forms of) lambda terms? What would that look like? (it seems easy and standard for multiplicative conjunction and additive disjunction - it's just Church encoding - but I have no idea if it can be done for additive conjunction and multiplicative disjunction)</p>",
        "id": 251181138,
        "sender_full_name": "Spencer Baugh",
        "timestamp": 1630296500
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"436298\">Spencer Baugh</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/treating.20implication.20as.20fundamental.20in.20linear.20logic/near/251181138\">said</a>:</p>\n<blockquote>\n<p>That's different from other lambda calculi which often prefer to use lambda as a primitive, and define conjunction and disjunction with Church encoding, rather than have data types as a distinct primitive. (e.g. System F)</p>\n</blockquote>\n<p>Actually, as far as I know, even in intuitionistic logic conjunction and disjunction cannot be fully defined in terms of implication alone, you need second order quantification.  That is, System F (or calculi with higher order quantification) is the only example of \"other lambda calculi\" you mention.  For example, in the simply-typed <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus, there's no way of defining <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\times B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> in terms of the arrow alone so that, say, the first projection gets type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A\\times B\\to A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>.</p>\n<p>That being said, something similar holds in linear logic: multiplicative conjunction and second order existential quantification are definable in terms of linear implication and second order universal quantification (the definitions are essentially identical to the standard ones of intuitionistic logic, you just trade intuitionistic implication for linear implication):<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>B</mi><mtext> </mtext><mo>:</mo><mo>=</mo><mtext> </mtext><mi mathvariant=\"normal\">∀</mi><mi>X</mi><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo>⊸</mo><mi>B</mi><mo>⊸</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>⊸</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">A\\otimes B\\ :=\\ \\forall X.(A\\multimap B\\multimap X)\\multimap  X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span><br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mtext> </mtext><mo>:</mo><mo>=</mo><mtext> </mtext><mi mathvariant=\"normal\">∀</mi><mi>X</mi><mi mathvariant=\"normal\">.</mi><mi>X</mi><mo>⊸</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">1\\ :=\\ \\forall X.X\\multimap X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span><br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∃</mi><mi>X</mi><mi mathvariant=\"normal\">.</mi><mi>A</mi><mtext> </mtext><mo>:</mo><mo>=</mo><mtext> </mtext><mi mathvariant=\"normal\">∀</mi><mi>Y</mi><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>X</mi><mi mathvariant=\"normal\">.</mi><mi>A</mi><mo>⊸</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo>⊸</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">\\exists X.A\\ :=\\ \\forall Y.(\\forall X.A\\multimap Y)\\multimap Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span></p>\n<p>Then, in order to define additive conjunction and additive disjunction, you need the exponential modality (which, of course, is not itself definable):<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo mathvariant=\"normal\">&amp;</mo><mi>B</mi><mtext> </mtext><mo>:</mo><mo>=</mo><mtext> </mtext><mi mathvariant=\"normal\">∃</mi><mi>X</mi><mi mathvariant=\"normal\">.</mi><mo><mo stretchy=\"false\">!</mo></mo><mo stretchy=\"false\">(</mo><mi>X</mi><mo>⊸</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mo><mo stretchy=\"false\">!</mo></mo><mo stretchy=\"false\">(</mo><mi>X</mi><mo>⊸</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">A \\mathrel{\\&amp;} B\\ :=\\ \\exists X.\\mathop !(X\\multimap A)\\otimes\\mathop !(X\\multimap B)\\otimes X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mord\">&amp;</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">.</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\" style=\"position:relative;top:0.09721999999999997em;\">!</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\" style=\"position:relative;top:0.09721999999999997em;\">!</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span><br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">⊤</mi><mtext> </mtext><mo>:</mo><mo>=</mo><mtext> </mtext><mi mathvariant=\"normal\">∃</mi><mi>X</mi><mi mathvariant=\"normal\">.</mi><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">\\top\\ :=\\ \\exists X.X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">⊤</span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span><br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊕</mo><mi>B</mi><mtext> </mtext><mo>:</mo><mo>=</mo><mtext> </mtext><mi mathvariant=\"normal\">∀</mi><mi>X</mi><mi mathvariant=\"normal\">.</mi><mo><mo stretchy=\"false\">!</mo></mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo>⊸</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>⊸</mo><mo><mo stretchy=\"false\">!</mo></mo><mo stretchy=\"false\">(</mo><mi>B</mi><mo>⊸</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>⊸</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">A\\oplus B\\ :=\\ \\forall X.\\mathop !(A\\multimap X)\\multimap\\mathop !(B\\multimap X)\\multimap X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">.</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\" style=\"position:relative;top:0.09721999999999997em;\">!</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\" style=\"position:relative;top:0.09721999999999997em;\">!</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span><br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mtext> </mtext><mo>:</mo><mo>=</mo><mtext> </mtext><mi mathvariant=\"normal\">∀</mi><mi>X</mi><mi mathvariant=\"normal\">.</mi><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">0\\ :=\\ \\forall X.X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span></p>\n<p>Defining multiplicative disjunction in terms of linear implication is either trivial in the classical case (they are the same connective up to a negation), or does not make sense in the intuitionistic case (the par connective needs more than one formula on the right hand side of sequents to be meaningful).</p>",
        "id": 251194464,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1630309492
    },
    {
        "content": "<p>Of course, in the classical case you can also define multiplicative conjunction from implication and negation:<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>B</mi><mo><mi mathvariant=\"normal\">≔</mi></mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo>⊸</mo><msup><mi>B</mi><mo>⊥</mo></msup><msup><mo stretchy=\"false\">)</mo><mo>⊥</mo></msup></mrow><annotation encoding=\"application/x-tex\">A\\otimes B \\coloneqq (A \\multimap B^\\perp)^\\perp</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mop\" style=\"position:relative;top:-0.03472em;\">:</span></span><span class=\"mrel\"><span class=\"mspace\" style=\"margin-right:-0.06666666666666667em;\"></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.099108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mrel mtight\">⊥</span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mrel mtight\">⊥</span></span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 251227090,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630329339
    },
    {
        "content": "<p>But NO! in Intuitionistic Logic conjunction, disjunction and implication are ALL independent connectives. In classical logic yes, you can define everything in terms of implication, but not in intuitionistic logic. so  if you have propositional quantification as in system F then the Russell-Prawitz translation works, but not with simple types. </p>\n<p>and yes you can have a linear logic formulation that thinks of lambda as the main operation in FILL [Full Intuitionistic Linear Logic] (<a href=\"http://tinyurl.com/59bpj5ec\">tinyurl.com/59bpj5ec</a>)</p>",
        "id": 251245910,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630336966
    },
    {
        "content": "<blockquote>\n<p>(the par connective needs more than one formula on the right hand side of sequents to be meaningful).</p>\n</blockquote>\n<p>is not true.  You can have multiple conclusion intuitionistic logic (FIL)  and multiple conclusion intuitionistic linear logic!</p>",
        "id": 251246455,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630337194
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276656\">Valeria de Paiva</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/treating.20implication.20as.20fundamental.20in.20linear.20logic/near/251246455\">said</a>:</p>\n<blockquote>\n<p>You can have multiple conclusion intuitionistic logic (FIL)  and multiple conclusion intuitionistic linear logic!</p>\n</blockquote>\n<p>Ha, that's something completely new to me!  Thank you.  The question then would be whether there is a second order definition of the par connective in FILL using only linear implication...</p>",
        "id": 251260993,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1630343339
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276839\">Damiano Mazza</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/treating.20implication.20as.20fundamental.20in.20linear.20logic/near/251194464\">said</a>:</p>\n<blockquote>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo mathvariant=\"normal\">&amp;</mo><mi>B</mi><mtext> </mtext><mo>:</mo><mo>=</mo><mtext> </mtext><mi mathvariant=\"normal\">∃</mi><mi>X</mi><mi mathvariant=\"normal\">.</mi><mo><mo stretchy=\"false\">!</mo></mo><mo stretchy=\"false\">(</mo><mi>X</mi><mo>⊸</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mo><mo stretchy=\"false\">!</mo></mo><mo stretchy=\"false\">(</mo><mi>X</mi><mo>⊸</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">A \\mathrel{\\&amp;} B\\ :=\\ \\exists X.\\mathop !(X\\multimap A)\\otimes\\mathop !(X\\multimap B)\\otimes X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mord\">&amp;</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">.</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\" style=\"position:relative;top:0.09721999999999997em;\">!</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\" style=\"position:relative;top:0.09721999999999997em;\">!</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span></p>\n</blockquote>\n<p>Ah, thanks! That's what I was looking for, that makes sense! Thanks all for all the other comments as well.</p>\n<p>(Ultimately the reason I wanted to know this is because my programmer brain is reliant on understanding logic through computation, so an encoding of linear logic into some lambda calculus helps me understand. And, indeed, this makes alternative conjunction much clearer to me, since now I can see how you'd write a lambda calculus term for it!)</p>",
        "id": 251278015,
        "sender_full_name": "Spencer Baugh",
        "timestamp": 1630350293
    },
    {
        "content": "<p>It may help to notice that Church encodings (or whatever they're called these days) arise as transcriptions of pattern-matching eliminators. For example, in system F, we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>+</mo><mi>B</mi><mo><mi mathvariant=\"normal\">≔</mi></mo><mi mathvariant=\"normal\">∀</mi><mi>X</mi><mi mathvariant=\"normal\">.</mi><mtext> </mtext><mo stretchy=\"false\">(</mo><mi>A</mi><mo>→</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mo stretchy=\"false\">(</mo><mi>B</mi><mo>→</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">A + B \\coloneqq \\forall X.~(A \\to X) \\to (B \\to X) \\to X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mop\" style=\"position:relative;top:-0.03472em;\">:</span></span><span class=\"mrel\"><span class=\"mspace\" style=\"margin-right:-0.06666666666666667em;\"></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">.</span><span class=\"mspace nobreak\"> </span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>. When using the encoded <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>+</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A + B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, we give the result type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> of the <em>case</em> expression and the two branches/continuations for handling <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>- and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>-values. As such, it's clearer how to encode type formers with pattern-matching eliminators (called <em>positive</em> when talking about polarity, with other type formers, like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊸</mo></mrow><annotation encoding=\"application/x-tex\">\\multimap</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.54986em;vertical-align:0em;\"></span><span class=\"mrel amsrm\">⊸</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">&amp;</mi></mrow><annotation encoding=\"application/x-tex\">\\&amp;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">&amp;</span></span></span></span>, called <em>negative</em>).</p>\n<p>By fluke, every propositional intuitionistic type former we care about other than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>→</mo></mrow><annotation encoding=\"application/x-tex\">\\to</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">→</span></span></span></span> is equivalent to a positive type former, so just functions are good enough to make encodings (in particular, positive and negative products are equivalent thanks to arbitrary deletion and duplication). An alternative approach in a linear setting would be to afford yourself all of the standard negative type formers, and encode the positive ones. This gives encodings like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊕</mo><mi>B</mi><mo><mi mathvariant=\"normal\">≔</mi></mo><mi mathvariant=\"normal\">∀</mi><mi>X</mi><mi mathvariant=\"normal\">.</mi><mtext> </mtext><mo stretchy=\"false\">(</mo><mi>A</mi><mo>⊸</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mtext> </mtext><mi mathvariant=\"normal\">&amp;</mi><mtext> </mtext><mo stretchy=\"false\">(</mo><mi>B</mi><mo>⊸</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>⊸</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">A \\oplus B \\coloneqq \\forall X.~(A \\multimap X)\\ \\&amp;\\ (B \\multimap X) \\multimap X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mop\" style=\"position:relative;top:-0.03472em;\">:</span></span><span class=\"mrel\"><span class=\"mspace\" style=\"margin-right:-0.06666666666666667em;\"></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">.</span><span class=\"mspace nobreak\"> </span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\"> </span><span class=\"mord\">&amp;</span><span class=\"mspace\"> </span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⊸</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, which are a tighter fit to the usual eliminators and avoid <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">!</mo></mrow><annotation encoding=\"application/x-tex\">!</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mclose\">!</span></span></span></span>.</p>",
        "id": 251408289,
        "sender_full_name": "James Wood",
        "timestamp": 1630425066
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281583\">James Wood</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/treating.20implication.20as.20fundamental.20in.20linear.20logic/near/251408289\">said</a>:</p>\n<blockquote>\n<p>It may help to notice that Church encodings (or whatever they're called these days) </p>\n</blockquote>\n<p>I learned about the encodings in Peter Aczel's \"The Russell-Prawitz Modality\" 1999 (<a href=\"http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=9FA745910624425FE262012EE70607FD?doi=10.1.1.39.5294&amp;rep=rep1&amp;type=pdf\">http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=9FA745910624425FE262012EE70607FD?doi=10.1.1.39.5294&amp;rep=rep1&amp;type=pdf</a>) so maybe my notation is outdated. just pointing it out to make sure we're talking about the same encodings.</p>",
        "id": 251411846,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1630426204
    }
]