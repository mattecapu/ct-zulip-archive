[
    {
        "content": "<p>I've noticed that you can define least and greatest fixpoints in linear logic in terms of the exponentials:</p>\n<div class=\"codehilite\"><pre><span></span><code>μα.F[α] = ∀α. α ⅋ ?(¬α ⊗ F[α])\nνα.F[α] = ∃α. α ⊗ !(¬α ⅋ F[α])\n</code></pre></div>\n<p>For instance, <code>Nat</code> can be defined as:</p>\n<div class=\"codehilite\"><pre><span></span><code>Nat\n    = μα.(1 + α)\n    = ∀α. α ⅋ ?(¬α ⊗ (1 + α))\n</code></pre></div>\n<p>This is probably easier to see if you look at its dual:</p>\n<div class=\"codehilite\"><pre><span></span><code>¬Nat\n    = να.(⊥ &amp; α)\n    = ∃α. α ⊗ !(¬α ⅋ (⊥ &amp; α))\n</code></pre></div>\n<p>To eliminate this you need to eliminate the <code>α</code> which you can only do by calling the function <code>¬α ⅋ (⊥ &amp; α)</code>. You then have a choice of stopping by taking the <code>⊥</code> or repeating by taking the <code>α</code> which you then have to put back into the function again. In other words you eliminate <code>¬Nat</code> by feeding it a <code>Nat</code>.</p>\n<p><code>μ</code> and <code>ν</code> types behave like additive connectives - you match on an inductive type by giving it a generator which folds over the tree, and you match on a generator by giving it a tree representing the path to take through the generator. They also have the property that:</p>\n<div class=\"codehilite\"><pre><span></span><code>μα.α = 0\nνα.α = ⊤\n</code></pre></div>\n<p>I feel like maybe there should be two more fixpoint-like type constructors which behave like multiplicative connectives. If we call them <code>φ</code> and <code>ψ</code>, these would have the property that:</p>\n<div class=\"codehilite\"><pre><span></span><code>φα.α = ⊥\nψα.α = 1\n</code></pre></div>\n<p>The intro rules for these types would have to mirror each other such that the pattern syntax for <code>φ</code> would be the term syntax for <code>ψ</code> and vice-versa.</p>\n<p>Does anyone know what these fixpoints could be? Is there any other way to define the \"fixpoint\" of a functor in linear logic such that you get these properties? I'm interested in this because trees and generators seem like pretty essential features of a programming language, and they also (kind-of) generalise <code>!</code> and <code>?</code>. I'm trying to design a programming language based on linear logic and I'm considering having <code>μ</code> and <code>ν</code> types instead of or in addition to <code>!</code> and <code>?</code>. But there's still a lack of expressivity that I'm trying to plug by looking for symmetries. Since <code>μ</code> and <code>ν</code> can be defined in terms of <code>!</code> and <code>?</code>, maybe <code>φ</code> and <code>ψ</code> can be defined in terms of <code>¡</code> and <code>¿</code>? Or not. I'm really clutching at straws here.  Any feedback would be appreciated :)</p>",
        "id": 215943814,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1604736091
    },
    {
        "content": "<p>these are gonna be church encodings right?</p>",
        "id": 215944397,
        "sender_full_name": "sarahzrf",
        "timestamp": 1604737322
    },
    {
        "content": "<p>Hmm, how do you mean? I'm trying to design a language around linear logic which I talk about a bit in my previous post <a href=\"#narrow/stream/233104-theory.3A-logic/topic/Exponential.20Modalities.20in.20Linear.20Logic.20.2F.20Type.20Theory\">here</a>. I'm not sure how or if it's possible to reduce this language to vanilla lambda calculus though.</p>",
        "id": 215944790,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1604738099
    },
    {
        "content": "<p>I concur with <span class=\"user-mention\" data-user-id=\"276072\">@sarahzrf</span> that it looks like a form of church encoding, and I think a variant <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>=</mo><mi mathvariant=\"normal\">∀</mi><mi>α</mi><mo separator=\"true\">,</mo><mi>α</mi><mo>→</mo><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">(</mo><mi>α</mi><mo>→</mo><mi>α</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N} = \\forall \\alpha, \\alpha \\to !(\\alpha \\to \\alpha) \\to \\alpha</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mclose\">!</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> is mentioned in Girard's original article on linear logic as a way to encode natural numbers (and further detailed later in the articles about light linear logics where this encoding crucially needs to be refined). Though you might have less negations in the way..</p>\n<p>You might be interested in <a href=\"https://perso.ens-lyon.fr/amina.doumane/these.pdf\">this outstanding PhD thesis</a> by Amina Doumane exploring in depth how to add primitively least and greatest fixpoints to linear logic.</p>",
        "id": 215946334,
        "sender_full_name": "Kenji Maillard",
        "timestamp": 1604741149
    },
    {
        "content": "<p>Notice that <code>∀α. α ⅋ ?(¬α ⊗ F[α])</code> is the same as <code>∀α. !(F[α] ⊸ α) ⊸ α</code>, which looks about right.</p>",
        "id": 215951588,
        "sender_full_name": "James Wood",
        "timestamp": 1604749871
    }
]