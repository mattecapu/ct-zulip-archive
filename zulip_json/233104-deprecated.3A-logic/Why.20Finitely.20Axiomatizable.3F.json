[
    {
        "content": "<p>I've been coming across a lot of papers concerned with the existence (or more commonly non-existence) of finite axiom schemes for this or that. I'm pretty puzzled by the whole thing. Does anyone know where this idea comes from? Do finitely axiomatiazble theories enjoy some extremely nice property?</p>",
        "id": 202780871,
        "sender_full_name": "Chad Nester",
        "timestamp": 1593766022
    },
    {
        "content": "<p>In particular (and in contrast), it feels like \"decidably axiomatizable\" is the natural thing to want to be.</p>",
        "id": 202781026,
        "sender_full_name": "Chad Nester",
        "timestamp": 1593766136
    },
    {
        "content": "<p>There are certainly some special things you can do with finitely axiomatizable theories - e.g. if you have axioms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><msub><mi>t</mi><mn>3</mn></msub><mo separator=\"true\">,</mo><msub><mi>t</mi><mn>4</mn></msub></mrow><annotation encoding=\"application/x-tex\">t_1, t_2, t_3, t_4</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.80952em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> for the theory of groups then you can axiomatize \"not a group\" as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>t</mi><mn>2</mn></msub><mo>∧</mo><msub><mi>t</mi><mn>3</mn></msub><mo>∧</mo><msub><mi>t</mi><mn>4</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\neg (t_1 \\wedge t_2 \\wedge t_3 \\wedge t_4)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">¬</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76508em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76508em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, which doesn't work if you only have an infinite axiomatization.</p>\n<p>Though I'm not a logician, so I don't know if that sort of thing is actually the reason people care</p>",
        "id": 202788561,
        "sender_full_name": "Thomas Read",
        "timestamp": 1593771672
    },
    {
        "content": "<p>Is there a significant difference between finitely axiomatisable and, say, recursively enumerably axiomatisable, in practice? Both describe representability properties by \"finite descriptions\" in some sense. I understand that when logicians talk about axiomatisability, they usually mean in (some fragment of) first-order logic, but this seems quite arbitrary. If you're willing to use a different metalogic, you could reasonably axiomatise a Turing machine first, then its program, to axiomatise any RE scheme finitely. (I suppose this is saying that I agree that I don't see that \"finite axiomatisation in FOL should be considered particularly interesting as a global property of a formal system\", though finite presentability in some suitable metalogic does seem reasonable for practical purposes, e.g. implementation.)</p>",
        "id": 202790841,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1593773525
    },
    {
        "content": "<p>Finitely axiomatizable theories in classical FO logic enjoy some nice properties due to compactness, if that helps. The property Thomas pointed out is a nice example.</p>",
        "id": 202793732,
        "sender_full_name": "vikraman",
        "timestamp": 1593775747
    },
    {
        "content": "<p>Ah so compactness says something like \"If a theory can be presented as a (possibly infinite) union of finite theories, each of which has a model, then it too has a model\" ?</p>",
        "id": 202808207,
        "sender_full_name": "Chad Nester",
        "timestamp": 1593785940
    },
    {
        "content": "<p>I guess that's pretty good motivation</p>",
        "id": 202808287,
        "sender_full_name": "Chad Nester",
        "timestamp": 1593785993
    },
    {
        "content": "<p>Is there any way to reformulate Peano arithmetic using finitely many axioms?   This system, with its usual axiom schema for induction, is a great example of a decidably but not finitely axiomatized system.</p>",
        "id": 202827535,
        "sender_full_name": "John Baez",
        "timestamp": 1593800264
    },
    {
        "content": "<p>Is that the technical distinction, though? Sometimes it only matters if you have finitely many schemata.</p>",
        "id": 202830796,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593803766
    },
    {
        "content": "<p>Like, a uniform schema might be different than an enumerable sequence of non-uniform axioms.</p>",
        "id": 202830887,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593803889
    },
    {
        "content": "<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> is any <em>finite</em> subsystem of Peano Arithmetic (i.e. set of provable formulas in PA), then PA can prove the consistency of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span>. By Gödel's second incompleteness theorem, PA cannot prove its own consistency, so it is <em>not</em> finitely axiomatizable (at least not in usual first-order logic).</p>\n<p>The above is a consequence of Kreisel's reflection schema: for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> a finite subsystem of PA, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> is a formula, there is a proof in PA of \"if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> is provable from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> is true\". I learned this from Girard's <em>The Blind Spot</em> (Section 3.B.4); the reference (that I never looked at) seems to be a 1968 paper by Kreisel and Levy.</p>",
        "id": 202831007,
        "sender_full_name": "Lê Thành Dũng (Tito) Nguyễn",
        "timestamp": 1593804046
    },
    {
        "content": "<p>Nice, thanks - that's great!  I didn't know this stuff.</p>",
        "id": 202831057,
        "sender_full_name": "John Baez",
        "timestamp": 1593804112
    },
    {
        "content": "<p>It reminds me of how there's an end run around Tarski's undefinability of truth: there's a truth predicate for statements with at most <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> quantifiers!  I still don't understand how that works.</p>",
        "id": 202831124,
        "sender_full_name": "John Baez",
        "timestamp": 1593804168
    },
    {
        "content": "<p>It's making me think some of these classic negative results are less severe than I'd thought.</p>",
        "id": 202831147,
        "sender_full_name": "John Baez",
        "timestamp": 1593804204
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/Why.20Finitely.20Axiomatizable.3F/near/202831124\">said</a>:</p>\n<blockquote>\n<p>It reminds me of how there's an end run around Tarski's undefinability of truth: there's a truth predicate for statements with at most <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> quantifiers!  I still don't understand how that works.</p>\n</blockquote>\n<p>I'd treat this as analogous to the fact that (at least classically) there is a program that decides the halting problem for programs of length at most <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>. The negative result  still has teeth: there is no way to describe these programs uniformly as a function of n, lest you solve the halting problem itself. I'd expect that something similar holds for these restricted truth predicates.</p>",
        "id": 202833120,
        "sender_full_name": "Martti Karvonen",
        "timestamp": 1593806062
    },
    {
        "content": "<p>Interesting!  How do you decide the halting problem for programs of length at most n?   I don't see how to do it in general except by running the program and waiting for it to halt, but that's only a \"semi-decision\" procedure: I don't know how long to wait before I say it won't halt.</p>",
        "id": 202833534,
        "sender_full_name": "John Baez",
        "timestamp": 1593806521
    },
    {
        "content": "<p>The argument I had in mind is not constructive: any finite set is decidable by a program that has that particular set hard-coded into it. The set of programs of length at most n that halt is finite.  Concretely, for any subset of  programs of length <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">&lt;n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> there is a program that accepts exactly that subset.  One of these will be the correct one, but I don't know which.</p>",
        "id": 202835362,
        "sender_full_name": "Martti Karvonen",
        "timestamp": 1593808447
    },
    {
        "content": "<p>I guess the same idea gives a recipe for the restricted truth predicates: given a subset of formulas of length at most n, there is a formula that describes exactly (the codes) of these. One such formula will be a truth predicate for formulas of length at most n.</p>",
        "id": 202835691,
        "sender_full_name": "Martti Karvonen",
        "timestamp": 1593808894
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277285\">Martti Karvonen</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/Why.20Finitely.20Axiomatizable.3F/near/202835362\">said</a>:</p>\n<blockquote>\n<p>The argument I had in mind is not constructive: any finite set is decidable by a program that has that particular set hard-coded into it. The set of programs of length at most n that halt is finite.  Concretely, for any subset of  programs of length <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">&lt;n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> there is a program that accepts exactly that subset.  One of these will be the correct one, but I don't know which.</p>\n</blockquote>\n<p>So it is the nonconstructiveness that forces the general case to not be uniform?</p>",
        "id": 202835880,
        "sender_full_name": "Cole Comfort",
        "timestamp": 1593809116
    },
    {
        "content": "<p>I don't think you can make the argument work this way; the thing with the result John mentioned is that you can actually have a truth predicate for an arbitrary big formula once you fix the number of quantifier alternations (typically, the truth predicate for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"normal\">Σ</mi><mn>1</mn><mn>0</mn></msubsup></mrow><annotation encoding=\"application/x-tex\">\\Sigma^0_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0622159999999998em;vertical-align:-0.24810799999999997em;\"></span><span class=\"mord\"><span class=\"mord\">Σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span></span></span></span> gives you a formula that can tell you if the Turing Machine number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> halts or not).</p>",
        "id": 202836024,
        "sender_full_name": "zigzag",
        "timestamp": 1593809310
    },
    {
        "content": "<p>Oops you're right, my reply gives a predicate  just for formulas of length at most n, whereas John was talking about formulas with at most n quantifiers. I don't know what the trick for that is.</p>",
        "id": 202836071,
        "sender_full_name": "Martti Karvonen",
        "timestamp": 1593809393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277391\">Cole Comfort</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/Why.20Finitely.20Axiomatizable.3F/near/202835880\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"277285\">Martti Karvonen</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/Why.20Finitely.20Axiomatizable.3F/near/202835362\">said</a>:</p>\n<blockquote>\n<p>The argument I had in mind is not constructive: any finite set is decidable by a program that has that particular set hard-coded into it. The set of programs of length at most n that halt is finite.  Concretely, for any subset of  programs of length <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">&lt;n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> there is a program that accepts exactly that subset.  One of these will be the correct one, but I don't know which.</p>\n</blockquote>\n<p>So it is the nonconstructiveness that forces the general case to not be uniform?</p>\n</blockquote>\n<p>The general case is not uniform because halting problem is undecidable: if I had a an algorithm that, given n, outputs the code for the program that decides the halting problem for programs of length at most n, I could solve the halting problem as well. I didn't have a particular precise definition of \"uniform\" in mind, but I'm tempted to say that a uniform description of these programs would let you extract the correct program for any n.</p>",
        "id": 202836198,
        "sender_full_name": "Martti Karvonen",
        "timestamp": 1593809549
    },
    {
        "content": "<p>The jist of the argument as I would imagine it goes is saying that any formula with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> quantifier alternations can be rewritten in prenex form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><msub><mi>k</mi><mn>1</mn></msub><mo>…</mo><mi>Q</mi><msub><mi>k</mi><mi>n</mi></msub><mtext>  </mtext><mi>δ</mi><mo stretchy=\"false\">(</mo><msub><mi>k</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>k</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall k_1 \\ldots Q k_n \\; \\delta(k_1, \\ldots,k_n)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">Q</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03785em;\">δ</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>δ</mi></mrow><annotation encoding=\"application/x-tex\">\\delta</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03785em;\">δ</span></span></span></span> is simple (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"normal\">Δ</mi><mn>1</mn><mn>0</mn></msubsup></mrow><annotation encoding=\"application/x-tex\">\\Delta^0_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0622159999999998em;vertical-align:-0.24810799999999997em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span></span></span></span>). This is a primitive recursive procedure (let's call it <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>x</mi><mi>i</mi><mi>f</mi><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">prenexify</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span> that you can formalize in arithmetics. Then, if you have a truth predicate <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>r</mi><mi>u</mi><mi>t</mi><mi>h</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo stretchy=\"false\">(</mo><mi>δ</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Truth(code(\\delta))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">h</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\">e</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03785em;\">δ</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> for the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"normal\">Δ</mi><mn>1</mn><mn>0</mn></msubsup></mrow><annotation encoding=\"application/x-tex\">\\Delta^0_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0622159999999998em;vertical-align:-0.24810799999999997em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span></span></span></span> fragment, a general truth predicate for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"normal\">Σ</mi><mi>n</mi><mn>0</mn></msubsup></mrow><annotation encoding=\"application/x-tex\">\\Sigma^0_n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.061108em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord\">Σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><msub><mi>k</mi><mn>1</mn></msub><mo>…</mo><mi>Q</mi><mtext>  </mtext><msub><mi>k</mi><mi>n</mi></msub><mtext>  </mtext><mi>T</mi><mi>r</mi><mi>u</mi><mi>t</mi><mi>h</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>p</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>x</mi><mi>i</mi><mi>f</mi><mi>y</mi><mo stretchy=\"false\">(</mo><mi>φ</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><msub><mi>k</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>k</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall k_1 \\ldots Q \\; k_n \\; Truth(code((prenexify(\\varphi)(k_1, \\ldots, k_n)))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">Q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">h</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\">e</span><span class=\"mopen\">(</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">φ</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span></p>\n<p>Sorry if this is a bit jargony; I think the basic idea is that, once you do the base case (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"normal\">Δ</mi><mn>1</mn><mn>0</mn></msubsup></mrow><annotation encoding=\"application/x-tex\">\\Delta^0_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0622159999999998em;vertical-align:-0.24810799999999997em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span></span></span></span>) which involves already a bit of annoying tinkering with Gödel numberings/formalization of computable functions in arithmetic, generalizing to the case with many quantifier alternations is not too big of a leap (in particular, the number of additional quantifiers that one needs to go from case <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n+1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> should be 1)</p>",
        "id": 202836818,
        "sender_full_name": "zigzag",
        "timestamp": 1593810310
    },
    {
        "content": "<p>Here's a description of the argument as Michael Weiss gave it:</p>\n<ul>\n<li><a href=\"https://diagonalargument.com/2019/09/22/non-standard-models-of-arithmetic-7/\">Nonstandard models of arithmetic 13</a>.</li>\n</ul>\n<p>Start where he says \"As Tarski taught us, truth is undefinable...\"</p>\n<p>The good explanation comes after I say \"First of all, what’s this about sneaking around Tarski’s theorem on the undefinability of truth by restricting to sentences with at most d quantifiers? How come nobody ever told me about this? It seems like such cheap dodge.\"</p>",
        "id": 202836875,
        "sender_full_name": "John Baez",
        "timestamp": 1593810373
    },
    {
        "content": "<p>(also now that I think about it, I don't know how this plays out in intuitionistic arithmetic)</p>",
        "id": 202836890,
        "sender_full_name": "zigzag",
        "timestamp": 1593810403
    },
    {
        "content": "<p>I need to reread what Michael wrote, but I think he gives a decent sketch of what's going on without sinking into too much details.</p>\n<p>It's all for classical logic, though!</p>",
        "id": 202837286,
        "sender_full_name": "John Baez",
        "timestamp": 1593810846
    },
    {
        "content": "<p>Yeah that's interesting, and it's not that analogous to what I said above: the fact that the halting problem is decidable for programs of a bounded size does not really help with the negative result as the proof doesn't tell us what the correct programs are, whereas here one can write down explicitly the restricted truth predicates.</p>",
        "id": 202838169,
        "sender_full_name": "Martti Karvonen",
        "timestamp": 1593812097
    },
    {
        "content": "<p>Yes, thanks for explaining why the halting problem is decidable for programs of a bounded size.  This is a dirty trick, sort of like those cons where you fool people into thinking you can predict the stock market by starting with 1024 people and emailing them 10 times predicting whether some stock will go up or down the next day.    You can make sure one of them will get all correct predictions.</p>",
        "id": 202838409,
        "sender_full_name": "John Baez",
        "timestamp": 1593812473
    },
    {
        "content": "<p>A result in similar spirit is the non-constructive proof that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant=\"double-struck\">N</mi><mo>→</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">f:\\mathbb{N}\\to\\mathbb{N}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span> defined by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable columnalign=\"left left\" columnspacing=\"1em\" rowspacing=\"0.3599999999999999em\"><mtr><mtd><mstyle displaystyle=\"false\" scriptlevel=\"0\"><mn>1</mn></mstyle></mtd><mtd><mstyle displaystyle=\"false\" scriptlevel=\"0\"><mrow><mtext> if </mtext><mi>π</mi><mtext> contains n consecutive 7s</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle displaystyle=\"false\" scriptlevel=\"0\"><mn>0</mn></mstyle></mtd><mtd><mstyle displaystyle=\"false\" scriptlevel=\"0\"><mtext>otherwise.</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">f(n)=\\begin{cases}1 &amp;\\text{ if }\\pi\\text{ contains n consecutive 7s}\\\\0 &amp;\\text{otherwise.} \\end{cases}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3.0000299999999998em;vertical-align:-1.25003em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">{</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\"> if </span></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span><span class=\"mord text\"><span class=\"mord\"> contains n consecutive 7s</span></span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">otherwise.</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> <br>\nis computable. Either <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span></span></span></span> has arbitrarily long sequences of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">7</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span> in which case we have a constant function (certainly computable), or we have a function that is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> until some fixed threshold and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> afterwards - and these are all computable as well. I vaguely remember someone quipping that in the \"real world\" saying that \"I have a proof that the correct program is one of these but I don't know which one\"  won't quite cut it.</p>",
        "id": 202839010,
        "sender_full_name": "Martti Karvonen",
        "timestamp": 1593813416
    },
    {
        "content": "<p>Yes. That is a good example of why excluded middle is wrong. :)</p>",
        "id": 202839254,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593813768
    },
    {
        "content": "<p>I knew about these dirty tricks but I didn't notice (or forgot) that in theory you can use them to decide the halting program for the first googol Turing machines.</p>",
        "id": 202839272,
        "sender_full_name": "John Baez",
        "timestamp": 1593813824
    },
    {
        "content": "<p>\"I can do it, just don't ask me to do it.\"</p>",
        "id": 202839307,
        "sender_full_name": "John Baez",
        "timestamp": 1593813843
    },
    {
        "content": "<p>Or: \"there exists someone who can do it, just don't ask me who.\"</p>",
        "id": 202839327,
        "sender_full_name": "John Baez",
        "timestamp": 1593813874
    },
    {
        "content": "<p>So this result seems useless (though good to know), while the end run around Tarski's undefinability of truth seems potentially useful to me.</p>",
        "id": 202839408,
        "sender_full_name": "John Baez",
        "timestamp": 1593813996
    },
    {
        "content": "<p>Useful in theoretical ways, that is.</p>",
        "id": 202839436,
        "sender_full_name": "John Baez",
        "timestamp": 1593814050
    },
    {
        "content": "<p>There's a possibly related paper by Sergei Artemov about Gödel's incompleteness theorems actually not meaning what most people say they mean (which is also related to some type theory results not meaning what people say they mean, I think).</p>",
        "id": 202839516,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593814106
    },
    {
        "content": "<p>The idea is that the notion of \"consistency\" used in the incompleteness theorems is not actually adequately modeling what people were concerned about with respect to consistency. It requires that consistency would hold in a uniform way in all models, because it quantifies over the internal natural numbers in its definition. But, that is too strong a notion for caring about whether or not people could theoretically deduce a contradiction on paper.</p>",
        "id": 202839660,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593814322
    },
    {
        "content": "<p>I don't get how consistency quantifies over <em>internal</em> natural numbers.</p>",
        "id": 202839712,
        "sender_full_name": "John Baez",
        "timestamp": 1593814406
    },
    {
        "content": "<p>Because it's like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">∃</mi><mi>n</mi><mi mathvariant=\"normal\">.</mi><mrow><mi mathvariant=\"sans-serif\">P</mi><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">v</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">s</mi></mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo separator=\"true\">,</mo><mtext>⊥</mtext><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">¬ ∃ n. \\mathsf{Proves}(n, ⊥)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">¬</span><span class=\"mord\">∃</span><span class=\"mord mathdefault\">n</span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord mathsf\">P</span><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">r</span><span class=\"mord mathsf\">o</span><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">v</span><span class=\"mord mathsf\">e</span><span class=\"mord mathsf\">s</span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">⊥</span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 202839771,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593814470
    },
    {
        "content": "<p>Okay, sure.</p>",
        "id": 202839875,
        "sender_full_name": "John Baez",
        "timestamp": 1593814672
    },
    {
        "content": "<p>Whereas the on-paper version is more like wanting that to be provable for specific numerals, and you can give a meta way of constructing a PA proof of each particular proposition for each numeral, I think.</p>",
        "id": 202839944,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593814770
    },
    {
        "content": "<p>Right.</p>\n<p>I took a long break from my discussion with Michael Weiss on nonstandard natural numbers, but I ought to get back to it because I think there's something really important about this circle of ideas.   We all too easily think the natural numbers are something understood.</p>",
        "id": 202839946,
        "sender_full_name": "John Baez",
        "timestamp": 1593814773
    },
    {
        "content": "<p>The problem is that \"each specific numeral\" doesn't really mean much.  It means 0, S0, SS0, SSS0, .... - but the \"...\" conceals an abyss.</p>",
        "id": 202840012,
        "sender_full_name": "John Baez",
        "timestamp": 1593814847
    },
    {
        "content": "<p>Anyway, I'm not arguing against  Sergei Artemov's point that the usual version of \"consistency\" is sort of weird.  I'm just saying it's dangerous to act like we know what \"all specific numerals\" are.</p>",
        "id": 202840031,
        "sender_full_name": "John Baez",
        "timestamp": 1593814908
    },
    {
        "content": "<p>There's a nice series of papers by V. Sorge, A. Sexton and S. Watt about the uses (and some formalizations) of \"...\" in mathematics.</p>",
        "id": 202840074,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1593814924
    },
    {
        "content": "<p>The type theory version is that people would give 'proofs' that a normalizing language cannot contain a type describing its own terms, and an interpreter from those terms into their actual values in the theory. But then someone did it, and the way that you do not try to code the terms as a single type, like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">N</mi></mrow><annotation encoding=\"application/x-tex\">ℕ</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord amsrm\">N</span></span></span></span>, but have a type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">m</mi></mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Tm} A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">T</span><span class=\"mord mathsf\">m</span></span><span class=\"mord mathdefault\">A</span></span></span></span> of terms of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>.</p>",
        "id": 202840366,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593815327
    },
    {
        "content": "<p>So there were assumptions about how you were allowed to assemble \"a self-interpreter\" that are integral to whether or not it's possible.</p>",
        "id": 202840434,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593815418
    },
    {
        "content": "<p>And I'm extremely proud that \"finally tagless\" played a role in Brown and Palsberg's work. The shift in encoding was a key idea that let them bootstrap things. It helped shift the thinking of how to encode languages in other languages. They then added a bunch of clever, subtle ingredients, and voila! Contradiction to the conventional wisdom. Unlike what most people use tagless for these days, it <em>was</em> designed for partial evaluation.</p>",
        "id": 202840740,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1593815913
    },
    {
        "content": "<p>Anyhow, the point on the math end is, I think, even though \"...\" is a little dicey, don't forget that the problem is what a human being could write in a book, or a computer could do in limited memory. At least, assuming you're attempting to address that problem.</p>",
        "id": 202842070,
        "sender_full_name": "Dan Doel",
        "timestamp": 1593818037
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/Why.20Finitely.20Axiomatizable.3F/near/202827535\">said</a>:</p>\n<blockquote>\n<p>Is there any way to reformulate Peano arithmetic using finitely many axioms?   This system, with its usual axiom schema for induction, is a great example of a decidably but not finitely axiomatized system.</p>\n</blockquote>\n<p>I understand people gave you negative answers for this, but there are trivial ways to take <em>any</em> theory, add a finite number of symbols, and make it a finitely axiomatizable theory. Basically you add a 1 parameter predicate symbol for each axiom in an axiom schema, and some axioms to encode its denotation at each instance, e.g. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mi>n</mi><mi>d</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>⇔</mo><mi mathvariant=\"normal\">∀</mi><mi>n</mi><mo separator=\"true\">,</mo><mi>P</mi><mn>0</mn><mo>⇒</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>m</mi><mo separator=\"true\">,</mo><mi>P</mi><mi>m</mi><mo>⇒</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>⇒</mo><mi>P</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">Ind(0) \\Leftrightarrow \\forall n, P 0 \\Rightarrow (\\forall m, P m \\Rightarrow P (m+1)) \\Rightarrow P n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">d</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⇔</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathdefault\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathdefault\">n</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span></span></span></span> is the \"zeroth\" predicate, etc.</p>\n<p>This doesn't contradict the theorem that says PA has no finite axiomatization, since it extends the language.</p>\n<p>I don't think finite axiomatization is all it's chalked up to be. I don't think logicians care much about it anymore.</p>",
        "id": 202851662,
        "sender_full_name": "Cody Roux",
        "timestamp": 1593829121
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276030\">@Cody Roux</span> How would you finitely axiomatize the meaning of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mi>n</mi><mi>d</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Ind(n)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">d</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span> without using an unrestricted truth predicate?</p>",
        "id": 202871530,
        "sender_full_name": "Lê Thành Dũng (Tito) Nguyễn",
        "timestamp": 1593865553
    },
    {
        "content": "<p>I don't quite get the precise scheme Cody has in mind here, but it is possible to finitely axiomatize <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mi>C</mi><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">ACA_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, a conservative extension of PA capturing a subset of second-order arithmetic. The list of axioms (which relies heavily on formalizing basic recursion theory in arithmetic) is mentioned there : <a href=\"https://math.stackexchange.com/questions/955523/finite-list-of-axioms-of-mathsfaca-0-reference\">https://math.stackexchange.com/questions/955523/finite-list-of-axioms-of-mathsfaca-0-reference</a> (there is no cheating by hiding infinitely many instances of the comprehension scheme under the carpet. You can think of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mi>C</mi><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">ACA_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> as a two-sorted first-order logic if you like)</p>\n<p>I don't know of a procedure of the sort Cody alludes to, but I would not be surprised if there was one if we allow for extending the language. IIUC, the purpose of bothering with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mi>C</mi><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">ACA_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and formalizing recursion theory <em>within arithmetic</em> is to study subsystems of second-order arithmetic rather than addressing finite axiomatizability of PA</p>",
        "id": 202874455,
        "sender_full_name": "zigzag",
        "timestamp": 1593870269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277285\">Martti Karvonen</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/Why.20Finitely.20Axiomatizable.3F/near/202835362\">said</a>:</p>\n<blockquote>\n<p>The argument I had in mind is not constructive: any finite set is decidable by a program that has that particular set hard-coded into it. The set of programs of length at most n that halt is finite.  Concretely, for any subset of  programs of length <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">&lt;n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> there is a program that accepts exactly that subset.  One of these will be the correct one, but I don't know which.</p>\n</blockquote>\n<p>A more constructive approach allows us to make some concrete progress on this problem. The idea being that if a program fails to halt, it must do some for some <em>reason</em> (like the program falling into a cycle of states that it can never leave), and for small lengths of program, there are few enough such reasons that they can be manually identified, essentially identifying the bugs in the code. Put this way, the stumbling block becomes Rice's theorem, which says that the identification of bugs is an undecidable problem. We can make some headway, but there is no way to systematically check for all possible bugs.</p>",
        "id": 202876857,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1593874009
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"278835\">Nguyễn Lê Thành Dũng</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/Why.20Finitely.20Axiomatizable.3F/near/202871530\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276030\">Cody Roux</span> How would you finitely axiomatize the meaning of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mi>n</mi><mi>d</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Ind(n)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">d</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span> without using an unrestricted truth predicate?</p>\n</blockquote>\n<p>It's not unrestricted, because the definition of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mi>n</mi><mi>d</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Ind(n)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">d</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span> never refers to itself. Basically you're just encoding some subset of ACA0 in first-order logic.</p>",
        "id": 202878582,
        "sender_full_name": "Cody Roux",
        "timestamp": 1593876708
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276030\">Cody Roux</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/Why.20Finitely.20Axiomatizable.3F/near/202851662\">said</a>:</p>\n<blockquote>\n<p>I understand people gave you negative answers for this, but there are trivial ways to take <em>any</em> theory, add a finite number of symbols, and make it a finitely axiomatizable theory. Basically you add a 1 parameter predicate symbol for each axiom in an axiom schema, and some axioms to encode its denotation at each instance, e.g. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mi>n</mi><mi>d</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>⇔</mo><mi mathvariant=\"normal\">∀</mi><mi>n</mi><mo separator=\"true\">,</mo><mi>P</mi><mn>0</mn><mo>⇒</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>m</mi><mo separator=\"true\">,</mo><mi>P</mi><mi>m</mi><mo>⇒</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>⇒</mo><mi>P</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">Ind(0) \\Leftrightarrow \\forall n, P 0 \\Rightarrow (\\forall m, P m \\Rightarrow P (m+1)) \\Rightarrow P n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">d</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⇔</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathdefault\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathdefault\">n</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span></span></span></span> is the \"zeroth\" predicate, etc.</p>\n<p>This doesn't contradict the theorem that says PA has no finite axiomatization, since it extends the language.</p>\n</blockquote>\n<p>Thanks, this matches my vague memories.  When I learned G&ouml;del's incompleteness theorems they were for recursively axiomatizable theories; lots of people seem to state them for finitely axiomatizable theories, but I got the feeling that the difference was only technical because if something is recursively axiomatizable you can pack the information in those axioms into a finite-sized \"program\" that \"prints out\" those axioms.</p>",
        "id": 202879154,
        "sender_full_name": "John Baez",
        "timestamp": 1593877466
    },
    {
        "content": "<p>Relating to both Schemes and Gödel, there's this paper by a known logican<br>\n<a href=\"https://arxiv.org/pdf/1902.07404.pdf\">https://arxiv.org/pdf/1902.07404.pdf</a><br>\narguing against the conclusion to be drawn from Gödel's lemma on consistency. At the risk of being vague or misunderstanding it, this is saying that the particular notion of consistency used in its formalization shouldn't be seen as a definite one. What can't be proven in PA is that <br>\n\"for all numbers n, the proof encoded by n is not a proof of absurdity\"<br>\nBut in the paper he expresses consistency with a Provability logic modality and argues that what can be proven is<br>\n\"for all numbers n, there's exists a proof that n is not a proof of absurdity\"</p>",
        "id": 203606251,
        "sender_full_name": "Nikolaj Kuntner",
        "timestamp": 1594489437
    },
    {
        "content": "<p>Yeah, that's the paper I was talking about. :)</p>",
        "id": 203606317,
        "sender_full_name": "Dan Doel",
        "timestamp": 1594489514
    },
    {
        "content": "<p>Oh, right you actually even name him on Jul 3rd.</p>",
        "id": 203606400,
        "sender_full_name": "Nikolaj Kuntner",
        "timestamp": 1594489634
    },
    {
        "content": "<p><a href=\"http://compilers.cs.ucla.edu/popl16/popl16-full.pdf\">This</a> is the paper for the programming language analogue I mentioned.</p>",
        "id": 203606548,
        "sender_full_name": "Dan Doel",
        "timestamp": 1594489868
    },
    {
        "content": "<p>The relations between the different varieties of axiomatizability, and their inter-convertibility, were discussed here. <a href=\"https://www.jstor.org/stable/2964289?seq=1\">https://www.jstor.org/stable/2964289?seq=1</a></p>",
        "id": 213857711,
        "sender_full_name": "Lydia Marie Williamson",
        "timestamp": 1603148852
    }
]