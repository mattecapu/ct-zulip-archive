[
    {
        "content": "<p>Hi people. I've got a question about linear logic / type theory:</p>\n<p>Linear logic defines two \"exponential\" type constructors, the \"of course\" modality <code>!P</code> and the \"why not\" modality <code>?P</code>. These can sort-of be defined as:</p>\n<div class=\"codehilite\"><pre><span></span><code>!P ≅ 1 &amp; P &amp; (P ⊗ P) &amp; (P ⊗ P ⊗ P) &amp; ...\n?P ≅ ⊥ + P + (P ⅋ P) + (P ⅋ P ⅋ P) + ...\n</code></pre></div>\n\n\n<p>Except where each <code>(P ⊗ P ⊗ ... )</code> and <code>(P ⅋ P ⅋ ... )</code> is unordered. These have some nice properties where they convert the additive connectives to the multiplicative connectives, hence the term \"exponential\":</p>\n<div class=\"codehilite\"><pre><span></span><code>!⊤ = 1\n!(A &amp; B) = !A ⊗ !B\n\n?0 = ⊥\n?(A + B) = ?A ⅋ ?B\n</code></pre></div>\n\n\n<p>It seems though that you could define two other type constructors, let's denote them <code>¡P</code> and <code>¿P</code>, such that:</p>\n<div class=\"codehilite\"><pre><span></span><code>¡P ≅ 1 + P + (P ⊗ P) + (P ⊗ P ⊗ P) + ...\n¿P ≅ ⊥ &amp; P &amp; (P ⅋ P) &amp; (P ⅋ P ⅋ P) &amp; ...\n</code></pre></div>\n\n\n<p>These would also have exponential-ish properties, similar to those for <code>!P</code> and <code>?P</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>¡0 = 1\n¡(A + B) = ¡A ⊗ ¡B\n\n¿⊤ = ⊥\n¿(A &amp; B) = ¿A ⅋ ¿B\n</code></pre></div>\n\n\n<p><code>¡P</code> can be thought of as being a multiset/bag of values of type <code>P</code>, it's also a monad. I'm not sure how to think of <code>¿P</code> yet but it's definitely a comonad. Since <code>¡⊤</code> is isomorphic to <code>Nat</code>, if you have type-dependency, this could give you a way to define inductive types.</p>\n<p>So I'm wondering why I've never seen these mentioned at all in the literature. Have I just not come across them? Or do they just not turn out to be very interesting on further inspection?</p>",
        "id": 203643561,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1594559913
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"320695\">@Andrew Cann</span>, take a look at page 5 here...<br>\n<a href=\"http://www.math.mcgill.ca/rags/fock/fock.pdf\">http://www.math.mcgill.ca/rags/fock/fock.pdf</a></p>",
        "id": 203650627,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1594571868
    },
    {
        "content": "<p>Ooops, sorry! I was in a hurry and I didn't see that you were asking about ¡P and ¿P...</p>",
        "id": 203652710,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1594574974
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"320695\">Andrew Cann</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/Exponential.20Modalities.20in.20Linear.20Logic.20.2F.20Type.20Theory/near/203643561\">said</a>:</p>\n<blockquote>\n<p>So I'm wondering why I've never seen these mentioned at all in the literature. Have I just not come across them? Or do they just not turn out to be very interesting on further inspection?</p>\n</blockquote>\n<p>I have not seen any investigation of these exponentials you described, but I'm sure you've heard that there are too many possibilities of exponentials, so this is not surprising. Exponentials are not uniquely defined at all. but I cannot see the rationale for these exponentials myself. do you have one, apart from trying out symmetry?</p>",
        "id": 203654123,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1594577093
    },
    {
        "content": "<p>So in the category of sets and relations, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mi>E</mi><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">REL</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathdefault\">L</span></span></span></span>, since <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">&amp;</mi><mo>=</mo><mo>+</mo></mrow><annotation encoding=\"application/x-tex\">\\&amp; = + </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">&amp;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">+</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊗</mo><mo>=</mo><mtext>⅋</mtext></mrow><annotation encoding=\"application/x-tex\">⊗ = ⅋</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0em;vertical-align:0em;\"></span><span class=\"mord\">⅋</span></span></span></span>, it follows that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>¡</mtext><mi>P</mi><mo>=</mo><mo stretchy=\"false\">!</mo><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">¡P=!P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">¡</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mclose\">!</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>¿</mtext><mi>P</mi><mo>=</mo><mo stretchy=\"false\">?</mo><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">¿P = ?P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">¿</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mclose\">?</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span></span></span></span>.</p>",
        "id": 203682683,
        "sender_full_name": "JS PL (he/him)",
        "timestamp": 1594622975
    },
    {
        "content": "<p>The construction you provided of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">!</mo><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">!P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mclose\">!</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span></span></span></span> often (not always!) results in the cofree cocommutative comonoid construction on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding=\"application/x-tex\">⊗</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊗</span></span></span></span>. So the same is true for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>¡</mtext><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">¡P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">¡</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span></span></span></span>. In general, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>¡</mtext><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">¡P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">¡</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span></span></span></span> is the free commutative monoid construction. For example, on the category of vector spaces, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>¡</mtext><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">¡V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">¡</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span></span></span></span> is better known as the free symmetric algebra <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>y</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mi>V</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Sym(V)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathdefault\">m</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mclose\">)</span></span></span></span> over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span></span></span></span>.</p>",
        "id": 203682892,
        "sender_full_name": "JS PL (he/him)",
        "timestamp": 1594623223
    },
    {
        "content": "<p>Same for the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>¿</mtext><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">¿P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">¿</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span></span></span></span> construction, this should be the general construction of the cofree cocommutative comonoid for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>⅋</mtext></mrow><annotation encoding=\"application/x-tex\">⅋</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0em;vertical-align:0em;\"></span><span class=\"mord\">⅋</span></span></span></span>.</p>",
        "id": 203682981,
        "sender_full_name": "JS PL (he/him)",
        "timestamp": 1594623334
    },
    {
        "content": "<p>So <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>¡</mtext></mrow><annotation encoding=\"application/x-tex\">¡</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0em;vertical-align:0em;\"></span><span class=\"mord\">¡</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>¿</mtext></mrow><annotation encoding=\"application/x-tex\">¿</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0em;vertical-align:0em;\"></span><span class=\"mord\">¿</span></span></span></span> provide exponentials on the opposite category.</p>",
        "id": 203683229,
        "sender_full_name": "JS PL (he/him)",
        "timestamp": 1594623640
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276773\">@Eduardo Ochs</span> </p>\n<p><code>¡</code> and <code>¿</code> are just names I made up. If they already have a common meaning that's just an unsurprising coincidence. The paper you linked me seems to be talking about the same thing but it is a bit over my head <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>\n<p><span class=\"user-mention\" data-user-id=\"276656\">@Valeria de Paiva</span></p>\n<blockquote>\n<p>I have not seen any investigation of these exponentials you described, but I'm sure you've heard that there are too many possibilities of exponentials, so this is not surprising.</p>\n</blockquote>\n<p>I'm aware that there's lots of different ways to define the usual <code>!</code> and <code>?</code> exponentials, and that there's a lattice of exponentials generated by <code>!</code> and <code>?</code>. The exponentials I'm talking about are a bit different to <code>!</code> and <code>?</code> though since they convert between the additive and multiplicative groups differently. eg:</p>\n<div class=\"codehilite\"><pre><span></span><code>!⊤ = 1\n?0 = ⊥\n¡0 = 1\n¿⊤ = ⊥\n</code></pre></div>\n\n\n<p>In terms of the above, there only seems to be four different possible exponential operators. (Or maybe it's more correct to say that there's 4 different families of exponential operators, though there might be multiple ways to instantiate each family in any given model of linear logic?). Or I have I misunderstood your comment?</p>\n<blockquote>\n<p>but I cannot see the rationale for these exponentials myself. do you have one, apart from trying out symmetry?</p>\n</blockquote>\n<p>Partly just trying out symmetry. Mainly though because I'm interested in programming language design and <code>¡P</code> seems like it could be practically useful. Having unordered multisets as a primitive type would mean having commutativity built into the language, which would be good for modelling race-free concurrency. For instance, you could allow a bunch of threads to atomically increment some global counter while still having the language enforce race-freedom by construction. Since <code>W</code> types can be defined in terms of <code>Nat</code> it also gives a way to build recursive/inductive types without having to axiomatize them.</p>\n<p><span class=\"user-mention\" data-user-id=\"277105\">@JS Pacaud Lemay</span></p>\n<p>Hmmm. I admit I don't know how to make use of that information. I'm not actually very well-versed on category theory, despite being on this zulip. I'm only here because I don't know where else to ask people these kinds of questions about logic and type theory <span aria-label=\"confused\" class=\"emoji emoji-1f615\" role=\"img\" title=\"confused\">:confused:</span>. Do you have any suggestions?</p>",
        "id": 203707650,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1594642825
    },
    {
        "content": "<p>Right now the main thing I'm interested in is how to define the introduction rules for <code>¿</code>-types, since that would also tell me how to define the eliminator for <code>¡</code>. Though if this whole avenue of investigation is likely to be a dead end that would also be useful to know.</p>",
        "id": 203707934,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1594643022
    },
    {
        "content": "<p>Thanks for the replies by the way everyone! :D</p>",
        "id": 203707941,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1594643035
    },
    {
        "content": "<p>Ah gotcha! I admit I'm a category theory who happens to work with categorical semantics of (differential) linear logic, so my linear logic/programming perspective isn't great! <br>\nBut whenever I have a linear logic question I just email Robert Seely. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 203715391,
        "sender_full_name": "JS PL (he/him)",
        "timestamp": 1594647456
    },
    {
        "content": "<p>If I had to take a stab at it,  I believe the rules for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>¡</mtext></mrow><annotation encoding=\"application/x-tex\">¡</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0em;vertical-align:0em;\"></span><span class=\"mord\">¡</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>¿</mtext></mrow><annotation encoding=\"application/x-tex\">¿</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0em;vertical-align:0em;\"></span><span class=\"mord\">¿</span></span></span></span> would be the dual rules for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">!</mo></mrow><annotation encoding=\"application/x-tex\">!</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mclose\">!</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">?</mo></mrow><annotation encoding=\"application/x-tex\">?</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mclose\">?</span></span></span></span>. </p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mtext>¡</mtext><mi>P</mi><mo>⊢</mo><mi>Q</mi></mrow><mrow><mtext>¡</mtext><mi>P</mi><mo separator=\"true\">,</mo><mtext>¡</mtext><mi>P</mi><mo>⊢</mo><mi>Q</mi></mrow></mfrac><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mfrac><mrow><mtext>¡</mtext><mi>P</mi><mo>⊢</mo><mi>Q</mi></mrow><mrow><mo>⊢</mo><mi>Q</mi></mrow></mfrac><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mfrac><mrow><mtext>¡</mtext><mi>P</mi><mo>⊢</mo><mi>Q</mi></mrow><mrow><mi>P</mi><mo>⊢</mo><mi>Q</mi></mrow></mfrac><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mfrac><mrow><mi>P</mi><mo>⊢</mo><mtext>¡</mtext><mi>Q</mi></mrow><mrow><mtext>¡</mtext><mi>P</mi><mo>⊢</mo><mtext>¡</mtext><mi>Q</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{¡P \\vdash Q}{¡P, ¡P \\vdash Q} \\quad \\quad \\quad \\quad \\frac{¡P \\vdash Q}{ \\vdash Q}  \\quad \\quad \\quad \\quad \\frac{¡P \\vdash Q}{P \\vdash Q} \\quad \\quad \\quad \\quad \\frac{P \\vdash ¡Q}{¡P \\vdash ¡Q} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.25188em;vertical-align:-0.8804400000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714399999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">¡</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">¡</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\">Q</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">¡</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\">Q</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804400000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714399999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\">Q</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">¡</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\">Q</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804400000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714399999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\">Q</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">¡</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\">Q</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804400000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714399999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">¡</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">¡</span><span class=\"mord mathdefault\">Q</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">¡</span><span class=\"mord mathdefault\">Q</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804400000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>P</mi><mo>⊢</mo><mtext>¿</mtext><mi>Q</mi></mrow><mrow><mi>P</mi><mo>⊢</mo><mtext>¿</mtext><mi>Q</mi><mo separator=\"true\">,</mo><mtext>¿</mtext><mi>Q</mi></mrow></mfrac><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mfrac><mrow><mi>P</mi><mo>⊢</mo><mtext>¿</mtext><mi>Q</mi></mrow><mrow><mi>P</mi><mo>⊢</mo></mrow></mfrac><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mfrac><mrow><mi>P</mi><mo>⊢</mo><mtext>¿</mtext><mi>Q</mi></mrow><mrow><mi>P</mi><mo>⊢</mo><mi>Q</mi></mrow></mfrac><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mfrac><mrow><mtext>¿</mtext><mi>P</mi><mo>⊢</mo><mi>Q</mi></mrow><mrow><mtext>¿</mtext><mi>P</mi><mo>⊢</mo><mtext>¿</mtext><mi>Q</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{P \\vdash ¿Q}{P \\vdash ¿Q,¿Q} \\quad \\quad \\quad \\quad \\frac{P \\vdash ¿Q}{P \\vdash }  \\quad \\quad \\quad \\quad \\frac{P \\vdash ¿Q}{P \\vdash Q} \\quad \\quad \\quad \\quad \\frac{¿P \\vdash Q}{¿P \\vdash ¿Q} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.25188em;vertical-align:-0.8804400000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714399999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">¿</span><span class=\"mord mathdefault\">Q</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">¿</span><span class=\"mord mathdefault\">Q</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">¿</span><span class=\"mord mathdefault\">Q</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804400000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714399999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">¿</span><span class=\"mord mathdefault\">Q</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714399999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\">Q</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">¿</span><span class=\"mord mathdefault\">Q</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804400000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714399999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">¿</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">¿</span><span class=\"mord mathdefault\">Q</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">¿</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\">Q</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804400000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>give or take some extra context <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Γ</span></span></span></span>. I derived these from the categorical semantics of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>¡</mtext></mrow><annotation encoding=\"application/x-tex\">¡</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0em;vertical-align:0em;\"></span><span class=\"mord\">¡</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>¿</mtext></mrow><annotation encoding=\"application/x-tex\">¿</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0em;vertical-align:0em;\"></span><span class=\"mord\">¿</span></span></span></span>.</p>",
        "id": 203715825,
        "sender_full_name": "JS PL (he/him)",
        "timestamp": 1594647705
    },
    {
        "content": "<p>Thanks! Those are the rules I had except I hadn't figured out the two on the right yet. They look correct though, so thank you very much for helping me :). Unfortunately though that confirms a fear I had - the elimination rule for <code>¡P</code> only allows you to eliminate into another <code>¡Q</code>. ie. Once you're in the <code>¡</code>-monad there's no way to \"get out\" again. As far as I can tell this makes it impossible to define the usual eliminator for <code>Nat</code> (if <code>Nat</code> is defined to be <code>¡1</code>) to, for instance, define an <code>is_even</code> function <code>is_even : Nat -&gt; 1 + 1</code>.</p>\n<p>I have the dual problem with <code>!</code>-types actually. A language like Rust allows you to take some linear piece of data and temporarily \"lend it out\" through a copyable reference. The references have a lifetime attached to their type which allows the type-checker to ensure that all the references have been released before you re-take unique ownership of the data. With the rules of linear logic though a term of type <code>!P</code> can only be constructed using other terms of type <code>!Q</code>, so there doesn't seem to be any way to model this. That is, there's no way to \"get into\" the <code>!</code>-comonad - you have to start there.</p>\n<p>I don't suppose you're aware of any work-arounds for this? Are there any generalisations of linear logic (eg. with an extra axiom) that allow you to take some non-<code>!</code> variable <code>A</code>, prove that you can use <code>A</code> to generate infinite copies of <code>B</code>, then use that to construct an <code>A ⅋ !B</code>? Or is this already possible using some trickery I'm unaware of?</p>",
        "id": 203720023,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1594649855
    },
    {
        "content": "<p>So in differential linear logic, you have the following extra rules for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">!</mo></mrow><annotation encoding=\"application/x-tex\">!</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mclose\">!</span></span></span></span> called codereliction, cocontraction, and coweakening (so the first three rules of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>¡</mtext></mrow><annotation encoding=\"application/x-tex\">¡</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0em;vertical-align:0em;\"></span><span class=\"mord\">¡</span></span></span></span> I wrote above): </p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mo stretchy=\"false\">!</mo><mi>P</mi><mo>⊢</mo><mi>Q</mi></mrow><mrow><mi>P</mi><mo>⊢</mo><mi>Q</mi></mrow></mfrac><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mfrac><mrow><mo stretchy=\"false\">!</mo><mi>P</mi><mo separator=\"true\">,</mo><mo stretchy=\"false\">!</mo><mi>P</mi><mo>⊢</mo><mi>Q</mi></mrow><mrow><mo stretchy=\"false\">!</mo><mi>P</mi><mo>⊢</mo><mi>Q</mi></mrow></mfrac><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mfrac><mrow><mo stretchy=\"false\">!</mo><mi>P</mi><mo>⊢</mo><mi>Q</mi></mrow><mrow><mo>⊢</mo><mi>Q</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{!P \\vdash Q}{P \\vdash Q} \\quad \\quad \\quad \\quad \\frac{!P, !P \\vdash Q}{!P \\vdash Q}  \\quad \\quad \\quad \\quad \\frac{!P \\vdash Q}{ \\vdash Q} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.25188em;vertical-align:-0.8804400000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714399999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\">Q</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mclose\">!</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\">Q</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804400000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714399999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mclose\">!</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\">Q</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mclose\">!</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mclose\">!</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\">Q</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804400000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714399999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\">Q</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mclose\">!</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\">Q</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804400000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>and similarly for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">?</mo></mrow><annotation encoding=\"application/x-tex\">?</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mclose\">?</span></span></span></span> we get: </p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>P</mi><mo>⊢</mo><mo stretchy=\"false\">?</mo><mi>Q</mi></mrow><mrow><mi>P</mi><mo>⊢</mo><mo stretchy=\"false\">?</mo><mi>Q</mi><mo separator=\"true\">,</mo><mo stretchy=\"false\">?</mo><mi>Q</mi></mrow></mfrac><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mfrac><mrow><mi>P</mi><mo>⊢</mo><mo stretchy=\"false\">?</mo><mi>Q</mi></mrow><mrow><mi>P</mi><mo>⊢</mo></mrow></mfrac><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mspace width=\"1em\"/><mfrac><mrow><mi>P</mi><mo>⊢</mo><mo stretchy=\"false\">?</mo><mi>Q</mi></mrow><mrow><mi>P</mi><mo>⊢</mo><mi>Q</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{P \\vdash ?Q}{P \\vdash ?Q,?Q} \\quad \\quad \\quad \\quad \\frac{P \\vdash ?Q}{P \\vdash }  \\quad \\quad \\quad \\quad \\frac{P \\vdash ?Q}{P \\vdash Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.25188em;vertical-align:-0.8804400000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714399999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mclose\">?</span><span class=\"mord mathdefault\">Q</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mclose\">?</span><span class=\"mord mathdefault\">Q</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mclose\">?</span><span class=\"mord mathdefault\">Q</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804400000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714399999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mclose\">?</span><span class=\"mord mathdefault\">Q</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714399999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\">Q</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mclose\">?</span><span class=\"mord mathdefault\">Q</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804400000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>These extra axioms might help do what you want to construct. Then you can ask for the dual rules for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>¡</mtext></mrow><annotation encoding=\"application/x-tex\">¡</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0em;vertical-align:0em;\"></span><span class=\"mord\">¡</span></span></span></span>  and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>¿</mtext></mrow><annotation encoding=\"application/x-tex\">¿</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0em;vertical-align:0em;\"></span><span class=\"mord\">¿</span></span></span></span>, and hopefully you get want you. (There are lots of models where all these axioms hold)</p>",
        "id": 203723171,
        "sender_full_name": "JS PL (he/him)",
        "timestamp": 1594651233
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"320695\">@Andrew Cann</span>  Some types are coalgebras of <code>!</code>, which gives you <code>T -&gt; !T</code>. For instance, pure 'data' (not using any functions internally) would generally behave this way, because you can do matching on one to build up two equivalent values (although perhaps in a real language you would want to not have to do that). This is explained in e.g. Filinski's Linear Continuations.</p>",
        "id": 203723252,
        "sender_full_name": "Dan Doel",
        "timestamp": 1594651270
    },
    {
        "content": "<p>One of the examples is <code>λ b. if b then (f true, g true) else (f false, g false)</code>, where the boolean stuff is syntax for  <code>1 + 1</code>. This is essentially the same as <code>λ b. (f b, g b)</code>. Presumably the same would be possible for the natural numbers.</p>",
        "id": 203724776,
        "sender_full_name": "Dan Doel",
        "timestamp": 1594651947
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"277105\">@JS Pacaud Lemay</span></p>\n<p>I haven't looked into differential linear logic at all, but those rules seems to break everything <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span>. If <code>!P ⊦ Q</code> implies <code>P ⊦ Q</code> then doesn't the entire theory become non-linear? And if <code>!P ⊦ Q</code> implies <code>⊦ Q</code> then can't that be used to prove anything? eg. <code>!0 ⊦ 0</code> so <code>⊦ 0</code>?</p>\n<p><span class=\"user-mention\" data-user-id=\"277270\">@Dan Doel</span></p>\n<p>I'm aware that pure-positive/data types are copyable (in the sense that you can derive <code>T -&gt; !T</code>) but it would be cool to be able to do this with negative types, or types whose definition is private (not that linear logic has a notion of \"private\", but most languages do via the module system).</p>\n<hr>\n<p>Come to think of it. Linear logic has the rule:</p>\n<div class=\"codehilite\"><pre><span></span><code>!Γ ⊦ B, ?Δ\n-----------\n!Γ ⊦ !B, ?Δ\n</code></pre></div>\n\n\n<p>Which means you also have:</p>\n<div class=\"codehilite\"><pre><span></span><code>!Γ, A ⊦ A, B, ?Δ\n------------------\n!Γ, A ⊦ A, !B, ?Δ\n</code></pre></div>\n\n\n<p>Which means you also have:</p>\n<div class=\"codehilite\"><pre><span></span><code>!Γ, A ⊦ A ⅋ B, ?Δ\n------------------\n!Γ, A ⊦ A ⅋ !B, ?Δ\n</code></pre></div>\n\n\n<p>Which seems to be the rule I'm looking for - if you can use <code>A</code> to derive any number of <code>B</code> then you can use it to derive <code>A ⅋ !B</code>. Huh...</p>",
        "id": 203725590,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1594652381
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"320695\">@Andrew Cann</span> : Yes in differential linear logic, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">&amp;</mi><mo>=</mo><mo>+</mo></mrow><annotation encoding=\"application/x-tex\">\\&amp; = +</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">&amp;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">+</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0=1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> (so in category theory terms, you have biproducts and zero objects), and so in particular this gives you zero maps. And I believe your question about why things don't become non-linear is because there is no \"copromotion\" rule for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">!</mo></mrow><annotation encoding=\"application/x-tex\">!</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mclose\">!</span></span></span></span>. The idea behind <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">!</mo><mi>P</mi><mo>⊢</mo><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">!P \\vdash Q</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mclose\">!</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">Q</span></span></span></span> implies <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>⊢</mo><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">P \\vdash Q</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">Q</span></span></span></span> is more like for every proof you have a linear version of that proof. So I don't think those extra rules break everything... But differential linear logic might not be what you're looking for!</p>",
        "id": 203727375,
        "sender_full_name": "JS PL (he/him)",
        "timestamp": 1594653168
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"320695\">Andrew Cann</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/Exponential.20Modalities.20in.20Linear.20Logic.20.2F.20Type.20Theory/near/203707650\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>but I cannot see the rationale for these exponentials myself. do you have one, apart from trying out symmetry?</p>\n</blockquote>\n<p>Partly just trying out symmetry. Mainly though because I'm interested in programming language design and <code>¡P</code> seems like it could be practically useful. Having unordered multisets as a primitive type would mean having commutativity built into the language, which would be good for modelling race-free concurrency.</p>\n</blockquote>\n<p>I don't see why the commutativity based on + would be better than the one based on tensor or on the product, maybe you think this would imply race-freeness? this does not seem to me clear, but I'd like to understand why you think so.</p>\n<p>I'm a great believer in multiplicative disjunction (or par) on intuitionistic linear logic and of ?'s that are not defined by negation from  the exponential \"!\", especially for program language design, so certainly would like to understand your intuition better. I wonder if that is at all similar to Aschieri and Genco's <br>\nPar Means Parallel: Multiplicative Linear Logic Proofs as Concurrent Functional Programs<br>\nProceedings of POPL 2020 <a href=\"https://dmg.tuwien.ac.at/aschieri/popl-clinear.pdf\">https://dmg.tuwien.ac.at/aschieri/popl-clinear.pdf</a></p>",
        "id": 203785908,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1594684955
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276656\">@Valeria de Paiva</span> </p>\n<p>From my thinking the concept of commutativity/unorderedness only applies to the exponential modalities. The binary connectives (<code>+</code>, <code>&amp;</code>, <code>⊗</code>, <code>⅋</code>) are unordered in the sense that <code>A + B</code> is isomorphic to <code>B + A</code> and so forth, but you still need to distinguish between the left and the right element because they have different types. If I wanted a type of unordered pairs of ints for instance, where <code>(1, 2)</code> is indistinguishable from <code>(2, 1)</code>, I couldn't use <code>Int ⊗ Int</code> for this. Being able to match on a <code>A ⊗ B</code> requires you to be able to handle the <code>A</code> and the <code>B</code> differently. You can't special-case that for when <code>A</code> and <code>B</code> happen to be the same type because that would require decidable type equality and it also breaks when you have generic types / type-variables.</p>\n<p>So if I want unordered pairs but I only have <code>⊗</code> I need to axiomatize them as a new primitve type. But then I still can't define and would need to axiomatize unordered triples, unorderd 5-tuples, and unordered p-tuples for any prime p in general. I could have a form of <code>¡</code> indexed by a natural number expressing the arity, but I'd rather avoid meta-level natural numbers for now and it's also unnecessary if I have dependent types and can express the arity separately with something like <code>∑(x: ¡P).(count(x) = n)</code></p>\n<p>Does this make sense?</p>\n<blockquote>\n<p>and of ?'s that are not defined by negation from the exponential \"!\", especially for program language design</p>\n</blockquote>\n<p>Interesting. I'm still having trouble wrapping my head around what <code>?</code> means from a programming-language design point of view, aside from it being the negation of <code>!</code>. Do you have some hints here?</p>\n<p>I haven't read \"par means parallel\", though mainly because my initial reaction to the title was <em>\"Huh? Par doesn't mean parallel. The tensor product is parallel, the whole point of par is to be not-parallel.\"</em> That's a dumb reason though so I should just get around to reading it.</p>",
        "id": 203843186,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1594738642
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"320695\">Andrew Cann</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/Exponential.20Modalities.20in.20Linear.20Logic.20.2F.20Type.20Theory/near/203843186\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276656\">Valeria de Paiva</span> </p>\n<p>The binary connectives (<code>+</code>, <code>&amp;</code>, <code>⊗</code>, <code>⅋</code>) are unordered in the sense that <code>A + B</code> is isomorphic to <code>B + A</code> and so forth, but you still need to distinguish between the left and the right element because they have different types. If I wanted a type of unordered pairs of ints for instance, where <code>(1, 2)</code> is indistinguishable from <code>(2, 1)</code>, I couldn't use <code>Int ⊗ Int</code> for this. Being able to match on a <code>A ⊗ B</code> requires you to be able to handle the <code>A</code> and the <code>B</code> differently. <br>\nDoes this make sense?</p>\n</blockquote>\n<p>well, I don't quite follow you. yes, you need natural isomorphisms to make <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>+</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A+B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> the same as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mo>+</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">B+A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>, etc. and for some things you want this identification, for others you don't, I agree. it's even worse with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>×</mo><mo stretchy=\"false\">(</mo><mi>B</mi><mo>+</mo><mi>C</mi><mo stretchy=\"false\">)</mo><mo>≅</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo>+</mo><mi>A</mi><mo>×</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">A\\times (B+C)\\cong A\\times B+ A\\times C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span>  imo. but then I don't see how the exponentials/modalities will help with these issues.</p>\n<p>Now the issue of the multiplicative disjunction and its modality \"?\" seems to me orthogonal to the conversation above.</p>\n<p>Tensor seems parallelism of assumptions/contexts, while \"par\" seems like parallelism of threads. Each thread is a linear function, they evolve independently, hence we can look at them as parallel disjunctions of executing threads.<br>\nWhat I wanted to model with !,? is the duality of production and consumption of resources, so the rules for a comonoidal monad (as above) make sense, but they do not enforce a total duality between !A and ?A. </p>\n<p>this does not preclude your problems with Nat. those are serious as there's cat theory showing that we can only do NNOs for cartesian categories, I think (see <a href=\"https://www.mscs.dal.ca/~pare/PareRomanNNO1.pdf\">https://www.mscs.dal.ca/~pare/PareRomanNNO1.pdf</a>)</p>",
        "id": 203853129,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1594743252
    },
    {
        "content": "<p>For those interested, it looks like a paper on this topic has just been uploaded to arxiv: <a href=\"https://arxiv.org/pdf/2010.13926.pdf\">https://arxiv.org/pdf/2010.13926.pdf</a></p>",
        "id": 214955373,
        "sender_full_name": "Chris Barrett",
        "timestamp": 1603971841
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"277010\">@Chris Barrett</span>: Oh wow! Thanks for posting this!</p>\n<p>I like that someone else is looking into these exponentials. I've been playing with them again recently and I'm convinced they're important, partly for the same reasons mentioned in the paper.</p>\n<p>That said, I'm sad that their version of <code>¿</code> (which they call <code>¡</code>) introduces non-determinism.</p>\n<p><code>¡A</code> (my <code>¡</code>, their <code>¿</code>) is the type of multisets of type <code>A</code>. Multisets are inherently unordered, so the eliminator for it (ie. its dual type <code>¿(¬A)</code>) should respect that lack of ordering. That is, it should process the <code>A</code>s it receives commutatively, rather than being able to distinguish between <code>{1, 1, 2}</code> and <code>{1, 2, 1}</code> since they're the same multiset. <span class=\"user-mention\" data-user-id=\"277105\">@JS Pacaud Lemay</span> gave an elimination rule above which satisfies this:</p>\n<div class=\"codehilite\"><pre><span></span><code>¿P ⊦ Q\n-------\n¿P ⊦ ¿Q\n</code></pre></div>\n<p>But unfortunately it's only commutative because it only allows you to eliminate a multiset into more multisets. eg. it can let you map a multiset of ints into a multiset of strings by calling \"<code>print</code>\" on each int, but it can't let you xor a multiset of bools into a single bool.</p>\n<p>I have a few issues with linear logic's promotion rule and this highlights one of them. The intro and elim rules for a type should be the exact inverse of each other. That is, they should allow you to \"get out\" exactly what you \"put in\". But if you turn the rules for <code>!</code> and <code>?</code> around to make <code>¡</code> and <code>¿</code> you can see that this doesn't work (at least for <code>¡</code> and <code>¿</code>). For instance, a multiset of units (<code>¡1</code>) is defined entirely by the number of elements put into it. So it should be equivalent to <code>Nat</code>. But since there's no way to check if that number of elements is even some information has been lost.</p>\n<hr>\n<p>I have a bunch of scattered thoughts around this topic and I'm hoping someone will review them for me and give me feedback.</p>\n<p>Firstly I want to motivate the <code>¡</code>/<code>¿</code>coexponentials a bit more. I've designed a programming-language syntax for multiplicative-additive linear logic. It captures all of MALL with nothing extraneous (like extra rules that weaken the system or <code>-o</code> types distinct from <code>⅋</code> types). One nice thing about it is that pattern syntax is identical to term syntax - every syntactic construct is usable in both positive (term) and negative (pattern) position. However the meaning of the syntax differs between the two positions. Specifically: let's define a \"semi-dual\" operation on types which only inverts the additive connectives. That is, writing <code>~A</code> to mean the semi-dual of <code>A</code>, you have:</p>\n<div class=\"codehilite\"><pre><span></span><code>~0 = ⊤\n~⊤ = 0\n~(A + B) = ~A &amp; ~B\n~(A &amp; B) = ~A + ~B\n~⊥ = ⊥\n~1 = 1\n~(A ⊗ B) = ~A ⊗ ~B\n~(A ⅋ B) = ~A ⅋ ~B\n</code></pre></div>\n<p>In my syntax you match on a term of type <code>A</code> with the <em>syntax</em> of a term of type <code>~A</code>. In terms of the underlying logic a type still needs to be cut against its full dual, but when moving between the term and pattern fragments you only <em>syntactically</em> take the semi-dual.</p>\n<p>A full description of the syntax might help (this is a simplified version of my hobby language syntax for explanation purposes):</p>\n<div class=\"codehilite\"><pre><span></span><code>## Terms:\n\nfor terms:\n    a : A\n    b : B\n    n : ¬A\nand patterns\n    c : A\n    m : ¬A\n\nyou have the terms:\n\n    [] : ⊤\n\n    [left = a, right = b] : A &amp; B\n\n    .left a : A + B\n\n    .right b : A + B\n\n    () : 1\n\n    (a, b) : A ⊗ B\n\n    connect a = n : ⊥\n\n    c =&gt; b : A ⅋ B\n\n    let m = a; b : B\n\n## Patterns:\n\nfor patterns:\n    a : A\n    b : B\n    n : ¬A\nand terms\n    c : A\n    m : ¬A\n\nyou have the patterns:\n\n    [] : ⊤\n\n    [left = a, right = b] : A &amp; B\n\n    .left a : A + B\n\n    .right b : A + B\n\n    connect a = n : 1\n\n    c =&gt; b : A ⊗ B\n\n    () : ⊥\n\n    (a, b) : A ⅋ B\n\n    let m = a; b : B\n</code></pre></div>\n<p>Notice that the term and pattern fragments are identical except that the syntax for the multiplicative fragment gets reversed. In other words, you match on a set of branches by choosing a branch and a sum by providing a set of branches, but you match on a tuple by destructuring it and a function by calling it with an argument and binding the result.</p>\n<p>This all works well and has some very pretty symmetry, but what happens when you try to add the exponentials? You can define the term syntax for <code>!A</code> as <code>&amp;a</code> where <code>a</code> is a term that only uses other <code>!</code>-typed variables, but to match on a <code>!A</code> you want to be able to destructure it into a set of variables of types <code>A</code> and <code>!A</code>. In other words, you want to <em>syntactically</em> match it against its semi-dual, which happens to be <code>¡(~A)</code>. And this also works in reverse - if you have <code>¡A</code> types then the syntax for matching on them is <code>&amp;a</code>, except where <code>a</code> is a pattern that only binds more <code>¡</code>-types (this follows directly from the elimination rule for <code>¡</code> that I gave above).</p>\n<p>So if I want to continue expanding my language to full linear logic with exponentials, and if I want to keep the nice property that term and pattern syntax is identical, then I end up needing to add <code>¡</code> and <code>¿</code> types to complement the <code>!</code> and <code>?</code> types, otherwise the syntax becomes lop-sided. And since LL is kinda useless for programming without <code>¡</code> and <code>¿</code> anyway (as pointed out in the paper) that seems like a good motivation to try and understand them, rather than abandon this exploration path in language-design-space.</p>\n<p>That said, I want to talk about generators, inductive types and fixpoints in LL, but I'll start a new topic for that...</p>",
        "id": 215940875,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1604730067
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"320695\">Andrew Cann</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/Exponential.20Modalities.20in.20Linear.20Logic.20.2F.20Type.20Theory/near/215940875\">said</a>:</p>\n<blockquote>\n<p>That said, I'm sad that their version of <code>¿</code> (which they call <code>¡</code>) introduces non-determinism.</p>\n</blockquote>\n<p>It looks like their system has a \"strong\" version of the co-exponentials and that the non-determinism comes from the multiplexing version of que. It's hard for me to tell exactly what's happening as they don't seem to list their cut-elimination rules. </p>\n<p>I'd be interested to see a system for just the \"weak\" co-exponentials, although they claim in the conclusion there is a problem with the commuting conversions for cut-elimination here. I've played around a bit with making a deep inference formulation of the system though and I think that should work fine. I can't see that non-determinism would arise in this setting, at least</p>",
        "id": 215957129,
        "sender_full_name": "Chris Barrett",
        "timestamp": 1604759041
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"277010\">@Chris Barrett</span> : when you say strong exponential, do you mean the one where they assume <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">!</mo><mi>A</mi><mo>≅</mo><mn>1</mn><mo>×</mo><mi>A</mi><mo>×</mo><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">!</mo><mi>A</mi><mo>⊗</mo><mo stretchy=\"false\">!</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">! A \\cong 1 \\times A \\times (! A \\otimes ! A)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mclose\">!</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mclose\">!</span><span class=\"mord mathnormal\">A</span><span class=\"mord\">⊗</span><span class=\"mclose\">!</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span></p>",
        "id": 215960283,
        "sender_full_name": "JS PL (he/him)",
        "timestamp": 1604763706
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"277105\">@JS Pacaud Lemay</span> I believe that's how they define their \"strong exponential\", but really I'm thinking more about the formulation of the rule for ! listed in section 2.1 of their paper. It looks unusual to me - I've never seen this presentation before and it doesn't have the subformula property (and thus neither do cut-eliminated proofs). Calling the usual LL exponentials ! and ? and the new \"co-exponentials\"  co-! and co-? , they have a strong rule for both ! and co-!</p>",
        "id": 216075673,
        "sender_full_name": "Chris Barrett",
        "timestamp": 1604923843
    }
]