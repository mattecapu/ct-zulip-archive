[
    {
        "content": "<p>Hey all,<br>\nThis is the discussion thread of Sam Staton's talk, \"Categorical models of probability with symmetries\".<br>\nThe talk, besides being on Zoom, is livestreamed here: <a href=\"https://youtu.be/eTa7-nW9AE8\">https://youtu.be/eTa7-nW9AE8</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"eTa7-nW9AE8\" href=\"https://youtu.be/eTa7-nW9AE8\"><img src=\"https://i.ytimg.com/vi/eTa7-nW9AE8/default.jpg\"></a></div>",
        "id": 199761684,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1591283626
    },
    {
        "content": "<p>Date and time: Friday, 5 Jun, 12h UTC.</p>",
        "id": 199796244,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1591298710
    },
    {
        "content": "<p>My slides: <a href=\"http://www.cs.ox.ac.uk/people/samuel.staton/2020cps.pdf\">http://www.cs.ox.ac.uk/people/samuel.staton/2020cps.pdf</a></p>",
        "id": 199865592,
        "sender_full_name": "Sam Staton",
        "timestamp": 1591358162
    },
    {
        "content": "<p>We start in 30 seconds!</p>",
        "id": 199865900,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1591358387
    },
    {
        "content": "<p>Hi Sam. I was unaware that graphons are such well studied objects. When you have time, can you point out some introductory resources on graphon theory? Also any results in category theory that you think are especially significant.</p>",
        "id": 199869712,
        "sender_full_name": "Oliver Shetler",
        "timestamp": 1591360801
    },
    {
        "content": "<p>Hi <span class=\"user-mention silent\" data-user-id=\"285161\">Oliver Shetler</span>. An overview reference I like is <a href=\"https://arxiv.org/pdf/1312.7857.pdf\">https://arxiv.org/pdf/1312.7857.pdf</a> . Another introduction is Tao's blog <a href=\"https://terrytao.wordpress.com/2014/10/12/additive-limits/\">https://terrytao.wordpress.com/2014/10/12/additive-limits/</a> which is from a very different perspective. <br>\nGraphons have been rediscovered in many different domains by many people over the years. They're considered everywhere from model theory, combinatorics, to data science. <br>\nThe reference to consistent local graph models in my talk was <a href=\"https://arxiv.org/abs/math/0408173\">https://arxiv.org/abs/math/0408173</a> , although perhaps the ideas go back to the 1970s.</p>",
        "id": 199872888,
        "sender_full_name": "Sam Staton",
        "timestamp": 1591362453
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 199872992,
        "sender_full_name": "Oliver Shetler",
        "timestamp": 1591362491
    },
    {
        "content": "<p>Sam, there was a lot of intriguing content in your talk and this will take time to process, but for now here's one more question. You had mentioned that natural families of functions are deterministic morphisms. What is the general precise statement here, and what definition of deterministic morphism does it use? I guess that it applies in at least every presheaf category, right? Is it your own observation, and is there a  reference?</p>",
        "id": 199883007,
        "sender_full_name": "Tobias Fritz",
        "timestamp": 1591366823
    },
    {
        "content": "<p>What I mean is that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> is a category, then we can consider two kinds of morphisms between presheaves <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo separator=\"true\">,</mo><mi>G</mi><mo>:</mo><msup><mi>C</mi><mrow><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">p</mi></mrow></msup><mo>→</mo><mi>S</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">F,G:C^{\\mathrm{op}}\\to Set</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">G</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">o</span><span class=\"mord mathrm mtight\">p</span></span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">t</span></span></span></span>. One is just arbitrary families of functions indexed by the objects of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span>, and the other one is only those families which form natural transformations. What you seem to be saying is that using arbitrary families of functions as morphisms, we get a Markov category in which the natural transformations coincide with the deterministic morphisms. If that's what it is then it's really neat! (And of course I imagine that it well predates the theory of Markov categories.)</p>",
        "id": 199885158,
        "sender_full_name": "Tobias Fritz",
        "timestamp": 1591367709
    },
    {
        "content": "<p>Interesting idea! I hadn't thought of that but it might work!<br>\nI mainly meant I would set things up as a Kleisli category or a Freyd category, where there are two given categories, which I was calling deterministic and probabilistic. Perhaps that was a bit unclear. <br>\nBut there is a simple theorem there, which is that all the _definable_ deterministic programs are interpreted as _natural_ transformations, i.e. the naturality is satisfied by everything definable, which is a kind of invariance property that shows that some nasty non-natural maps (such as &lt;, sin(-)=cos(-)) are not definable.</p>",
        "id": 199885836,
        "sender_full_name": "Sam Staton",
        "timestamp": 1591368019
    },
    {
        "content": "<p>That was indeed a very interesting talk and I also need some time to process it fully and relate to what I've been thinking about. </p>\n<p>The most immediate question I have related to the combinatorial model of probability, which I think I didn't fully grasp. How should I think of (or interpret) the objects X constructed in this fashion - as families of sets indexed by natural numbers? What does n represent here? Also, just to make sure, X is a functor and FinSet has all functions as morphisms, right?</p>",
        "id": 199887667,
        "sender_full_name": "Tomáš Gonda",
        "timestamp": 1591368816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308397\">Sam Staton</span> <a href=\"#narrow/stream/238032-Categorical-Probability.20and.20Statistics.202020.20workshop/topic/Jun.205.20-.20Sam.20Staton's.20talk/near/199885836\">said</a>:</p>\n<blockquote>\n<p>Interesting idea! I hadn't thought of that but it might work!<br>\nI mainly meant I would set things up as a Kleisli category or a Freyd category, where there are two given categories, which I was calling deterministic and probabilistic. Perhaps that was a bit unclear. </p>\n</blockquote>\n<p>The non-natural transformations can be described as non-deterministic maps in a monad sense: If we denote by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>:</mo><msup><mi>C</mi><mi>d</mi></msup><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">i: C^d \\to C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">d</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> the inclusion of the discrete category with just the objects of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span>, then non-natural transformations are exactly <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mi>a</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>F</mi><mo>∘</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>G</mi><mo>∘</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Nat(F\\circ i, G \\circ i)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">t</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">G</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">)</span></span></span></span>. But by adjointness this is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mi>a</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>F</mi><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mi>R</mi><mi>a</mi><mi>n</mi><mo>∘</mo><msup><mi>i</mi><mo>∗</mo></msup><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>G</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Nat(F, (Ran \\circ i^*)(G))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">t</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">i</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">G</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span>, so non-natural transformations are non-deterministic  maps with respect to the \"right Kanextension$$\\circ$$precomposition with i\"-monad.<br>\nIs that what you two were thinking ?</p>",
        "id": 199888192,
        "sender_full_name": "Peter Arndt",
        "timestamp": 1591369005
    },
    {
        "content": "<p>Hi <span class=\"user-mention silent\" data-user-id=\"302756\">Tomáš Gonda</span>. Yes, that's right. X is a functor and FinSet has all functions as morphisms. n represents the number of urns that have been created, or the number of times \"beta\" has been used. Naturality under the permutations in FinSet means that the urns are indistinguishable -- you can't look inside them or ask whether one was made before another. Naturality under inclusion maps in FinSet means that you can't ask \"how many urns have been made so far\".</p>",
        "id": 199888845,
        "sender_full_name": "Sam Staton",
        "timestamp": 1591369245
    },
    {
        "content": "<p>Hi <span class=\"user-mention silent\" data-user-id=\"303936\">Peter Arndt</span>, that's a good idea, and maybe what Tobias was thinking. But I just meant that if we have a monad on a presheaf category, then deterministic expressions would be interpreted as a plain natural transformation and probabilistic expression would be interpreted as a Kleisli natural transformation. And as I wrote to Tomas, the naturality is itself saying an invariance or equivariance property which is already a bit interesting in the deterministic case.</p>",
        "id": 199891429,
        "sender_full_name": "Sam Staton",
        "timestamp": 1591370237
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"308397\">@Sam Staton</span> , I enjoyed your talk a lot. A functional programmer may wonder: An urn represents a global state. For example in Haskell, this is modelled with a state monad. While probability monads are typically commutative, the state monad isn't, and that's the complication in commuting statements that use the state effect. In your example, that may not be relevant, but I'm wondering whether there is a general theory about how probability interplays with other effects? E.g. is there a theory on how to commute a state monad transformer with a probability monad transformer?</p>",
        "id": 199915616,
        "sender_full_name": "Manuel Bärenz",
        "timestamp": 1591381220
    },
    {
        "content": "<p>\"Getting a new name\" can also be thought as an effect (in Haskell, this monad is usually called \"Accum\", see <a href=\"http://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Accum.html\">http://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Accum.html</a>), as can the memoization function. Is there something going on between effects and probability? (Note that both State and Accum can be represented as polynomial functors (maybe even Lawvere theories, but I'm not sure about that))</p>",
        "id": 199917377,
        "sender_full_name": "Manuel Bärenz",
        "timestamp": 1591382034
    },
    {
        "content": "<p>Hah, I should have listened to the questions first :D of course Gordon asked about State. So if noncommutativity is such a problem, we can still look at the Accum monad with a commutative monoid as internal state, or something like that. Your \"fresh name\" effect is commutative if you disallow inspection of the actual name beyond equality comparison. Memoization is also commutative and even idempotent. So what can we do here?</p>",
        "id": 199920005,
        "sender_full_name": "Manuel Bärenz",
        "timestamp": 1591383399
    },
    {
        "content": "<p>Another question. I asked a similar question in Peter's talk, but I'm realising now that it might be relevant to your topic as well. In homotopy type theory, we can express symmetries as groupoid types, or higher inductive types. Does it make sense to use these to express symmetries, and can you extract a good model from that?</p>",
        "id": 199920731,
        "sender_full_name": "Manuel Bärenz",
        "timestamp": 1591383810
    },
    {
        "content": "<p>Hi <span class=\"user-mention silent\" data-user-id=\"309346\">Manuel Bärenz</span>! I agree, this interplay between state and probability is very interesting. To show that Polya's urn behaves in a commutative way is a bit of work because, as you observed it involves state, and state is not usually commutative. From a programming perspective, de Finetti's theorem says that if you have a module for the get/sample interface that uses state but is still commutative, then you can implement it without state, just using probability.  </p>\n<p>I also agree that name generation and memoization are important examples of state-like behaviour that are commutative. My current conjecture is that they are canonical with this property, in a certain sense. Also, Dario Stein is currently looking at name generation from a probability point of view. </p>\n<p>For type theory, it might be interesting but I haven't really thought about it. I know Harry Crane was looking at HOTT + probability at one point.  Bas Spitters may also have something to say if he is around.</p>",
        "id": 199936299,
        "sender_full_name": "Sam Staton",
        "timestamp": 1591392574
    },
    {
        "content": "<p>Hi all! Here is the recording:<br>\n<a href=\"https://youtu.be/8Y0b7e4OIUQ\">https://youtu.be/8Y0b7e4OIUQ</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"8Y0b7e4OIUQ\" href=\"https://youtu.be/8Y0b7e4OIUQ\"><img src=\"https://i.ytimg.com/vi/8Y0b7e4OIUQ/default.jpg\"></a></div>",
        "id": 199936426,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1591392659
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"308397\">@Sam Staton</span> is the internal logic of the Rado topos understood?</p>",
        "id": 199966261,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1591436523
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308397\">@Sam Staton</span>, if you don't mind I'd have a question that's not directly related to your talk (as far as I can see). The nLab <a href=\"https://ncatlab.org/nlab/show/Freyd+category#relation_to_strong_monads\">states</a> that if the underlying functor of a Freyd category has a right adjoint, then the Freyd category arises as a Kleisli category. Do you know of a reference for that? Or is it folklore, perhaps because it's sufficiently obvious?</p>",
        "id": 199976245,
        "sender_full_name": "Tobias Fritz",
        "timestamp": 1591451951
    },
    {
        "content": "<p>Hi <span class=\"user-mention silent\" data-user-id=\"278549\">Bas Spitters</span>! The topos is Boolean, and AC fails badly. It is quite like Schanuel topos (nominal sets, FM set theory) in this way, if you've ever looked at that. Also, as I mentioned briefly, if I write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span></span></span></span> for the object of vertices, then the powerobject <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>V</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.22222em;\">V</span></span></span></span></span></span></span></span></span></span></span> comprises all definable sets (with finite parameters) in the language of graphs, in the sense of model theory. So that's nice.</p>",
        "id": 199991108,
        "sender_full_name": "Sam Staton",
        "timestamp": 1591474165
    },
    {
        "content": "<p>Hi <span class=\"user-mention silent\" data-user-id=\"276702\">Tobias Fritz</span>, in general, if an identity-on-objects functor has a right adjoint, then it is a Kleisli adjunction. (I remember, as a student, finding it surprisingly hard to find this in a book. Maybe someone knows a nice reference.) For Freyd categories, the literature is mostly focused on _closed_ Freyd categories <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>J</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">J:C\\to D</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.09618em;\">J</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span></span></span></span>, which ask that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>J</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo>×</mo><mo>−</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">J(A\\times -)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.09618em;\">J</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">−</span><span class=\"mclose\">)</span></span></span></span> has a right adjoint for all A.</p>",
        "id": 199991490,
        "sender_full_name": "Sam Staton",
        "timestamp": 1591474815
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308397\">Sam Staton</span> <a href=\"#narrow/stream/238032-Categorical-Probability.20and.20Statistics.202020.20workshop/topic/Jun.205.20-.20Sam.20Staton's.20talk/near/199991490\">said</a>:</p>\n<blockquote>\n<p>in general, if an identity-on-objects functor has a right adjoint, then it is a Kleisli adjunction.</p>\n</blockquote>\n<p>Wow! That is obvious upon thinking about it, but somehow still quite surprising to me. Thanks!</p>",
        "id": 199994654,
        "sender_full_name": "Tobias Fritz",
        "timestamp": 1591480246
    }
]