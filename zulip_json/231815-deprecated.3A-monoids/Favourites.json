[
    {
        "content": "<p>The current focus of my research in topos theory is to use toposes to understand monoids and vice versa. So I want to know what monoids you use or encounter in your research, monoids you want to understand better, and which are your favourites for whatever reason!</p>",
        "id": 192874895,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1585955655
    },
    {
        "content": "<p>I've become very fond of the handful of monoids with just a few elements. They provide very workable (and sometimes surprising) examples and give me excuses to draw pictures, which I was afraid I would hardly ever get to do in topos theory. <span aria-label=\"heart eyes\" class=\"emoji emoji-1f60d\" role=\"img\" title=\"heart eyes\">:heart_eyes:</span></p>",
        "id": 192875155,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1585955881
    },
    {
        "content": "<p>My username I go by now is MonoidMusician. It was initially chosen because it sounded nice, but I do love monoids! I don‚Äôt have particular favorites, but I was just thinking the other day that a lot of monoids have layers of elements that are identities or ‚Äúalmost-identities‚Äù, and also absorbing elements or almost-absorbing elements. E.g. m &lt;&gt; e = m (identity), and m &lt;&gt; e1 = m for all m != e (almost identity).</p>",
        "id": 192875666,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1585956296
    },
    {
        "content": "<p>Ah, you mean like elements which are the identity of some subsemigroup?</p>",
        "id": 192875894,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1585956531
    },
    {
        "content": "<p>Yeah, I guess that would be one way to phrase it</p>",
        "id": 192875929,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1585956565
    },
    {
        "content": "<p>What you're describing sounds a bit more special, I like that. Like having an idempotent which absorbs the identity but is absorbed by every other element.</p>",
        "id": 192876065,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1585956678
    },
    {
        "content": "<p>Where do you get your intuition about monoids from/where do you find them?</p>",
        "id": 192876144,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1585956733
    },
    {
        "content": "<p>I like implementing programming languages in functional languages, so they pop up whenever I see a pattern I need to generalize or need to classify/aggregate data. As an example of a aggregation-type monoid, maybe something that looks at a list of (syntax) trees and finds their common intersection, or returns an identity if there is none. The identity is essentially adjoined to the set of trees, and I guess the empty tree is an absorbing element, but sometimes you‚Äôd get an almost-identity instead. I‚Äôm currently seeing how much I can implement typechecking in terms of monoids üòÉ</p>",
        "id": 192876857,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1585957359
    },
    {
        "content": "<p>I am a math undergrad, but we don‚Äôt talk about monoids a lot. Everyone loves groups of course. Groups and rings and fields.</p>",
        "id": 192877228,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1585957719
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276057\">Nicholas Scheel</span> <a href=\"#narrow/stream/231815-monoids/topic/Favourites/near/192877228\" title=\"#narrow/stream/231815-monoids/topic/Favourites/near/192877228\">said</a>:</p>\n<blockquote>\n<p>I am a math undergrad, but we don‚Äôt talk about monoids a lot. Everyone loves groups of course. Groups and rings and fields.</p>\n</blockquote>\n<p>As a computer scientist, I spend quite a lot of time peeling away inverses mathematicians have added to things.</p>",
        "id": 192877900,
        "sender_full_name": "James Wood",
        "timestamp": 1585958363
    },
    {
        "content": "<p>Haha, of course <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> Do you have any favorite examples to share?</p>",
        "id": 192878030,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1585958491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281583\">James Wood</span> <a href=\"#narrow/stream/231815-monoids/topic/Favourites/near/192877900\" title=\"#narrow/stream/231815-monoids/topic/Favourites/near/192877900\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276057\">Nicholas Scheel</span> <a href=\"#narrow/stream/231815-monoids/topic/Favourites/near/192877228\" title=\"#narrow/stream/231815-monoids/topic/Favourites/near/192877228\">said</a>:</p>\n<blockquote>\n<p>I am a math undergrad, but we don‚Äôt talk about monoids a lot. Everyone loves groups of course. Groups and rings and fields.</p>\n</blockquote>\n<p>As a computer scientist, I spend quite a lot of time peeling away inverses mathematicians have added to things.</p>\n</blockquote>\n<p>Amen to that. During my math (under)grad I asked myself more than once \"how can monoids be interesting? They look so simple and stupid\"<br>\nThen I found out about computer science :D</p>",
        "id": 192878194,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1585958646
    },
    {
        "content": "<p>I dream of one day of compiling a course ‚ÄúMonoids, Semirings, and Semimodules‚Äù, just to see how far it can go. I think some good motivating examples of semirings are the tropical semirings, where the addition is a meet and the multiplication is an addition. The standard example is (‚Ñù‚Å∫ ‚à™ {‚àû}, ‚àû, min, 0, +), though a favourite for computer scientists is any well behaved class of formal languages ùìõ, with addition being union of languages and multiplication being pointwise concatenation of words (the order in which union is meet is ‚äá). I did my batchelor's project on a generalisation of tropical semirings, which get used in shortest-distance problems on weighted graphs (like Dijkstra's algorithm solves). The example there is that you have vectors (‚Ñù‚Å∫ ‚à™ {‚àû})·µè, and instead of the addition being just the idempotent min, you merge the two vectors (as in mergesort), then take the first k. This has the property that if you add something to itself k times, it'll reach a fixed point (concretely, the first element repeated k times).</p>",
        "id": 192899727,
        "sender_full_name": "James Wood",
        "timestamp": 1585993863
    },
    {
        "content": "<p>But regarding just monoids, do people know of Conor McBride's favourite monoid on the integers, which has identity -1?</p>",
        "id": 192899792,
        "sender_full_name": "James Wood",
        "timestamp": 1585993943
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281583\">James Wood</span> <a href=\"#narrow/stream/231815-monoids/topic/Favourites/near/192899727\" title=\"#narrow/stream/231815-monoids/topic/Favourites/near/192899727\">said</a>:</p>\n<blockquote>\n<p>I think some good motivating examples of semirings are the tropical semirings, where the addition is a meet and the multiplication is an addition.</p>\n</blockquote>\n<p>So you can construct a tropical semiring from any ordered monoid? If so, I hadn't thought about that before!</p>",
        "id": 192900387,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1585994948
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281583\">James Wood</span> <a href=\"#narrow/stream/231815-monoids/topic/Favourites/near/192899792\" title=\"#narrow/stream/231815-monoids/topic/Favourites/near/192899792\">said</a>:</p>\n<blockquote>\n<p>But regarding just monoids, do people know of Conor McBride's favourite monoid on the integers, which has identity -1?</p>\n</blockquote>\n<p>I've not heard of this, what's the operation? <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 192900401,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1585994988
    },
    {
        "content": "<p>Essentially, it's a version of the category of thinnings (a strictification of the category of order-preserving embeddings between totally ordered finite sets), but where instead of each object being the size of a finite set, they're all just œâ, and it collapses into a monoid. This comes up when you want to implement de Bruijn indices without dependent types, so you have no way to enforce good scoping in types. In the usual case, a thinning from m to n is equivalent to {bs ‚àà 2‚Åø | ‚àëbs = m}, i.e, a certain class of bit vectors, with each bit telling you whether that n-element came from an m-element. Without the domain and codomain, we just have to give a bitstream. In implementation, it's convenient to restrict to the eventually constant bitstreams, which are exactly the integers represented in two's complement binary. The identity thinning corresponds to the identity order-preserving embedding, in which every element in the codomain came from the domain, hence every bit is 1, corresponding to the integer -1. The composition is a bit difficult to explain in this form, but it's not commutative.</p>",
        "id": 192900710,
        "sender_full_name": "James Wood",
        "timestamp": 1585995438
    },
    {
        "content": "<p>With composition written in diagrammatic order, Œ∏ ; œÜ works by iterating through œÜ, then sometimes Œ∏. If the first bit of œÜ is 0, we know that the first element of the codomain is not in the domain (because it wasn't even in the intermediate set), so the first bit of the result is 0. If the first bit of œÜ is 1, then we have to check with Œ∏ whether it carries all the way through to the domain. So the result is to copy the first bit of Œ∏, and continue on the tails of Œ∏ and œÜ.</p>",
        "id": 192901002,
        "sender_full_name": "James Wood",
        "timestamp": 1585995909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281583\">James Wood</span> <a href=\"#narrow/stream/231815-monoids/topic/Favourites/near/192900710\" title=\"#narrow/stream/231815-monoids/topic/Favourites/near/192900710\">said</a>:</p>\n<blockquote>\n<p>Essentially, it's a version of the category of thinnings (a strictification of the category of order-preserving embeddings between totally ordered finite sets), but where instead of each object being the size of a finite set, they're all just œâ, and it collapses into a monoid. This comes up when you want to implement de Bruijn indices without dependent types, so you have no way to enforce good scoping in types. In the usual case, a thinning from m to n is equivalent to {bs ‚àà 2‚Åø | ‚àëbs = m}, i.e, a certain class of bit vectors, with each bit telling you whether that n-element came from an m-element. Without the domain and codomain, we just have to give a bitstream. In implementation, it's convenient to restrict to the eventually constant bitstreams, which are exactly the integers represented in two's complement binary. The identity thinning corresponds to the identity order-preserving embedding, in which every element in the codomain came from the domain, hence every bit is 1, corresponding to the integer -1. The composition is a bit difficult to explain in this form, but it's not commutative.</p>\n</blockquote>\n<p>Wait why does the bitstream with every bit 1 correspond to -1? Is it just a convention in \"two's complement binary\" that the number encoded by a stream that's eventually 1 is the negative of the complementary, reversed stream with one added to the start..? I can accept that, I guess.</p>",
        "id": 192902421,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1585998288
    },
    {
        "content": "<p>Yeah, it's a convention that happens to be quite convenient. I'm thinking of the representation being little-endian, so ‚Äúeventually‚Äù refers to the high-value bits. For finite-range integers of n bits, two's complement says that the highest-value bit has value -2‚Åø‚Åª¬π, while the other values stay the same. You have to take some sort of limit to make this work for arbitrary-range integers, I guess. You at least get the properties that consing on high-valued 0s to a positive integer and high-valued 1s to a negative integer both don't change the value.</p>",
        "id": 192902819,
        "sender_full_name": "James Wood",
        "timestamp": 1585998874
    },
    {
        "content": "<p>IIRC, those properties are the ones that justify ‚Äúsign extension‚Äù.</p>",
        "id": 192902898,
        "sender_full_name": "James Wood",
        "timestamp": 1585999014
    }
]