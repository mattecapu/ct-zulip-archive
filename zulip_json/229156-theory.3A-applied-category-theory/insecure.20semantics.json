[
    {
        "content": "<p>Continued from <a href=\"#narrow/stream/229156-practice.3A-applied.20ct/topic/systems/near/209224488\">here</a><br>\nThis is all great as long as you are interpreting your theory in a category which has enough structure to interpret the syntax for <em>any</em> choice of interpretation of the signature. Following <a href=\"#narrow/stream/229156-practice.3A-applied.20ct/topic/systems/near/209221847\">Fabrizio's example</a>, if my syntax includes exponentials/hom-objects, then any interpration of the signature extends to an interpretation of the whole syntax/language in a nice way. But what about when that only sometimes holds? There may still be some valid models, but I have to prove that all of the interpretations of the syntax give well-defined structures <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 209224694,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1599397340
    },
    {
        "content": "<p>For example, any category with a terminal object contains a model of a group: the trivial group on the terminal object, since the product of the terminal object with itself is still the terminal object. But not every such category has products (or more generally, is a monoidal category).</p>",
        "id": 209224785,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1599397516
    },
    {
        "content": "<p>There is no general solution to this problem, but there are partial solutions. The main one is to look for subcategories which are closed under the required structure. In the exponential/hom-set example, we would need to look at subcategories of exponentiable objects. Some care must be taken to ensure that these categories still have the rest of the structure needed to interpret the syntax (eg we still need closure unter the monoidal product too!), and we won't always get <em>all</em> of the models of our theory this way. But when we get lucky, we'll find a big \"good\" subcategory where we can work safely with the structures we want to.</p>",
        "id": 209224986,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1599397824
    },
    {
        "content": "<p>Sorry for side-tracking the discussion this is the <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> this is the area of stuff I'm working on right now, and I felt a compulsion to write about it. I may move it elsewhere later <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span></p>",
        "id": 209225046,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1599397947
    },
    {
        "content": "<p>Wherever you do discuss this, please do continue! I have grad students implementing a lot of the underlying things you mention (various manipulations on signatures and languages, inside a host logic but also transporting between logics). We're walking a fine line between programming things for which we know there exists current meta-theory that says that what we're doing is meaningful, and hacking things up that 'seem' to work, but might be meaningless at the level of generality we're doing it [i.e. we're missing side conditions.]</p>\n<p>Including things like Zero objects for various theories (you mention group). I'm quite sure our constraints for the validity of that are not quite right. [Sometimes we don't care, as some meta-operations are not guaranteed to give non-trivial theories; but if they do non-trivial theories 'for free', that we surely would like to know.]</p>",
        "id": 209227093,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1599401556
    },
    {
        "content": "<p>For my current project I'm actually reverse-engineering a logic from a class of categories. If done successfully, this circumvents the kinds of problems that you're describing because by construction I will be able to interpret all of the syntax in my theory in the categories I care about. This hints at an alternative approach to the one I mentioned above: if your target category can't interpret all of the syntax in your theory, see if you can move down to a smaller fragment of logic, or across to a fragment which is sufficiently expressive for your purposes, and which <em>can</em> be interpreted in your target category.<br>\nAs a hypothetical example, suppose your categories don't have infinite unions of subobjects, but it <em>does</em> have power objects. That means that we can't interpret full geometric logic (which requires arbitrary small disjunctions of formulae to be interpretable), but we <em>can</em> interpret some second-order logic. Then we still have a way of talking about local rings, which can be axiomatised in either fragment (at least in a way that gives equivalent models in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">S</mi><mi mathvariant=\"bold\">e</mi><mi mathvariant=\"bold\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68611em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">S</span><span class=\"mord mathbf\">e</span><span class=\"mord mathbf\">t</span></span></span></span></span>).</p>",
        "id": 209230314,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1599407050
    },
    {
        "content": "<p>Making this kind of leap requires deep familiarity with the structural nature of your target category, though. When it comes to computer science, that means choosing a type theory/category of types, and doing the work to understand the consequences of such a choice. This is a world I find rather intimidating, so I need for context if I'm going to dive into it.</p>",
        "id": 209230582,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1599407417
    },
    {
        "content": "<p>Out of curiosity, what class of categories are you interested in (if you don't mind answering)? Or was your hypothetical example not so hypothetical?</p>",
        "id": 209237260,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1599419100
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276092\">Nathanael Arkor</span> <a href=\"#narrow/stream/229156-practice.3A-applied.20ct/topic/insecure.20semantics/near/209237260\">said</a>:</p>\n<blockquote>\n<p>Out of curiosity, what class of categories are you interested in (if you don't mind answering)?</p>\n</blockquote>\n<p>It's a class which I don't have a good name for, which I'm provisionally calling pre-regular, although that is a Bad Name since is already something by that name in the literature, and the link to regular categories is rather weak.</p>\n<p>Call an indexing category a <strong>funnel </strong> if it has a weakly terminal object. The categories I am looking at are those having all funneling colimits (colimits of diagrams indexed by funnels) and their class of strict epimorphisms is stable; I'm not assuming that pullbacks exist, but that any cospan where one leg is a strict epimorphism can be completed to a commutative square where the opposite side is also a strict epimorphism. Introducing them like this hides why this is a nice class to study, but you can already see that if such a category is to interpret a theory, then since it doesn't typically have finite limits or colimits, several of the most basic logical operations in algebraic, regular, coherent, geometric or first-order logic have to go out of the window.</p>",
        "id": 209268418,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1599466539
    },
    {
        "content": "<p>What are a couple of motivating examples of these categories?</p>",
        "id": 209289380,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1599481258
    },
    {
        "content": "<p>The objects isomorphic to quotients of representables in any presheaf topos form such a category. From that perspective, they present an alternative to completing sites under finite limits. Rather than giving more examples, I'll just plug the paper on \"supercompactly generated toposes\" that I'm hoping will be in a state to put online by the end of next week. The pursuit of a logic for these categories will form the basis for another paper which is already in the works <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 209291595,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1599482711
    },
    {
        "content": "<p>Looking forward to taking a look!</p>",
        "id": 209294884,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1599484888
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"277473\">@[Mod] Morgan Rogers</span> you asked about my context. I have not really tried to pin down a single target category. In fact, I am much more interested in a bunch of such categories (they probably form a lower semi-lattice). What I can about is the eventual functionality: I want to be able to write things in a reasonable meta-language that can then be interpreted in Agda, Coq, Isabelle/HOL, HOL-Light, and so on. A preview of that can seen from our preliminary work at CICM 2020 <a href=\"https://arxiv.org/abs/2006.09292\">paper</a>. </p>\n<p>I see as being able to reason about structured syntax (and its eventual interpretation).</p>\n<p>A good test of such a framework (that Universal Algebra fails) is to take the dependently-typed definition of a Category and automatically derive the definition of its homomorphisms (aka Functors), the homomorphisms of those (aka Natural Transformations), and from the definition of equivalence of categories. In theory, I think I know how, but I don't have adequate meta-theory that justifies all the steps. Of course, it should equally well apply to a very large set of 'theories' defined in the same meta-language.</p>",
        "id": 209295941,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1599485556
    },
    {
        "content": "<p>Do you mean you want to prove that a definition of homomorphism is the correct one, internal to the programming language the framework is written in, or would an external proof be sufficient?</p>",
        "id": 209296489,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1599485894
    },
    {
        "content": "<p>(Because the correct definition of homomorphism will be given by an interpretation of the theory of categories, e.g. as a GAT, in itself — but perhaps this is not sufficient for your purposes.)</p>",
        "id": 209296709,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1599486014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296322\">Jacques Carette</span> <a href=\"#narrow/stream/229156-practice.3A-applied.20ct/topic/insecure.20semantics/near/209295941\">said</a>:</p>\n<blockquote>\n<p>I want to be able to write things in a reasonable meta-language that can then be interpreted in Agda, Coq, Isabelle/HOL, HOL-Light, and so on.</p>\n</blockquote>\n<p>I figured it would be something like this: each of these languages is built on a different type theory. A quick google mentions \"unified theory of dependent types\", \"predicative Calculus of (co)Inductive Constructions\" and \"weak type theory\" for the first three respectively. I don't know the details of any of these, but I can still make general comments: the type constructions you need in order to express (generalised) algebraic theories are some of the most basic ones, so most if not all of the type theories employed in functional programming languages will interpret them; you won't have any trouble just building models of these theories. What you were saying about results regarding the categories of these things, on the other hand, will be more subtle. Certainly such results are constrained by the corresponding properties (existence of limits etc) in the underlying category of types.</p>",
        "id": 209297627,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1599486550
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276092\">@Nathanael Arkor</span> I want to <em>generate</em> the definition of homomorphism. A la Universal Algebra. Eventually, I want a Universal-Algebra like theory of manipulations of GATs into (parametrized) GATs. </p>\n<p>It's probably worthwhile mentioning that I really want the computer scientist's approach to all of this. It's all about folds and syntactic manipulations, backed by a meta-theory that says that the syntactic manipulations have a good denotational semantics.</p>",
        "id": 209299076,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1599487425
    },
    {
        "content": "<p>The definition of homomorphism is given inductively by the definition of (endo-)\"interpretation of a GAT\" in Cartmell's paper. If you define a group as a GAT, and look at the definition of interpretation of the GAT of groups in the GAT of groups, it should be the classical definition of a group homomorphism (and likewise for non-algebraic structures). The approach of Cartmell is already very syntactic (some would say too syntactic).</p>",
        "id": 209300466,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1599488189
    },
    {
        "content": "<p>In what sense are you using the term \"parameterised GAT\"?</p>",
        "id": 209300502,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1599488219
    },
    {
        "content": "<p>I need to reread Cartmell. </p>\n<p>By parametrized, I mean that the GAT has a non-empty context. The definition of homomorphism assumes two structures are in context. Putting them in the GAT itself (via a Sigma type) is a hack.</p>",
        "id": 209301099,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1599488567
    },
    {
        "content": "<p>Or maybe an example like \"a monoidal structure on a given category\"?</p>",
        "id": 209301270,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599488660
    },
    {
        "content": "<blockquote>\n<p>The definition of homomorphism assumes two structures are in context.</p>\n</blockquote>\n<p>Right, you have to have two definitions: of a GAT, and a GAT homomorphism (which is defined in terms of a source and target).</p>\n<blockquote>\n<p>Putting them in the GAT itself (via a Sigma type) is a hack.</p>\n</blockquote>\n<p>I think this is more than a hack: it ought to establish that the category of GATs is cartesian-closed (though I don't believe this has been worked out anywhere).</p>",
        "id": 209301893,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1599489108
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276480\">@Reid Barton</span> I'm not sure I understand your suggestion?</p>\n<p><span class=\"user-mention\" data-user-id=\"276092\">@Nathanael Arkor</span> I agree that the fact that the category of GATs is (likely) cartesian-closed is not a hack. This is however related to the bundling-unbundling problem that most proof assistants have. One issue with internalizing the parameters is that it forces the universe level up, which is definitely undesirable.</p>",
        "id": 209385663,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1599571699
    },
    {
        "content": "<p>Just an example where you'd want to consider additional algebraic structure in the context of some already existing algebraic structure.<br>\nYour example of homomorphisms seems a bit too special because presumably the notion of homomorphism of structures has a special status.</p>",
        "id": 209386086,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599571899
    },
    {
        "content": "<p>There's also 'signature' (strip out the equations), 'term algebra' (which come in different variations depending on how you parametrize by a theory of free variables), product theory, 'evaluator' (from the term language back into the theory), 'staged terms' (which mix both the term algebra and the language), induction principle, recursor, relational interpretation, and many more.  We've got about 1/3 of our list implemented.</p>\n<p>Our library of 227 theories (spanning 316 lines of code) becomes a library of 5047 definitions which, when pretty-printed, take up 106468 lines of code.  Current practice would have those 100K lines written by a human. The actual 'information content' is much, much smaller.</p>",
        "id": 209388697,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1599573163
    },
    {
        "content": "<p>With those numbers, I can see why one would put the effort into building a universal library! I appreciate what you're trying to do.</p>\n<p>I think the cartesian-closed structure of a category of GATs doesn't quite give you what you want for homomorphisms. I worked it out to be the following... For algebraic theories <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">T</mi><mo separator=\"true\">,</mo><msup><mi mathvariant=\"double-struck\">T</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{T},\\mathbb{T}'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.946332em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">T</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">T</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> over respective signatures <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Σ</mi><mo separator=\"true\">,</mo><msup><mi mathvariant=\"normal\">Σ</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\Sigma,\\Sigma'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.946332em;vertical-align:-0.19444em;\"></span><span class=\"mord\">Σ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">Σ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span>, a model of the theory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi mathvariant=\"double-struck\">T</mi><mo separator=\"true\">,</mo><msup><mi mathvariant=\"double-struck\">T</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[\\mathbb{T},\\mathbb{T}']</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.001892em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathbb\">T</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">T</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> consists of a mapping <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> between the signatures (sorts to sorts, function symbols to function symbols), a model <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">T</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{T}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">T</span></span></span></span></span>, a model <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">A'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">T</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{T}'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">T</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span>, and functions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>α</mi><mi>S</mi></msub><mo>:</mo><mi>A</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo><mo>→</mo><msup><mi>A</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">(</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\alpha_S: A(S) \\to A'(F(S))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.001892em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> for each sort <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Σ</mi></mrow><annotation encoding=\"application/x-tex\">\\Sigma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Σ</span></span></span></span>, such that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>S</mi><mo>→</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">f:S \\to T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> is a function symbol in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Σ</mi></mrow><annotation encoding=\"application/x-tex\">\\Sigma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Σ</span></span></span></span>, we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>α</mi><mi>T</mi></msub><mo>∘</mo><mi>A</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>A</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">(</mo><mi>F</mi><mi>f</mi><mo stretchy=\"false\">)</mo><mo>∘</mo><msub><mi>α</mi><mi>S</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\alpha_{T} \\circ A(f) = A'(Ff) \\circ \\alpha_S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.59445em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.001892em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.<br>\nThat not only involves going up a level, understanding the collections of sorts and function symbols of a signature as types rather than fundamental, it also includes too much stuff: I don't want homomorphisms to be allowed to swap two sorts or two function symbols of a theory.</p>",
        "id": 209392466,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1599574796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296322\">Jacques Carette</span> <a href=\"#narrow/stream/229156-practice.3A-applied.20ct/topic/insecure.20semantics/near/209299076\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276092\">Nathanael Arkor</span> I want to <em>generate</em> the definition of homomorphism. A la Universal Algebra. Eventually, I want a Universal-Algebra like theory of manipulations of GATs into (parametrized) GATs. </p>\n<p>It's probably worthwhile mentioning that I really want the computer scientist's approach to all of this. It's all about folds and syntactic manipulations, backed by a meta-theory that says that the syntactic manipulations have a good denotational semantics.</p>\n</blockquote>\n<p>Have you read \"Constructing Quotient Inductive-Inductive Types\" (<a href=\"https://akaposi.github.io/finitaryqiit.pdf\">https://akaposi.github.io/finitaryqiit.pdf</a>) ? It seems to be exactly what you ask for.</p>",
        "id": 209479187,
        "sender_full_name": "Rafaël Bocquet",
        "timestamp": 1599636375
    },
    {
        "content": "<p>I have. And I've had conversations with the authors.  </p>\n<p>It solves a different, interesting problem. Of course, 'solves' here is a big word, since none of the systems that I'm interested in actually implement QIIT !</p>\n<p>The structures that I want to generate \"fit\" in the current systems. So new structures are not needed.</p>",
        "id": 209498351,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1599650630
    }
]