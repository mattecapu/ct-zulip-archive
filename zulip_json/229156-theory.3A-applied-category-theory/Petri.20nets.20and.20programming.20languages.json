[
    {
        "content": "<p>I had no idea, but that makes sense given Scala's focus on FP for the purpose of achieving parallel computing.</p>",
        "id": 198761938,
        "sender_full_name": "James Fairbanks",
        "timestamp": 1590500009
    },
    {
        "content": "<p>I had no idea either. I keep seeing petri-nets pop up here and there but not realizing their relation to programming I had no Idea what they were: so I never looked there. Now I have a reason.  <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span><br>\nThis is actually the way I am guiding my research into (applied) category theory. I try to find out which categories relate to tools or problems in computing (and in philosophy) I have come across and when I find a few interesting relations I can then sketchily estimate  the value of looking into them and the time it would take to learn it superficially and then in more detail if I find that it fits. With time of course I find more and more connections.</p>\n<p>This makes me think that for the applied-CT what would be useful would be to build a map of such relations, so that people could find out where CT could help them.</p>",
        "id": 198763197,
        "sender_full_name": "Henry Story",
        "timestamp": 1590500635
    },
    {
        "content": "<p>a petri net is like a quiver where the source and target of each edge is a <em>formal sum</em> of vertices</p>",
        "id": 198822011,
        "sender_full_name": "sarahzrf",
        "timestamp": 1590527376
    },
    {
        "content": "<p>so they're nice for freely generating \"commutative monoidal categories\" in the same way that quivers are nice for freely generating categories</p>",
        "id": 198822118,
        "sender_full_name": "sarahzrf",
        "timestamp": 1590527424
    },
    {
        "content": "<p>or, e.g., a \"prenet\" is like a quiver where the source and target of each edge is a <em>word</em> of vertices</p>",
        "id": 198822214,
        "sender_full_name": "sarahzrf",
        "timestamp": 1590527496
    },
    {
        "content": "<p>so these are nice for freely generating ordinary non-symmetric monoidal categories</p>",
        "id": 198822239,
        "sender_full_name": "sarahzrf",
        "timestamp": 1590527511
    },
    {
        "content": "<p>actually, for any lawvere theory Q you can pull this off—you can define some kind of \"net\" which is like a quiver but with edges that go between <em>elements of the free model of Q on the set of vertices</em>, and this is good for freely generating categories that have Q-like structure</p>",
        "id": 198822503,
        "sender_full_name": "sarahzrf",
        "timestamp": 1590527604
    },
    {
        "content": "<p>here is a cool paper about it by <span class=\"user-mention\" data-user-id=\"276037\">@Jade Master</span> <a href=\"https://arxiv.org/abs/1904.09091\">https://arxiv.org/abs/1904.09091</a></p>",
        "id": 198822524,
        "sender_full_name": "sarahzrf",
        "timestamp": 1590527622
    },
    {
        "content": "<p>Hello I have been summoned <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span><span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 198822745,
        "sender_full_name": "Jade Master",
        "timestamp": 1590527744
    },
    {
        "content": "<p>Yeah my perspective on Petri nets is basically that they are graphs whose vertices are allowed to be fancier.</p>",
        "id": 198822869,
        "sender_full_name": "Jade Master",
        "timestamp": 1590527824
    },
    {
        "content": "<p>Instead of calling your generalized Petri nets \"Q-nets\" maybe you should have called them \"fancy graphs\".</p>",
        "id": 198822982,
        "sender_full_name": "John Baez",
        "timestamp": 1590527897
    },
    {
        "content": "<p>I asked Odersky if Petri-nets was still something he thought as contributing to Scala3. And he wrote:</p>\n<blockquote>\n<p>Oh, that’s been a while! No there are no current plans to continue on that front.</p>\n</blockquote>\n<p>Still the <a href=\"http://lampwww.epfl.ch/fn/\">functional nets</a> page is an intriguing historical document. But it may be that there is some library in Scala that is motivated by it... I'll need to research further.</p>",
        "id": 198920234,
        "sender_full_name": "Henry Story",
        "timestamp": 1590598449
    },
    {
        "content": "<p>There was an excellent talk <a href=\"https://www.youtube.com/watch?list=PLCOXjXDLt3pYot9VNdLlZqGajHyZUywdI&amp;time_continue=1&amp;v=cJfasciuCIs&amp;feature=emb_logo\">Whole Grain Petri Nets</a> by <span class=\"user-mention\" data-user-id=\"276625\">@Joachim Kock</span> last week at the Applied Category Theory online conference. Looking at it I remembered <span class=\"user-mention\" data-user-id=\"276424\">@GUI</span> 's link from a few months ago (above) to Martin Odersky's (father of Scala) early <a href=\"http://lampwww.epfl.ch/fn/\">work on Functional Nets</a>. So today I started reading the 2000 paper <a href=\"http://lampwww.epfl.ch/papers/esop2000.ps.gz\">Functional Nets</a>. </p>\n<ol>\n<li>Having watched the talk I can now understand the paper (which I could not really before). </li>\n<li>The current Scala syntax is actually remarkably similar to the syntax used in that paper.</li>\n</ol>\n<p>I could not clearly follow the second half of <span class=\"user-mention\" data-user-id=\"276625\">@Joachim Kock</span>'s talk  even though I know a bit of HoTT, but I guess that will be easier when I read the paper.  I wonder if Joachim's work has implications for Odersky's work on functional nets from 2000, and if he could have gone further with that idea had he known about it then.<br>\nDid I say the talk was really good? It is worth watching just  for the presentation style.</p>\n<p>PS. In mathematics sometimes it takes 3 months for something to go click! Sometimes 20, sometimes 2000. One has to be patient in this field :-)</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"cJfasciuCIs\" href=\"https://www.youtube.com/watch?list=PLCOXjXDLt3pYot9VNdLlZqGajHyZUywdI&amp;time_continue=1&amp;v=cJfasciuCIs&amp;feature=emb_logo\"><img src=\"https://i.ytimg.com/vi/cJfasciuCIs/default.jpg\"></a></div>",
        "id": 204344280,
        "sender_full_name": "Henry Story",
        "timestamp": 1595156805
    },
    {
        "content": "<p>Here is a passage from Odersky's year 2000 paper that seems relevant</p>\n<blockquote>\n<p>Functional nets are considerably more powerful than conventional Petri nets, however. First, function applications in a functional net can have arguments, whereas tokens in a Petri net are unstructured. Second, functions in a functional net can be higher-order, in that they can have functions as their arguments. In Petri nets, such self-referentiality is not possible. Third, definitions in a functional net can be nested inside rewrite rules, such that evolving net topologies are possible. A Petri-net, on the other hand, has a fixed connection structure.</p>\n</blockquote>",
        "id": 204345055,
        "sender_full_name": "Henry Story",
        "timestamp": 1595158000
    },
    {
        "content": "<p>The paragraph just after mentions Colored Petri nets (I guess this is why <span class=\"user-mention\" data-user-id=\"276625\">@Joachim Kock</span> was using colors in his slides.)</p>\n<blockquote>\n<p>Colored Petri nets [24] let one pass parameters along the arrows connecting places with transitions. These nets are equivalent to first-order functional nets with only global definitions. They still cannot express the higher-order and evo- lution aspects of functional nets. Bussi and Asperti have translated join calculus ideas into standard Petri net formalisms. Their mobile Petri nets [4] support first-class functions and evolution, and drop at the same time the locality re- strictions of join calculus and functional nets. That is, their notation separates function name introduction from rewrite rule definition, and allows a function to be defined collectively by several unrelated definitions.</p>\n</blockquote>",
        "id": 204345085,
        "sender_full_name": "Henry Story",
        "timestamp": 1595158078
    },
    {
        "content": "<p>I guess an important point half way through</p>\n<blockquote>\n<p>Functional nets have their formal basis in join calculus</p>\n</blockquote>",
        "id": 204350225,
        "sender_full_name": "Henry Story",
        "timestamp": 1595165616
    },
    {
        "content": "<p>Yes, functional nets are way more powerful than Petri nets. Still, this is not always an advantage, especially if you care about model checking.</p>",
        "id": 204350358,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595165801
    },
    {
        "content": "<p>In my experience at Statebox, it has turned out that a whole lot of CompSci can be done in a Turing incomplete setting. Petri nets are a great tool because they allow you to orchestrate tasks while retaining nice model checking features</p>",
        "id": 204350386,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595165864
    },
    {
        "content": "<p>I am at the point where I am happy to find a link between petri nets and a programming language (even better one that I use a lot!). That helps make sense of both. (definitely a link to add to the engineering nlab mentioned at the conference).  :-)</p>",
        "id": 204350547,
        "sender_full_name": "Henry Story",
        "timestamp": 1595166118
    },
    {
        "content": "<p><a href=\"https://arxiv.org/abs/1906.07629\">https://arxiv.org/abs/1906.07629</a></p>",
        "id": 204350596,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595166207
    },
    {
        "content": "<p>This is the best I can provide atm.</p>",
        "id": 204350599,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595166212
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> <a href=\"#narrow/stream/229156-practice.3A-applied.20ct/topic/Petri.20nets.20and.20programming.20languages/near/204350386\">said</a>:</p>\n<blockquote>\n<p>In my experience at Statebox, it has turned out that a whole lot of CompSci can be done in a Turing incomplete setting. </p>\n</blockquote>\n<p>That must be related to the <a href=\"https://www.w3.org/2001/tag/doc/leastPower-2006-01-23.html\">W3C Principle of Least Power</a> finding.<br>\nIt may be there are mathematical principles behind that finding and your experience at Statebox. That could be of interest to the W3C Technical Architecture Group.</p>",
        "id": 204350649,
        "sender_full_name": "Henry Story",
        "timestamp": 1595166247
    },
    {
        "content": "<p>What is interesting is that one the Web we started with a declarative systems that worked really well, where the principle of least power holds and is important, and then slowly JavaScript - a turing complete language - entered the picture and the original wisdom is being forgotten. So it would be useful to have some criteria as to when one should go one way rather than the other. (perhaps something for a <a href=\"https://web-cats.gitlab.io/\">WebCats channel</a> I was thinking of setting up here when I joined)</p>",
        "id": 204351665,
        "sender_full_name": "Henry Story",
        "timestamp": 1595167386
    },
    {
        "content": "<p>Since the thread topic is Petri nets and programming languages, should mention that Ada has built-in semantics for the PN place-transition notation in the form of the task rendezvous notation.  This is an early paper which shows some of the inspiration for the syntax and making the complete connection, primarily based on the idea of Communicating Sequential Processes by C.A.R. Hoare.  <a href=\"https://pdfs.semanticscholar.org/520a/1f7a3ffb5bc7ae7a04955ec79d3051c505fa.pdf\">https://pdfs.semanticscholar.org/520a/1f7a3ffb5bc7ae7a04955ec79d3051c505fa.pdf</a>  BTW, I have a large Ada library on github called the PetriNet Ada Component Environment that I have used over the years to simulate real-time multi-threaded robotic  applications.</p>",
        "id": 204479953,
        "sender_full_name": "Paul Pukite",
        "timestamp": 1595281401
    },
    {
        "content": "<p>And this paper by Shatz in IEEE Computer  --  Shatz. (1984). Communication Mechanisms for Programming Distributed Systems. Computer, 17(6), 21–28. doi:10.1109/mc.1984.1659159</p>",
        "id": 204488492,
        "sender_full_name": "Paul Pukite",
        "timestamp": 1595282053
    },
    {
        "content": "<p>Half way through his paper on Functional Nets Martin Odersky brings in the Join Calculus. I had heard of it vaguely, but never understood what it was meant to do. Odersky even wrote a library for it, which I think every advanced Scala programmer has looked at, but wondering how it was meant to be used. </p>\n<p>But now with the help of the Whole Grain Petri Nets talk, and the other talks at the Applied Category Theory Conference I felt that I was understanding what was going on. So I looked around if anything had been done in scala on this, and I found at talk 4 years ago <a href=\"https://www.youtube.com/watch?v=T2U2Uj5fXkU\">Concurrent Join Calculus in Scala</a> by Sergei Winitzki author of <a href=\"https://sites.google.com/site/winitzki/sofp\">The Science of Functional Programming</a> that came out last year. This was another very clear explanation. (A bit slow perhaps). Together with the Whole Grain talk I think that could form a very good introduction to the subject for newbies. <br>\nHe does ask the question why these have not been used that much, and gives a list of many implementations. Could it be that Petri Nets really shine for modeling things such as Pandemics? <span class=\"user-mention\" data-user-id=\"275927\">@James Fairbanks</span>'s talk <a href=\"https://twitter.com/bblfish/status/1284951417837543436\">compositional Scientific Computing</a> suggests so.</p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/bblfish/status/1284951417837543436\"><img class=\"twitter-avatar\" src=\"https://pbs.twimg.com/profile_images/1004326761608417281/HjxjS9BX_normal.jpg\"></a><p>Petri-Nets can be used to model Epidemics. This talk by <a href=\"https://twitter.com/fairbanksjp\">@fairbanksjp</a> shows how by extending #Julia (a scientific programming language) with categories of Petri Nets, one could quickly put complex multi-dimensional models for #Covid19 together. <a href=\"https://twitter.com/ejpatters\">@ejpatters</a>\n<a href=\"https://t.co/erflG8fjJo\">https://www.youtube.com/watch?v=Q5BzzkNDpPE&amp;list=PLCOXjXDLt3pYot9VNdLlZqGajHyZUywdI&amp;index=27&amp;t=0s</a></p><span>- The 🐟‍‍ BabelFish (@bblfish)</span></div></div><div class=\"youtube-video message_inline_image\"><a data-id=\"T2U2Uj5fXkU\" href=\"https://www.youtube.com/watch?v=T2U2Uj5fXkU\"><img src=\"https://i.ytimg.com/vi/T2U2Uj5fXkU/default.jpg\"></a></div>",
        "id": 204556720,
        "sender_full_name": "Henry Story",
        "timestamp": 1595342968
    },
    {
        "content": "<p>I think that one of the reasons that people haven't used Petri Nets for real programming is that they lack abstraction, until recently we haven't had the tools for boxing up a Petri Net as a subroutine in a bigger Net. I think this is the biggest advance of ACT the ability to take lots of mathematical things that look flat (ie. Petri Nets, Graphs, Networks, Circuits) and give them hierarchy. That is driving a lot of the work on AlgebraicJulia right now.</p>",
        "id": 204557298,
        "sender_full_name": "James Fairbanks",
        "timestamp": 1595343201
    },
    {
        "content": "<p>In this talk from April <a href=\"https://www.youtube.com/watch?v=QpWaSaYSyXw&amp;t=1790s\">Structured Cospans and Double Categories</a> where <span class=\"user-mention\" data-user-id=\"275920\">@John Baez</span> talks about how to compose Petri Nets as mentioned by James Fairbanks above, a question came up as to their relation to Operads. John says there is bound to be a relation there, though he had not worked it out yet.<br>\nI mention this because I recently used <a href=\"https://doc.akka.io/docs/akka/current/stream/stream-composition.html\">Akka Streams</a> to write a simple Web Crawler and they had images that reminded me of things I had seen in Category Theory about gluing processes together, and I was told those looked like Operads. Here is a diagram <br>\n<a href=\"user_uploads/21317/6Uas7CtEJ6CF5TX7pisDdLSE/image.png\">composite.png</a> and another <a href=\"/user_uploads/21317/FcIP4r95EuPG2stJ74-Ad-wC/image.png\">image.png</a> where the pieces are glued together and the main code for the crawler starting from a source of some uris is </p>\n<div class=\"message_inline_image\"><a href=\"user_uploads/21317/6Uas7CtEJ6CF5TX7pisDdLSE/image.png\" title=\"composite.png\"><img src=\"user_uploads/21317/6Uas7CtEJ6CF5TX7pisDdLSE/image.png\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/21317/FcIP4r95EuPG2stJ74-Ad-wC/image.png\" title=\"image.png\"><img src=\"/user_uploads/21317/FcIP4r95EuPG2stJ74-Ad-wC/image.png\"></a></div><div class=\"codehilite\"><pre><span></span><code>    <span class=\"k\">def</span> <span class=\"n\">crawlerSource</span><span class=\"o\">(</span><span class=\"n\">uris</span><span class=\"k\">:</span> <span class=\"kt\">AkkaUri*</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Source</span><span class=\"o\">[</span><span class=\"kt\">GraphImports</span><span class=\"p\">,</span> <span class=\"kt\">NotUsed</span><span class=\"o\">]</span> <span class=\"k\">=</span>\n        <span class=\"nc\">Source</span>\n            <span class=\"o\">.</span><span class=\"n\">fromGraph</span><span class=\"o\">(</span><span class=\"nc\">GraphDSL</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"o\">()</span> <span class=\"o\">{</span> <span class=\"k\">implicit</span> <span class=\"n\">builder</span> <span class=\"k\">=&gt;</span>\n                <span class=\"k\">import</span> <span class=\"nn\">GraphDSL.Implicits._</span>\n                <span class=\"k\">val</span> <span class=\"n\">merge</span> <span class=\"k\">=</span> <span class=\"n\">builder</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"o\">(</span>\n                    <span class=\"nc\">Merge</span><span class=\"o\">[</span><span class=\"kt\">AkkaUri</span><span class=\"o\">](</span><span class=\"mi\">2</span><span class=\"o\">).</span><span class=\"n\">addAttributes</span><span class=\"o\">(</span><span class=\"nc\">Attributes</span><span class=\"o\">.</span><span class=\"n\">inputBuffer</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">8192</span><span class=\"o\">))</span>\n                    <span class=\"o\">)</span>\n                <span class=\"k\">val</span> <span class=\"n\">bcast</span> <span class=\"k\">=</span> <span class=\"n\">builder</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"o\">(</span><span class=\"nc\">Broadcast</span><span class=\"o\">[</span><span class=\"kt\">GraphImports</span><span class=\"o\">](</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"kc\">true</span><span class=\"o\">).</span><span class=\"n\">async</span><span class=\"o\">)</span>\n                <span class=\"k\">val</span> <span class=\"n\">filterCntr</span> <span class=\"k\">=</span> <span class=\"n\">builder</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">FilterDuplicateURIsCounter</span><span class=\"o\">(</span><span class=\"n\">uris</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"o\">))</span>\n\n                <span class=\"k\">val</span> <span class=\"n\">in</span> <span class=\"k\">=</span> <span class=\"nc\">Source</span><span class=\"o\">(</span><span class=\"n\">uris</span><span class=\"o\">)</span>\n\n                <span class=\"n\">in</span> <span class=\"o\">~&gt;</span> <span class=\"n\">merge</span> <span class=\"o\">~&gt;</span> <span class=\"n\">uri2graphFlow</span> <span class=\"o\">~&gt;</span> <span class=\"n\">owlImportURLs</span> <span class=\"o\">~&gt;</span> <span class=\"n\">filterCntr</span> <span class=\"o\">~&gt;</span> <span class=\"n\">bcast</span><span class=\"o\">.</span><span class=\"n\">in</span>\n                      <span class=\"n\">merge</span>                <span class=\"o\">&lt;~</span> <span class=\"n\">getUris</span>                       <span class=\"o\">&lt;~</span> <span class=\"n\">bcast</span><span class=\"o\">.</span><span class=\"n\">out</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n                <span class=\"nc\">SourceShape</span><span class=\"o\">(</span><span class=\"n\">bcast</span><span class=\"o\">.</span><span class=\"n\">out</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">))</span>\n            <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>The <code>input</code> is sent to a <code>merge</code> component that merges the flow from <code>getUris</code> and from <code>in</code>. <code>merge</code> sends it on to <code>uri2graphFlow</code> which fetches each URI asynchronously on the web. <code>owlImportURLs</code> finds the <code>owl:imports</code> relations in the graph and spits out pairs of <code>Try[ (Graph,URLs)]</code>. (Try because fetching may have failed). The <code>filterCounter</code> counts urls send out and coming in so that it knows to stop the process and filters those already seen.  A <code>broadcast</code> component sends the flow in two directions: (0) to the output and (1) to a filter that retains just the urls of the pair.<br>\nI wonder if this is an instance of one of these concepts.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"QpWaSaYSyXw\" href=\"https://www.youtube.com/watch?v=QpWaSaYSyXw&amp;t=1790s\"><img src=\"https://i.ytimg.com/vi/QpWaSaYSyXw/default.jpg\"></a></div>",
        "id": 204582598,
        "sender_full_name": "Henry Story",
        "timestamp": 1595355207
    },
    {
        "content": "<p>\" I think this is the biggest advance of ACT the ability to take lots of mathematical things that look flat (ie. Petri Nets, Graphs, Networks, Circuits) and give them hierarchy. \"</p>\n<p>If I am not misinterpreting the remark, the entire logical circuit design industry hinges on being able to create massive hierarchical component structures using what are essentially programming languages such as VHDL. e.g.:</p>\n<p>Fernandes, J.M., Adamski, M. and Proenca, A.J., 1997. VHDL generation from hierarchical Petri net specifications of parallel controllers. IEE Proceedings-Computers and Digital Techniques, 144(2), pp.127-137.  <a href=\"https://digital-library.theiet.org/content/journals/10.1049/ip-cdt_19970845\">https://digital-library.theiet.org/content/journals/10.1049/ip-cdt_19970845</a></p>",
        "id": 204624519,
        "sender_full_name": "Paul Pukite",
        "timestamp": 1595384581
    },
    {
        "content": "<p>So I think this is a crucial point in general. Being able to black box bits of complex network, as long as they're composed in an obvious way like joining wires together, is an extremely obvious thing to do and it would be pretty much unbelievable to claim nobody did it before. So what do we have that's new? One thing we have is a decently behaved algebraic theory of composing black boxes, so we can hope that there's something interesting to say that you need those more advanced tools for vs the obvious naive thing. But that doesn't happen automatically...</p>",
        "id": 204638418,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1595404266
    },
    {
        "content": "<p>The other thing we have going for us is that with ACT methods we can also treat semantics compositionally on the same footing as syntax/networks/diagrams/circuits etc, I think it's much less likely that someone would naively come up with something equivalent to semantic span categories for example.</p>",
        "id": 204638532,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1595404376
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"275901\">@Jules Hedges</span> is there a good presentation of semantic span categories?</p>",
        "id": 204640785,
        "sender_full_name": "Henry Story",
        "timestamp": 1595406349
    },
    {
        "content": "<p>Not that I can think of. I mean, roughly, things that look like generalised relations</p>",
        "id": 204641061,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1595406546
    },
    {
        "content": "<p>An approximate rule of thumb (this isn't precise and probably shouldn't be load-bearing) is that syntax is cospan-ish and semantics is span-ish</p>",
        "id": 204641110,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1595406598
    },
    {
        "content": "<p>I need to learn Spanish. co-spanish is probably english I guess. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 204641183,
        "sender_full_name": "Henry Story",
        "timestamp": 1595406639
    },
    {
        "content": "<p>Jokes aside. I was reading a lot about coalgebras a year or two ago. When I see a Petri Net I would have first seen them as coalgebras, since they have state and move from one state to the other. Is that also a good way to look at them? Is there something lost in translation? (Looking at the index of Bart Jacbos \"Introduction to Coalgebra\" there is a reference to petri nets on the first page, but only there)</p>",
        "id": 204641876,
        "sender_full_name": "Henry Story",
        "timestamp": 1595407170
    },
    {
        "content": "<p>For sure that should be a thing. Maybe one of the petri nets people knows a standard reference for it</p>",
        "id": 204642530,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1595407647
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"320339\">Paul Pukite</span> <a href=\"#narrow/stream/229156-practice.3A-applied.20ct/topic/Petri.20nets.20and.20programming.20languages/near/204624519\">said</a>:</p>\n<blockquote>\n<p>\" I think this is the biggest advance of ACT the ability to take lots of mathematical things that look flat (ie. Petri Nets, Graphs, Networks, Circuits) and give them hierarchy. \"</p>\n<p>If I am not misinterpreting the remark, the entire logical circuit design industry hinges on being able to create massive hierarchical component structures using what are essentially programming languages such as VHDL. e.g.:</p>\n<p>Fernandes, J.M., Adamski, M. and Proenca, A.J., 1997. VHDL generation from hierarchical Petri net specifications of parallel controllers. IEE Proceedings-Computers and Digital Techniques, 144(2), pp.127-137.  <a href=\"https://digital-library.theiet.org/content/journals/10.1049/ip-cdt_19970845\">https://digital-library.theiet.org/content/journals/10.1049/ip-cdt_19970845</a></p>\n</blockquote>\n<p>I am always wary of hierarchical Petri nets. People are very eager to describe all the possible ways we can compose Petri nets together, but there is something we have to <strong>always</strong> keep in mind: Petri nets are useful as long as their reachability semantics doesn't go out of hand. When this happens, they are literally worth nothing in practice, since they lose all their \"predictive\" power. A lot of hiearchical definitions for Petri nets are very problematic from this point of view. This is a nice paper on the topic: <a href=\"https://www.researchgate.net/publication/262001792_A_Survey_of_Decidability_Results_for_Elementary_Object_Systems\">https://www.researchgate.net/publication/262001792_A_Survey_of_Decidability_Results_for_Elementary_Object_Systems</a></p>",
        "id": 204649128,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595412872
    },
    {
        "content": "<p>In general, this is one of my main concerns with the theory of composing systems: In many real life applications it is easy to obtain notions of compositions that are practically useless. This is why we need a strict collaboration with people that use the things we compose on a daily basis.</p>",
        "id": 204649209,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595412951
    },
    {
        "content": "<p>I think circuits work for building computers because they are compositional. If Intel had to think about circuits at the level of individual transistors, they would never be able to build processors.</p>\n<p>Petri nets have their flat structure of states and transitions and you need a tool like ACT to tell you how to put a useful hierarchy on them. For example if you want reaction network semantics, you can give them a hypergraph category structure for glueing along species. Then you get an Operad of wiring diagrams that you can use to design complex chemical systems. If you don’t put a hierarchy on your reaction networks it gets very hard to manage even relatively small systems.</p>",
        "id": 204657130,
        "sender_full_name": "James Fairbanks",
        "timestamp": 1595419875
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275927\">James Fairbanks</span> <a href=\"#narrow/stream/229156-practice.3A-applied.20ct/topic/Petri.20nets.20and.20programming.20languages/near/204657130\">said</a>:</p>\n<blockquote>\n<p>If Intel had to think about circuits at the level of individual transistors, they would never be able to build processors.</p>\n</blockquote>\n<p>I suspect that for a modern CPU there are significant failures of compositionality, coming from electromagnetic interaction effects between neighbouring components</p>",
        "id": 204657297,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1595419994
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275901\">Jules Hedges</span> <a href=\"#narrow/stream/229156-practice.3A-applied.20ct/topic/Petri.20nets.20and.20programming.20languages/near/204657297\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"275927\">James Fairbanks</span> <a href=\"#narrow/stream/229156-practice.3A-applied.20ct/topic/Petri.20nets.20and.20programming.20languages/near/204657130\">said</a>:</p>\n<blockquote>\n<p>If Intel had to think about circuits at the level of individual transistors, they would never be able to build processors.</p>\n</blockquote>\n<p>I suspect that for a modern CPU there are significant failures of compositionality, coming from electromagnetic interaction effects between neighbouring components</p>\n</blockquote>\n<p>Correct.</p>",
        "id": 204659816,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595421696
    },
    {
        "content": "<p>Actually the CPU example is really a good one, because the current CPU design status is awful, exectly because people blackbox stuff in a compositional algebra style without thinking about their semantics</p>",
        "id": 204659942,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595421772
    },
    {
        "content": "<p>Did you ever hear of RowHammer? It's an attack on Intel CPUs which depends on design flaws so embedded and radicated in intel's CPU architecture that there's very little to do about them.</p>",
        "id": 204660019,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595421826
    },
    {
        "content": "<p>Literally the family of RowHammer attacks grows by the day and no one has a decisive answer to fix the problem once and for all.</p>",
        "id": 204660126,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595421885
    },
    {
        "content": "<p>Long story short: Blackboxing things to compose them is not something new that ACT discovered. This is literally how engineering works since the beginning of time. The novelty is - or should be-  doing so in a way that is compositional with respect to the implications that composition has on semantics and model checking.</p>",
        "id": 204660195,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595421950
    },
    {
        "content": "<p>Oh I guess I don’t need to learn category theory because it apparently useless.</p>",
        "id": 204660882,
        "sender_full_name": "James Fairbanks",
        "timestamp": 1595422394
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"276438\">@Fabrizio Genovese</span> , I was wondering why there was talk of semantics in the various online lectures I saw recently on Petri-Nets, and so I missed that dimension (not a big problem, as I am just discovering them). I can already see how it could be useful in circuit modeling, without understanding how.<br>\nIs there an example of how the compositionally in semantics and model checking could improve pandemic simulation tools, as it is a topical subject?</p>",
        "id": 204660922,
        "sender_full_name": "Henry Story",
        "timestamp": 1595422428
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275927\">James Fairbanks</span> <a href=\"#narrow/stream/229156-practice.3A-applied.20ct/topic/Petri.20nets.20and.20programming.20languages/near/204660882\">said</a>:</p>\n<blockquote>\n<p>Oh I guess I don’t need to learn category theory because it apparently useless.</p>\n</blockquote>\n<p>This is a silly answer. It is not useless, on the contrary. The advantage of category theory is exactly that you can consider syntax AND semantics at the same time using functors, and come up with notions of composition that are best suited for your syntax. But focusing only on the \"wiring things together\" part of the  problem is indeed akin to approaching it as it has been already done in the past, and not very insightful in my opinion.</p>",
        "id": 204662079,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595423045
    },
    {
        "content": "<p>Also, for the very same reason, we should focus on functors between syntax and semantics that are strict or strong. Lax monoidal functors, in this respect, just tell you that \"the semantics of the composite is more than the sum of its parts\", which can be a nice categorical result, but not very usable in practice...</p>",
        "id": 204662225,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595423142
    },
    {
        "content": "<p>Surely that depends on how constructively the laxness is described? If we know <em>exactly how much</em> \"the semantics of the composite is more than the sum of its parts\", we should be able shift our perspective and think of the augmented composite semantics as an alternative composition. Like how composition in a Kleisli category for a monad isn't just composition of arrows, but carries along some extra information.<br>\n(I recently saw the use of monads in computer science justified as enabling Kleisli composition which carries along extra information, which is where I'm getting this idea from; I don't know how theoretically sound it is.)</p>",
        "id": 204667205,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1595425657
    },
    {
        "content": "<p>Well, kleisli composition tho is free</p>",
        "id": 204667364,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595425710
    },
    {
        "content": "<p>So you aren't really adding much, since everything can be rebuilt from the generators</p>",
        "id": 204667407,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595425728
    },
    {
        "content": "<p>So I guess I see what you say, but lax monoidality is most often treated as a black box in the literature</p>",
        "id": 204667449,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595425748
    },
    {
        "content": "<p>I think that when you have a clear understanding of what happens, you should be able to turn a lax monoidal correspondence into something better in a way or another</p>",
        "id": 204667528,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595425783
    },
    {
        "content": "<p>I have a sneaky suspicion the necessary conditions for that to happen would turn out to be something like the existence of a strength, but yes, that's what I was trying to get at! Even when it's not completely possible, I wonder if there's some mileage in approximating a lax monoidal functor with one of these \"nice\" lax monoidal things which can be presented in a practical way.</p>",
        "id": 204669131,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1595426488
    },
    {
        "content": "<p>I think that's a nice idea. Having different ways to \"frame\" lax functors would be something that goes in the same direction of a previous discussion we had here about categories handling failure in compositionality</p>",
        "id": 204670227,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595426960
    },
    {
        "content": "<p>That is, you have an algebraic framework for composition and a semantics that doesn't really compose over it because your functors are lax. But maybe you can try to refine the properties of the framework and semantics to get increasingly tamer notion of laxity. Hopefully, at some point you may get a fully compositional correspondence, where your functor is strict.</p>",
        "id": 204670388,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595427025
    },
    {
        "content": "<p>Btw, this kind of reasoning doesn't apply just to tensoring, but also to composition. So the natural setting to formulate all this are bicategories I believe</p>",
        "id": 204670458,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1595427071
    },
    {
        "content": "<p>Maybe a toy example to consider would be a free monoidal category on generating objects <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>X</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">X_1,\\dotsc,X_n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and lax monoidal functors to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">N</mi><mo separator=\"true\">,</mo><mo>≤</mo><mo separator=\"true\">,</mo><mo>+</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\mathbb{N}, \\leq, +)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">+</span><span class=\"mclose\">)</span></span></span></span> sending <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><msub><mi>i</mi><mn>1</mn></msub></msub><mo>⊗</mo><mo>⋯</mo><mo>⊗</mo><msub><mi>X</mi><msub><mi>i</mi><mi>n</mi></msub></msub></mrow><annotation encoding=\"application/x-tex\">X_{i_1} \\otimes \\cdots \\otimes X_{i_n}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.93343em;vertical-align:-0.2501em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.93343em;vertical-align:-0.2501em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.16454285714285719em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>F</mi><mo stretchy=\"false\">(</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">F(X_1) + \\cdots + F(X_n) + n - 1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> (assuming this would be well-defined, I haven't checked).</p>",
        "id": 204673109,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1595428205
    },
    {
        "content": "<p>Such a functor is lax monoidal relative to the stated monoidal structure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span>, but if we replace it with a tweaked monoidal structure, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>⊗</mo><mi>n</mi><mo>=</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">m \\otimes n = m+n+1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>, it's monoidal.</p>",
        "id": 204673497,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1595428355
    },
    {
        "content": "<p>There are probably some details that I'm missing but I think this conveys what we were discussing.</p>",
        "id": 204673791,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1595428478
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> <a href=\"#narrow/stream/229156-practice.3A-applied.20ct/topic/Petri.20nets.20and.20programming.20languages/near/204660195\">said</a>:</p>\n<blockquote>\n<p>Long story short: Blackboxing things to compose them is not something new that ACT discovered. This is literally how engineering works since the beginning of time. The novelty is - or should be-  doing so in a way that is compositional with respect to the implications that composition has on semantics and model checking.</p>\n</blockquote>\n<p>Maybe a good time to drop my slightly-famous blog post on compositionality: <a href=\"https://julesh.com/2017/04/22/on-compositionality/\">https://julesh.com/2017/04/22/on-compositionality/</a></p>",
        "id": 204705976,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1595443387
    },
    {
        "content": "<p>This is a bit of applied composition that we did years ago.  The application domain was real-time software design of robotic systems that typically had lots of Petri net synchronization. The idea is to lift out the real-time \"pthread\" scheduler and replace it with a black-box discrete event scheduler that could compress a timeline so that a process that may take hours to complete would run nearly instantaneously in a simulated environment.   I came up with this idea at the time because I thought there should be some way to make a general-purpose real-time programming language into a VHDL-like simulator.   YMMV </p>\n<p><a href=\"https://www.researchgate.net/publication/221444223_DEGAS_Discrete_event_Gnu_advanced_scheduler\">https://www.researchgate.net/publication/221444223_DEGAS_Discrete_event_Gnu_advanced_scheduler</a></p>\n<p><a href=\"https://www.researchgate.net/publication/234802134_Generic_discrete_event_simulations_using_DEGAS_application_to_logic_design_and_digital_signal_processing\">https://www.researchgate.net/publication/234802134_Generic_discrete_event_simulations_using_DEGAS_application_to_logic_design_and_digital_signal_processing</a></p>\n<p>Since that time, I have run across a few Haskell front-ends for generating VHDL code</p>",
        "id": 204735036,
        "sender_full_name": "Paul Pukite",
        "timestamp": 1595460664
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> <a href=\"#narrow/stream/229156-practice.3A-applied.20ct/topic/Petri.20nets.20and.20programming.20languages/near/204670458\">said</a>:</p>\n<blockquote>\n<p>Btw, this kind of reasoning doesn't apply just to tensoring, but also to composition. So the natural setting to formulate all this are bicategories I believe</p>\n</blockquote>\n<p>Or 2-categories, for what matters. Monoidal categories are 2-categories with one object. I think laxity can be given some topological interpretation. Then failure to be a strict 2-functor is going to be detected by some cohomological tools.<br>\nThe above can be retouched to cast the problem in a more traditional setting, thereby enabling more traditional interpretations of cohomology, e.g. by taking simplicial nerves.</p>",
        "id": 205098169,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1595843528
    },
    {
        "content": "<p>I don't know enough cohomology nor higher category theory nor homotopy theory to actually know how to do that, though. I hope I can bridge the gap in the following year.</p>",
        "id": 205098252,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1595843589
    },
    {
        "content": "<p>I came across an Open Source library developed by ING (a Dutch Bank) based on Petri-Nets to orchestrate their processes. Links here and in the thread links to the work on Petri-nets and CT<br>\n<a href=\"https://twitter.com/bblfish/status/1521084507541196800\">https://twitter.com/bblfish/status/1521084507541196800</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/bblfish/status/1521084507541196800\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/77b199c7e82b7b9c52e9d03926bbf1970d09fe5d/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313030343332363736313630383431373238312f486a786a533942585f6e6f726d616c2e6a7067\"></a><p>\"Orchestrate ING with Petri Nets\"\na 2017 talk by <a href=\"https://twitter.com/adilakhter\">@adilakhter</a> explaining the reason for developing the Baker open source library built on petri-nets at <a href=\"https://twitter.com/ING_news\">@ING_news</a> (the bank).\n(The slides are a bit fuzzy in the video: are they online somewhere?)\n<a href=\"https://t.co/s30E79xtBb\">https://www.youtube.com/watch?v=wICfskNsa2E</a></p><span>- The 🐟‍‍ BabelFish (@bblfish)</span></div></div>",
        "id": 280865662,
        "sender_full_name": "Henry Story",
        "timestamp": 1651493562
    }
]