[
    {
        "content": "<p>Sorry to cram that all in the title.  I am very interested in getting into what I can learn about these topics through the lens of monoidal categories and/or toposes.  We have many finite state machines at work, but my colleagues are not familiar with Behavior Trees per se.  Both FSMs and BT's seem amenable to applied category theory, maybe even BT's moreso.</p>\n<p>I am slowly reading the relevant parts of Seven Sketches on toposes, and the relation of logic, behavior and syntax seems very relevant.  It's just all so much to take in. I was hoping someone here might have tidbits to share to speed me along my learning path here.</p>",
        "id": 555708421,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1763176730
    },
    {
        "content": "<p><a href=\"https://autcat.github.io/\">https://autcat.github.io/</a> was a good branching point during my undergraduate thesis - but obviously more on the FSM side</p>",
        "id": 555729690,
        "sender_full_name": "Jonty Male",
        "timestamp": 1763198100
    },
    {
        "content": "<p>A more specific question could elicit lots of replies here.  Just asking for \"tidbits\" probably won't get folks excited, but there are people here who know <em>lots</em> about some of these topics.</p>",
        "id": 555734817,
        "sender_full_name": "John Baez",
        "timestamp": 1763203386
    },
    {
        "content": "<p>It's really a case of not knowing enough to have a specific question.  This is about as specific as I can get:</p>\n<ul>\n<li>What does Category Theory say, if anything, about the advantages/disadvantages between BT and FSM approaches?</li>\n<li>Can categories inform me how to design a better FSM/BT at the start?</li>\n<li>If none of that, what connections am I not even imagining that are worthwhile?</li>\n</ul>",
        "id": 556608051,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1763215468
    },
    {
        "content": "<p>Really the first exposure i had to FSM (are they different from finite state <em>automata</em>?)  was in algebraic coding theory, because you can use a FSM to encode a stream of bits, and it turns out that has a polynomial representation, and algebraic properties, IIRC.  Now the FSMs I work with are in software, and I wonder how I can understand and improve them.</p>",
        "id": 556608235,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1763215621
    },
    {
        "content": "<blockquote>\n<p>\"the first exposure i had to FSM (are they different from finite state <em>automata</em>?)\"</p>\n</blockquote>\n<p>That's the kind of question mathematicians love most: <em>a precise question that has a yes-or-no answer!</em>    There's no waffling around with these questions.    And if you pose them correctly, you get precious bits of information.  </p>\n<p>I looked up <a href=\"https://en.wikipedia.org/wiki/Finite-state_machine\">finite state machine</a> and in the first line it said</p>\n<blockquote>\n<p>A <strong>finite-state machine</strong> (<strong>FSM</strong>) or <strong>finite-state automaton</strong> (<strong>FSA</strong>, plural: <em>automata</em>), <strong>finite automaton</strong>, or simply a <strong>state machine</strong>, is a mathematical <a href=\"https://en.wikipedia.org/wiki/Model_of_computation\">model of computation</a>. It is an <a href=\"https://en.wikipedia.org/wiki/Abstract_machine\">abstract machine</a> that can be in exactly one of a finite number of <em><a href=\"https://en.wikipedia.org/wiki/State_(computer_science)\">states</a></em> at any given time. The FSM can change from one state to another in response to some <a href=\"https://en.wikipedia.org/wiki/Input_(computer_science)\">inputs</a>; the change from one state to another is called a <em>transition</em>.<a href=\"https://en.wikipedia.org/wiki/Finite-state_machine#cite_note-1\">[1]</a> An FSM is defined by a list of its states, its initial state, and the inputs that trigger each transition.</p>\n</blockquote>\n<p>So apparently the answer to your question is <em>yes.</em></p>\n<p>Eilenberg, one of the founding fathers of category theory, wrote two books on category theory and finite state machines.  Apparently all his friends in algebraic topology thought he was wasting his time.   You can get them on LibGen.  They're fairly interesting.   I think there are some newer papers that discuss some results in these books, but I can't remember what they are.</p>\n<p>What's a 'behavior tree'?</p>",
        "id": 556633591,
        "sender_full_name": "John Baez",
        "timestamp": 1763239343
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"275920\">@John Baez</span>  So, Automata, Language and Machines volumes A and B?  It's a very trippy journey even through the table of contents!</p>",
        "id": 556653698,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1763264060
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/channel/229156-theory.3A-applied-category-theory/topic/FiniteStateMachines.2FBehaviorTrees.2FStringDiagrams.2FToposes/near/556633591\">said</a>:</p>\n<blockquote>\n<p>What's a 'behavior tree'?</p>\n</blockquote>\n<p>When I first heard about them I couldn't tell what would make them different from FSMs, except for maybe the layout.  The idea is to lay out a pattern of behavior that's executed according to certain primitives.  The nodes have access to a pool of state, and the tree keeps being executed from root to some leaf where an action happens, potentially many times a second.</p>\n<p>Learning about the primitives helps with seeing how one might work. The execution of a node results in either \"success, running, or failure\"  A running node will eventually become \"success/failure.\"  There are nodes that act like conditionals, and nodes that execute a sequence of children, waiting for one to succeed, or maybe waiting for one to fail ,nodes that enable looping, and so on.  And it sure sounds like you could potentially dynamically graft subtrees into the tree depending on conditionals.</p>\n<p>I'm not good at explaining it because so far I've only read a couple websites and chatted with AI a bit to learn what to search for, but it does seem different in character from a finite state machine.</p>\n<p>I hear they use them for NPC player behavior in the gaming industry...</p>",
        "id": 556654212,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1763264811
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"275920\">@John Baez</span> This looks like a current and relevant extension to what Eilenberg was working on: <a href=\"https://www.irif.fr/~jep/PDF/MPRI/MPRI.pdf\">Mathematical Foundations of Automata Theory</a></p>",
        "id": 556688698,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1763302985
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"685603\">Ryan Schwiebert</span> <a href=\"#narrow/channel/229156-theory.3A-applied-category-theory/topic/FiniteStateMachines.2FBehaviorTrees.2FStringDiagrams.2FToposes/near/556653698\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span>  So, Automata, Language and Machines volumes A and B? </p>\n</blockquote>\n<p>Yes, those are the ones.  </p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> This looks like a current and relevant extension to what Eilenberg was working on: <a href=\"https://www.irif.fr/~jep/PDF/MPRI/MPRI.pdf\">Mathematical Foundations of Automata Theory</a></p>\n</blockquote>\n<p>This looks like a nice modern treatment!   </p>\n<p>(It should be \"Automaton Theory\", but that's a very minor complaint.   Saying \"Automata Theory\" is like saying \"Categories Theory\".)</p>",
        "id": 556719121,
        "sender_full_name": "John Baez",
        "timestamp": 1763331445
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"275920\">@John Baez</span>  Oo, i just ran across this survey <a href=\"https://arxiv.org/pdf/1709.00084\">Behavior Trees in Robotics and AI</a>.  Section 2 appears to be a very helpful and careful comparison of BTs to FSMs, decision trees, and a few other notions I did not know about.</p>",
        "id": 556735043,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1763347461
    },
    {
        "content": "<p>Do you think behavior trees are widely used in robotics?  <span class=\"user-mention\" data-user-id=\"275914\">@Joe Moeller</span> - maybe Aaron Ames will know.</p>\n<p>There are a million notions in computer science, and in some sense only the most elegant and the most widely used are worth learning for a nonexpert such as me.</p>",
        "id": 556777640,
        "sender_full_name": "John Baez",
        "timestamp": 1763370762
    },
    {
        "content": "<p>I guess what I can say at the moment is: </p>\n<ol>\n<li>I don't think I recognize any of the names in the references.</li>\n<li>I haven't heard anybody mention behavior trees in my time hanging around control theorists and roboticists.</li>\n<li>It vaguely makes me think of model predictive control, a major topic in control, but I don't think they're related.</li>\n<li>It also sounds to me very close to FSM, so I don't know how I would describe it to people I'm asking. But I'll ask.</li>\n</ol>",
        "id": 556871093,
        "sender_full_name": "Joe Moeller",
        "timestamp": 1763395551
    },
    {
        "content": "<p>Based on the pages I've found, and conversations with roboticists at work, they all know about BTs, but it is not yet something they've done. Perhaps it's just catching on.  Maybe the AI people are ahead of the roboticists at the moment.</p>",
        "id": 556930827,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1763413709
    },
    {
        "content": "<p>Two of the types of \"composite\" nodes are called \"sequence\" and \"selector\". The first one works like a universal quantifier (succeeding iff its children do) and the second like an existential quantifier (succeeding iff any of its children do.)  This tutorial I read today has a separate name for \"decorator nodes\" that only have one children, and they describe \"invert\", \"always succeed\" and \"always fail\" as cases of those nodes.  The final type of node is \"leaf\" which can do anything basically. It might trigger the agent to do an action, or else do some sort of check against state, and then report success or failure up the chain.</p>\n<p>At this point it looks kind of like the non-leaf nodes are largely control structures, and the leaves are where you can access and change state. (Possibly it's interesting that's where the side-effects are.)</p>\n<p>Maybe it's just because I\"m reading these at the same time, but it sounds like these trees have their own internal logic, possibly like a topos?  I'll have to keep my eye out to see if other such features appear.</p>",
        "id": 556931901,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1763414159
    },
    {
        "content": "<p>Here's some context that might be helpful.</p>\n<p>Behavior Trees were popularized by the following GDC talk on the AI in the video game Halo 2: <a href=\"https://www.youtube.com/watch?v=m9W-hpxuApk\">https://www.youtube.com/watch?v=m9W-hpxuApk</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"m9W-hpxuApk\" href=\"https://www.youtube.com/watch?v=m9W-hpxuApk\"><img src=\"https://uploads.zulipusercontent.net/377f11df79f92c4728d75b7f2924151208cebf72/68747470733a2f2f692e7974696d672e636f6d2f76692f6d39572d6870787541706b2f6d7164656661756c742e6a7067\"></a></div><p>Here's a transcription of the talk: <a href=\"https://www.gamedeveloper.com/programming/gdc-2005-proceeding-handling-complexity-in-the-i-halo-2-i-ai\">https://www.gamedeveloper.com/programming/gdc-2005-proceeding-handling-complexity-in-the-i-halo-2-i-ai</a></p>\n<p>Behavior trees were seen as a way to increase modularity over Finite state machines.</p>\n<p>In the talk there were suggestive tree diagrams:</p>\n<p><a href=\"/user_uploads/21317/-eoOZKBQNGoOq7oUajZ_sRpY/image.png\">Behavior Tree</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/-eoOZKBQNGoOq7oUajZ_sRpY/image.png\" title=\"Behavior Tree\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1930x1061\" src=\"/user_uploads/thumbnail/21317/-eoOZKBQNGoOq7oUajZ_sRpY/image.png/840x560.webp\"></a></div><p>My understanding is this talk was reverse engineered into other tools in game development, like the behavior tree editor in the unreal engine:</p>\n<p><a href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/behavior-tree-in-unreal-engine---overview\">https://dev.epicgames.com/documentation/en-us/unreal-engine/behavior-tree-in-unreal-engine---overview</a></p>\n<p><a href=\"/user_uploads/21317/FH8fxnZbGf1MXUogq9ib_482/image.png\">Unreal example of behavior tree</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/FH8fxnZbGf1MXUogq9ib_482/image.png\" title=\"Unreal example of behavior tree\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1111x603\" src=\"/user_uploads/thumbnail/21317/FH8fxnZbGf1MXUogq9ib_482/image.png/840x560.webp\"></a></div><p>The tree is somewhat deceptive, because implicit in the diagram is some means of sampling the world and player state to update the tree.</p>\n<p>After this popularization, I think the definitions you see on <a href=\"https://en.wikipedia.org/wiki/Behavior_tree_(artificial_intelligence,_robotics_and_control)\">wikipedia</a> were a consolidated. Whatever the history, these definitions were then carried over into fields like robotics.</p>\n<p>The name \"behavior tree\" is still a game developer term of art, it doesn't necessarily match the wikipedia definition. For example, in the original Halo 2 talk, \"impluses\" were \"added\" (really they were removed from the definition) to make small changes on the tree when unusual play states happened.</p>\n<p>With that context, I agree monoidal categories may be usefully applied here, BTs feel like a sort of multi-category to me. My sense is much of applied category theory amounts to making diagrams like the above rigorous. You've already identified a notion of \"And\" and \"Or\" in behavior trees, if you want it to be a topos you'd also need a sort of \"object classifier\" or \"boolean\" concept.</p>\n<p>Finite state machines, by contrast, have widely recognized careful definitions, or close analogs in category theory with careful definitions. And they are applied much more broadly than just game AI. The intro text on category theory \"Conceptual Mathematics\" spends quite a bit of space on discrete dynamical systems, graphs, etc.</p>\n<p>Basic concepts in category theory remind me of finite state machines. For example, if you imagine a category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span> with a single object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathrm\">C</span></span></span></span>, and say three distinct generating arrows from the object to itself, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo separator=\"true\">,</mo><mi>c</mi><mo>:</mo><mi mathvariant=\"normal\">C</mi><mo>→</mo><mi mathvariant=\"normal\">C</mi></mrow><annotation encoding=\"application/x-tex\">a, b, c : \\mathrm{C} \\rightarrow \\mathrm{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathrm\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathrm\">C</span></span></span></span>. That gives you a simple syntax, with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mi>b</mi><mi>c</mi><mi>c</mi><mi>b</mi><mi>b</mi><mi>c</mi><mi>a</mi><mo>:</mo><mi mathvariant=\"normal\">C</mi><mo>→</mo><mi mathvariant=\"normal\">C</mi></mrow><annotation encoding=\"application/x-tex\">abcbccbbca : \\mathrm{C} \\rightarrow \\mathrm{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">ab</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">cc</span><span class=\"mord mathnormal\">bb</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathrm\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathrm\">C</span></span></span></span> an example of a morphism in that category. Then finding a functor from this category into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Set</span></span></span></span></span>, would give the previous \"program\" an interpretation as a composition of endofunctions.</p>\n<p>These functions can be thought of as the arrows which transition the states of the associated set. Of course the entire state space is the object of this category, whereas finite state machine diagrams have arrows between states. You can define such a category with the states as objects by forming the <a href=\"https://ncatlab.org/nlab/show/category+of+elements\">category of elements</a> of the specified functor interpreting <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span> into Set.</p>\n<p>Individual automata aren't toposes by themselves, but all the possible interpretations <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">[</mo><mi mathvariant=\"script\">C</mi><mo separator=\"true\">,</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><mo fence=\"true\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\left [\\mathcal{C}, \\mathrm{Set}\\right ]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">[</span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Set</span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">]</span></span></span></span></span> collectively form a topos, by inheriting the topos structure from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Set</span></span></span></span></span>, just like how functions into a vector space, themselves form a vector space.</p>\n<p>I find these bundles of connections interesting to think about. I don't know much about how category theory might apply to AI specifically, but if you're interested I bet there's somebody here with some thoughts on how that works.</p>",
        "id": 558078451,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1763504711
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"277352\">@Alex Kreitzberg</span> The other thing that struck me as topos like (based on my limited understanding so far, from Seven Sketches) is that the tree evolves over time. Nodes convert to Success/Failure while going through Running.  The description in seven sketches is \"things happening over time over a site.\"</p>\n<p>Do these boolean-like evaluations of nodes convert into something globally boolean-like for a potential subobject classifier?  (Sorry my knowledge of toposes is still so sketchy. i cannot even bring the details of subobject classifiers to mind, and I recall not quite getting the glueing concepts for sheafs.)</p>",
        "id": 558079181,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1763505009
    },
    {
        "content": "<p>Essentially by definition, Toposes are certain well behaved categories of presheaves <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">[</mo><msup><mi mathvariant=\"script\">C</mi><mtext>op</mtext></msup><mo separator=\"true\">,</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><mo fence=\"true\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\left [ \\mathcal{C}^{\\text{op}}, \\mathrm{Set} \\right ]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">[</span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord text mtight\"><span class=\"mord mtight\">op</span></span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Set</span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">]</span></span></span></span></span> (The presheaves and category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span> are so well behaved they're called \"sheaves\" and a \"site\" respectively). What you're noticing is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span> can look \"temporal\".</p>\n<p>So <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Set}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Set</span></span></span></span></span> has a boolean set. Functions into that boolean set are the predicates. When you bake in an implicit time dependence by introducing a domain category, what happens to predicates? That would be how object classifiers are introduced via Sheafs. That's my understanding of how sheafs build toposes (but I confess, I'm an enthusiast so I don't have clever ideas here for your example).</p>\n<p>In my explanations, I've been leaning on the more general definition of <a href=\"https://ncatlab.org/nlab/show/topos#ElementaryTopos\">elementary topos</a> as a crutch. It simply requires our category:</p>\n<ol>\n<li>\n<p>has <a href=\"https://ncatlab.org/nlab/show/finitely+complete+category\">finite limits</a>, (\"And\")</p>\n</li>\n<li>\n<p>is <a href=\"https://ncatlab.org/nlab/show/cartesian+closed+category\">cartesian closed</a>, and (\"Implies\")</p>\n</li>\n<li>\n<p>has a <a href=\"https://ncatlab.org/nlab/show/subobject+classifier\">subobject classifier</a>. (\"Notion of truth\")</p>\n</li>\n</ol>\n<p>So you've already mentioned \"sequencing\" as a notion of \"and\" - for fun lets see if that satisfies point 1 (maybe this isn't what you were trying to do). Requirement 2, that it be cartesian closed, would mean our diagramatic language would need some notion of anonymous function defined nicey in terms of sequencing, since we're calling it \"and\". This would be analogous to currying in a functional language. </p>\n<p>You need these \"higher order functions\" to define predicates into the \"classifying space\" the analog of booleans.</p>\n<p>I don't have good ideas for how to do this, because I haven't thought about behavior trees for very long. I should say, I have a friend who worked on Halo who is familiar with the \"in the trenches\" definition, so you've inspired me to talk with them a bit about the definition. So maybe I'll have something more clever to add later.</p>",
        "id": 558084796,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1763508016
    },
    {
        "content": "<p>Just a drive-by comment that you have the implication backwards: all categories of presheaves are toposes, but most toposes are not full categories of presheaves. Most toposes are certain particularly nice reflective subcategories of presheaf categories, namely those for which the reflector (called \"sheafification\" in this context) preserves finite limits.</p>",
        "id": 558180401,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1763552587
    },
    {
        "content": "<p>I don't think what Alex said was actually wrong if he was talking about <em>Grothendieck</em> topoi here:</p>\n<blockquote>\n<p>Essentially by definition, Toposes are certain well behaved categories of presheaves <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">[</mo><msup><mi mathvariant=\"script\">C</mi><mtext>op</mtext></msup><mo separator=\"true\">,</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><mo fence=\"true\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\left [ \\mathcal{C}^{\\text{op}}, \\mathrm{Set} \\right ]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">[</span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord text mtight\"><span class=\"mord mtight\">op</span></span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Set</span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">]</span></span></span></span></span> (The presheaves and category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span> are so well behaved they're called \"sheaves\" and a \"site\" respectively).</p>\n</blockquote>\n<p>I think some people say \"topos\" and mean \"Grothendieck topos\", so maybe Alex is working within this tradition.  But if I were trying to explain toposes to someone (Ryan) I would have said something like \"The nicest toposes, called Grothendieck toposes, are categories of specially nice presheaves called sheaves\".</p>",
        "id": 558221367,
        "sender_full_name": "John Baez",
        "timestamp": 1763563282
    },
    {
        "content": "<p>Yes, I was responding as if Alex meant to say \"certain well-behaved categories of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><msup><mi mathvariant=\"script\">C</mi><mrow><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">p</mi></mrow></msup><mo separator=\"true\">,</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[\\mathcal{C}^{\\mathrm{op}},\\mathrm{Set}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">op</span></span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Set</span></span><span class=\"mclose\">]</span></span></span></span> \", which isn't quite right, whereas \"certain well-behaved categories whose objects are objects of categories of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><msup><mi mathvariant=\"script\">C</mi><mrow><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">p</mi></mrow></msup><mo separator=\"true\">,</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[\\mathcal{C}^{\\mathrm{op}},\\mathrm{Set}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">op</span></span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Set</span></span><span class=\"mclose\">]</span></span></span></span> \" does work, maybe that's what he meant.</p>",
        "id": 558251344,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1763569844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277352\">Alex Kreitzberg</span> <a href=\"#narrow/channel/229156-theory.3A-applied-category-theory/topic/FiniteStateMachines.2FBehaviorTrees.2FStringDiagrams.2FToposes/near/558084796\">said</a>:</p>\n<blockquote>\n<ul>\n<li>has <a href=\"https://ncatlab.org/nlab/show/finitely+complete+category\">finite limits</a>, (\"And\")</li>\n</ul>\n</blockquote>\n<p>Finite limits give you the ability to say \"and\", plus the ability to say \"the biggest subobject where f=g\"; the latter is impossible with conjunctions only, no?</p>",
        "id": 558253007,
        "sender_full_name": "fosco",
        "timestamp": 1763570217
    },
    {
        "content": "<p>I'm happy people are calling me out XD</p>\n<p>I tried to reverse engineer how the terminology is used on the nlab, but I wouldn't be surprised if my usage, or understanding, are confused.</p>\n<p>The sense I got from the nlab is you might have any of</p>\n<ul>\n<li>A category of sheaves</li>\n<li>A category of presheaves</li>\n<li>A category with just enough structure to define subobject classifiers</li>\n</ul>\n<p>And all of these would be called \"A Topos\" and it was up to the reader to establish from context whether it was a grothendieck topos or an elementary topos. (I found this odd, because it felt like calling a square a rectangle and expecting the reader to know we'll use square properties)</p>\n<p>Even with that, badly self imposed, rule I appreciate folks pointing out there are still mistakes.</p>\n<p>Additionally, the definition used in seven sketches (page 242) defined a topos to be a category of sheaves. So I was trying to walk backwards from that definition.</p>\n<p>The point is (which was subtly emphasized by fosco's comment), when talking about toposes - the subobject classifier, a generalization of \"boolean\" used for finding subsets, is the star of the show:</p>\n<p><a href=\"/user_uploads/21317/KnO1WDez4gJzfP7z1yvzt1Ub/image.png\">subobject classifier</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/KnO1WDez4gJzfP7z1yvzt1Ub/image.png\" title=\"subobject classifier\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"874x469\" src=\"/user_uploads/thumbnail/21317/KnO1WDez4gJzfP7z1yvzt1Ub/image.png/840x560.webp\"></a></div><p>After sleeping on the problem, it occured to me they actually did define an operation that looks very much like finding sub trees for Halo 2:</p>\n<p><a href=\"/user_uploads/21317/kowux17546SK--hJD5xDCN8L/image.png\">bitmasking trees in behavior trees</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/kowux17546SK--hJD5xDCN8L/image.png\" title=\"bitmasking trees in behavior trees\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1927x1073\" src=\"/user_uploads/thumbnail/21317/kowux17546SK--hJD5xDCN8L/image.png/840x560.webp\"></a></div><p>For example, If you're in a vehicle you only have access to some of your \"behaviors\". Given this \"subsetting\" via \"bit masks\", maybe something like intersections and unions becomes meaningful.</p>",
        "id": 558259399,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1763571852
    },
    {
        "content": "<p>A category of presheaves <em>is</em> a category of sheaves (ie Grothendieck topos), which <em>is</em> an elementary topos, which <em>is</em> category with a subobject classifier. But all these implications are irreversible. Most category theorists saying \"topos\" mean \"elementary topos\", but for historical reasons and the fact that Grothendieck toposes are pretty great, it's far from unheard of to use \"topos\" to mean \"Grothendieck topos.\"</p>",
        "id": 558263722,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1763573005
    },
    {
        "content": "<p>One thing that hasn't been clear to me so far in the discussion of behavior tree is the scope of \"blackboard\" which is shared.  It seems like if all nodes have access to global state, it might cause problems with composition.  If, say, two subtrees had actions competing over the same piece of shared state, it sounds like it could lead to deadlock or some runaway cycle.</p>\n<p>Maybe some scoping better than \"everything global\" would help.  Maybe, for example, a node knows all its children's scopes.  Or, potentially, all sibling nodes share a scope, slightly smaller than the parent node.</p>\n<p>Another question I have somewhat related to this is about whether or not it's expected you can dynamically modify the tree. If you can add siblings to a sequence node, for example, that seems to get us back into the same state-sharing danger I was worried about.</p>\n<p>Perhaps programmers have thought it through already. One person I talked to suggested that dynamically adding to trees is \"not the way to go.\"  It would certainly simplify things if the tree were locked in before execution. We would still have the option to make some subtrees function conditionally, which is kind of a proxy for dynamically inserting nodes.</p>",
        "id": 558299465,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1763585194
    },
    {
        "content": "<p>Anyhow, thanks for all your insights into toposes.  I never imagined I'd be at the stage where learning such things seemed within reach...</p>",
        "id": 558299658,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1763585261
    },
    {
        "content": "<p>When being scared of mutability, be careful to avoid throwing the baby out with the bath water.</p>\n<p>If I have a variable that allows \"mutating\" a 2 into a 3, that doesn't mean \"2 + 1\" is bad.</p>\n<p>Similarly, whether or not you decide it's a good idea to allow mutability for a tree, I very much think it's a good idea to understand what \"adding a sibling to a sequence\" means.</p>\n<p>These behavior trees might be the objects of some category. In which case figuring out the arrows between them, perhaps adding one tree to another tree, is key to understanding them.</p>",
        "id": 558306702,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1763587841
    },
    {
        "content": "<p>Well, naively one would try composition that grafts the root of tree B so that it becomes the leaf of tree A. Of course, questions immediately arise: where does the root of B go? it's not like A has empty-socket leaf nodes for this purpose.</p>\n<p>I have to get a little more used to the syntax of these gizmos.   I feel like the main distinction is between leaf nodes and non-leaf nodes.   The leaf nodes are the workhorses, which cause side-effects and do conditional checks.  We can think of them as \"action\" nodes.  The non-leaf nodes are \"control nodes\" which enable different stuff like loops, existential and universal quantification. A well formed tree is formed of some number of leaves, all of which are mutually connected with control nodes.</p>\n<p>It's almost like the morphisms want to be trees of control nodes with \"empty slots\" where leaves have to be, and then it can be \"applied to\" a collection of that many Action nodes, and the result is a single Action node.</p>\n<p>I feel like I'm close to something, but it doesn't look like anything familiar to me. Does it look like it's headed anywhere to you guys?</p>",
        "id": 558862862,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1763869962
    },
    {
        "content": "<p>Never mind. I think I want to make it so morphisms operate on only a single thing. </p>\n<p>A “composite node” is a finite tree whose leaves are composite nodes, and nonleaves are control nodes.  Define a morphism to be a finite tree, whose no leaves are control nodes, and one leaf is a distinguished “socket” node, and all other leaves are composite nodes.  Action nodes can be considered trivial composite nodes. </p>\n<p>Seems like this allows us to say composite nodes are the objects, and the trees with one “socket leaf” are morphisms?</p>",
        "id": 558864300,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1763872060
    },
    {
        "content": "<blockquote>\n<p>Does it look like it's headed anywhere to you guys?</p>\n</blockquote>\n<p>People often visualize <a href=\"https://en.wikipedia.org/wiki/Operad#Rooted_trees\">operads</a> as having tree-shaped operations (see the section \"understanding the axioms\").  In the \"grafting\" product one identifies the root of one such tree with a leaf of another.    A huge amount is known about operads, and I wrote a paper with Nina Otter about the <a href=\"https://golem.ph.utexas.edu/category/2014/03/operads_and_trees.html\">operad of phylogenetic trees</a>, making phylogenetic trees in biology into operations in a very natural operad.  So if you're thinking about trees and attaching the root of one tree to a leaf of another, it might be good to think about operads.</p>",
        "id": 558880632,
        "sender_full_name": "John Baez",
        "timestamp": 1763890046
    },
    {
        "content": "<p>The most important thing is to think about what you want the morphisms, or operad operations or whatever they need to be, to represent, rather than only thinking about what structure is convenient to access.  (You have to think about that <em>too</em> of course.)</p>",
        "id": 558897121,
        "sender_full_name": "James Deikun",
        "timestamp": 1763907034
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/channel/229156-theory.3A-applied-category-theory/topic/FiniteStateMachines.2FBehaviorTrees.2FStringDiagrams.2FToposes/near/558880632\">said</a>:</p>\n<blockquote>\n<p>In the \"grafting\" product one identifies the root of one such tree with a leaf of another.</p>\n</blockquote>\n<p>This grafting makes sense to me as a structural operation for abstract trees, but when I was considering it for this case, I hesitated because I had been thinking of nodes as already having some purpose.  If you have a leaf node with one purpose, and a tree that accomplishes some other purpose, then identifying the tree with that leaf node didn't seem to make sense. Maybe that would go away if \"purpose\" was filled in later. And yet, it seems like the nodes I'm talking about have different purposes baked-in... I can't quite visualize how to separate it and set it aside before composition.</p>",
        "id": 558897584,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1763907436
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"438995\">James Deikun</span> <a href=\"#narrow/channel/229156-theory.3A-applied-category-theory/topic/FiniteStateMachines.2FBehaviorTrees.2FStringDiagrams.2FToposes/near/558897121\">said</a>:</p>\n<blockquote>\n<p>The most important thing is to think about what you want the morphisms, or operad operations or whatever they need to be, to represent, rather than only thinking about what structure is convenient to access.  (You have to think about that <em>too</em> of course.)</p>\n</blockquote>\n<p>I'm not completely sure I have an adequate answer for what I \"want to represent.\"  The best answer I have now is, \"these trees represent potential behavior in code, and I'd like to have a model of how one can combine these trees to form larger behavior trees.\"</p>",
        "id": 558897799,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1763907632
    },
    {
        "content": "<blockquote>\n<p>This grafting makes sense to me as a structural operation for abstract trees, but when I was considering it for this case, I hesitated because I had been thinking of nodes as already having some purpose.</p>\n</blockquote>\n<p>You might want to look at my work on phylogenetic trees, which analyzes a common way of drawing operations in operads where grafting gets a different feel, which is very relevant to your worry.   In the material I linked to, I said:</p>\n<blockquote>\n<p>There are various slightly different concepts of ‘rooted tree’ and ‘rooted planar tree’.   For example, a graph theorist might draw a rooted planar tree like this:</p>\n</blockquote>\n<p><a href=\"/user_uploads/21317/GA7RqacnDxSKcj45z5QS_4SD/rooted_planar_tree_graph_theorist_style.png\">rooted_planar_tree_graph_theorist_style.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/GA7RqacnDxSKcj45z5QS_4SD/rooted_planar_tree_graph_theorist_style.png\" title=\"rooted_planar_tree_graph_theorist_style.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"150x92\" src=\"/user_uploads/thumbnail/21317/GA7RqacnDxSKcj45z5QS_4SD/rooted_planar_tree_graph_theorist_style.png/840x560.webp\"></a></div><blockquote>\n<p>while an operad theorist might draw it like this:</p>\n</blockquote>\n<p><a href=\"/user_uploads/21317/53sK6kiBg3IXPH9KGovO7BcQ/rooted_planar_tree_operad_theorist_style.png\">rooted_planar_tree_operad_theorist_style.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/53sK6kiBg3IXPH9KGovO7BcQ/rooted_planar_tree_operad_theorist_style.png\" title=\"rooted_planar_tree_operad_theorist_style.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"140x101\" src=\"/user_uploads/thumbnail/21317/53sK6kiBg3IXPH9KGovO7BcQ/rooted_planar_tree_operad_theorist_style.png/840x560.webp\"></a></div><p>In the operad theorist's style, when we graft one tree A onto another tree B, we connect the \"loose edge\" coming downwards out of the root of A to a \"loose edge\" coming out of a leaf of B.  We don't identify two vertices.</p>\n<p>Our <a href=\"https://arxiv.org/abs/1512.03337\">actual paper</a> goes into this in extreme detail.</p>",
        "id": 558898279,
        "sender_full_name": "John Baez",
        "timestamp": 1763908077
    },
    {
        "content": "<p>Gonna give the tree paper above a go and get back when I'm ready to discuss.</p>\n<p>Maybe I'm worrying too much about \"blocking ports\" when composing. I was somewhat worried you could \"block off all the ports\" with actions (necessarily terminal leaves.)  But maybe that's just an illusion. Sequence and Selector nodes are not really ever blocked off, it seems.  Any \"action\" (which before seemed like a terminal node that would 'plug up' one of the open ports of a tree) could just be wrapped in a Sequence before being plugged in, and now when you attach it to any leaf-position, you don't close off that branch of the tree.</p>",
        "id": 560294976,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1764128480
    },
    {
        "content": "<p>I was trying to figure out there's an analogy to be made here with circuit diagrams with boolean logic, and behavior trees with ternary logic.</p>\n<p>Thing is, as I remarked earlier, Sequence and Selector nodes seemed like good candidates for conjunction and disjunction-like operations, but the \"left to right evaluation\" really makes things different. In particular, they aren't symmetric: for example Selector(Running, True) = Running and Selector(True, Running)=True.</p>\n<p>Hopefully that isn't a huge setback... perhaps this sort of noncommutative ternary conjunction/disjunction might be studied already?  I know \"noncommutative logic\" is a thing but I don't know anything about it...</p>",
        "id": 562957148,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1765373951
    },
    {
        "content": "<p>Properly speaking, maybe those nodes further in the sequence that haven't run should be a fourth truth value, even.  In the basic system you'll never encounter [Running, True], as the second node is never evaluated before the first Running is completed.  Maybe I'll have a look at that...</p>",
        "id": 562957865,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1765374120
    },
    {
        "content": "<p>maybe more to the point, the “lazy evaluation” makes ”almost half the truth table” irrelevant as they won’t occur.</p>",
        "id": 562961602,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1765375114
    },
    {
        "content": "<p>If my idea about this being a topos is solid, then maybe the meaning of “those possibilities never happens in practice” amount to some restriction on sections of a sheaf?</p>",
        "id": 562967689,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1765376740
    },
    {
        "content": "<p>AI was able to point me to a few likely helpful resources which may specifically cover using some form of ternary logic. If you are interested:</p>\n<blockquote>\n<p>Gugliermo, Simona, David Cáceres Domínguez, Marco Iannotta, Todor Stoyanov, and Erik Schaffernicht. “Evaluating Behavior Trees.” <em>Robotics and Autonomous Systems</em> 178 (August 2024): 104714. <a href=\"https://doi.org/10.1016/j.robot.2024.104714\">https://doi.org/10.1016/j.robot.2024.104714</a>.</p>\n<p>Martens, Chris, Eric Butler, and Joseph C. Osborn. “A Resourceful Reframing of Behavior Trees.” arXiv:1803.09099. Preprint, arXiv, March 24, 2018. <a href=\"https://doi.org/10.48550/arXiv.1803.09099\">https://doi.org/10.48550/arXiv.1803.09099</a>.</p>\n<p>Marzinotto, Alejandro, Michele Colledanchise, Christian Smith, and Petter Ogren. “Towards a Unified Behavior Trees Framework for Robot Control.” <em>2014 IEEE International Conference on Robotics and Automation (ICRA)</em>, IEEE, May 2014, 5420–27. <a href=\"https://doi.org/10.1109/ICRA.2014.6907656\">https://doi.org/10.1109/ICRA.2014.6907656</a>.</p>\n<p>Souza, Thibaud de. <em>Implementing Behavior Trees Using Three-Valued Logic</em>. n.d.</p>\n</blockquote>",
        "id": 563027212,
        "sender_full_name": "Ryan Schwiebert",
        "timestamp": 1765392832
    }
]