[
    {
        "content": "<p>This is a schema:</p>\n<p><a href=\"/user_uploads/21317/YCnMe1F-rC06rKJOQct1ZajP/Screenshot-2025-01-18-at-2.43.18PM.png\">schema-a</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/YCnMe1F-rC06rKJOQct1ZajP/Screenshot-2025-01-18-at-2.43.18PM.png\" title=\"schema-a\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"476x182\" src=\"/user_uploads/thumbnail/21317/YCnMe1F-rC06rKJOQct1ZajP/Screenshot-2025-01-18-at-2.43.18PM.png/840x560.webp\"></a></div><p>In SQL, we can write:</p>\n<div class=\"codehilite\"><pre><span></span><code>CREATE TABLE Human (\n    name TEXT PRIMARY KEY,\n    mom TEXT,\n    FOREIGN KEY (mom) REFERENCES Human(name)\n);\n</code></pre></div>\n<p>When I look at the olog, I would like to say that \"mom\" is a morphism from Human to Human, such that mom(h), <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mo>∈</mo><mtext>Human</mtext></mrow><annotation encoding=\"application/x-tex\">h \\in \\text{Human}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord\">Human</span></span></span></span></span> is h's mom. So the codomain of mom is Human.</p>\n<p>In SQL, \"Human\" would not be an acceptable data type:</p>\n<div class=\"codehilite\"><pre><span></span><code>CREATE TABLE Human (\n    name TEXT PRIMARY KEY,\n    mom HUMAN,\n);\n</code></pre></div>\n<p>and as I understand it, we use primary keys as a way to refer to an entity that a row of a table represents. Instead of referring to a mom in general, we refer to them by their name. Thus, name becomes a primary key for the table, and the data type of attribute mom is TEXT.</p>\n<p>In the olog format, I think this means my diagram is wrong. Actually, the morphism mom is from Human to Text. It denotes the name of a person's mom:</p>\n<p><a href=\"/user_uploads/21317/j04mJL6UpxQ5TUq6bG4pTNeC/Screenshot-2025-01-18-at-3.10.07PM.png\">schema-b</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/j04mJL6UpxQ5TUq6bG4pTNeC/Screenshot-2025-01-18-at-3.10.07PM.png\" title=\"schema-b\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1598x454\" src=\"/user_uploads/thumbnail/21317/j04mJL6UpxQ5TUq6bG4pTNeC/Screenshot-2025-01-18-at-3.10.07PM.png/840x560.webp\"></a></div><p>I feel like this means that in the olog, we can compose the morphism <code>name</code> with <code>mom: Human -&gt; Human</code>, to get a morphism <code>mom_name: Human -&gt; Text</code>.</p>\n<p><a href=\"/user_uploads/21317/UXKCFXYl_dGcK5rJI-SEbiGR/Screenshot-2025-01-18-at-3.10.13PM.png\">schema-c.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/UXKCFXYl_dGcK5rJI-SEbiGR/Screenshot-2025-01-18-at-3.10.13PM.png\" title=\"schema-c.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1520x674\" src=\"/user_uploads/thumbnail/21317/UXKCFXYl_dGcK5rJI-SEbiGR/Screenshot-2025-01-18-at-3.10.13PM.png/840x560.webp\"></a></div><p>I feel like what stands out here is that in the olog, we would be more inclined to denote the morphism mom and name, and let the morphism mom_name be implicit. But in SQL, we make the morphisms name and mom_name explicit, and the 'foreign key' keyword implies there is a morphism mom : Human -&gt; Human with the equation name(mom(h)) = mom_name(h).</p>\n<p><a href=\"/user_uploads/21317/Sf0uU9kRjnzLxpjmeiKUB70J/Screenshot-2025-01-18-at-3.10.28PM.png\">schema-d</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/Sf0uU9kRjnzLxpjmeiKUB70J/Screenshot-2025-01-18-at-3.10.28PM.png\" title=\"schema-d\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1674x706\" src=\"/user_uploads/thumbnail/21317/Sf0uU9kRjnzLxpjmeiKUB70J/Screenshot-2025-01-18-at-3.10.28PM.png/840x560.webp\"></a></div><p>Would anyone like to comment on this?</p>",
        "id": 494563033,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1737237479
    },
    {
        "content": "<p>As far as I am aware, primary keys (even unary ones) in schemas are not possible in the original, purely equational functional olog formalism (functors to Set).  You need more than equational logic: you need cartesian logic / pullbacks : \"forall x y : Person, <a href=\"http://x.name\">x.name</a> = <a href=\"http://y.name\">y.name</a> -&gt; x = y\" states that name is a key of Person.  David talks about this in \"Database queries and constraints as lifting problems\" and this is why CQL's \"constraints\" rather than \"schemas\" are the main abstraction.  For functors into Rel, the story is different - there, I think you can express primary keys as equations.  Evan Patterson would know more about the Rel story presumably.</p>",
        "id": 494585153,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1737246287
    },
    {
        "content": "<p>Amazing thank you</p>",
        "id": 494589590,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1737250082
    }
]