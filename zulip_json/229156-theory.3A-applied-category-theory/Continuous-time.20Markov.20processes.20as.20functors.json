[
    {
        "content": "<p>In discrete time, one way to think about Markov chains is the following: let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> be the natural numbers as a monoid under addition. Then a functor from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> into a Markov category defines a (time homogeneous) Markov chain. In the finite case, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> gets mapped to some stochastic matrix <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span>, and any other natural number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> gets mapped to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>P</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">P^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>.</p>\n<p>I had it in my mind that one could do the same thing for continuous-time Markov processes just by replacing the natural numbers with the reals, but I've realised there's a subtlety, and I'm wondering (i) what's the best way to resolve it, and (ii) if there's an existing treatment that I can read about that takes this kind of approach.</p>\n<p>The most obvious way to do it is to use the monoid <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo lspace=\"0em\" rspace=\"0em\">+</mo><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">\\langle[0,\\infty),{+}\\rangle</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∞</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">+</span></span><span class=\"mclose\">⟩</span></span></span></span>. A continuous-time Markov process can be expressed as a functor from this monoid to a Markov category. For example, we could have a functor that maps a nonnegative real number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> to a stochastic matrix <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>e</mi><mrow><mi>H</mi><mi>t</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">e^{Ht}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span></span></span></span></span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> is an <a href=\"https://en.wikipedia.org/wiki/Transition_rate_matrix\">infinitesimal stochastic matrix</a>.</p>\n<p>The problem is that this scheme also admits things that are not of this form. For example, given an idempotent non-identity stochastic matrix <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span>, we can have a functor that maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> to the identity matrix, and any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">t&gt;0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65418em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span>. This corresponds in some way to a stochastic process with infinite transition rates, and it seems that in general functors of this form correspond to continuous-time Markov processes with possibly infinite rates.</p>\n<p>I actually find that kind of cool, but sometimes it would be convenient to talk about continuous-time Markov chains as we normally understand them, without the possibility of infinite rates. I had it in my mind that we could achieve this by using the monoid <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><mi mathvariant=\"double-struck\">R</mi><mo separator=\"true\">,</mo><mo lspace=\"0em\" rspace=\"0em\">+</mo><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">\\langle \\mathbb{R}, {+}\\rangle</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">+</span></span><span class=\"mclose\">⟩</span></span></span></span> instead of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo lspace=\"0em\" rspace=\"0em\">+</mo><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">\\langle[0,\\infty),{+}\\rangle</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∞</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">+</span></span><span class=\"mclose\">⟩</span></span></span></span>, but I've realised that doesn't work. Given an infinitesimal stochastic matrix <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">t&gt;0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65418em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>, the matrix <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>e</mi><mrow><mo>−</mo><mi>H</mi><mi>t</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">e^{-Ht}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span></span></span></span></span></span></span></span> can (and generally will) have negative entries. This means \"most\" continuous-time Markov processes don't correspond to functors of this form.</p>\n<p>So the question is, can the idea be salvaged? Is there a way to talk about continuous-time Markov processes as functors from a monoid into a Markov category, in such a way that we include all the Markov processes we'd normally want to talk about, but exclude the ones with infinite transition rates? I'm keen to read any existing treatment of ideas along these lines.</p>",
        "id": 212252722,
        "sender_full_name": "Nathaniel Virgo",
        "timestamp": 1601864629
    },
    {
        "content": "<p>I guess a related question: have these \"continuous-time Markov processes with possibly infinite rates\" been written about anywhere? It would be handy to know how to characterise them in terms of linear algebra.</p>",
        "id": 212253101,
        "sender_full_name": "Nathaniel Virgo",
        "timestamp": 1601865301
    },
    {
        "content": "<p>In <a href=\"https://jadeedenstarmaster.wordpress.com/2019/03/31/dynamical-systems-with-category-theory-yes/\">this blog post</a>, <span class=\"user-mention\" data-user-id=\"276037\">@Jade Master</span> talks about smooth dynamical systems as <em>enriched</em> functors from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><mi mathvariant=\"double-struck\">R</mi><mo separator=\"true\">,</mo><mo lspace=\"0em\" rspace=\"0em\">+</mo><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">\\langle \\mathbb{R},{+}\\rangle</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">+</span></span><span class=\"mclose\">⟩</span></span></span></span> to another category, where the enrichment takes care of the smoothness. I'm wondering if something similar can be done here. I hope the enrichment would be in something simpler than diffeological spaces, because in some sense a continuous-time Markov process is a simpler thing than a general dynamical system.</p>",
        "id": 212254842,
        "sender_full_name": "Nathaniel Virgo",
        "timestamp": 1601868178
    },
    {
        "content": "<p>You probably want to work in the context of topological categories and continuous functors.</p>",
        "id": 212256410,
        "sender_full_name": "John Baez",
        "timestamp": 1601871067
    },
    {
        "content": "<p>Great, many thanks!</p>\n<p>Where would I go to learn what those things are? Wikipedia and nlab tell me there are multiple nonequivalent things called topological categories, so I want to make sure I'm looking in to the right one.</p>",
        "id": 212256604,
        "sender_full_name": "Nathaniel Virgo",
        "timestamp": 1601871448
    },
    {
        "content": "<p>I mean categories enriched over Top, not categories internal to Top.</p>",
        "id": 212256796,
        "sender_full_name": "John Baez",
        "timestamp": 1601871762
    },
    {
        "content": "<p>A Markov semigroup is an example of a strongly continuous one-parameter semigroup on a Banach space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>, and it's pretty obvious (once one has the definitions understood) that the latter is the same as a continuous functor from the topological monoid <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo>+</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">([0,\\infty),+)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∞</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">+</span><span class=\"mclose\">)</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">E</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><mo stretchy=\"false\">(</mo><mi>V</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{End}(V)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">E</span><span class=\"mord mathrm\">n</span><span class=\"mord mathrm\">d</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mclose\">)</span></span></span></span> where the latter is a topological monoid using the strong operator topology.  (A topological monoid is the same as a one-object topological category.)</p>",
        "id": 212256888,
        "sender_full_name": "John Baez",
        "timestamp": 1601871932
    },
    {
        "content": "<p>Strongly continuous one-parameter semigroups: <a href=\"https://en.wikipedia.org/wiki/C0-semigroup\">https://en.wikipedia.org/wiki/C0-semigroup</a></p>",
        "id": 212256992,
        "sender_full_name": "John Baez",
        "timestamp": 1601872119
    },
    {
        "content": "<p>Strong operator topology: <a href=\"https://en.wikipedia.org/wiki/Strong_operator_topology\">https://en.wikipedia.org/wiki/Strong_operator_topology</a></p>",
        "id": 212257136,
        "sender_full_name": "John Baez",
        "timestamp": 1601872433
    },
    {
        "content": "<p>I've done stuff on Markov processes from a categorical viewpoint in my work on the phylogenetic operad:</p>\n<p><a href=\"http://www.tac.mta.ca/tac/volumes/32/40/32-40abs.html\">http://www.tac.mta.ca/tac/volumes/32/40/32-40abs.html</a></p>\n<p>However, it's probably more efficient to ask me questions than read this.</p>",
        "id": 212257212,
        "sender_full_name": "John Baez",
        "timestamp": 1601872547
    },
    {
        "content": "<p>By the way, a one-object category <em>enriched</em> in Top is the same as a one-object category <em>internal</em> to Top since there's just one topology on the one-element set.  They're both just topological monoids.  So it doesn't really matter what concept of \"topological category\" you use as long as you're only dealing with one-object categories.</p>",
        "id": 212257544,
        "sender_full_name": "John Baez",
        "timestamp": 1601872908
    },
    {
        "content": "<p>The point is, this gives a way to force everything to be continuous.</p>",
        "id": 212257634,
        "sender_full_name": "John Baez",
        "timestamp": 1601872961
    },
    {
        "content": "<p>That'll eliminate the pathological example you mentioned.  And people working on continuous-time Markov processes always demand them to be continuous.</p>",
        "id": 212257673,
        "sender_full_name": "John Baez",
        "timestamp": 1601872998
    },
    {
        "content": "<p>Great, thanks, I'll look in to this stuff and get back to you if I have questions.</p>\n<p>(Thanks for the link to the phylogenetics paper also. I probably should read it at some point, it's relevant to my interests.)</p>",
        "id": 212257876,
        "sender_full_name": "Nathaniel Virgo",
        "timestamp": 1601873147
    },
    {
        "content": "<p>The cool part of that paper is that \"phylogenetic trees\" as widely studied are operations in a topological operad that's the coproduct of the topological monoid <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[0,\\infty)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span> and the operad for commutative semigroups.</p>",
        "id": 212258393,
        "sender_full_name": "John Baez",
        "timestamp": 1601873516
    },
    {
        "content": "<p>It took about a day to realize this and over a year to prove it.</p>",
        "id": 212258458,
        "sender_full_name": "John Baez",
        "timestamp": 1601873543
    },
    {
        "content": "<p>The annoying part was getting a really concrete general description of the coproduct of topological operads.</p>",
        "id": 212258551,
        "sender_full_name": "John Baez",
        "timestamp": 1601873626
    },
    {
        "content": "<p>This might be totally wrong/unhelpful, but one idea I've had in mind for a long time for similar things is to try to work in the poset of real intervals, in the hope that it makes the passage from discrete to continuous look like a categorical limit</p>",
        "id": 212278764,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1601892015
    },
    {
        "content": "<p>When you say phylogenetic tree, do you mean <a href=\"https://oeis.org/A000311\">https://oeis.org/A000311</a> ? This version of phylogenetic trees is the heart of my derivation of continuous dynamical systems. Unfortunately the derivation is not categorical .</p>",
        "id": 212366111,
        "sender_full_name": "Daniel Geisler",
        "timestamp": 1601938275
    },
    {
        "content": "<p>No, I mean the concept of phylogenetic tree where the edges have lengths - in biology they want to know how \"long\" (in years) is the edge between each branching.   It's explained in the intro to <a href=\"http://math.ucr.edu/home/baez/phylo.pdf\">my paper</a>.</p>",
        "id": 212366648,
        "sender_full_name": "John Baez",
        "timestamp": 1601938777
    },
    {
        "content": "<p>Here's a related, but possibly more difficult/interesting question:</p>\n<p>We can think of a continuous-time Markov chain (CTMC) as a continuous functor from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"false\">(</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo>+</mo><mo fence=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\big([0,\\infty),+\\big)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.20001em;vertical-align:-0.35001em;\"></span><span class=\"mord\"><span class=\"delimsizing size1\">(</span></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∞</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">+</span><span class=\"mord\"><span class=\"delimsizing size1\">)</span></span></span></span></span> to a Markov category. (For now I'm just assuming the 'continuous' part works - I guess it's not actually needed for this next question.) But we might also want to think of it as a set of states and possible transitions, that is, a graph whose edges have rate constants associated with them, which are numbers in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(0,\\infty)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<p>Given such a transition graph, one can build a CTMC by building an infinitesimal stochastic matrix in a straightforward way. (If there are multiple edges you have to add their rate constants together, and if there are self-loops you ignore them.) Then from the infinitesimal stochastic matrix you can build a functor from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"false\">(</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo>+</mo><mo fence=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\big([0,\\infty),+\\big)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.20001em;vertical-align:-0.35001em;\"></span><span class=\"mord\"><span class=\"delimsizing size1\">(</span></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∞</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">+</span><span class=\"mord\"><span class=\"delimsizing size1\">)</span></span></span></span></span> to a Markov category, as discussed above.</p>\n<p>But is there a way to express that relationship in a more category-theoretic way, that is, in terms of functors between suitable categories of weighted graphs and CTMCs, without needing to talk about what goes on \"inside\" the objects?</p>",
        "id": 212503793,
        "sender_full_name": "Nathaniel Virgo",
        "timestamp": 1602031602
    },
    {
        "content": "<p>I don't have it worked out but I'm guessing that this might be a free monoid construction.</p>",
        "id": 212507801,
        "sender_full_name": "Jade Master",
        "timestamp": 1602036143
    },
    {
        "content": "<p>Sorry for the vague comment but I've got to go</p>",
        "id": 212507834,
        "sender_full_name": "Jade Master",
        "timestamp": 1602036213
    },
    {
        "content": "<p>I think I've figured out the answer to my second question now. It turned out to be less of a technical question and more of a philosophical \"how to do applied category theory\" sort of a question. But since that kind of question is currently relevant in another thread, I might as well mention it.</p>\n<p>My question, basically, was \"how do I think of these things as objects with internal structure (weighted transition graphs in this case) and also as functors at the same time?\". I think the solution is just to define the right notion of morphism on weighted transition graphs. If I define the right morphism then the category of weighted graphs will become equivalent to the category of continuous functors, and the equivalence will give me functors in both directions, between the category of transition graphs and the category of continuous functors from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"false\">(</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo>+</mo><mo fence=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\big([0,\\infty),+\\big)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.20001em;vertical-align:-0.35001em;\"></span><span class=\"mord\"><span class=\"delimsizing size1\">(</span></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∞</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">+</span><span class=\"mord\"><span class=\"delimsizing size1\">)</span></span></span></span></span> to FinStoch. Even if it doesn't end up being an equivalence of categories, having a functor from a category transition graphs to the functor category is still useful. Natural transformations between these functors seem to correspond to lumpability of Markov processes, and that tells me how I should define the morphisms of weighted transition graphs - the rest is just filling in the details.</p>",
        "id": 213737114,
        "sender_full_name": "Nathaniel Virgo",
        "timestamp": 1603073279
    },
    {
        "content": "<p>+1 for 'lumpability' <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 213766096,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1603103058
    }
]