[
    {
        "content": "<p>Say I run an e-commerce web site that sells gadgets. It is implemented as an HTTP server program <em>X</em> that can write stuff to a PostgreSQL database <em>Y</em> or to an ElasticSearch installation <em>Z</em>. Then:</p>\n<ul>\n<li>When a manager adds a new gadget, <em>X</em> should write to <em>Y</em> <strong>and</strong> to <em>Z</em>.</li>\n<li>When a customer views a gadget, <em>X</em> may ask the details from either <em>Y</em> <strong>or</strong> <em>Z</em>.</li>\n</ul>\n<p>Here, <em>Y</em> and <em>Z</em> are two backups of the same data. Here is another possible situation:</p>\n<ul>\n<li>When a gadget is written to <em>Y</em>, <em>Y</em> may write to either <em>Y₁</em> <strong>or</strong> <em>Y₂</em>, both of which are SQL databases with identical schemata.</li>\n<li>When a gadget is asked of <em>Y</em>, <em>X</em> must ask the details from <em>Y₁</em> <strong>and</strong> maybe also from <em>Y₂</em> <em>(or in the other order, or in parallel)</em>.</li>\n</ul>\n<p>Whenever I see words <strong>and</strong> and <strong>or</strong>, I think there must be a category with sums and products in play. But in this case I cannot think of a way to formalize this intuition.</p>\n<p>For one approach, we can say that objects are storages and arrows are connections, and we can ask that connections compose associatively. So, for example, <em>X</em> would have composite connection to <em>Y₁</em> through <em>Y</em>. And maybe we can say that now there is a <em>«virtual»</em> storage <em>(Y₁ + Y₂) × Z</em> that <em>X</em> is connected to by virtue of being connected to <em>Y</em> <strong>and</strong> to <em>Z</em>.</p>\n<p>One aspect this model does not account for is the difference between potentiality and actuality at a given time. <em>Z</em> can in principle hold any element of the set of gadgets, but <em>Z</em> is not the set of gadgets — at any given time it is some subset of that set. And <em>X</em> is either the empty set <em>(when the HTTP server is idling)</em> or a singleton set holding one gadget <em>(when the HTTP server is working)</em> at any given time, even though in potentiality it holds all possible gadgets.</p>\n<p>Where can I go from here?</p>",
        "id": 478237777,
        "sender_full_name": "Ignat Insarov",
        "timestamp": 1729587743
    },
    {
        "content": "<p>If I understand you correctly, you first note that we can form a category from \"storages\". We start as follows:</p>\n<ul>\n<li>the objects are storages</li>\n<li>we put an arrow from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> if we have a \"connection\" from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></li>\n</ul>\n<p>It's not totally clear to me what exactly a \"connection\" is. I have at least two questions about that: (1) Can we have a connection from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> without a connection from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>? (2) Can we have multiple distinct connections from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>?</p>\n<p>At any rate, we end up with a (directed multi-)graph of storages and connections, and from that we can freely generate a category.</p>",
        "id": 478333613,
        "sender_full_name": "David Egolf",
        "timestamp": 1729617785
    },
    {
        "content": "<p>However, you then note that this category only describes (to some level of detail) how information can flow around between our storages. It doesn't keep track of the particular state of any storage at some moment in time.</p>",
        "id": 478333708,
        "sender_full_name": "David Egolf",
        "timestamp": 1729617835
    },
    {
        "content": "<p>I don't know enough about this kind of thing to give specific suggestions. (Maybe someone else can chime in though?)</p>\n<p>Here are some resources that might possibly be helpful to you, that talk about ways to model things that change over time using categories:</p>\n<ul>\n<li>a series of blog posts on \"Agent-Based Models\" by John Baez: <a href=\"https://johncarlosbaez.wordpress.com/2023/07/06/agent-based-models-part-1/\">here</a></li>\n<li>\"Categorical System Theory\" by David Jaz Myers: <a href=\"http://davidjaz.com/Papers/DynamicalBook.pdf\">here</a></li>\n<li>\"Seven Sketches in Compositionality\" by Brendan Fong and David Spivak: <a href=\"https://arxiv.org/abs/1803.05316\">here</a></li>\n</ul>\n<p>(I haven't read these yet - just bits and pieces of some of them. But I would like to read them properly someday!)</p>",
        "id": 478335138,
        "sender_full_name": "David Egolf",
        "timestamp": 1729618364
    },
    {
        "content": "<p>On a side note, I find it interesting that two kinds of information flow are present here: reading and writing. This reminds me of medical imaging, where a transducer can both transmit and receive. It seems like there ought to be a way to dream up a category where objects involve two-way interactions... but I'm not sure what morphisms should be! (What should a morphism be between two reading-writing systems? What should a morphism be between two transmitting-receiving systems?)</p>",
        "id": 478336174,
        "sender_full_name": "David Egolf",
        "timestamp": 1729618717
    },
    {
        "content": "<p>Thank you David. These are great questions.</p>\n<p>Say we have a logic. Then:</p>\n<ul>\n<li>There is a category of propositions and implications in this logic, which is a kind of a preorder category — either proposition <em>B</em> follows from proposition <em>A</em> or not. This is the way I think about mathematical problems where I do not usually try to do induction on proof terms or anything such.</li>\n<li>There is a category of propositions and proofs in this logic, which allows for multiple arrows — there is generally any number of ways to prove <em>B</em> given <em>A</em>. This is the way I think about code in Agda or another proof relevant dependently typed programming language.</li>\n</ul>\n<p>By analogy, we may say that:</p>\n<ul>\n<li>There is a category of computers and ways they are allowed to connect. This is how I should think about virtual machines and other abstract resources when I design a cloud based deployment. Either connection from <em>A</em> to <em>B</em> is allowed and will be happening with some regularity, or such connection is not allowed and will never be happening.</li>\n<li>There is a category of storages and <em>«connection options»</em>, where an object is also a computer, and an arrow is a specific private SSH key — or an encryption key of another type, such as a PostgreSQL connection string. Now it is possible to have multiple arrows from one computer to another. This lets us talk concretely about how two specific computers will be connected.</li>\n</ul>\n<p>Either way, connections are not generally symmetric. In some situations, like say a blockchain, we have multiple independent communicating agents that all have connection to one another. In other situations, like say an e-commerce installation, there is a hierarchy with few if any cycles.</p>\n<p>One way we can think about this <em>«duality»</em> of reading and writing is by saying that there are two opposite categories — one where arrows are reading connections and another where arrows are writing connections. Maybe this should even be one single dagger category. But I am not ready to do any meaningful mathematical work in this direction yet.</p>\n<p>None of this brings us closer to understanding transactions as they happen over time. The straightforward way would be to ask for a time-indexed sequence of categories defined as above — but we still need some secret sauce in order to be able to say that at time <em>t₁</em> <em>A</em> knows about gadget <em>g</em> but <em>B</em> does not, and at time <em>t₂</em> both <em>A</em> and <em>B</em> know about <em>g</em>. The things we may wish to prove here are like so:</p>\n<ul>\n<li><em>A</em> can always obtain knowledge about any <em>g</em> at any time <em>t &gt; t₁</em> given some network of connections.</li>\n<li>There are some <em>g</em> such that removing any connection will result in <em>A</em> being unable to obtain knowledge about <em>g</em> at some time <em>t &gt; t₁</em>.</li>\n</ul>\n<p>Practically, in a non-trivial installation there will be many storages, some storages will store more than one type of information, and not all storages will be allowed to store information for time intervals longer than some value. For example:</p>\n<ul>\n<li>An HTTP server is not guaranteed to store anything — it may cache stuff at its own discretion, but it may be forcibly rebooted any time, losing all knowledge.</li>\n<li>An HTTP server may push its logs to a third party logging service that will retain these logs indefinitely, without possibility of erasure.</li>\n<li>The same HTTP server may read and write stuff to the SQL database… but also delete stuff from it!</li>\n<li>The information stored in ElasticSearch may be dropped and regenerated from the SQL database — we may think that there is a one way connection from the SQL database to the ElasticSearch service, even though it goes through some other program that connects to both, reads form SQL, performs the necessary conversions and writes to ElasticSearch. It is as if the ElasticSearch service was a sub-object of the SQL database…</li>\n</ul>\n<p>I have no idea how to formalize any of this.</p>\n<p>I read some of David Jaz Myers's book, and I read some of Brendan Fong and David Spivak's book. But their ideas do not live in me yet. I can draw composition of lenses if you wake me at 3 AM — I have been trying to apply this stuff for the last two years. But still it is not easy to explain how, for example, a non-trivial React web app is a composite lens. I have not seen John Baez's series of blog posts before — it looks interesting!</p>",
        "id": 478342069,
        "sender_full_name": "Ignat Insarov",
        "timestamp": 1729620877
    },
    {
        "content": "<blockquote>\n<ul>\n<li>When a gadget is written to <em>Y</em>, <em>Y</em> may write to either <em>Y₁</em> <strong>or</strong> <em>Y₂</em>, both of which are SQL databases with identical schemata.</li>\n</ul>\n</blockquote>\n<p>Ok. I’m curious, why do <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>Y</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">Y_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>Y</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">Y_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> have identical schemas in this scenario - is it like for “data resilience”, in case one goes down or gets deleted?</p>\n<blockquote>\n<ul>\n<li>When a gadget is asked of <em>Y</em>, <em>X</em> must ask the details from <em>Y₁</em> <strong>and</strong> maybe also from <em>Y₂</em> <em>(or in the other order, or in parallel)</em>. Whenever I see words <strong>and</strong> and <strong>or</strong>, I think there must be a category with sums and products in play. But in this case I cannot think of a way to formalize this intuition.</li>\n</ul>\n</blockquote>\n<p>In the type of categorical data science which I am learning, created by <span class=\"user-mention\" data-user-id=\"281326\">@Ryan Wisnesky</span> and others, schemas are logical (“regular”) theories which have categories as their semantics (I believe), and an instance of a schema is a Set-valued functor on that category. (I am still learning, this may not be accurate).</p>\n<p>Once you have a “database” (which is a schema and an instance), you can run queries to manipulate/transform/migrate that data. I am pretty sure that queries are actually natural transformations.</p>\n<blockquote>\n<p>For one approach, we can say that objects are storages and arrows are connections, and we can ask that connections compose associatively. So, for example, <em>X</em> would have composite connection to <em>Y₁</em> through <em>Y</em>. And maybe we can say that now there is a <em>«virtual»</em> storage <em>(Y₁ + Y₂) × Z</em> that <em>X</em> is connected to by virtue of being connected to <em>Y</em> <strong>and</strong> to <em>Z</em>.</p>\n</blockquote>\n<p>Let’s say a “storage” is an <em>instance</em>. We can update and query these instances, with SQL commands like Insert and Select. </p>\n<p>One thing your question reminds me of is a question of my own about “data synchronization”. I was also recently thinking about a scenario where I wanted updates to one instance to be automatically passed to other instances. In SQL, I think this is done with “triggers”. In Categorical Query Language, I don’t know if this is something that can be implemented or not.</p>\n<p>In categorical query language, migrations are written using the <em>transform</em> keyword (I think). And I do believe transformations can be composed! Let’s hope Ryan gives us some input.</p>\n<blockquote>\n<p>One aspect this model does not account for is the difference between potentiality and actuality at a given time. <em>Z</em> can in principle hold any element of the set of gadgets, but <em>Z</em> is not the set of gadgets — at any given time it is some subset of that set. </p>\n</blockquote>\n<p>I think categorical query language can handle this. First, you’ll define the <strong>schema</strong> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span>, which you said was “ElasticSearch”. In CQL, a schema is defined essentially using types, functions, and equations. I don’t know the structure of ElasticSearch, but we can work on it together if you like. CQL comes with many commonly used schemas already defined. For example, it already has the schema of Apache TinkerPop graph databases, so you can load an actual TinkerPop database into CQL and transform that data in various ways. If you define the schema of your e-commerce data, and of ElasticSearch, you can define “mappings” (CQL’s keyword for functors) which will transform data between the different schemas. Sometimes the mapping will be invertible, so you might be able to synchronize back and forth between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>, I don’t know.</p>\n<p>When you say “potentiality and actuality”, I think you are thinking about the difference between a schema, which would include a type like “Gadget”, and an instance, which would specify which gadgets some instance <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> has.</p>\n<blockquote>\n<p>Where can I go from here?</p>\n</blockquote>\n<p>Trying to model this in CQL could be a beneficial exercise. I’m happy to help.</p>",
        "id": 482443008,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1731604458
    },
    {
        "content": "<p>Remember that all models are wrong, but some models are useful - to determine how to formalize, one must know what one wants to do with the formalization.  For example, this could be implemented, and proved correct, in Coq - even to the level of reasoning about HTTP protocols and file systems (see the paper 'certified web services in ynot' for example).  Or you could formalize a series of updates using techniques from database theory, or CQL; there's several different ways \"updates\" in SQL can be formalized, even in the Spivak body of work.  Sometimes if I don't know what I want to do with the formalization, I pick \"run a simulation\" as a default - could you implement a toy simulator of your system as a state machine, or Petri net, or python code, or ... ?</p>",
        "id": 482462154,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1731611042
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"699750\">Julius Hamilton</span> <a href=\"#narrow/channel/229156-theory.3A-applied-category-theory/topic/Categorification.20of.20storages.2C.20backups.20and.20shardings.3F/near/482443008\">said</a>:</p>\n<blockquote>\n<blockquote>\n<ul>\n<li>When a gadget is written to <em>Y</em>, <em>Y</em> may write to either <em>Y₁</em> <strong>or</strong> <em>Y₂</em>, both of which are SQL databases with identical schemata.</li>\n</ul>\n</blockquote>\n<p>Ok. I’m curious, why do <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>Y</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">Y_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>Y</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">Y_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> have identical schemas in this scenario - is it like for “data resilience”, in case one goes down or gets deleted?</p>\n</blockquote>\n<p>Cool question!</p>\n<ul>\n<li>If <em>X</em> writes everything to <em>Y</em> and <em>Z</em> simultaneously, then one of them can go down and <em>X</em> can still read whatever it wants to recall. Say <em>Y</em> and <em>Z</em> have 50% chance to be down each. Now we have 25% chance to be unable to read <em>(improvement)</em>, but 75% chance to be unable to write <em>(regression)</em>. So, this is a trade-off.</li>\n<li>If <em>X</em> writes everything either to <em>Y₁</em> or <em>Y₂</em> at its choice, then both of them have to be online in order for <em>X</em> to read whatever it wants to recall. Say <em>Y₁</em> and <em>Y₂</em> have 50% chance to be down each. Now we have 50% chance to be unable to read and 25% chance to be unable to write. So, this is a clear-cut improvement.</li>\n</ul>\n<p>I never thought about it this way!</p>\n<p>In practice, I figure people do the <em>«simultaneous write»</em> construction when there are two different systems that should handle the same data. For example, ElasticSearch may be used for, well, searching — it will handle complex search queries better than SQL, while not generally being as fast and reliable as PostgreSQL. And people do the <em>«optional write»</em> construction when they want to distribute load between several back ends. For example, we may want to have two ElasticSearch instances because it is kinda slow and memory inefficient. We can divide rows randomly between the two instances. Then, when we need to search for something, we shall ask both and merge the results. We do not do this currently in the project I use ElasticSearch in, but it is plausible.</p>\n<hr>\n<p>So, I have been thinking about this topic a bit more and I have come up with some half-baked ideas which I am now going to share. Hopefully this will help me fully bake them without being much of a nuisance to everyone else.</p>\n<ol>\n<li>\n<p><a href=\"https://arxiv.org/pdf/1009.1166\">David Spivak's *Functorial Data Migration*</a> seems to be a fitting formalization. It is definitely easier to handle than his earlier simplicial data bases thing, and surely better than the classic relational theory of data bases. So, I am going to use terminology and results from <em>Functorial Data Migration</em> freely from now on.</p>\n</li>\n<li>\n<p>What we are digging into here are not merely schema instances, but schema instances indexed by discrete time. So, in the example above, the HTTP server <em>X</em> is at any time an instance with a single row — it is a stateless <em>«function»</em>. But this row will generally be different at different time indices. Meanwhile, <em>Y</em> will be growing over time: <em>t₁ ≤ t₂ ⇒ Y (t₁) ⊆ Y (t₂)</em>. Generally, instances may either grow or shrink over time.</p>\n</li>\n<li>\n<p>Whenever some <em>X</em> has a connexion to some <em>Y</em>, it is motivated by the need for some information to be synchronized between them. So, we want to say that some rows are in agreement between <em>X</em> and <em>Y</em> at all times.</p>\n</li>\n<li>\n<p>Practically, <em>X</em> and <em>Y</em> may have different clocks and there may be some delay in their connexion, but if so we ask that there be a monotone and continuous function between their time lines, so that for every time interval in <em>X</em>'s time line there were a time interval in <em>Y</em>'s time line where they are in agreement.</p>\n</li>\n</ol>\n<p>The question now is what it means for two instances, say <em>Y₁</em> and <em>Y₂</em>, to be in agreement. Practically, this means that we can run a <em>select A₁ from B₁ where C₁</em> in <em>Y₁</em> and <em>select A₂ from B₂ where C₂</em> in <em>Y₂</em> and get exactly the same instance <em>Z</em> — at all times.</p>\n<p>In the terminology of <em>Functorial Data Migration</em> we can formalize this <em>select …</em> thing as <em>«a single regressive update followed by a single progressive update»</em> <em>(proposition 3.5.6)</em>. For conceptual simplicity, I assume that the regressive update is a natural family of <strong>one to one</strong> functions, which means that we delete some rows, and the progressive update is a natural family of functions <strong>onto</strong> <em>Z</em>, which means that we drop some columns. These spans will be arrows in the category of instances and simple updates. Its construction is a bit technical but, in short, our arrows will be relations that <a href=\"https://arxiv.org/abs/2007.05733v2\">reflect elements and distinctions</a>. I checked and it turns out that these properties are preserved by composition of relations, so we do have here a subcategory of the category of sets and relations.</p>\n<p><em>(I went about the proofs by translating statements about relations to first order logic and then asking an online solver to draw me some pretty pictures like <a href=\"https://www.umsu.de/trees/#(~6y~7xP(x,y))~1(~6z~7yQ(y,z))~5~6z~7x(~7y(P(x,y)~1Q(y,z)))\">this</a> (reflexion of elements is preserved by composition) and <a href=\"https://www.umsu.de/trees/#(~6x~6y~6z(P(x,y)~1P(x,z)~5y=z))~1(~6x~6y~6z(Q(x,y)~1Q(x,z)~5y=z))~5~6x~6y~6z((~7a(P(x,a)~1Q(a,y))~1~7a(P(x,a)~1Q(a,z)))~5y=z)\">this</a> (reflexion of distinctions is preserved by composition).)</em></p>\n<p>So, if <em>select A₁ from B₁ where C₁</em> in <em>Y₁</em> is the relation <em>R₁</em> and <em>select A₂ from B₂ where C₂</em> in <em>Y₂</em> is the relation <em>R₂</em>, and they form an inward span <em>Y₁ → Z ← Y₂</em>, we can take the pullback <em>Y₁ ← P → Y₂</em>. This <em>P</em> tells us exactly which rows of <em>Y₁</em> are synchronized with which rows of <em>Y₂</em>. Let us call such a pullback a <em>«synchrony»</em>.</p>\n<p>Now, a pullback in the category of sets and relations is itself a relation. So we can now pass from the category of instances and simple updates to <strong>the purple bubble foam of instances and synchronies</strong>. To recapitulate, if <em>Y₁</em> and <em>Y₂</em> are time indexed instances, a synchrony from <em>Y₁</em> to <em>Y₂</em> is given by:</p>\n<ul>\n<li>a monotone and continuous function <em>f</em> from time to time</li>\n<li>a pair of updates that form an inward span <em>Y₁ → Z ← Y₂</em></li>\n<li>to every time index <em>t</em>, a pullback <em>Y₁ (t) ← P (t) → Y₂ (f (t))</em> of that inward span</li>\n<li>to every time index <em>t</em>, a proof that <em>P (t)</em> is exactly the pre-image of <em>Z (t)</em> along either side of the pullback square, and not some smaller instance</li>\n</ul>\n<p>This is a bit technical. And I have not done all my homework yet.</p>\n<ul>\n<li>I should like to show that <strong>the purple bubble foam of instances and their synchronies</strong> is really a category.</li>\n<li>It would be interesting to explore whether the pullback <em>Y₁ ← P → Y₂</em> that I defined as an outward span of relations can be understood as updates, and what does <em>P</em> look like.</li>\n<li>I talk of all this as if my instances were simple sets, but they are really diagrams made of multiple sets, arrows and equations. Everything will hopefully work smoothly if I replace relations by natural families of relations as appropriate, but I have not really checked.</li>\n<li>We can probably handle a more general situation where <em>Y₁</em> and <em>Y₂</em> are instances of two different schemate connected by a translation functor, using the contravariant <em>Δ</em> data migration functor, but this also needs to be looked into.</li>\n</ul>\n<p>Does this make sense?</p>",
        "id": 486588781,
        "sender_full_name": "Ignat Insarov",
        "timestamp": 1733516506
    },
    {
        "content": "<p>Let me know if you want to try to formalize some of this in CQL (<a href=\"http://categoricaldata.net\">categoricaldata.net</a>), which is based on functorial data migration - I can help.</p>",
        "id": 486592769,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1733518398
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281326\">@Ryan Wisnesky</span>   Haha thanks, I am honoured! I was staring at that page for an extended period of time today. I guess I should start with the tutorial.</p>",
        "id": 486598809,
        "sender_full_name": "Ignat Insarov",
        "timestamp": 1733521223
    }
]