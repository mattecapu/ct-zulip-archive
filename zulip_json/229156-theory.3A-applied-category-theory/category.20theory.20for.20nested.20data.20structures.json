[
    {
        "content": "<p>Hello, friends. Recently, I've read an article from Spivak (2015) where he talked about how nested data structures had not yet been formalized in category theory. I'm quite interested in this topic, I was wondering if anyone is aware of advances in such front?</p>",
        "id": 281043248,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1651596868
    },
    {
        "content": "<p>Not me.  Maybe someone else here knows.   If not, it would be good to email David Spivak and let us know his answer!</p>",
        "id": 281043576,
        "sender_full_name": "John Baez",
        "timestamp": 1651597013
    },
    {
        "content": "<p>As in \"nested inductive types\"?</p>",
        "id": 281085534,
        "sender_full_name": "Alex Gryzlov",
        "timestamp": 1651616380
    },
    {
        "content": "<p>David showed how a schema can be thought of as a category, and thus used it to rigorously define things like data migration. I was wondering if there was something similar, but with nested data structures.</p>",
        "id": 281089752,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1651618753
    },
    {
        "content": "<p>Are you aware of datatypes represented as polynomial functors/containers? <br>\n<a href=\"https://www.cs.nott.ac.uk/~psztxa/publ/fossacs03.pdf\">https://www.cs.nott.ac.uk/~psztxa/publ/fossacs03.pdf</a></p>",
        "id": 283174440,
        "sender_full_name": "Eric Bond",
        "timestamp": 1653140649
    },
    {
        "content": "<p><a href=\"http://www.contrib.andrew.cmu.edu/~avigad/Papers/qpf.pdf\">http://www.contrib.andrew.cmu.edu/~avigad/Papers/qpf.pdf</a></p>",
        "id": 283174499,
        "sender_full_name": "Eric Bond",
        "timestamp": 1653140730
    },
    {
        "content": "<p>Thanks for the Avigad et al paper <span class=\"user-mention\" data-user-id=\"380293\">@Eric Bond</span> that I didn't know about. but 2019 is a bit old too, what happened since?  do you know?did they complete their Lean library? has it been ported to agda?</p>",
        "id": 283175326,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1653141853
    },
    {
        "content": "<p>I’m not sure what has happened since. Im sure a fair amount of their constructions have been replicated in Agda. What would be interesting is a reexamination of this paper through the lense of HoTT where we can use higher inductive types or quotient inductive inductive types instead of Lean’s notion of quotient.</p>",
        "id": 283175882,
        "sender_full_name": "Eric Bond",
        "timestamp": 1653142661
    },
    {
        "content": "<p>Didn't know about it, <span class=\"user-mention\" data-user-id=\"380293\">@Eric Bond</span> . Thanks for the references.</p>",
        "id": 283176328,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1653143307
    },
    {
        "content": "<p>I once asked in Strathclyde why containers are not used in proof assistants. If I remember correctly, the answer was that you need functional extensionality to prove the container representation theorem (aka that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"bold\">D</mi><mi mathvariant=\"bold\">L</mi><mi mathvariant=\"bold\">e</mi><mi mathvariant=\"bold\">n</mi><mi mathvariant=\"bold\">s</mi></mrow><mo>≅</mo><mrow><mi mathvariant=\"bold\">P</mi><mi mathvariant=\"bold\">o</mi><mi mathvariant=\"bold\">l</mi><mi mathvariant=\"bold\">y</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathbf{DLens} \\cong \\mathbf{Poly}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">DLens</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathbf\" style=\"margin-right:0.01597em;\">Poly</span></span></span></span></span>)</p>",
        "id": 283184778,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1653154880
    },
    {
        "content": "<p>Another reason containers are not used in proof assistants is that the direct implementation isn't very efficient. Using a function to represent a small tuple is usually going to be worse, and involve more unnecessary recomputation, than just storing the values.</p>",
        "id": 283223715,
        "sender_full_name": "Bob Atkey",
        "timestamp": 1653213040
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"277308\">@Bob Atkey</span> and <span class=\"user-mention\" data-user-id=\"275901\">@Jules Hedges</span> , this makes sense. but  I wish <span class=\"user-mention\" data-user-id=\"277574\">@Conor McBride</span>  would comment, as when this zulip started he seemed to have high hopes for the implementation of polynomials, if I understood correctly what he was saying then. (always a big if...)</p>",
        "id": 283235161,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1653230237
    },
    {
        "content": "<p>There's combinatorial species which is very similar to datataypes-as-functors.Maybe this may be of use since from the abstract it tries to reconcile ADTs and species through HoTT? Don't know about nesting though. Is there any reason it couldn't just be regular composition of functors?</p>\n<p><a href=\"https://www.cis.upenn.edu/~sweirich/papers/yorgey-thesis.pdf\">https://www.cis.upenn.edu/~sweirich/papers/yorgey-thesis.pdf</a></p>",
        "id": 283281733,
        "sender_full_name": "Simonas Tutlys",
        "timestamp": 1653291743
    },
    {
        "content": "<p>The idea is the formalize the interplay between the schema category defined by <span class=\"user-mention\" data-user-id=\"276049\">@David Spivak</span> , and a representation of the data as a nested collection. David formalized the notion of a database schema, where one defines the schema as a category <code>S</code> and the instance of a database is a functor (everyone here probably knows this better than me). So what I'm seeking is a way to represent the nested collection  in a similar way, such that one can translate an instance from a relational db to a nested collection.<br>\nI'm still very new to category theory (started studying this year actually), so it's very likely that the solution might not at all complicated, and I'm just unable to grasp it. Or it might be quite complicated, and I just have no idea what I'm getting into.</p>",
        "id": 283304124,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1653305178
    },
    {
        "content": "<p>You can do category theory in category theory so I get where you're coming from - I'm self taught and CT is less of a dense forest and more like fractal matroshka doll where you can model one thing in various equally abstract ways which turn out to be equivalent for some notion of equivalence.It's the most useful empty bowl in math.</p>",
        "id": 283708785,
        "sender_full_name": "Simonas Tutlys",
        "timestamp": 1653378917
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"498398\">@Davi Sales Barreira</span>: Nesting (also related to <em>aggregation</em>) turns out to be surprisingly tricky in this context. Spivak has made some <a href=\"https://arxiv.org/abs/2111.10968\">recent progress</a> on the problem using polynomial functors, but I wouldn't say the issue is resolved yet,</p>\n<p>To understand what's going on, lets build a schema with one object (entity) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and one arrow <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">ℓ</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>P</mi><mo>=</mo><mi mathvariant=\"script\">P</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\ell:X\\to P=\\mathcal{P}(\\mathbb{Z})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">ℓ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.08222em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathbb\">Z</span><span class=\"mclose\">)</span></span></span></span>. </p>\n<p>In order to \"disaggregate\" the subsets, we could extend the schema with a <a href=\"https://ncatlab.org/nlab/show/bundle\">[[bundle]]</a> over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>. If you're not familiar with this idea, we can represent a families of sets indexed by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>Y</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">f:Y\\to X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>; each element <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> corresponds to the set of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span>'s that map to it (the <a href=\"https://ncatlab.org/nlab/show/fiber\">[[fiber]]</a>).</p>\n<p>This forgets about the \"identity\" of the elements in the list, but we can put that back in by adding an attribute <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo>:</mo><mi>Y</mi><mo>→</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">v:Y\\to \\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>. So the new schema will look like this<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">S</mi><mo>←</mo><mi>Y</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{S}\\leftarrow Y \\rightarrow X </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">←</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span></p>\n<p>Using bundles and spans to replace nested data structures is a relatively routine move in database engineering.</p>\n<p>The problem of aggregation is basically the reverse: if we have a bundle in our schema, how can we calculate aggregate operation like a sum over the fibers. The simplest case is just counting how many elements are in a fiber (or even whether there are any).</p>\n<p>\"Aggregate attributes\" like this don't behave in the same way as ordinary attributes; in particular, they are not preserved by natural transformations.  You can check <a href=\"https://www.ams.org/journals/notices/202011/rnoti-p1666.pdf?adat=December%202020&amp;trk=2186&amp;cat=feature&amp;galt=feature\">this paper</a> for a discussion of some of the issues involved.</p>",
        "id": 283747781,
        "sender_full_name": "Spencer Breiner",
        "timestamp": 1653400206
    },
    {
        "content": "<p>thanks a lot <span class=\"user-mention\" data-user-id=\"278008\">@Spencer Breiner</span> ! Some of the concepts are new to me, and I'm still trying to figure out the machinery necessary. You gave me a lot to think about. Indeed, I'm aware of the Functorial Aggregation paper by Spivak. It's in my reading list ;D I just didn't start yet because I need more solid foundation in CT.<br>\nI've actually set a message to David Spivak asking whether the nested structure had already been figured out, since it was related to the aggregation. He told me that it was still not resolved.</p>",
        "id": 283748544,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1653400547
    },
    {
        "content": "<p>The Functorial Aggregation paper is pretty hard. I'm still digesting it myself. The scheduling paper I pointed to is intended to be accessible, so that's probably a good place to start.</p>",
        "id": 283748970,
        "sender_full_name": "Spencer Breiner",
        "timestamp": 1653400726
    },
    {
        "content": "<p>Do you have an example or use case that you want to apply? I find it helps to have a concrete example in front of me when I want to understand an abstract concept.</p>",
        "id": 283749093,
        "sender_full_name": "Spencer Breiner",
        "timestamp": 1653400775
    },
    {
        "content": "<p>A good exercise is to think about the difference between representing a subset in a schema as an arrow <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">Y\\to X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> versus a truth function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mrow><mi mathvariant=\"normal\">B</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">l</mi></mrow></mrow><annotation encoding=\"application/x-tex\">X\\to {\\rm Bool}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Bool</span></span></span></span></span></span>. The instances are the same, but the morphisms are different.</p>",
        "id": 283749458,
        "sender_full_name": "Spencer Breiner",
        "timestamp": 1653400870
    },
    {
        "content": "<p>Whoops! We actually need a limit sketch/schema <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi><mo>↣</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">Y\\rightarrowtail X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6969em;vertical-align:-0.0135em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">↣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> (rather than just a plain category) to get the instances to agree.</p>",
        "id": 283749745,
        "sender_full_name": "Spencer Breiner",
        "timestamp": 1653400986
    },
    {
        "content": "<p>See <a href=\"http://algo.inria.fr/flajolet/Publications/book.pdf\">Analytic Combinatorics - Algorithms Project</a> pg.124<br>\nExample using combinatorial species - <br>\nSet Partitions: F=set(set(Z, card≥1)) while the recursive version is Total Partitions: H=Z+set(H, card≥2).</p>",
        "id": 283758728,
        "sender_full_name": "Daniel Geisler",
        "timestamp": 1653404752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"278008\">Spencer Breiner</span> <a href=\"#narrow/stream/229156-practice.3A-applied-ct/topic/category.20theory.20for.20nested.20data.20structures/near/283749093\">said</a>:</p>\n<blockquote>\n<p>Do you have an example or use case that you want to apply? I find it helps to have a concrete example in front of me when I want to understand an abstract concept.</p>\n</blockquote>\n<p>Yeah, I do.</p>",
        "id": 283776863,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1653411991
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276867\">Daniel Geisler</span> <a href=\"#narrow/stream/229156-practice.3A-applied-ct/topic/category.20theory.20for.20nested.20data.20structures/near/283758728\">said</a>:</p>\n<blockquote>\n<p>See <a href=\"http://algo.inria.fr/flajolet/Publications/book.pdf\">Analytic Combinatorics - Algorithms Project</a> pg.124<br>\nExample using combinatorial species - <br>\nSet Partitions: F=set(set(Z, card≥1)) while the recursive version is Total Partitions: H=Z+set(H, card≥2).</p>\n</blockquote>\n<p>Thanks, I'll take a look.</p>",
        "id": 283776878,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1653412002
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"278008\">@Spencer Breiner</span> , I'll take a look at the article you posted. At the moment, I've mostly studied CT via more applied books (e.g. Seven Sketches; Category Theory for the Sciences). I'm actually finishing Category Theory for the Sciences, do you recommend any follow up book? Many of the terms you've used I haven't actually encountered in these books.</p>",
        "id": 283777162,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1653412124
    },
    {
        "content": "<p>I'm interested in the interplay between a relational db and a nested data structure. I want to formalize how to take RDB instances to a nested format.</p>",
        "id": 283812209,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1653430405
    }
]