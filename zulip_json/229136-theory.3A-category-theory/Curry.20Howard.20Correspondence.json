[
    {
        "content": "<p>I would like to ask the community for references to papers on using category theory to model type theory and proof theory in a way which <em>includes</em> the dynamic aspects of type theory and proof theory, that is, term reduction in type theory and cut elimination in proof theory.</p>\n<p>I am aware of a few papers on this front, but I would very much like to be aware of it if there is a more substantial theory developed which uses category theory to model term reduction semantics.<br>\nThere is this paper - <a href=\"https://dl.acm.org/doi/10.1017/S0960129597002508\">https://dl.acm.org/doi/10.1017/S0960129597002508</a> which uses categories enriched over PER's. This seems like a reasonable approach.<br>\nThere is this paper - <a href=\"https://math.ucr.edu/home/baez/qg-winter2007/seely_2-categorical.pdf\">https://math.ucr.edu/home/baez/qg-winter2007/seely_2-categorical.pdf</a><br>\nWhat else is out there?<br>\nIntuitively it seems that higher category theory would be suited for this. For example, let T be a monad on the category of sets, and let X be a T-algebra. The bar construction associates to X an augmented simplicial object whose higher simplices are n-nested trees of expressions in a certain formal language under an underlying set of variables drawn from X. The 0th face map represents evaluation of terms in X; the other face maps represent flattening of certain trees. So here is a sketch of a semantics of computation, one computes by following the face maps down. We might speculate that using monads for theories with binding operators like the lambda calculus, as developed here, <a href=\"https://drops.dagstuhl.de/opus/volltexte/2019/10513/pdf/LIPIcs-FSCD-2019-6.pdf\">https://drops.dagstuhl.de/opus/volltexte/2019/10513/pdf/LIPIcs-FSCD-2019-6.pdf</a> we could extend this semantics to constructs that programming language theory cares about, beyond just considering terms in first order logic.</p>\n<p>But more generally I would just love to see papers which use either 2-category theory, poset enriched category theory, or infinity category theories to model reduction semantics. If they can say something interesting about strong normalization, cut elimination theorems, and logical consistency, so much the better!</p>\n<p>BTW, homotopy type theory gets pretty close to something I'm talking about, with the idea of adjoint equivalences between types rather than isomorphisms, so that the zigzag identities for adjunctions become \"up to homotopy\" - which is almost, almost, almost what I want. I want zigzag identities for adjunction up to a computational notion of reduction. Basically, the introduction/elimination rule pairs for most constructors should take the form of \"lax adjunctions.\"</p>",
        "id": 397330264,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1697640624
    },
    {
        "content": "<p>My impression is that most category theory literature on type theory and proof theory neglects this but I have not yet done a thorough literature search.  Just some light skimming on Google Scholar. I found this - <br>\n\"Categorical reconstruction of a reduction free normalization proof - Thorsten Altenkirch, Martin Hofmann &amp; Thomas Streicher\"<br>\n<a href=\"https://link.springer.com/chapter/10.1007/3-540-60164-3_27\">https://link.springer.com/chapter/10.1007/3-540-60164-3_27</a><br>\nwhich looks pretty cool.</p>",
        "id": 397331582,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1697641067
    },
    {
        "content": "<p>I sometimes hear people use the phrase \"Curry-Howard-Lambek correspondence.\" I do not like this phrase very much and I will explain why.<br>\nThe phrase \"Curry-Howard correspondence\" refers to </p>\n<ol>\n<li>a static correspondence between <em>types</em> in a type theory and <em>propositions</em> in a logic, and between <em>terms</em> in a type theory and <em>proofs</em> of propositions in a logic</li>\n<li>a dynamic correspondence between <em>term reduction</em> in a type theory and <em>cut elimination</em> in proof theory.</li>\n</ol>\n<p>Number 2 is of <em>substantial interest</em> to proof theorists and type theorists. Strongly normalizing type theories are equivalent to logics with a cut elimination theorem, and cut elimination theorems have very important consequences for analysis of proofs in the logic that lets you prove things by a fairly straightforward induction on the structure of cut-free proofs, not least of which is often the consistency of the logic! I cannot stress enough how much of structural proof theory deals with establishing cut elimination theorems and deriving consequences of them. <br>\nSimilarly type theorists care about using type systems to establish important results about programs in the programming language such as termination guarantees, this is one of the most fundamental things that distinguishes the simply typed lambda calculus from the untyped lambda calculus.</p>\n<p>Now, say 70% of proof theory deals with cut elimination theorems and consistency results, and say 70% of type theory is about using type systems to establish guarantees about program reduction, then 70% of what is important about the Curry-Howard correspondence is in point 2.</p>\n<p>My problem with phrases like \"Curry-Howard-Lambek correspondence\" and \"computational trinitarianism\" is that category theory has had so far very little to say about these dynamic aspects of computation and proof. As far as I am concerned, the phrase \"Curry-Howard-Lambek\" is substantially overstating what category theory has contributed here. I have no problem with recognizing the contributions of Lambek in general, I love categorical logic and think it's extremely valuable, I don't mean to diminish anybody's contributions here, just pointing out what is implicitly being promised when you suggest that category theory gives an <em>equivalent</em> perspective on proof theory and type theory. I would either discourage the use of the phrase \"Curry-Howard-Lambek\" or at least urge anyone who uses it to be aware of the important as-yet-unfulfilled promise contained in that phrase.</p>",
        "id": 397337005,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1697642710
    },
    {
        "content": "<p>My feeling is that everybody is speaking about this but there are not a lot of papers about a general theory which would be about a framework to model any kind of type theory 2-categorically (this is what I'm thinking about). Most of the work is about modelling a specific kind of type theory, most of the time simply typed lambda calculus, as you can see it in the papers you link. </p>\n<p>I can find papers where such ideas are used but it is always applied to a somehow complicated system, not about a general theory for all type theories. Ex: <a href=\"http://Categorifying%20Non-Idempotent%20Intersection%20Types\">Categorifying Non-Idempotent Intersection Types</a>: in this paper he uses a bicategory but I don't understand what the paper is about. Something using bicategories (but this is not a bicategory where the 2-arrows model computations), homotopy and proof theory: <a href=\"https://www.irif.fr/~mellies/template-games/2-template-games-and-differential-linear-logic.pdf\">Template games and differential linear logic</a>.</p>\n<p>I think logicians which are more into logic than category theory don't care too much about establishing a big clean framework like in the book <strong>Categorical Logic and Type Theory</strong>. They are just interested by specific models of specific kind of computations, and can use 2-categories to model computation, along the way.</p>\n<p>Defining a super general framework for all the logics at the same time, taking account of the dynamic aspect would be very cool :) Like something where you allow morphism between the different logics, which preserve computation in some way etc...</p>",
        "id": 397337273,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1697642788
    },
    {
        "content": "<p>By the way, I haven't read your second message before posting this one. You did an edit it so it appeared before this message :)</p>",
        "id": 397337693,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1697642906
    },
    {
        "content": "<p>I was having a felling recently that you could define such kind of a functor from regular logic to differential linear logic. But in fact, it would be a 3-morphism in a 3-category maybe :) if each of the logic is modeled by a 2-category</p>",
        "id": 397338549,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1697643142
    },
    {
        "content": "<p>In the 3-category of all computational/logical systems :)</p>",
        "id": 397338640,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1697643172
    },
    {
        "content": "<p>If I understand your question correctly, my paper <a href=\"https://hal.science/hal-00540205v2/file/macy.pdf\">Cartesian closed 2-categories and permutation equivalence in higher-order rewriting</a> goes in this direction. It exhibits a universal property of something called permutation equivalence in higher-order rewriting (for any simply-typed, higher-order rewriting system), in terms of 2-categories.<br>\n<span class=\"user-mention\" data-user-id=\"506749\">@Benedikt Ahrens</span>'s thesis might also interest you -- if I remember correctly he uses monads relative to the embedding of sets into posets. <br>\nFinally, <span class=\"user-mention\" data-user-id=\"277754\">@Philip Saville</span>'s more recent thesis is about bicategorical interpretations of type theories.</p>",
        "id": 397340865,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1697643865
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"383799\">@Tom Hirschowitz</span>  I was just writing to add your paper to the list ;) there was also a nice paper at POPL this year showing how bicategorical models of untyped lambda calculus let you prove more than the classical setting,  roughly because you're remembering how terms are derived all the time (<a href=\"https://dl.acm.org/doi/10.1145/3571201\">link</a>)</p>\n<p>I did some work on 2-dimensional modelling of type theories in my thesis and a couple of subsequent papers, mainly focussed on versions of simply-typed lambda calculus (e.g. <a href=\"https://philipsaville.co.uk/thesis-for-screen.pdf\">1</a>, <a href=\"https://philipsaville.co.uk/lics2019.pdf\">2</a>, <a href=\"https://philipsaville.co.uk/fossacs2020.pdf\">3</a> ).  In this case you get a particularly tight correspondence between the traditional type theory and the 2-dimensional semantics, in that you can prove there's a rewrite <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>⇒</mo><msup><mi>t</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">t \\Rightarrow t&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> in the 2-dimensional calculus (or equivalently, in the free 2-dimensional model) iff the corresponding terms in the usual lambda calculus are <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">\\beta\\eta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span></span></span></span>-equal. You can also show that rewriting in the calculus with products and exponentials is conservative over the calculus with just products. </p>\n<p>I think the route Marcelo and I took does lay the groundwork for doing 2-dimensional work properly: we started from abstract clones (also presented as cartesian multicategories / Lawvere theories / relative monads), which are an excellent model of syntax, and replaced them with a 2-dimensional version called biclones,  then extracted the type theory from that.  The 2-dimensional rules you end up with then coincide with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">\\beta\\eta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span></span></span></span> in a quite a pleasing way, but with the caveat that you're introducing a quotient on the rewrites. This quotient is a natural one because it says <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction after <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">\\eta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span></span></span></span>-expansion is doing nothing (cf. some papers by Ghani &amp; Jay talking about this), but it's perhaps less nice to rewriting theorists, who have spent a long time thinking about which quotients have good properties for proving things -- my impression is that some of the categorically-natural rules are very badly behaved from this perspective. (Another consequence is that the semantic interpretation + free model are easier to construct this way -- otherwise there are some subtleties with how strict things are that get pretty ticklish.)</p>\n<p>A lot of type-theoretic constructs (products, exponentials, sums, monadic metalanguage a la Moggi,...) can be phrased as structure in the 2-category of clones, so I expect a version of this to work one level up if you play the same game in the tricategory of biclones. Likewise for linear / ordered type theories, where you work with (symmetric) multicategories instead. I'm currently looking to see whether you can get Moggi's monadic metalanguage + its rewrites from this framework, by looking at pseudomonads in 2-Clone / Biclone.</p>\n<p>I haven't got round to checking yet (it's on the list, with too much other stuff!), but I imagine a lot of this can be done using the kind of ideas Marcelo has already used (e.g. <a href=\"https://arxiv.org/abs/2006.16949\">this paper with Nathanael Arkor</a> or <a href=\"https://homepages.inf.ed.ac.uk/gdp/publications/Abstract_Syn.pdf\">the '99 abstract syntax paper</a> ) because one of the big insights there is that type theories can be described using structured clones (see e.g. Prop 3.4 in the '99 paper). So I imagine one could start with a signature described as an endofunctor on Cat and construct a collection of corresponding biclones (or 2-clones if you prefer) that is sound and complete for describing the corresponding type theory, complete with the rewrites. </p>\n<p>(If you want type theories that go beyond simple type theory, then at that point I'm stuck.)</p>",
        "id": 397343312,
        "sender_full_name": "Philip Saville",
        "timestamp": 1697644801
    },
    {
        "content": "<p>Pinging <span class=\"user-mention\" data-user-id=\"520261\">@William Troiani</span> because he is interested in using higher categorical structures to model dynamics/computational content of proofs.</p>",
        "id": 397385105,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1697664128
    },
    {
        "content": "<p>As far back as the 2nd edition of LICS (!), in 1987, <a href=\"https://lics.siglog.org/archive/1987/Seely-ModellingComputatio.html\">Seely</a> advocated for using higher category theory to, so to speak, take seriously the computational/cut-elimination aspect of the Curry-Howard correspondence.  For years, this viewpoint was picked up only very sporadically, for example by <a href=\"https://www.irif.fr/~mellies/mpri/mpri-ens/articles/hilken-2-lambda-calculus.pdf\">Hilken</a> in his <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">2\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus, by <span class=\"user-mention\" data-user-id=\"383799\">@Tom Hirschowitz</span> in the paper he already mentioned, or, on the semantic side, by <a href=\"https://www.irif.fr/~mellies/mpri/mpri-ens/articles/fiore-gambino-hyland-winskel-the-cartesian-closed-bicategory-of-generalised-species-of-structures.pdf\">Fiore, Gambino, Hyland and Winskel</a>.  It was even discussed, long ago, on the nCategory Café, in <a href=\"https://golem.ph.utexas.edu/category/2006/08/categorifying_cccs_seeing_comp.html\">a post</a> written by <span class=\"user-mention\" data-user-id=\"275920\">@John Baez</span>.  Now it looks like interest in \"2-dimensional\" semantics and rewriting is really starting to spread out, which is great!  (For example, at the last LICS there were at least three papers on bicategorical semantics of logic/computation, and then of course there are all the papers mentioned by other people above.  I am particularly impressed by Fiore and <span class=\"user-mention\" data-user-id=\"277754\">@Philip Saville</span>'s work, which I was not aware of).</p>",
        "id": 397469651,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1697709181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"424412\">Patrick Nicodemus</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/397330264\">said</a>:</p>\n<blockquote>\n<p>[...] I would just love to see papers which use either 2-category theory, poset enriched category theory, or infinity category theories to model reduction semantics. If they can say something interesting about strong normalization, cut elimination theorems, and logical consistency, so much the better!</p>\n</blockquote>\n<p>With my former PhD students Luc Pellissier and Pierre Vial, we used <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Cat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Cat</span></span></span></span></span>-enriched cartesian multicategories and certain kinds of (very \"loose\") fibrations to model type systems for programming languages.  The idea is the obvious one: a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Cat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Cat</span></span></span></span></span>-enriched cartesian multicategory models a (possibly typed) programming language, in which objects are types, multimorphisms of arity <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> are programs with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> parameters and 2-arrows are computations.   A functor between such multicategories (I mean a morphism of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Cat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Cat</span></span></span></span></span>-enriched cartesian multicategories) is a semantic-preserving encoding of a programming language into another.   If the target programming language is somehow of a \"semantic\" nature, then functors may also be seen as semantic interpretations (for instance, if the target is a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">S</mi><mi mathvariant=\"bold\">e</mi><mi mathvariant=\"bold\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Set}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Set</span></span></span></span></span>-enriched cartesian multicategory, then you recover traditional denotational semantics).</p>\n<p>Picking up on an idea due to Melliès and Zeilberger, we view type systems as special kinds of functors, which we call <em>Niefield functors</em> and which enjoy a version of the Grothendieck construction: a Niefield functor on (small) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> is the same as a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>→</mo><mrow><mi mathvariant=\"script\">R</mi><mi mathvariant=\"script\">e</mi><mi mathvariant=\"script\">l</mi></mrow></mrow><annotation encoding=\"application/x-tex\">L\\to\\mathcal{Rel}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">R</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">R</mi><mi mathvariant=\"script\">e</mi><mi mathvariant=\"script\">l</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{Rel}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">R</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span> is a certain (large) bicategory of distributors and relational natural transformations.  In particular, Niefield functors are stable under pullback, so the pullback of a type system is a type system.  Fundamental properties of type systems like subject reduction and subject expansion become \"fibrational\" properties of Niefield functors: a Niefield fibration/opfibration is a type system satisfying subject expansion/reduction.  These too are pullback-stable.</p>\n<p>This allowed us to formulate a very general theorem about so-called <em>intersection types</em>.  These are known to be able to capture all sorts of termination properties for all sorts of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculi (call-by-name, call-by-value, with continuations, etc.).  We show that, for each \"flavor\" of intersection types (idempotent or not, etc.) there's a \"universal\" intersection type system <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> for linear logic, and basically every intersection type system for some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> introduced in the past 30 years may be obtained by pulling back the suitable <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> along an encoding of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> in linear logic.  In fact, the framework also immediately gives you new systems (for example, for the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda\\mu</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\">μ</span></span></span></span>-calculus) and, with Ugo Dal Lago, Marc de Visme and Akira Yoshimizu, we later used it to get an intersection type system for the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span>-calculus, thanks to previous work by Honda and Laurent, and Ehrhard and Laurent, showing how this may be mapped to linear logic.</p>\n<p>A very interesting aspect of all this is, I think, that it uncovers how intersection types actually build a \"bridge\" between a \"weak termination\" property and a \"strong termination\" property.  That is, you have properties <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> of your programming language, such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> trivially implies <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span>, and every proof showing that intersection types capture some kind of termination is actually showing that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> implies typable and that typable implies <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>, so that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> and typable coincide.  We give a categorical abstraction of what <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> may be, as well as sufficient conditions, formulated at the level of the Niefield functors representing the type systems, so that these implications hold.  We call it the \"fundamental theorem of intersection types\".</p>\n<p>What happens in practice is that people focus on one of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>, disregarding the other (in the sense that they don't even see that it's there), and present their result as \"typable iff <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>\" (or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span>).  The (higher) categorical perspective allows you to see that usually there is also a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> (or an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>), and it is often very interesting to know that it is equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> (or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span>).  For instance, fundamental <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus results like</p>\n<ul>\n<li>a term is solvable iff it is has a head normal form;</li>\n<li>a term has a head normal form iff head reduction terminates;</li>\n<li>a term is normalizable iff leftmost reduction terminates;</li>\n<li>a term is strongly normalizable iff perpetual reduction terminates;</li>\n</ul>\n<p>and so on, are all instances of the fundamental theorem of intersection types!</p>\n<p>All this appeared in <a href=\"https://lipn.univ-paris13.fr/~mazza/papers/IntersectionTypes.pdf\">a POPL 2018 paper</a>, as well as in Luc's thesis.  I also wrote my <em>habilitation</em> <a href=\"https://hal.science/tel-04238579\">thesis</a> with this higher-multicategorical perspective in mind.  The higher-categorical approach to Curry-Howard was also briefly discussed here on Zulip, in <a href=\"#narrow/stream/269484-seminar.3A-Topos-Colloquium/topic/Valeria.20de.20Paiva.3A.20.22Categorical.20Explicit.20Substitutions.22/near/250597527\">a thread about explicit substitutions</a>, which are a typical thing that \"does not exist\" at the 1-categorical level (calculi with explicit substitutions have the same normal forms as calculi without them, so explicit substitutions are invisible in 1-categorical semantics.  This is just an observation, at the moment I am not aware of any work trying to give a higher-categorical semantics to explicit substitutions).</p>",
        "id": 397469981,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1697709297
    },
    {
        "content": "<p>This is a lot of interesting stuff! It's definitely true in general that operational semantics is under-appreciated in on the category theory side. I remember Neil Ghani complaining to me about people using 2-cells to model reduction, which he thought is naive compared to what's possible - namely \"structural operational semantics\", which is about having a monad describing your syntax and a comonad describing your dynamics, and a distributive law saying how they interact. I don't know anything else about it, and I suspect it was worked out for things like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span>-calculus, so it might or might not be known how it applies to harder things like cut elimination</p>",
        "id": 397480969,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1697713310
    },
    {
        "content": "<p>I would really like to see this monad/comonad interaction worked out on a simple example, it sounds really interesting but I don't understand how it's supposed to work (especially the comonadic part, how does it describe the dynamics?) and how it relates to higher categories...  Has Neil Ghani written something on this approach?</p>",
        "id": 397519731,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1697726161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276839\">Damiano Mazza</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/397469651\">said</a>:</p>\n<blockquote>\n<p>As far back as the 2nd edition of LICS (!), in 1987, <a href=\"https://lics.siglog.org/archive/1987/Seely-ModellingComputatio.html\">Seely</a> advocated for using higher category theory to, so to speak, take seriously the computational/cut-elimination aspect of the Curry-Howard correspondence.  For years, this viewpoint was picked up only very sporadically, for example by <a href=\"https://www.irif.fr/~mellies/mpri/mpri-ens/articles/hilken-2-lambda-calculus.pdf\">Hilken</a> in his <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">2\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus, by <span class=\"user-mention silent\" data-user-id=\"383799\">Tom Hirschowitz</span> in the paper he already mentioned, or, on the semantic side, by <a href=\"https://www.irif.fr/~mellies/mpri/mpri-ens/articles/fiore-gambino-hyland-winskel-the-cartesian-closed-bicategory-of-generalised-species-of-structures.pdf\">Fiore, Gambino, Hyland and Winskel</a>.  It was even discussed, long ago, on the nCategory Café, in <a href=\"https://golem.ph.utexas.edu/category/2006/08/categorifying_cccs_seeing_comp.html\">a post</a> written by <span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span>.  Now it looks like interest in \"2-dimensional\" semantics and rewriting is really starting to spread out, which is great!  (For example, at the last LICS there were at least three papers on bicategorical semantics of logic/computation, and then of course there are all the papers mentioned by other people above.  I am particularly impressed by Fiore and <span class=\"user-mention silent\" data-user-id=\"277754\">Philip Saville</span>'s work, which I was not aware of).</p>\n</blockquote>\n<p>Since you @ed some of the people: <span class=\"user-mention\" data-user-id=\"276755\">@Robert Seely</span> is also on this Zulip.</p>",
        "id": 397529509,
        "sender_full_name": "Leopold Schlicht",
        "timestamp": 1697729208
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276839\">Damiano Mazza</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/397519731\">said</a>:</p>\n<blockquote>\n<p>I would really like to see this monad/comonad interaction worked out on a simple example, it sounds really interesting but I don't understand how it's supposed to work (especially the comonadic part, how does it describe the dynamics?) and how it relates to higher categories...  Has Neil Ghani written something on this approach?</p>\n</blockquote>\n<p>Apparently this paper is the standard reference on this: <a href=\"https://homepages.inf.ed.ac.uk/gdp/publications/Math_Op_Sem.pdf\">https://homepages.inf.ed.ac.uk/gdp/publications/Math_Op_Sem.pdf</a></p>\n<p>(Don't ask me any questions about it, I haven't read it!)</p>",
        "id": 397531347,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1697729783
    },
    {
        "content": "<p>Well, recently, <span class=\"user-mention\" data-user-id=\"585426\">@Sergey Goncharov</span>,  <span class=\"user-mention\" data-user-id=\"275900\">@Stelios Tsampas</span>, <span class=\"user-mention\" data-user-id=\"590526\">@Henning Urbat</span>, and Stefan Milius, but also <span class=\"user-mention\" data-user-id=\"276696\">@Ambroise</span> and I, have <a href=\"https://arxiv.org/abs/2302.08200\">worked</a> on categorical <a href=\"https://hal.science/hal-03999584\">approaches</a> to operational semantics. They use a variant of the distributive law approach, while we model dynamics as edges (in a generalised kind of graph). Both groups have been mainly working on congruence of bisimilarity for now, but I believe both approaches may be used to prove other kinds of results. (This is getting a bit far away from the OP's original question, sorry.)</p>",
        "id": 397569029,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1697745566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276839\">Damiano Mazza</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/397519731\">said</a>:</p>\n<blockquote>\n<p>I would really like to see this monad/comonad interaction worked out on a simple example, it sounds really interesting but I don't understand how it's supposed to work (especially the comonadic part, how does it describe the dynamics?) and how it relates to higher categories...  Has Neil Ghani written something on this approach?</p>\n</blockquote>\n<p>I don't really know anything about this topic but Power and Watanabe have a paper on every possible way to have a monad distribute over a comonad or vice versa, and they cite a paper by Turi and Plotkin on this topic as their motivation. <br>\n\"D. Turi, G. Plotkin, Towards a mathematical operational semantics\"<br>\nProceedings, Lecture Notes in Computer Science, Vol. 97, IEEE Press, 1997, pp. 280–291</p>\n<p>This appears to maybe be inspired by earlier work of Turi.<br>\n\"J. Rutten, D. Turi, Initial algebra and Final coalgebra semantics for concurrency\" <br>\n J. de Bakker, et al.<br>\n(Eds.), Proc. REX Workshop A Decade of Concurrency – Reflections and Perspectives, Lecture Notes in Computer Science, Vol. 803, Springer, Berlin, 1994, pp. 530–582</p>",
        "id": 397596791,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1697761724
    },
    {
        "content": "<p>Brooke and Geva have also studied the distributivity of a monad over comonad in computer science but their motivations are different. <br>\n\" S. Brookes, S. Geva, Computational comonads and intensional semantics\"</p>",
        "id": 397596912,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1697761797
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276839\">Damiano Mazza</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/397469981\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"424412\">Patrick Nicodemus</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/397330264\">said</a>:</p>\n<blockquote>\n<p>[...] I would just love to see papers which use either 2-category theory, poset enriched category theory, or infinity category theories to model reduction semantics. If they can say something interesting about strong normalization, cut elimination theorems, and logical consistency, so much the better!</p>\n</blockquote>\n<p>With my former PhD students Luc Pellissier and Pierre Vial, we used <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Cat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Cat</span></span></span></span></span>-enriched cartesian multicategories and certain kinds of (very \"loose\") fibrations to model type systems for programming languages.  The idea is the obvious one: a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Cat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Cat</span></span></span></span></span>-enriched cartesian multicategory models a (possibly typed) programming language, in which objects are types, multimorphisms of arity <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> are programs with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> parameters and 2-arrows are computations.   A functor between such multicategories (I mean a morphism of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Cat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Cat</span></span></span></span></span>-enriched cartesian multicategories) is a semantic-preserving encoding of a programming language into another.   If the target programming language is somehow of a \"semantic\" nature, then functors may also be seen as semantic interpretations (for instance, if the target is a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">S</mi><mi mathvariant=\"bold\">e</mi><mi mathvariant=\"bold\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Set}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Set</span></span></span></span></span>-enriched cartesian multicategory, then you recover traditional denotational semantics).</p>\n<p>Picking up on an idea due to Melliès and Zeilberger, we view type systems as special kinds of functors, which we call <em>Niefield functors</em> and which enjoy a version of the Grothendieck construction: a Niefield functor on (small) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> is the same as a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>→</mo><mrow><mi mathvariant=\"script\">R</mi><mi mathvariant=\"script\">e</mi><mi mathvariant=\"script\">l</mi></mrow></mrow><annotation encoding=\"application/x-tex\">L\\to\\mathcal{Rel}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">R</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">R</mi><mi mathvariant=\"script\">e</mi><mi mathvariant=\"script\">l</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{Rel}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">R</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span> is a certain (large) bicategory of distributors and relational natural transformations.  In particular, Niefield functors are stable under pullback, so the pullback of a type system is a type system.  Fundamental properties of type systems like subject reduction and subject expansion become \"fibrational\" properties of Niefield functors: a Niefield fibration/opfibration is a type system satisfying subject expansion/reduction.  These too are pullback-stable.</p>\n<p>This allowed us to formulate a very general theorem about so-called <em>intersection types</em>.  These are known to be able to capture all sorts of termination properties for all sorts of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculi (call-by-name, call-by-value, with continuations, etc.).  We show that, for each \"flavor\" of intersection types (idempotent or not, etc.) there's a \"universal\" intersection type system <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> for linear logic, and basically every intersection type system for some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> introduced in the past 30 years may be obtained by pulling back the suitable <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> along an encoding of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> in linear logic.  In fact, the framework also immediately gives you new systems (for example, for the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda\\mu</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\">μ</span></span></span></span>-calculus) and, with Ugo Dal Lago, Marc de Visme and Akira Yoshimizu, we later used it to get an intersection type system for the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span>-calculus, thanks to previous work by Honda and Laurent, and Ehrhard and Laurent, showing how this may be mapped to linear logic.</p>\n<p>A very interesting aspect of all this is, I think, that it uncovers how intersection types actually build a \"bridge\" between a \"weak termination\" property and a \"strong termination\" property.  That is, you have properties <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> of your programming language, such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> trivially implies <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span>, and every proof showing that intersection types capture some kind of termination is actually showing that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> implies typable and that typable implies <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>, so that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> and typable coincide.  We give a categorical abstraction of what <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> may be, as well as sufficient conditions, formulated at the level of the Niefield functors representing the type systems, so that these implications hold.  We call it the \"fundamental theorem of intersection types\".</p>\n<p>What happens in practice is that people focus on one of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>, disregarding the other (in the sense that they don't even see that it's there), and present their result as \"typable iff <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>\" (or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span>).  The (higher) categorical perspective allows you to see that usually there is also a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> (or an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>), and it is often very interesting to know that it is equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> (or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span>).  For instance, fundamental <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus results like</p>\n<ul>\n<li>a term is solvable iff it is has a head normal form;</li>\n<li>a term has a head normal form iff head reduction terminates;</li>\n<li>a term is normalizable iff leftmost reduction terminates;</li>\n<li>a term is strongly normalizable iff perpetual reduction terminates;</li>\n</ul>\n<p>and so on, are all instances of the fundamental theorem of intersection types!</p>\n<p>All this appeared in <a href=\"https://lipn.univ-paris13.fr/~mazza/papers/IntersectionTypes.pdf\">a POPL 2018 paper</a>, as well as in Luc's thesis.  I also wrote my <em>habilitation</em> <a href=\"https://hal.science/tel-04238579\">thesis</a> with this higher-multicategorical perspective in mind.  The higher-categorical approach to Curry-Howard was also briefly discussed here on Zulip, in <a href=\"#narrow/stream/269484-seminar.3A-Topos-Colloquium/topic/Valeria.20de.20Paiva.3A.20.22Categorical.20Explicit.20Substitutions.22/near/250597527\">a thread about explicit substitutions</a>, which are a typical thing that \"does not exist\" at the 1-categorical level (calculi with explicit substitutions have the same normal forms as calculi without them, so explicit substitutions are invisible in 1-categorical semantics.  This is just an observation, at the moment I am not aware of any work trying to give a higher-categorical semantics to explicit substitutions).</p>\n</blockquote>\n<p>Ok, thank you. this is really interesting, I think it will take me a bit to understand it. This has sparked some really good discussion, I am super thankful for all commenters.</p>",
        "id": 397597331,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1697762050
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"424412\">Patrick Nicodemus</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/397596791\">said</a>:</p>\n<blockquote>\n<p>I don't really know anything about this topic but Power and Watanabe have a paper on every possible way to have a monad distribute over a comonad or vice versa, and they cite a paper by Turi and Plotkin on this topic as their motivation. <br>\n\"D. Turi, G. Plotkin, Towards a mathematical operational semantics\"<br>\nProceedings, Lecture Notes in Computer Science, Vol. 97, IEEE Press, 1997, pp. 280–291</p>\n</blockquote>\n<p>Yes, very nice, the Turi and Plotkin framework is the basis of our work (the one that <span class=\"user-mention\" data-user-id=\"383799\">@Tom Hirschowitz</span>, who has himself done super cool work on the foundations of operational semantics,  mentioned, see e.g. <a href=\"https://arxiv.org/pdf/2210.13387.pdf\">https://arxiv.org/pdf/2210.13387.pdf</a> and <a href=\"https://arxiv.org/abs/2302.08200\">https://arxiv.org/abs/2302.08200</a>).</p>\n<p>I'll try to be brief and I can elaborate if you find this interesting. Lately we've extended said Turi and Plotkin approach to higher-order languages and some core principles carry over to the higher-order setting. We can also do languages with variable binding such as the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus; for that we are making use of Fiore's foundations  in \"Abstract syntax and variable binding\" that <span class=\"user-mention\" data-user-id=\"277754\">@Philip Saville</span> mentioned.</p>\n<p>The main goal of this track is not to give a computational aspect to the Curry-Howard-Lambek correspondence... it's more about coming up with a precise, satisfactory definition of operational semantics, generalize and simplify reasoning principles, that sort of stuff. However, in our latest (yet unreleased) work we have been playing around with an implementation of STLC in the higher-order Mathematical Operational Semantics style. This got me thinking if there is something to be said about the Curry-Howard-Lambek correspondence!</p>",
        "id": 397685551,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1697799955
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275901\">Jules Hedges</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/397531347\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276839\">Damiano Mazza</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/397519731\">said</a>:</p>\n<blockquote>\n<p>I would really like to see this monad/comonad interaction worked out on a simple example, it sounds really interesting but I don't understand how it's supposed to work (especially the comonadic part, how does it describe the dynamics?) and how it relates to higher categories...  Has Neil Ghani written something on this approach?</p>\n</blockquote>\n<p>Apparently this paper is the standard reference on this: <a href=\"https://homepages.inf.ed.ac.uk/gdp/publications/Math_Op_Sem.pdf\">https://homepages.inf.ed.ac.uk/gdp/publications/Math_Op_Sem.pdf</a></p>\n<p>(Don't ask me any questions about it, I haven't read it!)</p>\n</blockquote>\n<p>It's weird because this paper is <strong>very</strong>, <strong><em>very</em></strong> famous in the CS crowd doing semantics of programming languages &amp; so on. This and the paper with Fiore have around 500 citations each!<br>\nThat said, I'm a big big fan of 2-cells-as-reductions and of the paper of Seely's mentioned by <span class=\"user-mention\" data-user-id=\"276839\">@Damiano Mazza</span> . I'd love to see the two approaches coming together though, instead of having CT go off its tangent ignoring the current practice in the field (I will now retreat in my shell---I'm sure people <em>are</em> aware of the current practice in the field)</p>",
        "id": 398036284,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1698049786
    },
    {
        "content": "<p>Wait, <span class=\"user-mention\" data-user-id=\"275932\">@Matteo Capucci (he/him)</span>, before retreating, could you please explain what you mean? <span aria-label=\"shell\" class=\"emoji emoji-1f41a\" role=\"img\" title=\"shell\">:shell:</span> Maybe something that wasn't clear from the discussion is why there are two different approaches: I think one main reason is that the 2-categorical approach takes “congruence” as built in, hence isn't <em>a priori</em> as expressive as the bialgebraic approach.<br>\nWhat I mean by congruence is that rewrites may occur anywhere in programs, which is only true for a restricted class of languages. Typically, you don't evaluate the body of an effectful function before it is applied.<br>\nDoes this have to do with what you meant?</p>",
        "id": 398038748,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1698050790
    },
    {
        "content": "<p>I'm not very familiar with the details, I only eavesdrop on programming language semantics. Is there a common use case of both approaches where you can compare?</p>",
        "id": 398039583,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1698051106
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"383799\">Tom Hirschowitz</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/398038748\">said</a>:</p>\n<blockquote>\n<p>What I mean by congruence is that rewrites may occur anywhere in programs, which is only true for a restricted class of languages.</p>\n</blockquote>\n<p>But isn't this only accidentally true?  I mean, it is true because people (including myself) have only considered approaches where, roughly, 1-cells <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\to B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> are programs of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> with a free variable <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>, and compositon is substitution for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>.  But other approaches are conceivable in which rewrites are still 2-cells (for instance, 1-cells could be evaluation contexts, which are usually closed under composition).  I mean, I have never seriously done anything like this so maybe it will fail for trivial reasons as soon as one tried to actually develop it, but at the moment I don't see why the 2-categorical approach must <em>necessarily</em> force rewrites everywhere...</p>",
        "id": 398041289,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1698051717
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"275932\">@Matteo Capucci (he/him)</span> yes, sure, (potentially higher-order) rewrite systems exist on both sides. Did you mean that someone should bridge the gap? Like, define a, say “congruent” subcase of the bialgebraic approach in which one may construct a 2-category related in some suitable sense to the generated bialgebra?</p>\n<p><span class=\"user-mention\" data-user-id=\"276839\">@Damiano Mazza</span> You're right of course, there are ways around this. Another way is to have a special constructor to trigger evaluation. But another problem is that 2-categories hardly model <strong>labelled</strong> transition systems, so you need to go to double categories. People like Roberto Bruni, Fabio Gadducci, and Ugo Montanari tried that in the 90's. I also spent quite some time trying to make this work, in vain. I'd be a bit jealous if someone succeeded, but also really glad, because it should work.</p>",
        "id": 398046648,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1698053633
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"383799\">Tom Hirschowitz</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/398046648\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"275932\">Matteo Capucci (he/him)</span> yes, sure, (potentially higher-order) rewrite systems exist on both sides. Did you mean that someone should bridge the gap? Like, define a, say “congruent” subcase of the bialgebraic approach in which one may construct a 2-category related in some suitable sense to the generated bialgebra?</p>\n</blockquote>\n<p>I'm saying it'd be weird if there is nothing to learn from the current state of the art of categorial operational semantics, i.e. Turi-Plotkin semantics, and that if higher CT ever wants to be taken seriously in this domain (or, for what matters, any domain) then it should at last show how it relates to it.<br>\nSorry, I sound like a grumpy old man. That's why I wanted to stay in my shell. I don't like being the <em>umarel</em> of the situation.</p>",
        "id": 398057109,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1698057628
    },
    {
        "content": "<p>So... this kind of sounds like a “yes”, right?</p>",
        "id": 398069356,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1698062389
    },
    {
        "content": "<p>Yeah</p>",
        "id": 398071927,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1698063259
    },
    {
        "content": "<p>I think it's for certain known by many who think about Curry-Howard-Lambek that you _could_ extend the Lambek side so that beta-reduction is modelled by 2-morphisms. When people consider beta-reduction/cut-elimination, they are often concerned with complexity theoretic questions. In the translation to category theory -- even 2-category theory -- this information is lost. So my question is: what is gained from this perspective? One might even suggest that the _point_ of denotational semantics _is_ to reduce (beta-)equivalence to a more strict equality.</p>",
        "id": 398262569,
        "sender_full_name": "Chris Barrett",
        "timestamp": 1698145316
    },
    {
        "content": "<p>Wht does modelling beta reduction as a 2-morphism lose information about complexity?</p>",
        "id": 398271679,
        "sender_full_name": "John Baez",
        "timestamp": 1698147911
    },
    {
        "content": "<p>I guess <span class=\"user-mention\" data-user-id=\"277010\">@Chris Barrett</span> means because general 2-cells don't have an intrinsic length, while reduction sequences do. But probably this could be remedied rather easily.</p>\n<p>What is gained, on the other hand, is essentially that </p>\n<ul>\n<li>\n<p>everything is more typed: we have notions of “language with reductions” and “specification of a language with reductions” (“signatures”, say), and</p>\n</li>\n<li>\n<p>we have a generic construction of a language with reductions from any signature.</p>\n</li>\n</ul>\n<p>This should be contrasted with the mainstream technology used in the programming languages literature, which consists in doing everything by hand (or sweeping things under the rug for clarity).</p>",
        "id": 398281043,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1698151350
    },
    {
        "content": "<p>Adding to (or, really, rephrasing) Tom's message, being able to have a higher-categorical account of reductions will hopefully give us better answers (than those available today) to the question \"What is a programming language?\", so there's definitely something to be gained.  More in topic with this thread, if we had a good answer to the question \"What is the Curry-Howard 'isomorphism' an isomorphism of?\" that would be nice too I think.  The length of reductions plays no role in these questions.</p>",
        "id": 398283544,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1698152223
    },
    {
        "content": "<p>It is true, though, that the answer to all these questions has an unspecified format (they are <em>koans</em>, as Jan Willem Klop would call them!), so the actual gain will depend on the nature of the answers...</p>",
        "id": 398284635,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1698152530
    },
    {
        "content": "<p>Yes, no problem with the length of the reductions, for cut elemination in a logic, your 2-morphisms are freely generated by the reduction steps, so that the notion of length of the reduction is definied. Nothing in such a loss of information would have to do with category theory, it's exactly when you write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><msup><mo>→</mo><mo>∗</mo></msup><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x \\rightarrow^* y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\">→</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> instead of say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><msup><mo>→</mo><mi>n</mi></msup><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x \\rightarrow^{n} y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\">→</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> if a term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> is rewritten to a term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> in a rewriting system, in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> steps. You chose whether you specify the lengths or not, with a categorical or non-categorical formalism, this is just a choice. But this is true that complexity issues have not been analysed with category theory as far as know. It doesn't mean that it is impossible. The thing to do is to encode as much as CSists need in category theory.</p>",
        "id": 398298835,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698157134
    },
    {
        "content": "<p>I agree.  However, let me say that being able to count reduction steps in a programming language is such a marginal \"complexity theoretic question\" (I am quoting <span class=\"user-mention\" data-user-id=\"277010\">@Chris Barrett</span>'s original comment here), I mean relatively to what complexity theorists actually do,  that I would not see it as a convincing motivation for the development of a higher categorical Curry-Howard.  It would be kind of like saying that some super interesting technique for graph theory is also relevant for category theory because, you know, in the end categories are just graphs <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 398308621,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1698160143
    },
    {
        "content": "<p>Yeah, the connection between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction steps and the measures of computational complexity that are relevant for actual computation is rather fraught.</p>",
        "id": 398315359,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1698162083
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276777\">@Mike Shulman</span> I'm not sure whether <span class=\"user-mention\" data-user-id=\"276839\">@Damiano Mazza</span> means this, or rather that being able to count steps hardly counts as complexity theory. At least, regarding the connection between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction steps and complexity, work by Beniamino Accattoli -- which I'm sure Damiano knows better than me -- has considerably tightened the connection.</p>",
        "id": 398317336,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1698162767
    },
    {
        "content": "<p>The length of a reduction sequence is not really the kind of question I had in mind -- it's not obviously a good measure of the complexity of beta-reduction, after all, since a single beta reduction step is not implemented in constant time. Now, probably one _could_ encode \"as much as CSists need in category theory\", but it is not obvious to me that the encoding would be a particularly natural one or that it would provide a useful perspective on those questions! Of course, I'd love to be wrong about this! </p>\n<p><span class=\"user-mention\" data-user-id=\"383799\">@Tom Hirschowitz</span> <span class=\"user-mention\" data-user-id=\"276839\">@Damiano Mazza</span> I'd really love if you could expand on your answers to my question about what is gained! Tom, if I understand correctly your notion of signature would include some generating 2-reductions also? And then presumably you're imagining constructing some free such-and-such category over it. I'm struggling to really unpack your comments. In what sense is everything more typed?</p>",
        "id": 398318562,
        "sender_full_name": "Chris Barrett",
        "timestamp": 1698163164
    },
    {
        "content": "<blockquote>\n<p>Picking up on an idea due to Melliès and Zeilberger, we view type systems as special kinds of functors, which we call <em>Niefield functors</em> and which enjoy a version of the Grothendieck construction: a Niefield functor on (small) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> is the same as a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>→</mo><mrow><mi mathvariant=\"script\">R</mi><mi mathvariant=\"script\">e</mi><mi mathvariant=\"script\">l</mi></mrow></mrow><annotation encoding=\"application/x-tex\">L\\to\\mathcal{Rel}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">R</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">R</mi><mi mathvariant=\"script\">e</mi><mi mathvariant=\"script\">l</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{Rel}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">R</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span> is a certain (large) bicategory of distributors and relational natural transformations.  In particular, Niefield functors are stable under pullback, so the pullback of a type system is a type system.  Fundamental properties of type systems like subject reduction and subject expansion become \"fibrational\" properties of Niefield functors: a Niefield fibration/opfibration is a type system satisfying subject expansion/reduction.  These too are pullback-stable.</p>\n<p>This allowed us to formulate a very general theorem about so-called <em>intersection types</em>.  These are known to be able to capture all sorts of termination properties for all sorts of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculi (call-by-name, call-by-value, with continuations, etc.).  We show that, for each \"flavor\" of intersection types (idempotent or not, etc.) there's a \"universal\" intersection type system <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> for linear logic, and basically every intersection type system for some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> introduced in the past 30 years may be obtained by pulling back the suitable <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> along an encoding of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> in linear logic.  In fact, the framework also immediately gives you new systems (for example, for the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda\\mu</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\">μ</span></span></span></span>-calculus) and, with Ugo Dal Lago, Marc de Visme and Akira Yoshimizu, we later used it to get an intersection type system for the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span>-calculus, thanks to previous work by Honda and Laurent, and Ehrhard and Laurent, showing how this may be mapped to linear logic.</p>\n<p>A very interesting aspect of all this is, I think, that it uncovers how intersection types actually build a \"bridge\" between a \"weak termination\" property and a \"strong termination\" property.  That is, you have properties <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> of your programming language, such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> trivially implies <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span>, and every proof showing that intersection types capture some kind of termination is actually showing that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> implies typable and that typable implies <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>, so that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> and typable coincide.  We give a categorical abstraction of what <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> may be, as well as sufficient conditions, formulated at the level of the Niefield functors representing the type systems, so that these implications hold.  We call it the \"fundamental theorem of intersection types\".</p>\n</blockquote>\n<p>I somehow managed to skip over this in my initial reading of the thread, but this is super interesting and I'm keen to take a closer look at your work on intersection types here!</p>",
        "id": 398321433,
        "sender_full_name": "Chris Barrett",
        "timestamp": 1698164013
    },
    {
        "content": "<p>If the mere number of beta-reduction steps is not what one is concerned with, it seems one could use some other way(s) of measuring the complexity of 2-cells in a 2-categorical approach to the lambda calculus.  I thought people were saying it's impossible to count the beta-reductions in a  2-cell, but now they seem to be saying they don't want to.   That's fine.   I'm just struggling to see if there's any real obstacle to studying complexity 2-categorically.    Whether it's worth doing is a separate question, which has to come later.</p>",
        "id": 398322055,
        "sender_full_name": "John Baez",
        "timestamp": 1698164244
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/398322055\">said</a>:</p>\n<blockquote>\n<p>If the mere number of beta-reduction steps is not what one is concerned with, it seems one could use some other way(s) of measuring the complexity of 2-cells in a 2-categorical approach to the lambda calculus.  I thought people were saying it's impossible to count the beta-reductions in a  2-cell, but now they seem to be saying they don't want to.   That's fine.   I'm just struggling to see if there's any real obstacle to studying complexity 2-categorically.    Whether it's worth doing is a separate question, which has to come later.</p>\n</blockquote>\n<p>This is my fault -- I first said that the complexity theoretic information is \"lost\", but I don't believe this is necessarily the case: of course, one can probably encode almost anything in CT, since CT is very expressive. I expect it is the case with the simple approach of considering beta steps as 2-morphisms.</p>",
        "id": 398323379,
        "sender_full_name": "Chris Barrett",
        "timestamp": 1698164758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"383799\">Tom Hirschowitz</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/398317336\">said</a>:</p>\n<blockquote>\n<p>being able to count steps hardly counts as complexity theory.</p>\n</blockquote>\n<p>Yes, that's the spirit of my comment!  Complexity theory is WAY more than counting (deterministic) time up to a polynomial, which is what we are able to do with certain restricted notions of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction (which, incidentally, do not even compose, so they can't even be the 2-arrows of a 2-category!).</p>",
        "id": 398323469,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1698164783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/398322055\">said</a>:</p>\n<blockquote>\n<p>I'm just struggling to see if there's any real obstacle to studying complexity 2-categorically.</p>\n</blockquote>\n<p>\"Studying complexity 2-categorically\" is a bit vague, so no, I don't think I can come up with any reason why it would be impossible <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span>  I mean, for example, I don't think there's a conceptual obstacle to <em>defining</em> time complexity 2-categorically.  What I know is that, doing it in the context of Curry-Howard as discussed in this thread (more precisely, via some categorification of CCCs) leads either to something worthless (unrelated to Turing machines) or to a very limited definition which would only capture a handful interesting complexity classes.  That's a real obstacle, but of course it doesn't preclude from switching to a different 2-categorical model, or a categorification of CCCs which does not correspond to anything I have in mind now, which will turn out to do wonders for complexity theory.</p>\n<p>My main point is that \"studying complexity\" is like \"studying category theory\".  These are huge fields with countless ramifications and with specific viewpoints on things, it's not because we managed to express one very basic definition (like deterministic time complexity) that we will be able to actually do anything relevant...</p>",
        "id": 398327389,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1698166348
    },
    {
        "content": "<p>There's some recent work like <a href=\"https://arxiv.org/abs/2107.04663\">https://arxiv.org/abs/2107.04663</a> that I think is intended to give a more flexible and modular way to incorporate notions of complexity into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculus.</p>",
        "id": 398328081,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1698166638
    },
    {
        "content": "<p><code>Tom, if I understand correctly your notion of signature would include some generating 2-reductions also? And then presumably you're imagining constructing some free such-and-such category over it. I'm struggling to really unpack your comments. In what sense is everything more typed?</code></p>\n<p>For the first question, yes, that's the idea. It is developed in <a href=\"https://lmcs.episciences.org/1132\">this paper</a>.</p>\n<p>For the last question, it's always been difficult for me to explain, so if others have better ways, please don't hesitate to help! </p>\n<p>In a sense, <span class=\"user-mention\" data-user-id=\"276839\">@Damiano Mazza</span> already answered this question: it's about trying to answer the question “what is a programming language”?<br>\nAnd also how and from what do we generate them?</p>\n<p>I don't know how familiar you are with programming language research, but, taking a few steps back, what the average paper does is construct a mathematical object by induction (and perhaps some quotienting for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span>-equivalence), without attempting to give it a type. This process is almost the same across the literature, so you quickly recognise and name the objects involved: you first have a grammar, maybe some typing rules, and then some reduction or transition rules, which generate a (maybe indexed) set and a (maybe labelled) binary transition relation. What we're doing is defining these notions formally, and giving a universal property and generic construction of the set-and-binary-relation from the grammar and transition rules. We use this to turn methods into theorems. This is what <span class=\"user-mention\" data-user-id=\"585426\">@Sergey Goncharov</span>, <span class=\"user-mention\" data-user-id=\"275900\">@Stelios Tsampas</span>, Henning and Stefan, as well as <span class=\"user-mention\" data-user-id=\"276696\">@Ambroise</span> and I, did with Howe's method. Well, to be fair, there were theorems about it, but we generalised them.  </p>\n<p>Does this help?!</p>",
        "id": 398422692,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1698216984
    },
    {
        "content": "<p>Thanks, Tom, that helps me understand where you're coming from! I suppose what I was imagining initially was a kind of 2-category for lambda-terms but, taking a broader perspective, I can see how one would be motivated to find a way to unify and study in generality the many e.g., extensions to the lambda-calculus that people consider in the literature. I look forward to taking a closer look at the work you mentioned to understand better. </p>\n<p>By the way, I hope my initial comment was not too pointed -- I am very interested in this line of work, since it seems such a natural extension of Curry-Howard-Lambek. I do consider myself a PL theorist btw, albeit a young one! </p>\n<p>This is a vague musing, but I have wondered before: perhaps instead of considering higher CT as a way to understand type/proof theory, one could use tools from type/proof theory to understand higher CT -- in particular, I wonder if one could use (some variant of) cut elimination to give proofs of coherence for higher categories.</p>",
        "id": 398493376,
        "sender_full_name": "Chris Barrett",
        "timestamp": 1698242849
    },
    {
        "content": "<p>I think it is indeed a very good idea. I'm only aware of applications of cut elimination to 1-order categorical doctrines, possibly replacing their equality by 2-morphisms</p>",
        "id": 398500541,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698244820
    },
    {
        "content": "<p>I think that anyone who knows a bit of proof theory and multiplicative linear logic understands that using its cut elimination is the most natural way to prove the MacLance coherence theorem for symmetric monoidal categories. Frederico Olimpieri proves coherence for some kind of multicategories using \"resource calculus\": <a href=\"https://arxiv.org/pdf/2302.05755.pdf\">Coherence by Normalization for Linear Multicategorical Structures</a>. And one of my favorite paper, by Hasegawa: <a href=\"http://www.tac.mta.ca/tac/volumes/35/50/35-50abs.html\">A Categorical Reduction System for Linear Logic</a>. He says in the abstract that this \"gives the first step towards the mechanization of diagram chasing\" and honnestly, I'd like to extend it in particular to differential categories to obtain automatic proofs of commutative diagrams about differentation.</p>",
        "id": 398501551,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698245106
    },
    {
        "content": "<p>I was thinking about creating a sequent calculus for abelian categories and then apply the same kind of methodology to mechanize diagram chasing but I didn't succeed to have a calculus with cut elimination. Indeed, abelian categories, which rely heavily on negative numbers don't sound very compatible with proof theory. I don't understand precisely why but negative numbers interact badly with logic and several people told me that. But one could maybe build a sequent calculus for regular logic, obtain cut elimination and apply the same kind of methodology to mechanize diagam chasing in this context.</p>",
        "id": 398503448,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698245616
    },
    {
        "content": "<p>There is a variety of logical systems, which regular logic is part of whose dynamic has apparently never been studied by anybody (or maybe I just don't know the papers ) because they come from pure mathematics rather than computer science. I'm thinking to regular logic, coherent logic and geometric logic</p>",
        "id": 398503776,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698245703
    },
    {
        "content": "<p>People know about Curry-Howard but what is important to me would be to apply it to concrete settings in mathematics, in order to apply techniques of proof theory / computer science to the categories mathematicians are interested by. It implies that some people need to know at the same time pretty abstract mathematics and proof theory / lambda calculus etc, to make progress in this wonderful direction. I'm super excited by the paper of Hasegawa, as well as by Bewl because they are going in this direction of applying computer science to mathematical structures, in order to make mathematics easier to work with.</p>",
        "id": 398511529,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698247730
    },
    {
        "content": "<blockquote>\n<p>This is a vague musing, but I have wondered before: perhaps instead of considering higher CT as a way to understand type/proof theory, one could use tools from type/proof theory to understand higher CT -- in particular, I wonder if one could use (some variant of) cut elimination to give proofs of coherence for higher categories.</p>\n</blockquote>\n<p>I really like Federico's line of thinking on this -- there is a well-developed theory around standardisation etc that seems likely to tell us things about coherence. Marcelo and I did something similar but more semantic than syntactic <a href=\"https://dl.acm.org/doi/10.1145/3373718.3394769\">here</a>, where we used his semantic take on normalisation by evaluation to prove normalisation of a 2-dimensional lambda calculus and hence a strong form of coherence for cartesian closed bicategories. NBE is such a powerful tool I've always expected similar results to work for other structures, but I've not seen it done yet.</p>\n<p>Something I'd also like to know is whether this 2-dimensional point of view (1-cells as morphisms / terms, 2-cells as 2-cells / rewrites) has anything useful to say about proof transformations in the way they talk about them in proof theory.  I still don't know enough proof theory to be able to say either way</p>",
        "id": 398512540,
        "sender_full_name": "Philip Saville",
        "timestamp": 1698248027
    },
    {
        "content": "<p>There is the problem to know what kind of natural transformations must the proofs be interpreted by in a logical system 2-categorically, in fact the problem is already here at the 1-categorical level. Interpreting proofs by morphisms and formulas by objects is correct but very far to be ideal. In fact it is better to interpret formulas by functors and proofs by natural transformations. </p>\n<p>I don't rememenber exactly in what setting, but often proofs are not basic natural transformations but rather <a href=\"http://url\">extranatural transformation</a> or <a href=\"https://ncatlab.org/nlab/show/dinatural+transformation\">dinatural transformations</a>. And I think it's still not known when you can compose them (indeed you can't always compose them). </p>\n<p>I'm not sure it's related to your question. But It made me think to this. It's just that 2-categories made me think to natural transformations but it's not the same 2-categorical structure that the one for rewriting</p>",
        "id": 398515122,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698248776
    },
    {
        "content": "<p>So, the good way to interpret reduction would be as some kind of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>-morphisms (so <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>-morphisms is maybe a better word) between extranatural transformations or something like this in fact. So Curry-Howard is maybe something 3-categorical at the end</p>",
        "id": 398515424,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698248884
    },
    {
        "content": "<p>Thinking about it, I'm not sure lot of people are aware of this</p>",
        "id": 398516171,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698249121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"428716\">Jean-Baptiste Vienney</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/398515122\">said</a>:</p>\n<blockquote>\n<p>There is the problem to know what kind of natural transformations must the proofs be interpreted by in a logical system 2-categorically, in fact the problem is already here at the 1-categorical level. Interpreting proofs by morphisms and formulas by objects is correct but very far to be ideal. In fact it is better to interpret formulas by functors and proofs by natural transformations. </p>\n<p>I don't rememenber exactly in what setting, but often proofs are not basic natural transformations but rather <a href=\"http://url\">extranatural transformation</a> or <a href=\"https://ncatlab.org/nlab/show/dinatural+transformation\">dinatural transformations</a>. And I think it's still not known when you can compose them (indeed you can't always compose them). </p>\n<p>I'm not sure it's related to your question. But It made me think to this. It's just that 2-categories made me think to natural transformations but it's not the same 2-categorical structure that the one for rewriting</p>\n</blockquote>\n<p>A contemporary of mine during my PhD, Alessio Santamaria, all but settled the question of compositionality of dinaturals in his PhD thesis, I believe.</p>",
        "id": 398516938,
        "sender_full_name": "Chris Barrett",
        "timestamp": 1698249357
    },
    {
        "content": "<p>Oh, he says it's related to acyclicity of some graphs so it sounds somehow related to the correctness criterion for proof nets</p>",
        "id": 398517289,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698249471
    },
    {
        "content": "<p>Interesting, it makes two different but related subjects who talk about acyclicity of graphs</p>",
        "id": 398517966,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698249644
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"428716\">Jean-Baptiste Vienney</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/398503448\">said</a>:</p>\n<blockquote>\n<p>I was thinking about creating a sequent calculus for abelian categories and then apply the same kind of methodology to mechanize diagram chasing but I didn't succeed to have a calculus with cut elimination. Indeed, abelian categories, which rely heavily on negative numbers don't sound very compatible with proof theory. I don't understand precisely why but negative numbers interact badly with logic and several people told me that. But one could maybe build a sequent calculus for regular logic, obtain cut elimination and apply the same kind of methodology to mechanize diagam chasing in this context.</p>\n</blockquote>\n<p>Thanks for the links to those papers, I'm excited to take a look. This idea of (as I would imagine it) applying proof theoretic techniques to more free-categories-with-structure than are typically considered when one thinks of \"logic\" is something I've thought a bit about, and I think could definitely be interesting. I'm writing up at the moment a calculus for rig categories with biproducts, for instance -- more focussed on the PL than proof theory side, though. </p>\n<p>About negatives: I know they generally don't interact well with infinite dimensions because of diverging sums, and I've noticed this problem too in similar-ish investigations.</p>",
        "id": 398518061,
        "sender_full_name": "Chris Barrett",
        "timestamp": 1698249669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"428716\">Jean-Baptiste Vienney</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/398517289\">said</a>:</p>\n<blockquote>\n<p>Oh, he says it's related to acyclicity of some graphs so it sounds somehow related to the correctness criterion for proof nets</p>\n</blockquote>\n<p>Yes, it very much looks that way! The proof has a geometry-of-interaction / token-passing feel, too.</p>",
        "id": 398518176,
        "sender_full_name": "Chris Barrett",
        "timestamp": 1698249704
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277010\">Chris Barrett</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/398518061\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"428716\">Jean-Baptiste Vienney</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/398503448\">said</a>:</p>\n<blockquote>\n<p>I was thinking about creating a sequent calculus for abelian categories and then apply the same kind of methodology to mechanize diagram chasing but I didn't succeed to have a calculus with cut elimination. Indeed, abelian categories, which rely heavily on negative numbers don't sound very compatible with proof theory. I don't understand precisely why but negative numbers interact badly with logic and several people told me that. But one could maybe build a sequent calculus for regular logic, obtain cut elimination and apply the same kind of methodology to mechanize diagam chasing in this context.</p>\n</blockquote>\n<p>Thanks for the links to those papers, I'm excited to take a look. This idea of (as I would imagine it) applying proof theoretic techniques to more free-categories-with-structure than are typically considered when one thinks of \"logic\" is something I've thought a bit about, and I think could definitely be interesting. I'm writing up at the moment a calculus for rig categories with biproducts, for instance -- more focussed on the PL than proof theory side, though. </p>\n<p>About negatives: I know they generally don't interact well with infinite dimensions because of diverging sums, and I've noticed this problem too in similar-ish investigations.</p>\n</blockquote>\n<p>Oh, and maybe it has something to do with fixed-points ? I don't understand anything  about the role of fixed-points in computer science. But Lionel Vaux in this paper: <a href=\"https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=759619f05a42ff3045bcf87fcaa3edbff01e1130\">The Algebraic Lambda-Calculus</a>, introduce a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-term that he is writing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">∞</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\infty_s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">∞</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and says that in presence of negative numbers, big problems happen. That's as far as I understand. But now that you tell me it's related to infinite sums, it sounds easier to me to understand: the problem is about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi><mo>−</mo><mi mathvariant=\"normal\">∞</mi><mo mathvariant=\"normal\">≠</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\infty - \\infty \\neq 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">∞</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">∞</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>...</p>",
        "id": 398519620,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698250085
    },
    {
        "content": "<p>However, even without infinite sums, in an abelian category, I didn't know how to deal with the kernels, cockernels etc... in a cut elimination. But hopefully, it's possible to do math without negative numbers and there are not negative numbers in regular categories for instance which are kind of categories like the category of sets and relations and are much more general than abelian categories</p>",
        "id": 398520131,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698250253
    },
    {
        "content": "<p>In the weighted relational models of LL, proofs are interpreted as matrices over some complete semiring (in the sense that every infinite sum is convergent), with completeness necessary for dealing with the infinities that crop up interpreting the exponential $!$. Iirc, there are no complete rings because there is no well-defined way to understand the infinite sum a+(-a)+a+(-a)+... However, the coherence space models and similar give another way of resolving this issue. This is getting a bit out-of-my-depth: perhaps I will say something wrong.</p>",
        "id": 398521803,
        "sender_full_name": "Chris Barrett",
        "timestamp": 1698250890
    },
    {
        "content": "<p>I suspect Vaux's comments are related to this issue of completeness. But your issues with Abelian categories may not be related!</p>",
        "id": 398521930,
        "sender_full_name": "Chris Barrett",
        "timestamp": 1698250932
    },
    {
        "content": "<p>I'm interested in your investigations on Abelian categories. My thinking on rig categories with biproducts is like a baby version of this (homsets are commutative monoids, not abelian groups; no notion of co/kernels, etc.)</p>",
        "id": 398522149,
        "sender_full_name": "Chris Barrett",
        "timestamp": 1698251013
    },
    {
        "content": "<p>I didn't do much honnestly, I just wrote a sequent calculus on a sheet of paper one day and realized that cut elimination didn't seem to work well</p>",
        "id": 398522341,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698251081
    },
    {
        "content": "<p>It's a delicate thing, indeed!</p>",
        "id": 398522558,
        "sender_full_name": "Chris Barrett",
        "timestamp": 1698251172
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"428716\">Jean-Baptiste Vienney</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/398511529\">said</a>:</p>\n<blockquote>\n<p>People know about Curry-Howard but what is important to me would be to apply it to concrete settings in mathematics, in order to apply techniques of proof theory / computer science to the categories mathematicians are interested by. It implies that some people need to know at the same time pretty abstract mathematics and proof theory / lambda calculus etc, to make progress in this wonderful direction. I'm super excited by the paper of Hasegawa, as well as by Bewl because they are going in this direction of applying computer science to mathematical structures, in order to make mathematics easier to work with.</p>\n</blockquote>\n<p>Btw what is the work by Bewl you mention here?</p>",
        "id": 398523038,
        "sender_full_name": "Chris Barrett",
        "timestamp": 1698251363
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277010\">Chris Barrett</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/398523038\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"428716\">Jean-Baptiste Vienney</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/398511529\">said</a>:</p>\n<blockquote>\n<p>People know about Curry-Howard but what is important to me would be to apply it to concrete settings in mathematics, in order to apply techniques of proof theory / computer science to the categories mathematicians are interested by. It implies that some people need to know at the same time pretty abstract mathematics and proof theory / lambda calculus etc, to make progress in this wonderful direction. I'm super excited by the paper of Hasegawa, as well as by Bewl because they are going in this direction of applying computer science to mathematical structures, in order to make mathematics easier to work with.</p>\n</blockquote>\n<p>Btw what is the work by Bewl you mention here?</p>\n</blockquote>\n<p>Ahah, it's the work by Felix Dilke, cf. the topic \"Introducing me and Bewl...\"</p>",
        "id": 398523173,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698251409
    },
    {
        "content": "<p>It's a pogramming language, not a person</p>",
        "id": 398523234,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698251431
    },
    {
        "content": "<p>But about abelian categories: I could try again when I have more time. Now I must work on courses because I am at the beginning of my Phd, in America. But regular categories are nice too. People working on categorical algebra, like Dominique Bourn who wrote the nice book <a href=\"https://doi.org/10.1007/978-3-319-57219-2\">Dominique Bourn, From Groups to Categorial Algebra : Introduction to Protomodular and Mal’tsev Categories</a> are already using more general structures than abelian categories, in a pure math perspective. Abelian categories seem to be insufficient in mathematics.</p>",
        "id": 398523715,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698251606
    },
    {
        "content": "<p>And I suspect that every regular category is a model of linear logic: they are the categories resembling the category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mi>e</mi><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">Rel</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span></p>",
        "id": 398524120,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698251759
    },
    {
        "content": "<p>But for sure, you can't do as much in a regular category than in an abelian category</p>",
        "id": 398524258,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698251803
    },
    {
        "content": "<p>(at least you lose some basic results on techniques related to negative numbers which sounds like a lot)</p>",
        "id": 398524790,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698252006
    },
    {
        "content": "<p>Exact categories (in the sense of Barr) are much more precisely the right analogue of abelian categories without the additivity. In particular a category is abelian if and only if it's additive and exact, but regular doesn't suffice.</p>",
        "id": 398530414,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1698254129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"609515\">Kevin Arlin</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Curry.20Howard.20Correspondence/near/398530414\">said</a>:</p>\n<blockquote>\n<p>Exact categories (in the sense of Barr) are much more precisely the right analogue of abelian categories without the additivity. In particular a category is abelian if and only if it's additive and exact, but regular doesn't suffice.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"609515\">@Kevin Arlin</span> you say additive, can you get away with preadditive?</p>",
        "id": 398789933,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1698367274
    },
    {
        "content": "<p>Yeah, an exact category is in particular regular so has finite products, which are biproducts in any preadditive category.</p>",
        "id": 398794738,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1698369427
    }
]