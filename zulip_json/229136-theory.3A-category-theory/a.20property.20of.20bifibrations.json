[
    {
        "content": "<p>A bifibration <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>:</mo><mi>E</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">p : E \\to B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> induces for each <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>b</mi><mo>→</mo><msup><mi>b</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">f : b \\to b&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> adjoint functors between the fibers <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mo stretchy=\"false\">!</mo></msub><mo>⊣</mo><msup><mi>f</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">f_! \\dashv f^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mclose mtight\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>. </p>\n<p>In my work I use bifibrations where this adjunction is a co-reflection, i.e., <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup><mo>∘</mo><msub><mi>f</mi><mo stretchy=\"false\">!</mo></msub></mrow><annotation encoding=\"application/x-tex\">f^* \\circ f_!</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mclose mtight\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is isomorphic to the identity. Is there a name for this kind of bifibration/is anyone aware of places this concept has been used?</p>",
        "id": 289911489,
        "sender_full_name": "Max New",
        "timestamp": 1658102855
    },
    {
        "content": "<p>Does the bifibration <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>:</mo><mrow><mi mathvariant=\"sans-serif\">G</mi><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">a</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">h</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">p: \\mathsf{Graph} \\to \\mathsf{Set}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Graph</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Set</span></span></span></span></span>, which picks out the set of nodes of a graph, have this property?</p>",
        "id": 289911797,
        "sender_full_name": "John Baez",
        "timestamp": 1658103362
    },
    {
        "content": "<p>No, because you can take any graph G and map it to a one node graph with no edges and then push/pull to get back the discrete graph of G.</p>\n<p>This probably indicates that you need a pretty restrictive notion of morphism in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span>. I should mention that in my examples, E and B are preorders and so <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mo stretchy=\"false\">!</mo></msub></mrow><annotation encoding=\"application/x-tex\">f_!</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mclose mtight\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">f^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> are a Galois connection.</p>",
        "id": 289912270,
        "sender_full_name": "Max New",
        "timestamp": 1658104227
    },
    {
        "content": "<p>Thanks.   Okay, yes, it sounds like a strong condition.</p>",
        "id": 289919760,
        "sender_full_name": "John Baez",
        "timestamp": 1658116167
    },
    {
        "content": "<p>Oh, I wasn't quite right above but the property is still not true. As an example start with { l -&gt; r }, pushforward the unique function to a one-element set  to get a vertex with a self loop, and then pull back  and you will get a complete graph on two vertices</p>",
        "id": 289963647,
        "sender_full_name": "Max New",
        "timestamp": 1658150257
    },
    {
        "content": "<p>Okay, that's better.  You fooled me with the first example.   <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 289964736,
        "sender_full_name": "John Baez",
        "timestamp": 1658150790
    },
    {
        "content": "<p>Is it true that pulling back and then pushing forward is also not isomorphic to the identity for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>:</mo><mrow><mi mathvariant=\"sans-serif\">G</mi><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">a</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">h</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">p: \\mathsf{Graph} \\to \\mathsf{Set}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Graph</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Set</span></span></span></span></span>?   If I were awake I could figure it out.</p>",
        "id": 289964841,
        "sender_full_name": "John Baez",
        "timestamp": 1658150860
    },
    {
        "content": "<p>I guess it's not.   Start with the map from the 2-element set to the 1-element set.  Take the graph with a single self-loop on the 1-element set.   Pull it back to the 2-element set, then push forward.   I think you get a graph with 4 self-loops on the 1-element set.</p>",
        "id": 289965030,
        "sender_full_name": "John Baez",
        "timestamp": 1658150944
    },
    {
        "content": "<p>I think a simpler example that works for non-multi-graphs would be to start with a vertex with a self loop and then pull back over an empty set of vertices and then push forward and you get a vertex with no self loop</p>",
        "id": 289965304,
        "sender_full_name": "Max New",
        "timestamp": 1658151087
    },
    {
        "content": "<p>Yes.</p>",
        "id": 289965465,
        "sender_full_name": "John Baez",
        "timestamp": 1658151151
    },
    {
        "content": "<p>So, it seems nothing like this property holds for the bifibrations of the sort I've been thinking about.   (If it did, I would want to know!)</p>",
        "id": 289965567,
        "sender_full_name": "John Baez",
        "timestamp": 1658151216
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276642\">@Max New</span> Now I'm curious about how your bifibration looks like!</p>",
        "id": 289967627,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1658152209
    },
    {
        "content": "<p>It comes from my work on gradual typing <a href=\"https://arxiv.org/abs/1802.00061\">https://arxiv.org/abs/1802.00061</a> That paper is phrased in terms of double categories that are pro-arrow equipments, and there's a way to define pro-arrow equipments using fibrations so I was wondering if there was a word for this additional axiom that we have.</p>",
        "id": 290146755,
        "sender_full_name": "Max New",
        "timestamp": 1658257874
    },
    {
        "content": "<p>As you probably know - but just in case you don't - when Shulman gets pro-arrow equipments from bifibrations in <a href=\"https://arxiv.org/abs/0706.1286\">Framed bicategories and monoidal fibrations</a>, in Definition 13.31 he introduces various special kinds of bifibrations, like Beck-Chevalley, strong Beck-Chevalley, weak Beck-Chevalley, etc.   I needed to learn about these in my work on decorated and structured cospan double categories.   But I don't think he mentions the kind you're talking about.</p>",
        "id": 290147814,
        "sender_full_name": "John Baez",
        "timestamp": 1658258384
    },
    {
        "content": "<p>This seems quite an unusual property to impose on an equipment: asking for every induced adjunction to be a coreflection is asking for every morphism in the underlying 2-category to be fully faithful. Accordingly, the condition is in a sense an equipment-theoretic version of <a href=\"https://ncatlab.org/nlab/show/cancellative+category\">left cancellative (2-)category</a>. I would suspect that such structures are not particularly widespread.</p>",
        "id": 290151379,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1658260080
    }
]