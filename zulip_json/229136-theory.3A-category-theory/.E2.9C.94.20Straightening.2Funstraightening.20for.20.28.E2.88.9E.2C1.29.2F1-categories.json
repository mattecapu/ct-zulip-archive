[
    {
        "content": "<p>I've been thinking a bit about straightening/unstraightening, and although I can't pretend I've read the proof for ∞,1-categories (I ought to at some point), am I right in my intuition that the complicated part of straightening/unstraightening isn't doing the Grothendieck construction part, but rather actually straightening the data of an ∞,2-functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mo>→</mo><msub><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow><mrow><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\"> B → \\mathrm{Cat}_{∞,1} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Cat</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">∞</span><span class=\"mpunct mtight\">,</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> into a bona-fide ∞-functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mo>→</mo><msub><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow><mrow><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\"> B → \\mathrm{Cat}_{∞,1} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Cat</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">∞</span><span class=\"mpunct mtight\">,</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> that ought to be equivalent with it?</p>\n<p>If so, then am I right in expecting a 1-categorical analogue of straightening/unstraightening along the lines of: the 1-category of Grothendieck fibrations over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\"> B </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> up to equivalence is equivalent to the category of 1-functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>B</mi><mrow><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">p</mi></mrow></msup><mo>→</mo><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\"> B^\\mathrm{op} → \\mathrm{Cat} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">op</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Cat</span></span></span></span></span></p>",
        "id": 374921900,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1689253021
    },
    {
        "content": "<p>The Grothendieck construction gives an equivalence between fibrations over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and <em>pseudo</em>functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>B</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mi>C</mi><mi>a</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">B^{op} \\to Cat</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span></span></span></span>.</p>",
        "id": 374970865,
        "sender_full_name": "Joe Moeller",
        "timestamp": 1689261700
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275914\">Joe Moeller</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories/near/374970865\">said</a>:</p>\n<blockquote>\n<p>The Grothendieck construction gives an equivalence between fibrations over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and <em>pseudo</em>functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>B</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mi>C</mi><mi>a</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">B^{op} \\to Cat</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span></span></span></span>.</p>\n</blockquote>\n<p>yes, but that's not what I'm asking here, I'm asking for a strictification of this result, and first whether this strictification underlies the straightening/unstraightening for (∞,1)-categories</p>",
        "id": 374982789,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1689263934
    },
    {
        "content": "<p>To get a split fibration (i.e. a strict functor into Cat) equivalent to an arbitrary Grothendieck fibration, I believe you generally have to change the base to an equivalent category.</p>",
        "id": 374983668,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1689264082
    },
    {
        "content": "<p>Sorry, I misunderstood the question. I see now why the question seemed odd to me.</p>",
        "id": 374987972,
        "sender_full_name": "Joe Moeller",
        "timestamp": 1689264830
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"609515\">Kevin Arlin</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories/near/374983668\">said</a>:</p>\n<blockquote>\n<p>To get a split fibration (i.e. a strict functor into Cat) equivalent to an arbitrary Grothendieck fibration, I believe you generally have to change the base to an equivalent category.</p>\n</blockquote>\n<p>Could you explain how this would work with like short exact sequences of groups? Split sequences correspond to split fibrations. What can you change in a non-split sequence to get an equivalent split one?</p>",
        "id": 374990690,
        "sender_full_name": "Joe Moeller",
        "timestamp": 1689265410
    },
    {
        "content": "<p>I'll think about it more if I get a chance but in particular I'm pretty sure you won't end up with a functor into groups.</p>",
        "id": 374991838,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1689265660
    },
    {
        "content": "<p>No, you don't have to change the base.  It's true in general that to replace a pseudofunctor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\to B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> between arbitrary 2-categories by a strict one, you have to change the domain.  But in the special case when the codomain is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\rm Cat</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Cat</span></span></span></span></span>, you don't.</p>",
        "id": 374991882,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1689265673
    },
    {
        "content": "<p>Oh oops, thanks Mike.</p>",
        "id": 374992008,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1689265691
    },
    {
        "content": "<p>A highfalutin' way to explain it is that there's a 2-monad (and also a 2-comonad) whose strict (co)algebras are strict 2-functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">A\\to\\rm Cat</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Cat</span></span></span></span></span> and whose pseudoalgebras are pseudofunctors, and it satisfies the general strictification theorem, so any pseudoalgebra can be replaced by a strict one.</p>",
        "id": 374992462,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1689265779
    },
    {
        "content": "<p>There are also more explicit constructions.  For instance, given a pseudofunctor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>:</mo><mi>A</mi><mo>→</mo><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">F:A\\to \\rm Cat</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Cat</span></span></span></span></span>, you can define an object of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>F</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F&#x27;(a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span></span></span></span> to be an object of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span></span></span></span> together with isomorphic \"choices\" of its image under all maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a\\to b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> (this is the comonad version).  Or, you can define an object of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>F</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F&#x27;(a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span></span></span></span> to be a morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">c\\to a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> together with an object of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(c)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span></span></span></span> (this is the monad version).  In both cases you define the morphisms to be induced from those of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 374993600,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1689266025
    },
    {
        "content": "<p>Is giving the explicit construction the usual way you'd suggest showing these co/monads satisfy strictification? I don't really know how to check in concrete cases in general using the condition that there's a splitting of the counit of the pseudomorphism classifier or whatever.</p>",
        "id": 374995017,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1689266302
    },
    {
        "content": "<p>Right, but can you strictify the whole equivalence you get from the Grothendieck construction?</p>",
        "id": 374996271,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1689266569
    },
    {
        "content": "<p>There's a general theorem of Power (\"A general coherence theorem\"), generalized further by Lack (\"Codescent objects and coherence\"), which is usually my first resort when asking whether a 2-monad satisfies strictification.  You observe that the base 2-category has a certain sort of factorization system and that the monad preserves the left class of it.</p>",
        "id": 374999843,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1689267336
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284453\">Josselin Poiret</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories/near/374996271\">said</a>:</p>\n<blockquote>\n<p>Right, but can you strictify the whole equivalence you get from the Grothendieck construction?</p>\n</blockquote>\n<p>Oh argh, this is the thing I always get wrong.  Let's see, I think the 1-category of fibrations and morphisms of fibrations is equivalent to the 1-category of pseudofunctors and pseudonatural transformations.  But the 1-category of pseudofunctors is not equivalent to the 1-category of 2-functors, for two reasons: every pseudofunctor is <em>equivalent</em> to a 2-functor, but not isomorphic to it, and even between 2-functors not every pseudonatural transformation is isomorphic to a strict natural transformation.</p>",
        "id": 375000800,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1689267540
    },
    {
        "content": "<p>What if you quotient by equivalences of fibrations on the left, and strictify to the 1-category of functors and pseudonatural transformations on the right side? I'm trying to mirror the straightening/unstraightening for ∞,1-categories</p>",
        "id": 375009096,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1689269304
    },
    {
        "content": "<p>A theorem that seems to be in the direction you're looking for is on page 12-13 of Streicher's notes on fibered categories, and states that the forgetful functor from the 2-category of split fibrations and split cartesian functors to the 2-category of fibrations and cartesian functors is the 2-functor freely inverting the split cartesian functors which are equivalences on every fiber, but it's not an equivalence. So this says that if you quotient split fibrations by a weak notion of equivalence of fibration, one which isn't visible in the underlying 1-category, then the result is the same as the 2-category of fibrations.</p>\n<p>The fact that this isn't an equivalence illustrates Mike's point that not every pseudonatural transformation comes from a 2-natural transformation.</p>",
        "id": 375016111,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1689270890
    },
    {
        "content": "<p>This localizing forgetful functor also has both left and right adjoints, which may be relevant to the straightening and unstraightening argument you're trying to follow.</p>",
        "id": 375016327,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1689270943
    },
    {
        "content": "<p>Quotienting is very rarely what you want to do.  Taking pseudonatural transformations between 1-functors (which accidentally form a 1-category) solves one problem but not the other.</p>",
        "id": 375028807,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1689273628
    },
    {
        "content": "<p>You also don't have an equivalence of 1-categories in the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">∞</span></span></span></span> world, so I'm not sure what you're hoping to mirror.</p>",
        "id": 375028897,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1689273651
    },
    {
        "content": "<p>Isn't there a Quillen equivalence between sSet-enriched presheaves and the slice category of simplical sets? But yeah I guess what you're alluding to is that while you can lower ∞,2 to ∞,1 you can't really get rid of all the 2-morphisms here.</p>",
        "id": 375030945,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1689274124
    },
    {
        "content": "<p>A Quillen equivalence is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-equivalence, which is much weaker than a 1-equivalence.  There's nothing to be done in \"lowering\" an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span>-equivalence to an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-equivalence: since the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">∞</span></span></span></span> is still the same, the former isn't any weaker than the latter, it just contains more data that you can easily forget.</p>",
        "id": 375032548,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1689274445
    },
    {
        "content": "<p>In other words: the weakness of the equivalence lies in the <em>invertible</em> morphisms, which are the same in the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> and the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span> world.  The analogue in lower dimensions would be a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(2,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-equivalence, which is likewise easy to get from a 2-equivalence by forgetting the noninvertible 2-cells.</p>",
        "id": 375032840,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1689274514
    },
    {
        "content": "<p>ah, yes, it's much clearer now, I don't know why I didn't think of that... thanks!</p>",
        "id": 375034082,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1689274787
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284453\">Josselin Poiret</span> has marked this topic as resolved.</p>",
        "id": 375034114,
        "sender_full_name": "Notification Bot",
        "timestamp": 1689274793
    },
    {
        "content": "<p>(FTR, I was looking for universe construction similar to eg. regular functions X → Sets, but for 1-categories, but I guess the picture is much more complicated since you can't just take functors B → Cat to faithfully represent all opfibrations over B)</p>",
        "id": 375034718,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1689274906
    }
]