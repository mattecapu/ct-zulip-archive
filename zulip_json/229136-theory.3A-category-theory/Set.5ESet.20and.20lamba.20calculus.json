[
    {
        "content": "<p>It's been quite a few months that I've been having this idea popping up in my head at random: The functor category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>e</mi><msup><mi>t</mi><mrow><mi>S</mi><mi>e</mi><mi>t</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\"> Set^{Set} </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\">e</span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault mtight\">e</span><span class=\"mord mathdefault mtight\">t</span></span></span></span></span></span></span></span></span></span></span></span> being conceptually very close to some sort of polymorphic <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\"> \\lambda </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">λ</span></span></span></span>-calculus, in that polymorphic (well-behaved) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">λ</span></span></span></span>-terms are morphisms  and parametric types are objects. Non-parametric stuff are just plain-old terms between \"const\" functors. </p>\n<p>This has the advantage that polymorphic terms are now \"internalized\" (I'm hoping I'm using the word properly) as morphisms. Thoughts?</p>",
        "id": 192679507,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585840320
    },
    {
        "content": "<p>It's similar to schematic types from e.g. Hindley-Milner. But I think there are some issues. One is that there's only one variable, and it's covariant only. Also, that category might not be (Cartesian) closed, due to size issues (not sure).</p>",
        "id": 192683250,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585841492
    },
    {
        "content": "<p>Yeah, I was thinking about Hindley-Milner as well. As for the CCC structure, according to <a href=\"https://ncatlab.org/nlab/show/functor+category\" title=\"https://ncatlab.org/nlab/show/functor+category\">this</a> entry in nlab, sec. 3, 1st subsec., 2nd paragraph, it is indeed a CCC.</p>",
        "id": 192683840,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585841687
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">Set</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">t</span></span></span></span> isn't small.</p>",
        "id": 192684121,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585841775
    },
    {
        "content": "<p>Is that a hard no? Is it not possible to restrict to small sets?</p>",
        "id": 192684262,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585841837
    },
    {
        "content": "<p>Ah, look at \"Size\" section in the previous nlab link, this can be easily done.</p>",
        "id": 192684323,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585841867
    },
    {
        "content": "<p>Sorry, for the post right above I meant this <a href=\"https://ncatlab.org/nlab/show/Set\" title=\"https://ncatlab.org/nlab/show/Set\">link</a>.</p>",
        "id": 192684542,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585841947
    },
    {
        "content": "<p>Restrict what? The category of small sets isn't small itself.</p>",
        "id": 192684583,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585841969
    },
    {
        "content": "<p>Hmmmmm :/.</p>",
        "id": 192684775,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585842040
    },
    {
        "content": "<p>You could have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>E</mi><msup><mi>T</mi><mrow><mi>S</mi><mi>e</mi><mi>t</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">SET^{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault mtight\">e</span><span class=\"mord mathdefault mtight\">t</span></span></span></span></span></span></span></span></span></span></span></span> where the capital one is the category of large sets, and non-capital one is itself large, but then it's not exactly the same situation.</p>",
        "id": 192685029,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585842140
    },
    {
        "content": "<p>Whatever works really. I struggle to figure out where things might go wrong. Which brings my to why I have an interest in this. I dabble in Turi's mathematical operational semantics, where semantics are represented by distributive laws of various complexity.</p>",
        "id": 192685499,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585842328
    },
    {
        "content": "<p>If said distributive laws (or semantics) correspond to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\"> \\lambda </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">λ</span></span></span></span>-terms themselves (as they are morhpisms in the functor category we are working in), or any terms of the model of computation of choice, maybe there's some room for experimentation.</p>",
        "id": 192685724,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585842414
    },
    {
        "content": "<p>Like, in the spirit of classic fixpoint results, attempt to (show that it is not possible to) make a distributive law that is \"equivalent\" to the computational model one is working in. That would be fun.</p>",
        "id": 192686169,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585842586
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275900\">Stelios Tsampas</span> <a href=\"#narrow/stream/229136-category-theory/topic/Set.5ESet.20and.20lamba.20calculus/near/192684323\" title=\"#narrow/stream/229136-category-theory/topic/Set.5ESet.20and.20lamba.20calculus/near/192684323\">said</a>:</p>\n<blockquote>\n<p>Ah, look at \"Size\" section in the previous nlab link, this can be easily done.</p>\n</blockquote>\n<p>The problem that one encounters when doing category theory formally is that one wants to work with precisely-defined categories, and that means dealing with size issues. In this instance the problem is that while we can choose a category (or \"universe\") of sets to be closed under typical operations like products, powersets/exponentials, subsets... when we try to build a category like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>e</mi><msup><mi>t</mi><mrow><mi>S</mi><mi>e</mi><mi>t</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">Set^{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\">e</span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault mtight\">e</span><span class=\"mord mathdefault mtight\">t</span></span></span></span></span></span></span></span></span></span></span></span>, we would like to argue that these operations are still possible in a point-wise way, but what we find is that even if we know how to \"construct\" them, the resulting functors may be \"too big\", in that they no longer take values in our original universe.</p>",
        "id": 192686949,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1585842874
    },
    {
        "content": "<p>Yea <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>e</mi><msup><mi>t</mi><mrow><mi>S</mi><mi>e</mi><mi>t</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">Set^{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\">e</span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault mtight\">e</span><span class=\"mord mathdefault mtight\">t</span></span></span></span></span></span></span></span></span></span></span></span> is definitely not a CCC.</p>",
        "id": 192687047,
        "sender_full_name": "Cody Roux",
        "timestamp": 1585842913
    },
    {
        "content": "<p>In this case a solution might be to work in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>e</mi><msup><mi>t</mi><mrow><mi>F</mi><mi>i</mi><mi>n</mi><mi>S</mi><mi>e</mi><mi>t</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">Set^{FinSet}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\">e</span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathdefault mtight\">i</span><span class=\"mord mathdefault mtight\">n</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault mtight\">e</span><span class=\"mord mathdefault mtight\">t</span></span></span></span></span></span></span></span></span></span></span></span> until you desperately need to have uncountably many objects to work with <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 192687212,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1585842964
    },
    {
        "content": "<p>An important lesson learned :).</p>",
        "id": 192687221,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585842971
    },
    {
        "content": "<p>But I like my identity function to be polymorphic...</p>",
        "id": 192687293,
        "sender_full_name": "Cody Roux",
        "timestamp": 1585843003
    },
    {
        "content": "<p>I think there are pretty strong constraints about what things can be models of System F. In particular, a boolean topos <em>cannot</em> fit the bill...</p>",
        "id": 192687402,
        "sender_full_name": "Cody Roux",
        "timestamp": 1585843054
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277473\">Morgan Rogers</span> <a href=\"#narrow/stream/229136-category-theory/topic/Set.5ESet.20and.20lamba.20calculus/near/192687212\" title=\"#narrow/stream/229136-category-theory/topic/Set.5ESet.20and.20lamba.20calculus/near/192687212\">said</a>:</p>\n<blockquote>\n<p>In this case a solution might be to work in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>e</mi><msup><mi>t</mi><mrow><mi>F</mi><mi>i</mi><mi>n</mi><mi>S</mi><mi>e</mi><mi>t</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">Set^{FinSet}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\">e</span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathdefault mtight\">i</span><span class=\"mord mathdefault mtight\">n</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault mtight\">e</span><span class=\"mord mathdefault mtight\">t</span></span></span></span></span></span></span></span></span></span></span></span> until you desperately need to have uncountably many objects to work with <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<p>Thank you for the idea. Maybe there's another (full) subcategory that's CCC?</p>",
        "id": 192687434,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585843064
    },
    {
        "content": "<p>It doesn't have to be System F by the way. But it looked like some flavor of polymorphic lambda calculus.</p>",
        "id": 192687795,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585843103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276030\">Cody Roux</span> <a href=\"#narrow/stream/229136-category-theory/topic/Set.5ESet.20and.20lamba.20calculus/near/192687402\" title=\"#narrow/stream/229136-category-theory/topic/Set.5ESet.20and.20lamba.20calculus/near/192687402\">said</a>:</p>\n<blockquote>\n<p>I think there are pretty strong constraints about what things can be models of System F. In particular, a boolean topos <em>cannot</em> fit the bill...</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"275900\">@Stelios Tsampas</span> you should look into whether/why this^ is the case, since it likely precludes many otherwise plausible categories, given that the Yoneda embedding preserves any limits and exponentials that exist. Even if you don't need it to be System F, it might be enlightening to see what goes wrong, and you'll learn some topos theory along the way <span aria-label=\"heart eyes\" class=\"emoji emoji-1f60d\" role=\"img\" title=\"heart eyes\">:heart_eyes:</span> Do you have references, <span class=\"user-mention\" data-user-id=\"276030\">@Cody Roux</span>?</p>",
        "id": 192688412,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1585843351
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"277473\">@Morgan Rogers</span> What?! You mean to tell me that there isn't a quick and dirty way to git things done? That I can't just cut the Gordian knot??</p>\n<p>Just kidding, foundational stuff usually deserve doing them the hard way. This should be worthwhile.</p>",
        "id": 192688904,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585843549
    },
    {
        "content": "<p>For System F, the classic is \"Polymorphism Is Not Set Theoretic\". That it can be done in a non-boolean topos, there's \"Polymorphism is Set Theoretic, Constructively\". However, System F may not be relevant, because the question was about schematic types a la Hindley-Milner, which can be predicative, and (the sort of) impredicativity of System F is the real issue.</p>",
        "id": 192690474,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585844191
    },
    {
        "content": "<p>Yes, that makes perfect sense.</p>",
        "id": 192691300,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585844532
    },
    {
        "content": "<p>So maybe I could take a look in the paper you mention and make sure I stay within the boundaries of Set Theory when dealing with polymorphism. And then figure out the best fit for the functor category I'm looking for.</p>",
        "id": 192692065,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585844849
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277473\">Morgan Rogers</span> <a href=\"#narrow/stream/229136-category-theory/topic/Set.5ESet.20and.20lamba.20calculus/near/192687212\" title=\"#narrow/stream/229136-category-theory/topic/Set.5ESet.20and.20lamba.20calculus/near/192687212\">said</a>:</p>\n<blockquote>\n<p>In this case a solution might be to work in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><mrow><mi mathvariant=\"sans-serif\">F</mi><mi mathvariant=\"sans-serif\">i</mi><mi mathvariant=\"sans-serif\">n</mi><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Set}^{\\mathsf{FinSet}}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9334479999999998em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">S</span><span class=\"mord mathsf\">e</span><span class=\"mord mathsf\">t</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9334479999999998em;\"><span style=\"top:-3.1473400000000002em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathsf mtight\">F</span><span class=\"mord mathsf mtight\">i</span><span class=\"mord mathsf mtight\">n</span><span class=\"mord mathsf mtight\">S</span><span class=\"mord mathsf mtight\">e</span><span class=\"mord mathsf mtight\">t</span></span></span></span></span></span></span></span></span></span></span></span></span> until you desperately need to have uncountably many objects to work with <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<p>Note that $\\mathsf{FinSet}$ is a large category.  But it's <strong>essentially small</strong> - equivalent to a small one - so you can replace it with a equivalent small category before taking presheaves on it.</p>\n<p>You could do the same replacing finite sets by sets with cardinality bounded by whatever you want.  All these give essentially small categories.   So, take an inaccessible cardinal...</p>",
        "id": 192698879,
        "sender_full_name": "John Baez",
        "timestamp": 1585848139
    },
    {
        "content": "<p>So a large category being equivalent to a small one <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span>. This sounds crazy, and evil. Or is it I that's evil?</p>",
        "id": 192700206,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585848748
    },
    {
        "content": "<p>But don't you run into equivalent problems if you just do the original thing? Like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi><mo>−</mo><mi>S</mi><mi>e</mi><msup><mi>t</mi><mrow><mi>κ</mi><mo>−</mo><mi>S</mi><mi>e</mi><mi>t</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">κ-Set^{κ-Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">κ</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\">e</span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">κ</span><span class=\"mbin mtight\">−</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault mtight\">e</span><span class=\"mord mathdefault mtight\">t</span></span></span></span></span></span></span></span></span></span></span></span> is probably not a CCC because it's not κ-complete?</p>",
        "id": 192700218,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585848754
    },
    {
        "content": "<p>The problem with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>e</mi><msup><mi>t</mi><mrow><mi>F</mi><mi>i</mi><mi>n</mi><mi>S</mi><mi>e</mi><mi>t</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">Set^{FinSet}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\">e</span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathdefault mtight\">i</span><span class=\"mord mathdefault mtight\">n</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault mtight\">e</span><span class=\"mord mathdefault mtight\">t</span></span></span></span></span></span></span></span></span></span></span></span> is that it doesn't function in the way the original question was posed, because it is type schemas whose variables are finite types, not arbitrary types.</p>",
        "id": 192700312,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585848823
    },
    {
        "content": "<p>For strong limit cardinals <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">κ</span></span></span></span> (those for which <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi><mo>&lt;</mo><mi>κ</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><msup><mn>2</mn><mi>λ</mi></msup><mo>&lt;</mo><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda &lt; \\kappa \\implies 2^\\lambda &lt; \\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">λ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.549em;vertical-align:-0.024em;\"></span><span class=\"mord mathdefault\">κ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.888208em;vertical-align:-0.0391em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">λ</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">κ</span></span></span></span>) it <em>might</em> be okay?</p>",
        "id": 192700538,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585848939
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"275920\">@John Baez</span> implies that one cat take the category of sets bounded by something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">ℵ</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\"> ℵ_{0} </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">ℵ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, not necessarily finite.</p>",
        "id": 192700643,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585848975
    },
    {
        "content": "<p>Oh never mind, the problem is again <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi><mo>−</mo><mi>S</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa-Set</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">κ</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">t</span></span></span></span> itself is not <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">κ</span></span></span></span>-small</p>",
        "id": 192701023,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585849149
    },
    {
        "content": "<p>Oh right. It probably would be κ-complete.</p>",
        "id": 192701082,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585849190
    },
    {
        "content": "<p>It's not crazy at all. Every small category is equivalent to a large one: just throw in a proper class of objects isomorphic to objects you already have.  (You have to do this correctly to maintain equivalence.)   So when someone hands you a large category you should query whether it's equivalent to a small one.  The easiest way is to find a skeleton and see if that's small.</p>",
        "id": 192701141,
        "sender_full_name": "John Baez",
        "timestamp": 1585849217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277270\">Dan Doel</span> <a href=\"#narrow/stream/229136-category-theory/topic/Set.5ESet.20and.20lamba.20calculus/near/192700218\" title=\"#narrow/stream/229136-category-theory/topic/Set.5ESet.20and.20lamba.20calculus/near/192700218\">said</a>:</p>\n<blockquote>\n<p>But don't you run into equivalent problems if you just do the original thing? Like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi><mo>−</mo><mi>S</mi><mi>e</mi><msup><mi>t</mi><mrow><mi>κ</mi><mo>−</mo><mi>S</mi><mi>e</mi><mi>t</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">κ-Set^{κ-Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">κ</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\">e</span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">κ</span><span class=\"mbin mtight\">−</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault mtight\">e</span><span class=\"mord mathdefault mtight\">t</span></span></span></span></span></span></span></span></span></span></span></span> is probably not a CCC because it's not κ-complete?</p>\n</blockquote>\n<p>First of all, there's no requirement that a cartesian closed category have any limits other than finite products.</p>\n<p>Second, I'm not sure what you mean by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi><mo>−</mo><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\kappa-\\mathsf{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">κ</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">S</span><span class=\"mord mathsf\">e</span><span class=\"mord mathsf\">t</span></span></span></span></span> - the category of sets of cardinality <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\lt \\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">κ</span></span></span></span>, or some equivalent small category.  I prefer working with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><mi mathvariant=\"sans-serif\">C</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Set}^\\mathsf{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9334479999999998em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">S</span><span class=\"mord mathsf\">e</span><span class=\"mord mathsf\">t</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9334479999999998em;\"><span style=\"top:-3.1473400000000002em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathsf mtight\">C</span></span></span></span></span></span></span></span></span></span></span></span> when the category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">C</span></span></span></span></span> is <em>small</em>, because then <a href=\"https://ncatlab.org/nlab/show/category+of+presheaves#definition\" title=\"https://ncatlab.org/nlab/show/category+of+presheaves#definition\">a bunch more theorems apply</a>.   For example: whenever <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">C</span></span></span></span></span> is small, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><mi mathvariant=\"sans-serif\">C</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Set}^{\\mathsf{C}}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9334479999999998em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">S</span><span class=\"mord mathsf\">e</span><span class=\"mord mathsf\">t</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9334479999999998em;\"><span style=\"top:-3.1473400000000002em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathsf mtight\">C</span></span></span></span></span></span></span></span></span></span></span></span></span> is complete and cocomplete.   That is, it has all small limits and colimits.</p>\n<p>So, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi><mo>−</mo><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\kappa-\\mathsf{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">κ</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">S</span><span class=\"mord mathsf\">e</span><span class=\"mord mathsf\">t</span></span></span></span></span> means some small category equivalent to the category of sets of cardinality <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\lt \\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">κ</span></span></span></span> (or maybe <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\le \\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">κ</span></span></span></span>) then  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><mrow><mi>κ</mi><mo>−</mo><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow></mrow></msup></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Set}^{\\kappa-\\mathsf{Set}}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9334479999999998em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">S</span><span class=\"mord mathsf\">e</span><span class=\"mord mathsf\">t</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9334479999999998em;\"><span style=\"top:-3.14734em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">κ</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\"><span class=\"mord mathsf mtight\">S</span><span class=\"mord mathsf mtight\">e</span><span class=\"mord mathsf mtight\">t</span></span></span></span></span></span></span></span></span></span></span></span></span> is complete and cocomplete.   And yes, it's a cartesian closed category.</p>",
        "id": 192701973,
        "sender_full_name": "John Baez",
        "timestamp": 1585849633
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/stream/229136-category-theory/topic/Set.5ESet.20and.20lamba.20calculus/near/192701141\" title=\"#narrow/stream/229136-category-theory/topic/Set.5ESet.20and.20lamba.20calculus/near/192701141\">said</a>:</p>\n<blockquote>\n<p>It's not crazy at all. Every small category is equivalent to a large one: just throw in a proper class of objects isomorphic to objects you already have.  (You have to do this correctly to maintain equivalence.)   So when someone hands you a large category you should query whether it's equivalent to a small one.  The easiest way is to find a skeleton and see if that's small.</p>\n</blockquote>\n<p>I see! Thank you, I hadn't thought of that :).</p>",
        "id": 192701994,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1585849643
    },
    {
        "content": "<p>It's possible that the suggestion of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><mrow><mi mathvariant=\"sans-serif\">F</mi><mi mathvariant=\"sans-serif\">i</mi><mi mathvariant=\"sans-serif\">n</mi><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Set}^{\\mathsf{FinSet}}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9334479999999998em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">S</span><span class=\"mord mathsf\">e</span><span class=\"mord mathsf\">t</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9334479999999998em;\"><span style=\"top:-3.1473400000000002em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathsf mtight\">F</span><span class=\"mord mathsf mtight\">i</span><span class=\"mord mathsf mtight\">n</span><span class=\"mord mathsf mtight\">S</span><span class=\"mord mathsf mtight\">e</span><span class=\"mord mathsf mtight\">t</span></span></span></span></span></span></span></span></span></span></span></span></span> was for something else, because it is like extending sets with variables. But it's not obvious to me how that would help.</p>",
        "id": 192702055,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585849667
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"275900\">@Stelios Tsampas</span>: you might be interested in Fiore–Hamana's <em>Multiversal Polymorphic Algebraic Theories</em> (<a href=\"https://www.cl.cam.ac.uk/~mpf23/papers/Algebra/mpat.pdf\" title=\"https://www.cl.cam.ac.uk/~mpf23/papers/Algebra/mpat.pdf\">https://www.cl.cam.ac.uk/~mpf23/papers/Algebra/mpat.pdf</a>), which describes a framework for polymorphic type theories (including System F) using presheaf categories</p>",
        "id": 192702375,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1585849817
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"275920\">@John Baez</span> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><mrow><mi>κ</mi><mo>−</mo><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow></mrow></msup></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Set}^{κ-\\mathsf{Set}}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9334479999999998em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">S</span><span class=\"mord mathsf\">e</span><span class=\"mord mathsf\">t</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9334479999999998em;\"><span style=\"top:-3.14734em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">κ</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\"><span class=\"mord mathsf mtight\">S</span><span class=\"mord mathsf mtight\">e</span><span class=\"mord mathsf mtight\">t</span></span></span></span></span></span></span></span></span></span></span></span></span> is not like 'types schemas in variables that range over all types', assuming that the 'types' are sets (which is why the base is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">S</span><span class=\"mord mathsf\">e</span><span class=\"mord mathsf\">t</span></span></span></span></span>). It has just expanded what the variables range over to κ-sized sets, but that is still the same restriction as using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">F</mi><mi mathvariant=\"sans-serif\">i</mi><mi mathvariant=\"sans-serif\">n</mi><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{FinSet}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">F</span><span class=\"mord mathsf\">i</span><span class=\"mord mathsf\">n</span><span class=\"mord mathsf\">S</span><span class=\"mord mathsf\">e</span><span class=\"mord mathsf\">t</span></span></span></span></span>. I would presume we are looking for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">C^C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span> is Cartesian closed.</p>",
        "id": 192702910,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585850064
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> is the types, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">C^C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span> are the schemas in one variable.</p>",
        "id": 192702998,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585850119
    },
    {
        "content": "<p>I don't know anything about \"type schemas in variables that range over all types\", so I'm not attempting to join this part of the conversation.  I just know which categories are complete, cartesian closed, etc., so I was correcting some apparent mistakes I saw.</p>",
        "id": 192703367,
        "sender_full_name": "John Baez",
        "timestamp": 1585850285
    },
    {
        "content": "<p>The completeness criterion is that I'm assuming that the nlab's sufficient condition for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>D</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">D^C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span> to be a CCC generalizes to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span></span></span></span> being <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span>-complete.</p>",
        "id": 192703412,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585850319
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span></span></span></span> needs to be complete for things indexed by certain constructions <em>related</em> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span>, but im not sure that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span>-completeness is sufficient</p>",
        "id": 192706104,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585851608
    },
    {
        "content": "<p>at the very least, in a constructive setting i think it may not be—in a classical setting i don't know</p>",
        "id": 192706175,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585851646
    },
    {
        "content": "<p>consider presheaves on some preordered set; the exponential is basically kripke semantics, so you're using Set's completeness over a <em>down-set</em> (er, maybe an up-set), not just the base category itself</p>",
        "id": 192706307,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585851714
    },
    {
        "content": "<p>and constructively speaking, it's totally possible to have completeness for some shape but not for arbitrary subshapes or similar things—just consider that any category has all limits of shape 1, but few have all limits of every subsingleton shape!</p>",
        "id": 192706536,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585851824
    },
    {
        "content": "<p>it's possible i'm missing something that resolves the issue, but in any case i think this shows that it's not cut-and-dry</p>",
        "id": 192706629,
        "sender_full_name": "sarahzrf",
        "timestamp": 1585851860
    },
    {
        "content": "<p>Yeah, you probably need small copowers as well or something.</p>",
        "id": 192707484,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585852304
    },
    {
        "content": "<p>For the well-known construction.</p>",
        "id": 192707604,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585852357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/stream/229136-category-theory/topic/Set.5ESet.20and.20lamba.20calculus/near/192701141\" title=\"#narrow/stream/229136-category-theory/topic/Set.5ESet.20and.20lamba.20calculus/near/192701141\">said</a>:</p>\n<blockquote>\n<p>It's not crazy at all. Every small category is equivalent to a large one: just throw in a proper class of objects isomorphic to objects you already have.  (You have to do this correctly to maintain equivalence.)   So when someone hands you a large category you should query whether it's equivalent to a small one.  The easiest way is to find a skeleton and see if that's small.</p>\n</blockquote>\n<p>except for the empty category <span aria-label=\"smirk cat\" class=\"emoji emoji-1f63c\" role=\"img\" title=\"smirk cat\">:smirk_cat:</span></p>",
        "id": 192754648,
        "sender_full_name": "Joe Moeller",
        "timestamp": 1585884877
    },
    {
        "content": "<p>Wow, true.   It's so damned small it's not equivalent to any large category!</p>",
        "id": 192755096,
        "sender_full_name": "John Baez",
        "timestamp": 1585885497
    },
    {
        "content": "<p>The empty sets strikes again</p>",
        "id": 192766736,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1585899266
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277270\">Dan Doel</span> <a href=\"#narrow/stream/229136-category-theory/topic/Set.5ESet.20and.20lamba.20calculus/near/192700312\" title=\"#narrow/stream/229136-category-theory/topic/Set.5ESet.20and.20lamba.20calculus/near/192700312\">said</a>:</p>\n<blockquote>\n<p>The problem with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>e</mi><msup><mi>t</mi><mrow><mi>F</mi><mi>i</mi><mi>n</mi><mi>S</mi><mi>e</mi><mi>t</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">Set^{FinSet}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\">e</span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathdefault mtight\">i</span><span class=\"mord mathdefault mtight\">n</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault mtight\">e</span><span class=\"mord mathdefault mtight\">t</span></span></span></span></span></span></span></span></span></span></span></span> is that it doesn't function in the way the original question was posed, because it is type schemas whose variables are finite types, not arbitrary types.</p>\n</blockquote>\n<p>If you're trying to tackle \"arbitrary types\" you'll never escape these size issues! Surely there must be some upper bound on the size of type constructions you reeeeally need?</p>",
        "id": 192780727,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1585907557
    },
    {
        "content": "<p>Alternatively put, is there a reason why you need <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">C^C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span> and can't use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>D</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">D^C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span> for some larger category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span></span></span></span>? The only one actually mentioned so far is \"I want the identity to be in there\", but there is a natural embedding of eg. FinSet into Set which tastes just like the identity. I remember reading some work a long time ago about Relative Pseudomonads (Highland et al, I believe) that was built to overcome size issues a lot like this (eg I want to think of the Yoneda embedding as a kind of monad but I can't because it makes things Big)</p>",
        "id": 192781583,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1585907993
    },
    {
        "content": "<p>This is (I think) the original reference about relative 1-monads: <a href=\"https://arxiv.org/abs/1412.7148\" title=\"https://arxiv.org/abs/1412.7148\">https://arxiv.org/abs/1412.7148</a>. This is the paper about relative pseudomonads: <a href=\"https://arxiv.org/abs/1612.03678\" title=\"https://arxiv.org/abs/1612.03678\">https://arxiv.org/abs/1612.03678</a>.</p>",
        "id": 192788654,
        "sender_full_name": "Paolo Capriotti",
        "timestamp": 1585912542
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"277473\">@Morgan Rogers</span> Types can have infinite numbers of values in them, like the natural numbers. Type schemas look like <code>a -&gt; a</code> (that's the one for the identity function), and <code>a</code> can be instantiated to any concrete type (or schema, if you're using it to produce another schema). My understanding is that the original question was about fixing a category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> that represents all the concrete types, and then representing these schemas as functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">C^C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span>. I'm not surprised that it doesn't work, because I was trying to explain ways why it wouldn't, initially.</p>",
        "id": 192816766,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585925928
    },
    {
        "content": "<p>Or, I'm not surprised it doesn't work with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>=</mo><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">C = \\mathsf{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">S</span><span class=\"mord mathsf\">e</span><span class=\"mord mathsf\">t</span></span></span></span></span>.</p>",
        "id": 192817015,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585926014
    },
    {
        "content": "<p>Unless I'm not understanding the alternate suggestion, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>D</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">D^C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span> is going to be a situation where 1) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> does not allow being schematic in all concrete types or 2) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span></span></span></span> contains things that <em>aren't</em> concrete types, so it isn't a precise correspondence like the initial question wants.</p>",
        "id": 192818109,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585926426
    },
    {
        "content": "<p>From the preceding discussion, your option 2 sounds like a concession which might ultimately be necessary to avoid size issues if you want both your category of concrete types and your category of schemas to have moderately strong closure properties. <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 192820899,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1585927520
    },
    {
        "content": "<p>I actually studied Fiore and Hamana's work on algebras with binders a long time ago, and I'd be happy to see discussion on the subject. It's clear there is a stark distinction between viewing polymorphism as a <em>function</em> between <em>universes</em> and as a <em>schema</em> which involves syntax, which is what Dan is getting at. Obviously syntax allows for anything, including inconsistent theories, so one usually wants some semantics at some point, but it's interesting to start with the syntax.</p>",
        "id": 192883593,
        "sender_full_name": "Cody Roux",
        "timestamp": 1585965567
    },
    {
        "content": "<p>I can kind of understand the hope, because being a <em>functor</em> rather than a function requires you to be coherent in a way that might only allow things we'd understand as parametric. But there are at least technical issues.</p>",
        "id": 192884806,
        "sender_full_name": "Dan Doel",
        "timestamp": 1585967141
    },
    {
        "content": "<p>You could take the category CESet of computably enumerable sets and partial computable functions and do category theory internal to it.  Then CESet is \"<a href=\"https://mathesismessianisme.wordpress.com/2015/05/01/une-categorie-interne-a-elle-meme/\" title=\"https://mathesismessianisme.wordpress.com/2015/05/01/une-categorie-interne-a-elle-meme/\">internal to itself</a>\" [1] and CESet^CESet is countable, because only computable functors are allowed.</p>\n<p>[1] That's a link to a page quoting a thread on the category theory mailing list; I can't find the thread online anywhere else.</p>",
        "id": 193829236,
        "sender_full_name": "Mike Stay",
        "timestamp": 1586816636
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276048\">Mike Stay</span> <a href=\"#narrow/stream/229136-theory.3A-category.20theory/topic/Set.5ESet.20and.20lamba.20calculus/near/193829236\" title=\"#narrow/stream/229136-theory.3A-category.20theory/topic/Set.5ESet.20and.20lamba.20calculus/near/193829236\">said</a>:</p>\n<blockquote>\n<p>You could take the category CESet of computably enumerable sets and partial computable functions and do category theory internal to it.  Then CESet is \"<a href=\"https://mathesismessianisme.wordpress.com/2015/05/01/une-categorie-interne-a-elle-meme/\" title=\"https://mathesismessianisme.wordpress.com/2015/05/01/une-categorie-interne-a-elle-meme/\">internal to itself</a>\" [1] and CESet^CESet is countable, because only computable functors are allowed.</p>\n<p>[1] That's a link to a page quoting a thread on the category theory mailing list; I can't find the thread online anywhere else.</p>\n</blockquote>\n<p>That indeed sounds very, very promising. Thanks!</p>",
        "id": 193972828,
        "sender_full_name": "Stelios Tsampas",
        "timestamp": 1586910867
    }
]