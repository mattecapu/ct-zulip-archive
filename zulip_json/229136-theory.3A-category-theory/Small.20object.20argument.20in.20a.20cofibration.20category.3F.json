[
    {
        "content": "<p>I want to construct a weak factorization system using the small object argument in something like a homotopy cocomplete cofibration category, though I think I don't need to specify any weak equivalences. Basically I have a category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">A</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\">A</span></span></span></span> with a class of cofibrations <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi><mo separator=\"true\">,</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal C,</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mpunct\">,</span></span></span></span> I don't necessarily have all pushouts but I can pushout cofibrations along any map, I have small coproducts and coproducts of cofibrations are cofibrations, and I have transfinite compositions of cofibrations. </p>\n<p>It seems pretty obvious that if I have a small class of cofibrations between small objects in such a setting, then I can run the small object argument exactly as usual. But the small object argument is (almost?) always described for categories such as model categories that are actually cocomplete. Does anybody know whether there's a reference for this mild generalization?</p>",
        "id": 393582121,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1695855599
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"609515\">@Kevin Arlin</span>  I was interested when you asked the question, but now I kind of need the result <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span> <br>\nDid you get any useful feedback or find anything on your own? Or even write up the result yourself?</p>",
        "id": 395840841,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1696929590
    },
    {
        "content": "<p>I'm curious what an application would be where you don't already have an \"enveloping\" cocomplete category with a WFS at hand, in which <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">A</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{A}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\">A</span></span></span></span> is the full subcategory of \"cofibrant\" objects.</p>",
        "id": 395926814,
        "sender_full_name": "Reid Barton",
        "timestamp": 1696958227
    },
    {
        "content": "<p>I'm actually thinking of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">A</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\">A</span></span></span></span> as a wide subcategory, Reid. That said, the key examples I have in mind are where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">A</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\">A</span></span></span></span> is a 2-category with flexible limits and colimits. These are omnipresent in 2-category theory, starting with the 2-category of categories with finite products and that of monoidal categories with strong monoidal functors, because whenever <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">K</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.01445em;\">K</span></span></span></span> is a reasonable 2-category and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> is a reasonable 2-monad on it, the Eilenberg-Moore 2-category of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>-algebras and pseudomorphisms has these properties.</p>",
        "id": 395945311,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1696964700
    },
    {
        "content": "<p>And in cases like this I really don't think there's any reasonable envelopment like you're thinking of in cases more like CW-complexes vs. nice-category topological spaces.</p>",
        "id": 395945442,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1696964754
    },
    {
        "content": "<p>Interested to know what your application is, Tom! I'm planning to just write it up and have it in an appendix of our paper in prep, I'll send you something privately.</p>",
        "id": 395945562,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1696964789
    },
    {
        "content": "<p>(Oh, and in my application, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span> is the normal isocofibrations, which is usually the same as the 1-morphisms sent to isofibrations in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Cat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Cat</span></span></span></span></span> by representables.)</p>",
        "id": 395945812,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1696964894
    },
    {
        "content": "<p>Oh, so you need the enriched variant of the small object argument? Btw, did you have in mind the original Quillen version, or the more algebraic one by <span class=\"user-mention\" data-user-id=\"280390\">@Richard Garner</span>,  John Bourke, <span class=\"user-mention\" data-user-id=\"277432\">@Emily Riehl</span>...?</p>",
        "id": 396014691,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1697003665
    },
    {
        "content": "<p>Anyway, my application is in the context of familial functors, following my <a href=\"https://hal.science/hal-01246365v3\">paper</a> with Richard. Familial functors enjoy a spectrum-exponent representation.<br>\nThis means that familial functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ’</mi><mo>â†’</mo><mover accent=\"true\"><mi>ğ”»</mi><mo stretchy=\"true\">^</mo></mover></mrow><annotation encoding=\"application/x-tex\">ğ’ â†’ \\widehat{ğ”»}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9289em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9289em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathbb\">D</span></span><span class=\"svg-align\" style=\"top:-3.6889em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span style=\"height:0.24em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span></span></span></span> are equivalent to pairs of a <em>spectrum</em> presheaf <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>âˆˆ</mo><mover accent=\"true\"><mi>ğ”»</mi><mo stretchy=\"true\">^</mo></mover></mrow><annotation encoding=\"application/x-tex\">S âˆˆ \\widehat{ğ”»}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">âˆˆ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9289em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9289em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathbb\">D</span></span><span class=\"svg-align\" style=\"top:-3.6889em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span style=\"height:0.24em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span></span></span></span>, and an <em>exponent</em> functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mspace></mspace><mspace width=\"0.1111em\"/><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext>â€‰â£</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333em\"/><mi>ğ²</mi><mi mathvariant=\"normal\">/</mi><mi>S</mi><mo>â†’</mo><mi>ğ’</mi></mrow><annotation encoding=\"application/x-tex\">E\\colon ğ²/S â†’ğ’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333em;\"></span><span class=\"mord mathbf\" style=\"margin-right:0.01597em;\">y</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ²</mi><mi mathvariant=\"normal\">/</mi><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">ğ²/S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbf\" style=\"margin-right:0.01597em;\">y</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> denotes the category of elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>. The original functor is recovered as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>â†¦</mo><mi>c</mi><mo>â†¦</mo><msub><mo>âˆ‘</mo><mrow><mi>x</mi><mo>âˆˆ</mo><mi>S</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo stretchy=\"false\">)</mo></mrow></msub><mi>ğ’</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo separator=\"true\">,</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">C â†¦ c â†¦ âˆ‘_{x âˆˆ S(c)} ğ’(E(c,x),C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6943em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â†¦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.522em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â†¦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2247em;vertical-align:-0.4747em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">âˆ‘</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2253em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"mrel mtight\">âˆˆ</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">c</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4747em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<p>We have a notion of analytic functor which generalises familial functors, essentially by replacing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ’</mi></mrow><annotation encoding=\"application/x-tex\">ğ’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span></span></span></span> with a category of <em>orbits</em> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ’ª</mi><mo stretchy=\"false\">(</mo><mi>ğ’</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ğ’ª(ğ’)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.08078em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mclose\">)</span></span></span></span>. An object of this category is a pair <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>G</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(C,G)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">)</span></span></span></span> of an object of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ’</mi></mrow><annotation encoding=\"application/x-tex\">ğ’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span></span></span></span> and a subgroup <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> of the automorphism group of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>. (This is a generalisation to presheaf categories of Joyal's notion of analytic functors.) The idea is that analytic functors enable some limited form of quotienting. E.g., the free commutative monoid monad is analytic, but not familial. Its spectrum is the set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">N</mi></mrow><annotation encoding=\"application/x-tex\">â„•</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">N</span></span></span></span>, and its exponent maps any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> to the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>-element set, with its full automorphism group. </p>\n<p>The problem is that analytic functors behave badly, e.g., they are not even closed under composition. Richard came up with a slightly less general notion, called <em>cellular</em> functor, which fixes some issues â€” though not all. The core issue is that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ’ª</mi><mo stretchy=\"false\">(</mo><mi>ğ’</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ğ’ª(ğ’)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.08078em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mclose\">)</span></span></span></span> does not have colimits, even the most basic ones like pushouts. The rough idea is to restrict to a well-behaved subcategory, say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">I</mi></mrow><annotation encoding=\"application/x-tex\">â„</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.19189em;\">I</span></span></span></span> of <em>cell complexes</em>, and take exponents <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ²</mi><mi mathvariant=\"normal\">/</mi><mi>S</mi><mo>â†’</mo><mi mathvariant=\"script\">I</mi></mrow><annotation encoding=\"application/x-tex\">ğ²/S â†’ â„</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbf\" style=\"margin-right:0.01597em;\">y</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.19189em;\">I</span></span></span></span>. But in fact we need to take it a bit further. In the paper this is done with additional technical conditions, but it may be viewed as equipping also <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>ğ”»</mi><mo stretchy=\"true\">^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\widehat{ğ”»}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9289em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9289em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathbb\">D</span></span><span class=\"svg-align\" style=\"top:-3.6889em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span style=\"height:0.24em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span></span></span></span> with cell complexes, say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ’¥</mi></mrow><annotation encoding=\"application/x-tex\">ğ’¥</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9778em;vertical-align:-0.2778em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.19189em;\">J</span></span></span></span>, and taking well-behaved exponents <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ’¥</mi><mi mathvariant=\"normal\">/</mi><mi>S</mi><mo>â†’</mo><mi mathvariant=\"script\">I</mi></mrow><annotation encoding=\"application/x-tex\">ğ’¥/S â†’ â„</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0278em;vertical-align:-0.2778em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.19189em;\">J</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.19189em;\">I</span></span></span></span>. The point now is that cell complexes are defined in a rather <em>ad hoc</em> way in the paper, so, my student Yoann Barszezak and I would like to view them as cofibrant objects in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ’ª</mi><mo stretchy=\"false\">(</mo><mi>ğ’</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ğ’ª(ğ’)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.08078em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mclose\">)</span></span></span></span>, which involves setting up a weak factorisation system. As I said, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ’ª</mi><mo stretchy=\"false\">(</mo><mi>ğ’</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ğ’ª(ğ’)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.08078em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mclose\">)</span></span></span></span> does not have pushouts, but it does have pushouts along our candidate generating cofibrations (which was in fact the whole point of cell complexes from the beginning), and we <em>think</em> it has transfinite compositions. </p>\n<p><span class=\"user-mention\" data-user-id=\"276480\">@Reid Barton</span>, it might be a good idea to (fully) embed <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ’ª</mi><mo stretchy=\"false\">(</mo><mi>ğ’</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ğ’ª(ğ’)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.08078em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mclose\">)</span></span></span></span> into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>ğ’</mi><mo separator=\"true\">,</mo><mrow><mi mathvariant=\"bold\">S</mi><mi mathvariant=\"bold\">e</mi><mi mathvariant=\"bold\">t</mi></mrow><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[ğ’,\\mathbf{Set}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Set</span></span><span class=\"mclose\">]</span></span></span></span> and work there, but there will probably be a few things that we won't know how to do. E.g., a notion that is crucial to the theory is that of <em>vertical</em> morphism in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ’ª</mi><mo stretchy=\"false\">(</mo><mi>ğ’</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ğ’ª(ğ’)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.08078em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mclose\">)</span></span></span></span>, which is essentially one that merely modifies automorphisms (= the underlying morphism is an iso). I don't see offhand how to extend this to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>ğ’</mi><mo separator=\"true\">,</mo><mrow><mi mathvariant=\"bold\">S</mi><mi mathvariant=\"bold\">e</mi><mi mathvariant=\"bold\">t</mi></mrow><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[ğ’,\\mathbf{Set}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Set</span></span><span class=\"mclose\">]</span></span></span></span>. </p>\n<p>Of course we'll be grateful for constructive comments and suggestions!</p>",
        "id": 396019034,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1697005904
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"383799\">@Tom Hirschowitz</span> I'm hoping to just run the small object argument on the underlying categories, but I'm not completely sure yet whether that'll go through, after thinking more about the colimits in these 2-categories.</p>",
        "id": 396142505,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1697047978
    },
    {
        "content": "<p>But the basic overlap of being in a bad 1-category that does have pushouts along a distinguished class of maps is still there. Looks like an interesting case.</p>",
        "id": 396142771,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1697048088
    },
    {
        "content": "<p>Ah, and I'm thinking mainly about the old-fashioned small object argument but am certainly interested in thinking about the algebraic one, at least in principle.</p>",
        "id": 396150210,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1697051231
    },
    {
        "content": "<p>You can, of course, always embed a given category into a cocomplete one universally, via its Yoneda embedding.  That embedding won't preserve the existing colimits, but it does if you restrict the Yoneda embedding to land in presheaves that themselves preserve those colimits (<em>qua</em> functors to Set).</p>",
        "id": 396151697,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1697051935
    },
    {
        "content": "<p>Thanks for these explanations.</p>\n<p><span class=\"user-mention\" data-user-id=\"609515\">@Kevin Arlin</span> 's example is similar to things I have thought about before, so maybe I can say something useful. Let's take the example of the 2-category of (categories with finite products, functors that preserve finite products [in the usual up-to-iso] sense, all natural transformations). It sounds like your approach is to keep these 1-morphisms, get rid of the 2-morphisms, and work with the 1-category that results and whatever (co)limits it still has.</p>\n<p>Two other possible approaches would be:</p>\n<ol>\n<li>\n<p>Take categories with <strong>chosen</strong> finite products, and functors that <strong>strictly</strong> preserve the chosen finite products. This is not very nice from the 2-categorical viewpoint, but on the other it does produce a 1-category that is exactly the category of models of an essentially algebraic theory, hence is locally presentable and in particular has all colimits and limits.</p>\n<p>In general these (co)limits will not be homotopically meaningful (i.e., equivalence-invariant). We can try to address using a model structure in which, for example, the cofibrant objects are the ones where the chosen finite products are \"freely adjoined\". The idea is that,  when we consider functors out of a cofibrant category-equipped-with-chosen-finite-products, the category of strictly-product-preserving functors should be equivalent to the category of functors that are product-preserving in the usual up-to-iso sense. If we don't care about a full model category structure, we could also restrict attention to the cofibrant categories and make them into a cofibration category.</p>\n<p>This approach is maybe a bit awkward if you would prefer to be working with categories up to equivalence (e.g., if one of the categories you would like to consider is \"the\" category of sets), since it requires distinguishing equivalent categories with non-isomorphic chosen-finite-product structure. For example, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> is the chosen terminal object, the chosen product <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>Ã—</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1 \\times 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">Ã—</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> might or not be <em>equal</em> as an object to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>, (and, therefore, in a cofibrant category they will be forced to be non-equal).</p>\n</li>\n<li>\n<p>Work with the \"correct\" 2-categorical (co)limit notions through out, so that everything is equivalence-invariant. If you only need some specific colimits (say initial objects, pushouts, sequential colimits, and maybe some tensors), then this needn't be very technical. On the other hand, you would have to check that whatever you want to do with a cofibration category also works in a \"cofibration 2-category\".</p>\n</li>\n</ol>\n<p>With the suggested approach of using the 1-category of up-to-iso product-preserving functors, I find the situation a bit confusing. It seems that this approach works better for limits than for colimits. For example, this approach is used in <a href=\"https://arxiv.org/abs/1411.0303\">https://arxiv.org/abs/1411.0303</a> to build a fibration category of cofibration categories, in which the fibrations are (among other conditions) isofibrations. But for colimits it seems problematic. For example, there cannot be an initial object in this category, since whatever it is, it should admit a <em>unique</em> product-preserving functor to any other category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, yet we could replace <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>Ã—</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">X \\times S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">Ã—</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is a contractible category with multiple objects, and then there cannot also be a unique product-preserving functor to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>Ã—</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">X \\times S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">Ã—</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>.</p>\n<p>However, this setup also depends delicately on the exact 2-category we started with, and discarded the 2-morphisms of. It could be that we can replace it by a (bi)equivalent 2-category with more success. For instance, this happens with (categories and left adjoints), because we could work instead with the opposite of the category formed by the right adjoints. I don't have a good sense for when this kind of strategy should succeed.</p>",
        "id": 396967669,
        "sender_full_name": "Reid Barton",
        "timestamp": 1697485631
    },
    {
        "content": "<p>Thanks for the thoughts, Reid. Switching to the strict-morphisms category probably doesn't help if I insist on getting an orthogonal factorization system, since precisely as you say the underlying categories are far from equivalent. The hope is to do something closer to 2. I don't really need much about 2-cofibration categories because I'm not localizing or anything. A third option might be to give up on the strictly orthogonal factorization and instead look for one with unique-up-to-iso factorizations. But this seems annoying.</p>",
        "id": 396973354,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1697488370
    },
    {
        "content": "<p>The colimits that are present in this kind of situation are a case of what Bourke et al call \"shrinkable colimits\" here: <a href=\"https://arxiv.org/pdf/2006.07843.pdf\">https://arxiv.org/pdf/2006.07843.pdf</a></p>\n<p>Specifically these 2-categories, if I understand correctly, have all weighted colimits for which there is merely a surjective equivalence from the  maps from the colimit to the category of cocones/cocylinders. This is enough to get all weak colimits in the underlying category, but that's pretty much it. I didn't understand this till last Friday and I'm now less confident what one might be able to get away with here.</p>",
        "id": 396974079,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1697488749
    },
    {
        "content": "<p>Hm, actually, this afternoon it's looking to me like option #1 might get me somewhere. There's such a nice 2-equivalence between the strict-morphism 2-category and the pseudo-morphism one that I seem to be able to transfer orthogonal factorization systems across on the nose.</p>",
        "id": 396979487,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1697491548
    }
]