[
    {
        "content": "<p>From a purely logical point of view, category theory is \"easy\" in some sense, a lot of the reasoning is just equational reasoning. There are universal quantifiers in universal properties, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">∃</mi><mo stretchy=\"false\">!</mo><mi>y</mi><mi mathvariant=\"normal\">.</mi><mi>R</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall x. \\exists! y.R(x,y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.∃</span><span class=\"mclose\">!</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span> but these are rarely nested in a way that leads to deep chains of alternating quantifiers. On another hand, it is hard in the sense that it seems to fundamentally involve dependent types. This makes it unfortunately seemingly not a good candidate for automated theorem provers using first order logic because an explosion of predicates is necessary to control the type dependency.</p>\n<p>It seems very plausible that, for example, some of the theory of pure categories or bicategories is decidable, i.e., we can write down a theory encompassing much of of pure non-applied elementary theory of categories or bicategories, and there is an algorithm to decide whether this is a theorem.</p>\n<p>This led me to ask a more specific question. Mathematicians have a notion of a \"follow-your-nose\" proof, where the next step is obvious from the current one, and the proof is merely a mechanical matter of doing the obvious next thing. For example, to prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>∨</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A \\lor B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∨</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> you should pick one of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A, B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and try to prove it (trying to prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> first and then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> if this fails); to prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\implies B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7073em;vertical-align:-0.024em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> you should assume <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> and try to prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>; to prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>∧</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\land B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> you should try and prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A, B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> separately, and so on. Of course this does not always work, for example if you try to prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>∨</mo><mi>B</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>B</mi><mo>∨</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A\\lor B \\implies B \\lor A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∨</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7073em;vertical-align:-0.024em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∨</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> by following these rules, you will assume <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>∨</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\lor B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∨</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and then try to either prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>, which is a dead-end. But it is of interest to write down exactly the logical structure of formulas for which the \"naive\" proof procedure does work, and the field of logic programming is in part about identifying a good class of logical formulas for which the naive \"follow-your-nose\" method works, and trying to encode interesting practical algorithms into the direct proof-search procedure for this class of formulas. So my question is, is there a known fragment of category theory which falls into the logic fragment supported by a logic programming language such as Lambda Prolog or Twelf? If such a fragment was identified it would give a very simple and easy to implement proof procedure for theorems in the fragment, just by essentially writing down the axioms and the goal to be proved and telling Lambda Prolog / Twelf to prove it.</p>",
        "id": 419650189,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1707001960
    },
    {
        "content": "<p>As a starting point, although we commonly say that category theory uses only intuitionistic reasoning, we can probably say something stronger: it uses only minimal logic, i.e., most category theory proofs do not rely on the principle of explosion in a fundamental way.</p>",
        "id": 419650419,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1707002212
    },
    {
        "content": "<p>(Twelf is unique in being a dependently typed logic programming language, and it is tempting to try and encode a decision procedure for category theory theorems in it.)</p>",
        "id": 419650519,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1707002347
    },
    {
        "content": "<p>FWIW, Coq's typeclass-search mechanism is also a kind of dependently typed logic programming language.</p>",
        "id": 419652122,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1707004088
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Logic.20programming/near/419652122\">said</a>:</p>\n<blockquote>\n<p>FWIW, Coq's typeclass-search mechanism is also a kind of dependently typed logic programming language.</p>\n</blockquote>\n<p>Yes, that's a good point. I think that understanding Coq's typeclasses helped me to understand logic programming better. It seems like Enrico Tassi, one of the Coq developers, has really bought into the idea expressed by Dale Miller here <a href=\"https://link.springer.com/article/10.1007/s10817-018-9483-3\">https://link.springer.com/article/10.1007/s10817-018-9483-3</a> that for things like type inference and type class resolution it is best to have a dedicated logic programming language to explicitly write such functionality, viewing it as a natural generalization of typeclass resolution and canonical structures. I think that a long term goal is to implement a full elaborator for the calculus of inductive constructions in Lambda Prolog, ideally giving users the ability to extend the elaborator with additional unification hints.<br>\n<a href=\"https://github.com/LPCIC/\">https://github.com/LPCIC/</a><br>\nI'm not sure it's practical to manually assemble functors in Coq using the typeclass system, but with a dedicated user extensible language for the elaborator I feel like it might be.</p>",
        "id": 419652407,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1707004465
    },
    {
        "content": "<p>I'm fond of that idea as well.</p>",
        "id": 419652948,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1707005035
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"424412\">Patrick Nicodemus</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Logic.20programming/near/419650189\">said</a>:</p>\n<blockquote>\n<p>It seems very plausible that, for example, some of the theory of pure categories or bicategories is decidable, i.e., we can write down a theory encompassing much of of pure non-applied elementary theory of categories or bicategories, and there is an algorithm to decide whether this is a theorem.<br>\n</p>\n</blockquote>\n<p>I was struck by this seeming rather implausible, since one-object categories aren't even decidable (because the theory of groups isn't decidable). Then I came across <a href=\"https://mishap.sdf.org/mints-a-decidable-fragment-of-category-theory-without-automorphisms.pdf\">this paper draft</a> which skirts around the worry by considering equational theories of categories without any automorphisms (so that you cannot interpret the theory of groups).</p>",
        "id": 419663973,
        "sender_full_name": "Evan Washington",
        "timestamp": 1707016138
    },
    {
        "content": "<p>That's a good point, yeah. The example in the paper of a localization in a model category was more complicated than I had in mind, obviously a localization often gives categories for which the word problem is impossible to solve, along with other foundational issues. Maybe one way to make the problem more tractable would be to eliminate arbitrary equalities from the list of possible hypotheses, considering only equality hypotheses of the form \"a morphism with this universal property is unique\", so one does not have the ability to encode arbitrary problems from group theory.</p>",
        "id": 419701690,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1707056107
    },
    {
        "content": "<p>The functor laws and naturality laws aren't of this form, it's not obvious that there's a subset of equational reasoning which includes these without including much more complicated things.</p>",
        "id": 419701958,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1707056359
    },
    {
        "content": "<p>I don't mean to trivialize your point here by saying \"well, pathological examples aside...\". I did make a mistake in conflating equational reasoning with easy. But, I think experience does tell us that categorical proofs are often straightforward and direct, even if it is not obvious what would be a convenient formal language which is capable of expressing many of these arguments and does not encode the halting problem.</p>",
        "id": 419712258,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1707065559
    },
    {
        "content": "<p>there's a fast decision procedure  from the 1980s for the word problem for any finitely presented category that admits an equivalent non-length-increasing  re-write/Thue system.  <a href=\"https://www.proquest.com/openview/1e022b58b2f1b944c3bb775cdf98f98d/\">https://www.proquest.com/openview/1e022b58b2f1b944c3bb775cdf98f98d/</a></p>",
        "id": 419732774,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1707082121
    }
]