[
    {
        "content": "<p>The definition of <em>binoidal category</em> as given at <a href=\"https://ncatlab.org/nlab/show/premonoidal%20category\">[[premonoidal category]]</a> seems overly strict and, in fact, seems to not respect the <a href=\"https://ncatlab.org/nlab/show/principle%20of%20equivalence\">[[principle of equivalence]]</a>. So this gives it an air of a not-particular-categorical concept. All the papers that I've seen that define binoidal category give a similar definition that mentions equality on objects.</p>\n<p>Is this inevitable?</p>",
        "id": 439070835,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1715881410
    },
    {
        "content": "<p>Example 13.4 page 111 of <a href=\"https://arxiv.org/abs/2102.06275\">The Univalence Principle</a> by Benedikt Ahrens, Paige Randall North, Michael Shulman, and Dimitris Tsementzis does tackle the case of premonoidal categories.</p>",
        "id": 439072259,
        "sender_full_name": "Kenji Maillard",
        "timestamp": 1715881945
    },
    {
        "content": "<p>Ah, thanks, yes, that does seem better. (Minor point: it is example 13.4 but that's on p.117; I was confused as there's an example 12.4 on p.111 !)</p>",
        "id": 439080467,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1715885043
    },
    {
        "content": "<p>And I was able to formalize that in Agda in no time, and it looks like it's going to be smooth sailing to work with that.</p>",
        "id": 439083538,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1715886049
    },
    {
        "content": "<p>I would push back a bit on this idea that definitions which don't respect the principle of equivalence should be viewed as \"not particularly categorical\". My feeling is that we shouldn't get into the habit of automatically making all our definitions weaker just so the principle of equivalence holds, because in some cases it adds work without clarifying the theory.  (Though I accept that when it comes to formalisation things might well be the opposite!) </p>\n<p>For example, I think people would agree Gray-monoids or Gray-categories (see <a href=\"https://www.sciencedirect.com/science/article/pii/S0001870897916492\">e.g. Day and Street</a>) are \"categorical\", but their definition involves a similar equality to binoidal categories. And this arises very naturally from the enriched category theory. (I strongly suspect similar properties are in play in the binoidal case.)</p>\n<p>Alternatively: Lawvere theories are typically defined using strict preservation of products, but I don't think this is ever an obstacle in developing their theory. In fact I suspect that making the definition weaker but invariant under equivalence would add complication without much gain. Another similar example would be the Kelly-Eilenberg definition of closed categories, which uses an identity of functors but -- so far as I remember -- that doesn't cause any issues with the proofs. (Again, I'm talking here about pen-and-paper mathematics rather than formalisation.)</p>\n<p>For another, perhaps more provocative, example: functors strictly preserving some kind of structure are typically not closed under isomorphism (e.g. a strict product preserving functor can be naturally isomorphic to one that only preserves products up to iso) but it is sometimes very useful to work with strict functors because you can then talk about uniqueness on the nose, and so get (1-dimensional) adjunctions.  This occurs quite often in even in categorical semantics but is especially obvious in higher category theory. For example, in his  book <em>Coherence in three-dimensional category theory</em> Gurski often states free properties using strict pseudofunctors or similar. Taking the idea things ought to be invariant under equivalence completely seriously in this setting would require us to work up to equivalence of pseudofunctors, which would change the universal property from an adjunction to a biadjunction. So we'd have to do a lot more work only to get a property that's much less easy to work with. (And that's before we start on any tricategories!)</p>",
        "id": 439101011,
        "sender_full_name": "Philip Saville",
        "timestamp": 1715893402
    },
    {
        "content": "<p>The only reason the definition on the nLab looks non-categorical is that we're used to a bundled definition of \"functor\" that includes the action on objects, so if you want to have two functors that act the same on objects you have to ask for an equality of objects.  The solution is to view \"a functor whose action on objects is F\" as a perfectly good and categorical definition, given a function F on objects.  This notion can't be defined categorically in terms of the definition of \"functor\", but rather the reverse: a functor is a function F on objects together with \"a functor whose action on objects is F\".</p>",
        "id": 439102528,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1715894054
    },
    {
        "content": "<p>This is a totally different issue from things like the strictness of strict 2-categories and Gray-categories.</p>",
        "id": 439102620,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1715894095
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276777\">@Mike Shulman</span> 's interpretation seems to me to be of the same flavour as \"identity on objects functors\" - it is a bunch of data that <em>induces</em> a functor, but not a special kind of functor. As an unbundled definition, IOO makes perfect sense.</p>\n<p>I much prefer that view as also applied to Binoidal.</p>",
        "id": 439114398,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1715899466
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Binoidal.20categories.20and.20the.20principle.20of.20equivalence/near/439102528\">said</a>:</p>\n<blockquote>\n<p>The only reason the definition on the nLab looks non-categorical is that we're used to a bundled definition of \"functor\" that includes the action on objects, so if you want to have two functors that act the same on objects you have to ask for an equality of objects. The solution is to view \"a functor whose action on objects is F\" as a perfectly good and categorical definition, given a function F on objects</p>\n</blockquote>\n<p>This is a neat point I've not appreciated before :)</p>\n<p>My worry is that sometimes we give the impression that a definition involving identities should automatically be considered less 'nice' than definitions which are weak enough to be respected by equivalence. I imagine a student writing down the definition of binoidal category and then thinking to themselves it can't be right, so they throw it away and end up writing something much more complicated when they didn't need to.</p>\n<p>So my point is that  </p>\n<ol>\n<li>\n<p>Definitions that at first sight appear 'suspect' can actually arise for good reasons. For me, Mike's argument is a nice example of this: the binoidal definition looks 'off' but is actually quite natural from the right point of view. And I suggested Gray-monoids because they have a very similar equality between functors on objects, which also occurs very naturally because it falls out of the definition of the Gray tensor product on Cat. </p>\n</li>\n<li>\n<p>Even if a definition does involve some equalities that are not preserved by equivalence, that doesn't necessarily make it less good. Perhaps one might have to occasionally take a bit more care but the net simplification in the theory can make this worthwhile. For me, Lawvere theories and closed categories sit in this bracket.</p>\n</li>\n</ol>",
        "id": 439217110,
        "sender_full_name": "Philip Saville",
        "timestamp": 1715950664
    },
    {
        "content": "<p>I don't think that definitions that are written using identities (on objects) are necessarily bad - but as software developers says, it is a \"code smell\". It's not that what you're trying to define (such as Binoidal categories, identity on objects functors, Lawvere theories, etc) are themselves bad, but that the means you've chosen to define them is suspect.</p>\n<p>I think using a variety of different foundations is useful in this regard: certain settings (such as dependent type theory) let you more easily see that some definitions' exact phrasing is suspect. In some foundations (like ZFC), certain utterances are invisibly equivalent.</p>\n<p>In many of the cases that I've encountered, the subtle difference is between <em>is</em> and <em>induces</em> -- a category, a functor, etc. It's a data-flow problem: what data is given a priori, and what data can be extracted a posteriori out of a bundle. Equalities on a posteriori information is problematic, equalities that are pre-witnessed on a priori information is perfectly fine. (This is quite clear IOO Functors, IMHO.)</p>",
        "id": 439222969,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1715952408
    },
    {
        "content": "<p>For me the word 'suspect' is too strong. By which I mean: I can't recall an instance where this 'suspect'ness has actually caused me a problem in a proof (e.g. when working with binoidal categories or Lawvere theories or whatever). In my mind it doesn't reduce the stock of examples but does simplify the theory so I'm happy. Of course, I might just be outing myself as someone who has never tried to persuade a theorem prover of every detail of their definitions, because I know then these issues can really bite!  </p>\n<p>Part of my motivation for being so pernickety is that a lot of people learn CT from Zulip nowadays, and I want to point out that -- while one can be very careful about making everything invariant --  you don't <em>have</em> to do that in order to do good category theory. And there are central concepts in the field where this happens (or at least appears to). We can debate which is better, but I do think both approaches are actually fine.</p>\n<p>(I do agree with your point about different foundations being a useful way to make explicit coercions so we can ask ourselves whether or not we're really happy with them, and also that there's lots of interesting questions about whether one can tweak the phrasing of a definition to make it more invariant. But I think we probably disagree on the extent to which these questions trouble us in our day-to-day research!)</p>",
        "id": 439234453,
        "sender_full_name": "Philip Saville",
        "timestamp": 1715955989
    },
    {
        "content": "<p>Gray-monoids do have an equality like binoidal/premonoidal categories that can be dealt with in the same way, but they also have strict associativity and unit laws which can't be removed similarly.  The latter sort of strictness is of a different flavor, and also appears more simply in strict 2-categories.  I would probably argue that Eilenberg-Kelly closed categories are also of that sort, since an EK closed structure is not transportable across an equivalence of categories (but every LaPlaza-Manzyuk closed category is <em>isomorphic</em> to an EK one with different hom-sets -- a sort of \"strictification theorem\" like \"every bicategory is equivalent to a strict 2-category\").</p>",
        "id": 439246884,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1715959829
    },
    {
        "content": "<p>When working in <a href=\"https://ncatlab.org/nlab/show/set-level%20foundations\">[[set-level foundations]]</a>, I agree that definitions that are \"too strict\" aren't necessarily wrong, and can be very useful on occasion.  When using them one incurs an extra obligation to verify that all the \"important\" constructions are equivalence-invariant (in addition to the \"strictification\" result that justifies their use in the first place), but sometimes that can be a worthwhile price to pay for the simplification that accrues from strictness.  <a href=\"https://ncatlab.org/nlab/show/2-monad\">[[2-monad]]</a> theory is one of my favorite examples of this.</p>",
        "id": 439247316,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1715959959
    },
    {
        "content": "<p>But in <a href=\"https://ncatlab.org/nlab/show/higher-level%20foundations\">[[higher-level foundations]]</a>, the \"too strict\" definitions usually aren't sufficiently general, e.g. it's no longer true that every bicategory is equivalent to a strict 2-category.</p>",
        "id": 439247703,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1715960065
    },
    {
        "content": "<p>The original article is a bit sloppy, I should probably clean up the writing. A binoidal category is simply a category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> equipped with a \"separately functorial bifunctor\" <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo separator=\"true\">,</mo><mi>C</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C,C \\to C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> (would be nice to have simple terminology for separate vs jointly functorial bifunctors). Separately functorial bifunctors respect equivalence of categories so there's no issue with the principle of equivalence.</p>\n<p>You seem to be complaining that the definition of separately functorial bifunctor (which is basically inlined on this page) says that it is two functors that agree on objects, and that in general imposing equality of functors on objects is not equivalence-respecting. But just because each intermediate step of a construction doesn't follow from a generally applicable equivalence-respecting principle doesn't mean that the final construction is not equivalence respecting.</p>",
        "id": 439356197,
        "sender_full_name": "Max New",
        "timestamp": 1716039853
    },
    {
        "content": "<p>It's indeed very sad that bifunctors are not separately functorial functors but jointly functorial functors</p>",
        "id": 439402315,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1716089283
    },
    {
        "content": "<p>In fact I would push to reappropriate bifunctor for the latter since there is no reason to call bifunctors the first instead of just 'functors of 2 variables' or the suchlike</p>",
        "id": 439402363,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1716089340
    },
    {
        "content": "<p>I think the word \"bifunctor\" is just unfortunate and should be retired completely.  It could variously be interpreted as a joint functor of two variables, a separate functor of two variables, a functor between bicategories, or a functor that is also a cofunctor.</p>",
        "id": 439403618,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1716090670
    },
    {
        "content": "<p>I forgot about the last two. Ugh.</p>",
        "id": 439599053,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1716219543
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276642\">Max New</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Binoidal.20categories.20and.20the.20principle.20of.20equivalence/near/439356197\">said</a>:</p>\n<blockquote>\n<p>The original article is a bit sloppy, I should probably clean up the writing.  [...]<br>\nYou seem to be complaining that the definition of separately functorial bifunctor (which is basically inlined on this page) says that it is two functors that agree on objects, and that in general imposing equality of functors on objects is not equivalence-respecting. But just because each intermediate step of a construction doesn't follow from a generally applicable equivalence-respecting principle doesn't mean that the final construction is not equivalence respecting.</p>\n</blockquote>\n<p>You're probably correct that my main complaint is one of \"sloppy writing\". </p>\n<p>There is definitely an issue of who is the audience: is the nLab purely reference material for people who are assumed to already know all of this intimately, or is it also meant as somewhat pedagogical material for people new to the less standard parts of category theory? I'd say the vast majority of readers belong to the latter class of people.</p>\n<p>So yeah, \"sloppy writing\" will definitely confuse me. I am not at the level of understanding (yet) where I can tell that apart from 'the definition means what it says <em>exactly</em>'.</p>",
        "id": 439848475,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1716306761
    },
    {
        "content": "<p>The nLab is whatever people make of it.  There's lots of pedagogical material, but lots of articles don't have a pedagogical aspect just because no one has felt inspired to write it yet.</p>",
        "id": 439879128,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1716316809
    },
    {
        "content": "<p>I don't know why I keep getting myself embroiled in these things. I don't care about binoidal categories... I was trying to help someone else. Next thing I knew, I was way way deep in a rabbit hole that I had no idea even existed, never mind being as this deep.</p>",
        "id": 439880254,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1716317189
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276642\">Max New</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Binoidal.20categories.20and.20the.20principle.20of.20equivalence/near/439356197\">said</a>:</p>\n<blockquote>\n<p>Separately functorial bifunctors respect equivalence of categories so there's no issue with the principle of equivalence.</p>\n</blockquote>\n<p>Maybe I'm misunderstanding some of the words in this sentence, but this surprises me.<br>\nSay <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> is the \"walking isomorphism\". Isn't a \"separately functorial bifunctor\" <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mo separator=\"true\">,</mo><mi>I</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">I, I \\to C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> the same as giving a possibly non-commuting square of isomorphisms in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>?<br>\nWhile a \"separately functorial bifunctor\" <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo separator=\"true\">,</mo><mn>1</mn><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">1, 1 \\to C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> is just an object of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>; and these aren't equivalent. Unless the natural transformations are also not what I expect, maybe?</p>",
        "id": 440175864,
        "sender_full_name": "Reid Barton",
        "timestamp": 1716409313
    },
    {
        "content": "<p>(I'm also open to the possibility that \"principle of equivalence\" doesn't mean what I expect)</p>",
        "id": 440175961,
        "sender_full_name": "Reid Barton",
        "timestamp": 1716409343
    },
    {
        "content": "<p>Yes, I think I agree.  In fact, that's one of the important and subtle things about premonoidal categories and their ilk, that things in them are <em>not</em> invariant under arbitrary isomorphism, but only under central isomorphism.  That's why they were an interesting example for the ANST paper.</p>",
        "id": 440180639,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1716410916
    },
    {
        "content": "<p>So perhaps the definition is \"non-categorical\" in that sense.  I was just thinking of the fact that it can be defined without reference to equality of objects.</p>",
        "id": 440180918,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1716411012
    },
    {
        "content": "<p>There's a tensor product of categories called the <a href=\"https://ncatlab.org/nlab/show/funny%20tensor%20product\">[[funny tensor product]]</a> such that a separately functorial bifunctor from C,D to a category K is the same as a functor from the funny tensor product of C and D to K.  The funny tensor product is a symmetric monoidal structure on the category Cat - in fact, one of the only two symmetric monoidal closed structures on the category Cat! </p>\n<p><span class=\"user-mention\" data-user-id=\"277473\">@Morgan Rogers (he/him)</span> gave an example implying that the funny tensor product can't extend to a monoidal structure on the <em>2-category</em> of categories, functors and natural transformations, because equivalent categories can have inequivalent funny tensor products.</p>",
        "id": 440348046,
        "sender_full_name": "John Baez",
        "timestamp": 1716478321
    },
    {
        "content": "<p>So, we can conclude that the <em>other</em> symmetric monoidal closed structure on Cat, namely the cartesian product, is the only one that extends to a monoidal structure on the 2-category of categories, functors and natural transformations!</p>",
        "id": 440349044,
        "sender_full_name": "John Baez",
        "timestamp": 1716478645
    },
    {
        "content": "<p>I wonder if there are any other places in mathematics where the word \"funny\" has been given a precise meaning.</p>",
        "id": 440349277,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1716478712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Binoidal.20categories.20and.20the.20principle.20of.20equivalence/near/440348046\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"277473\">Morgan Rogers (he/him)</span> gave an example implying that the funny tensor product can't extend to a monoidal structure on the <em>2-category</em> of categories, functors and natural transformations, because equivalent categories can have inequivalent funny tensor products.</p>\n</blockquote>\n<p>I'd already forgotten that I did that... Someone could put that on the nLab page ;)</p>",
        "id": 440350707,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1716479174
    },
    {
        "content": "<p>Do it before you forget!  <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 440351440,
        "sender_full_name": "John Baez",
        "timestamp": 1716479411
    },
    {
        "content": "<p>suggestion for a title: \"A Tale of Two Tensors\"  </p>\n<p>just kidding, but it would be nice to have it in the nLab.</p>",
        "id": 440355581,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1716480725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Binoidal.20categories.20and.20the.20principle.20of.20equivalence/near/440348046\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"277473\">Morgan Rogers (he/him)</span> gave an example implying that the funny tensor product can't extend to a monoidal structure on the <em>2-category</em> of categories, functors and natural transformations, because equivalent categories can have inequivalent funny tensor products.</p>\n</blockquote>\n<p>What is the consequence of this? That it's not possible to define \"premonoidal natural transformations\"?</p>",
        "id": 440366173,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1716484495
    },
    {
        "content": "<p>Around here there's also <a href=\"https://ncatlab.org/nlab/show/sesquicategory\">[[sesquicategory]]</a>, which are to premonoidal categories as 2-categories are to monoidal categories, ie. it's like a 2-category but without the interchange law. Allegedly they are categories enriched in Cat with the funny tensor</p>",
        "id": 440366413,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1716484595
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Binoidal.20categories.20and.20the.20principle.20of.20equivalence/near/440351440\">said</a>:</p>\n<blockquote>\n<p>Do it before you forget!  <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<p>Done. It's one of those cases where the simplest possible example of an equivalence gives a counterexample.</p>",
        "id": 440401715,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1716499683
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275901\">Jules Hedges</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Binoidal.20categories.20and.20the.20principle.20of.20equivalence/near/440366413\">said</a>:</p>\n<blockquote>\n<p>Around here there's also <a href=\"https://ncatlab.org/nlab/show/sesquicategory\">[[sesquicategory]]</a>, which are to premonoidal categories as 2-categories are to monoidal categories, ie. it's like a 2-category but without the interchange law. Allegedly they are categories enriched in Cat with the funny tensor</p>\n</blockquote>\n<p>Yes, the allegation is true.    Relatedly, there are 3 important tensor products of 2-categories: the white tensor product (= funny tensor product, where you don't fill in the squares that get formed by pairs of morphisms), the Gray tensor product (where you fill them in, either with a 2-morphism or a 2-isomorphism), and the black tensor product (= cartesian product, where you fill them in with an equation, making the squares commute).</p>",
        "id": 440457658,
        "sender_full_name": "John Baez",
        "timestamp": 1716536699
    },
    {
        "content": "<p>Although, as you alluded to in the corresponding parenthetical, there are actually 3 Gray tensor products, one where the morphism goes in each way and a third where it's invertible.</p>",
        "id": 440458677,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1716537143
    },
    {
        "content": "<p>Yes, so we've got a total of 5 tensor products of 2-categories here!</p>",
        "id": 440459581,
        "sender_full_name": "John Baez",
        "timestamp": 1716537523
    },
    {
        "content": "<p>Given that the funny tensor product doesn't extend to the 2-category Cat, I'd expect that some (at least the white tensor product) of these 5 tensor products fail to work for the 3-category of 2-categories (or perhaps issues come up already for 2-cells?). Is that the case?</p>",
        "id": 440474772,
        "sender_full_name": "Martti Karvonen",
        "timestamp": 1716543498
    },
    {
        "content": "<p>A counterexample for even the 2-functoriality of the (lax/colax) Gray tensor product is given <a href=\"https://mathoverflow.net/a/459360\">in this MathOverflow answer</a>.</p>",
        "id": 440481200,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1716546203
    },
    {
        "content": "<p>However, the lax Gray tensor product is a functor of \"lax-Gray 3-categories\" and dually, just by abstract enriched category theory.</p>",
        "id": 440528587,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1716563466
    },
    {
        "content": "<p>To clarify, are you saying that, since the lax Gray tensor product forms a closed structure on the category 2-Cat, we can enrich in it, in which case 2-Cat becomes a (lax Gray)-enriched category, and the lax Gray tensor product is consequently also (lax Gray)-enriched?</p>",
        "id": 440532591,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1716565021
    },
    {
        "content": "<p>Yes!</p>",
        "id": 440532626,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1716565032
    },
    {
        "content": "<p>Although actually, I didn't check that that works in the usual way when the tensor product is non-symmetric, so it's possible I just lied.</p>",
        "id": 440532695,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1716565062
    },
    {
        "content": "<p>Hmm, yes, I think I lied.</p>",
        "id": 440532807,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1716565101
    },
    {
        "content": "<p>To make the tensor product an enriched functor on a closed monoidal category, you want <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">]</mo><mo>⊗</mo><mo stretchy=\"false\">[</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>D</mi><mo stretchy=\"false\">]</mo><mo>→</mo><mo stretchy=\"false\">[</mo><mi>A</mi><mo>⊗</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>B</mi><mo>⊗</mo><mi>D</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[A,B] \\otimes [C,D] \\to [A\\otimes C, B\\otimes D]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">]</span></span></span></span>, which by adjunction is equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">]</mo><mo>⊗</mo><mo stretchy=\"false\">[</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>D</mi><mo stretchy=\"false\">]</mo><mo>⊗</mo><mi>A</mi><mo>⊗</mo><mi>C</mi><mo>→</mo><mi>B</mi><mo>⊗</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">[A,B] \\otimes [C,D] \\otimes A \\otimes C \\to B\\otimes D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>, and the obvious thing to do is put together the evaluation maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">]</mo><mo>⊗</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">[A,B]\\otimes A \\to B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>D</mi><mo stretchy=\"false\">]</mo><mo>⊗</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">[C,D]\\otimes C \\to D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>, but it looks like to do that you have to permute <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>D</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[C,D]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">]</span></span></span></span> past <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>.</p>",
        "id": 440532965,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1716565190
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277285\">Martti Karvonen</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Binoidal.20categories.20and.20the.20principle.20of.20equivalence/near/440474772\">said</a>:</p>\n<blockquote>\n<p>Given that the funny tensor product doesn't extend to the 2-category Cat, I'd expect that some (at least the white tensor product) of these 5 tensor products fail to work for the 3-category of 2-categories (or perhaps issues come up already for 2-cells?). Is that the case?</p>\n</blockquote>\n<p>Yeah, I'm also a little confused about how it can be that the white tensor product exists but the funny tensor product isn't 2-functorial on Cat, but haven't gotten a chance to actually try to work it out yet.</p>",
        "id": 440558620,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1716575398
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"609515\">@Kevin Carlson</span> - When I said there's a white tensor product of 2-categories I didn't say this put a monoidal structure on the 2-category or 3-category 2Cat.   My guess is that it only puts a monoidal structure on the 1-category 2Cat, just like the funny tensor product of 1-categories only puts a monoidal structure on the 1-category Cat, not the 2-category.</p>",
        "id": 440560161,
        "sender_full_name": "John Baez",
        "timestamp": 1716576098
    },
    {
        "content": "<p>And just like the Gray tensor product is only on the 1-category 2Cat, as we just concluded.</p>",
        "id": 440560291,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1716576148
    },
    {
        "content": "<p>That breaks down already for the 2-category?   For some reason I didn't see anyone concluding that. </p>\n<p>Do you mean the \"iso Gray tensor product\" or the \"lax Gray tensor product\"?</p>",
        "id": 440560592,
        "sender_full_name": "John Baez",
        "timestamp": 1716576307
    },
    {
        "content": "<p>Unless I misunderstood, Tim Campion's counterexample in the MO link works at the level of the 2-category.  And he stated it only in the lax case, but I think it works in the iso case as well.</p>",
        "id": 440560820,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1716576407
    },
    {
        "content": "<p>Right, right, so as in Mike's Gray stuff, there's a closure on (the 1-category!) 2Cat whose exponential is the 2-category of 2-functors, <em>un</em>natural transformations, and modifications (where I guess a modification between unnatural transformations is just a family of 2-morphisms satisfying no axioms), and if we set White to be 2-Cat with the white product, then the white product is a White-enriched functor but not a 2-functor. Something like that. Thanks John!</p>",
        "id": 440564636,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1716578279
    },
    {
        "content": "<p>Right, because unlike Gray, White <em>is</em> symmetric.</p>",
        "id": 440564776,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1716578328
    },
    {
        "content": "<p>Luckily the white product is symmetric so that weird thing about the lax...yep!</p>",
        "id": 440564785,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1716578333
    },
    {
        "content": "<p>Pseudo-Gray is symmetric too, right, so that the pseudo-Gray product is a pseudo-Gray enriched functor?</p>",
        "id": 440564881,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1716578383
    },
    {
        "content": "<p>Yes.</p>",
        "id": 440564896,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1716578389
    },
    {
        "content": "<p>Thanks for clarifying things, Mike and Kevin.</p>\n<blockquote>\n<p>Right, right, so as in Mike's Gray stuff...</p>\n</blockquote>\n<p>Do you mean <a href=\"https://link.springer.com/book/10.1007/BFb0061280\">John Gray</a>? It would be great if there were three guys named Gray - Lax, Oplax and Pseudo - but I think there's just John.</p>",
        "id": 440568031,
        "sender_full_name": "John Baez",
        "timestamp": 1716579918
    },
    {
        "content": "<p>Haha, just meant the Gray-related comments Mike made, not crediting the Gray structure to Mike, pseudo-Mike, etc</p>",
        "id": 440568150,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1716579978
    },
    {
        "content": "<p>Oh wow, I misread that as \"Mike Gray's stuff\".  <span aria-label=\"anguished\" class=\"emoji emoji-1f627\" role=\"img\" title=\"anguished\">:anguished:</span></p>",
        "id": 440568509,
        "sender_full_name": "John Baez",
        "timestamp": 1716580182
    },
    {
        "content": "<p>I remember a discussion I had about this a while back. I was wondering if anyone had an answer to this...<br>\nLet's say nCat is the 1-category of n-categories and functors between them. What is the function f(n) that takes in n and outputs the number of tensor products on that category? For instance, f(1) = 2 (the funny and cartesian product), f(2) = 5 (the funny, cartesian, and the 3 Gray tensor products), etc. What is the general equation to calculate f(n) for a general n, and is this exponential, factorial, etc.? Or what is the OEIS sequence number?</p>",
        "id": 440586452,
        "sender_full_name": "John Onstead",
        "timestamp": 1716590203
    },
    {
        "content": "<p>Since there are infinitely many symmetric monoidal structures on 0Cat, we'll only get a fun game if we restrict to symmetric monoidal <em>closed</em> structures.  Then we get f(1) = 2 by a theorem of Foltz, Lair and Kenny, and it seems easy to show f(0) = 1 since such a tensor product distributes over colimits and every set is a coproduct of copies of the terminal set.  I don't really know that f(2) = 5, just that f(2) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≥</mo></mrow><annotation encoding=\"application/x-tex\">\\ge</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">≥</span></span></span></span> 5, but it should be possible to compute the actual answer.</p>",
        "id": 440589526,
        "sender_full_name": "John Baez",
        "timestamp": 1716592401
    }
]