[
    {
        "content": "<p>Category theory is an amazingly expressive theory that allows one to describe a vast array of mathematical objects in relation to one another. However, for all its wonders, there's one key flaw: in a category where the objects are sets with extra structure, there is only one canonical and appropriate notion of morphism, which is the one that precisely preserves that extra structure. This can cause typing issues if one wants to define morphisms between objects of different categories, leading to a loss of expressiveness and limitations on the maps one can define in CT relative to the kinds of maps you can define in traditional material set-based math. One key place this crops up is in vector spaces and topological vector spaces. The appropriate notion of map for these structures are linear maps, and this is unfortunate because this is an extremely limiting restriction and we often want to define nonlinear maps between these spaces. We can try to solve the problem with representability, where an appropriate map in one setting is in correspondence with a \"not allowed\" map in another, and by extension adjunctions and monads (such as what can be done with (co)differential categories). However these are not general solutions.</p>\n<p>So here I want to stop complaining about this problem and finally come up with a general solution to it. It comes in the form of double categories, specifically a type of double category known as a double category with companions AKA an F-category. An F-category is defined to be a category with two different types of morphism: loose and tight, where the tight morphisms are meant to be generalized by the loose morphisms. Examples of this in effect include the category of categories with strict functors as tight morphisms and pseudo/lax/oplax functors as loose morphisms, or the category of categories with normal functors as tight morphisms and profunctors as loose morphisms (the latter of which is the proarrow equipment of Cat).</p>",
        "id": 471384373,
        "sender_full_name": "John Onstead",
        "timestamp": 1726713606
    },
    {
        "content": "<p>Here's how I want to apply F-categories to the problem. Let's say you have a category C and forgetful functor U: C -&gt; D, and want to define a D-morphism between the underlying objects of C while still keeping track of the extra structure the objects in C have over those in D. For instance, defining a continuous function between topological vector spaces based on the forgetful functor U: TopVect -&gt; Top. In normal category theory, you can either work in C where you are limited to the morphisms found there, or you can work in D where you have more morphisms at your disposal, but you've lost the structure on the objects you wanted to maintain by \"forgetting\" it. But using F-categories, we can define an F-category where the objects and tight morphisms are just exactly those of C, and the loose morphisms are the morphisms between the underlying objects of C in D. Symbolically, HomTight(A, B) ~ HomC(A, B) and HomLoose(A, B) ~ HomD(U(A), U(B)). The good news is you can do this for any forgetful functor U. An F-category corresponds to a bijective on objects, faithful functor between a category of tight and loose morphisms. Given any faithful (\"forgetful\") functor U: C -&gt; D, you can use bo/ff factorization via the full image to get a bijective on objects and faithful functor C -&gt; Im(U), thus automatically defining the F-category we desire. </p>\n<p>With this F-category we can define for any faithful functor, we have the best of both worlds. We can define a non-structure preserving map between two objects without having to forget about the structure we've specified on them! It even works for non-structure preserving maps not generated by a forgetful functor, such as defining the F-category of sets, functions, and binary relations or partial functions. The latter, for instance, can allow us to define a partial map of sets A x A -&gt; A without having to use the coproduct, which is important since it allows for a much easier definition of partial monoids or partial groups that would not have worked otherwise (since the single category of partial maps between sets does not define products the correct way, at least not as far as I know). I see a lot of potential in this idea, and I'm surprised this isn't more widely discussed since it solves such a big problem with category theory. Anyways, this is the idea. Let me know what you think of it and if you have any comments!</p>",
        "id": 471384380,
        "sender_full_name": "John Onstead",
        "timestamp": 1726713612
    },
    {
        "content": "<p>This is nice, nothing wrong with it;  for myself, I see it as mostly a straightforward rephrasing of the notion of two categories with a forgetful functor between them. In fact <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> is the category of b.o. full embeddings and you’re seemingly describing an object of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> here, rather than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span>-enriched categories, which is what <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span>-category usually means. To make an enriched category out of the situation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">U:C\\to D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>, it would probably be more natural to consider a category enriched over the category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> whose objects are monomorphisms in Set (rather than Cat, as with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span>.) That is, you could give an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>-category such that the hom-object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X\\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is the monomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>D</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">C(X,Y)\\to D(X,Y).</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mord\">.</span></span></span></span></p>",
        "id": 471400846,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1726721768
    },
    {
        "content": "<p>With that said, you’re presuming a lot when you say this “solves such a big problem in category theory.” Specifically, you’re assuming this typing issue is a big problem, and that this solves it, and that there’s not already another solution.</p>",
        "id": 471400947,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1726721825
    },
    {
        "content": "<p>I don’t think either of the first two claims is true, and I can prove that the third one isn’t. For instance, the boff factorization you mention precisely allows you to construct a category whose objects are topological vector spaces and whose morphisms are continuous maps.</p>",
        "id": 471401061,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1726721884
    },
    {
        "content": "<p>But talking about the boff factorization is already a bit overly fancy here; the reason why I don’t agree that this is a big problem in category theory is that nobody’s ever been sitting around going “oh geez, I really wanted a continuous map between these topological vector spaces but I just can’t figure out how to put them in the right category!” On paper, this is easy to do, so it doesn’t worry people. It’s true that on the computer people have to make these things more explicit. But I don’t think there’s been any fundamental mystery about how to do so when you need to. Hope this doesn’t come across as coming down hard on your thoughts; it’s a cool idea, just explaining why it might not make anybody jump up and down.</p>",
        "id": 471401232,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1726721998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"609515\">Kevin Carlson</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Resolving.20CT's.20Typing.20Issues/near/471400846\">said</a>:</p>\n<blockquote>\n<p>it would probably be more natural to consider a category enriched over the category M whose objects are monomorphisms in Set (rather than Cat, as with F.) That is, you could give an M-category</p>\n</blockquote>\n<p>Ah thanks for the suggestion! I looked up M-category and it appeared to be exactly what I was talking about, they even mention on the nlab that you can get an M-category from any faithful functor just as I described! The M-category seems more natural to the 1-categorical setting, although an M-category does appear to be the same as an F-category when you view a 1-category as a 2-category where the 2-morphisms are all trivial (a locally discrete 2-category)!</p>\n<p><span class=\"user-mention silent\" data-user-id=\"609515\">Kevin Carlson</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Resolving.20CT's.20Typing.20Issues/near/471401232\">said</a>:</p>\n<blockquote>\n<p>But I don’t think there’s been any fundamental mystery about how to do so when you need to. Hope this doesn’t come across as coming down hard on your thoughts; it’s a cool idea, just explaining why it might not make anybody jump up and down.</p>\n</blockquote>\n<p>Thanks for the explanation! It makes sense; what might seem like a problem for someone might not be so much of a problem for someone else, depending on their philosophy. To illustrate, my philosophy of category theory fixates heavily on the structure preserving nature of morphisms, so while it is possible to define a category with a bijective correspondence of objects with C and with morphisms of D, those morphisms in D don't preserve the structure of objects of C. As such I find it difficult to accept an interpretation of the objects of the full image as being objects of C; rather, I see them as objects of D with the extra property that they can have the structure of objects in C equipped onto them. Another way to look at it is through the Yoneda perspective, which identifies an object with the surrounding environment of its category via all the morphisms into and out of it. If you change the morphisms in the category, then you are essentially also changing the nature of the objects described by that category under this kind of reasoning. Again this is just my personal philosophy but hopefully it gives insight into why I fixate so much on these typing issues!</p>",
        "id": 471403453,
        "sender_full_name": "John Onstead",
        "timestamp": 1726723181
    },
    {
        "content": "<p>I've been confused with and trying to understand something similar.</p>\n<p>I have an image of a sphere in my mind, and I could imagine messing with it with Euclidean transforms, or projective transforms, or continuous transforms, and what becomes isomorphic changes as we consider what the ambient setting of maps are.</p>\n<p>If I want to conclude something about a sphere in the category of topological spaces, and translate that to the category of Euclidean spaces, how to I keep my head on straight?</p>\n<p>I think there's a chain of faithful forgetful Functors between the categories</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mi>u</mi><mi>c</mi><mi>l</mi><mi>i</mi><mi>d</mi><mo>→</mo><mi>T</mi><mi>o</mi><mi>p</mi><mo>→</mo><mi>S</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">Euclid \\rightarrow Top \\rightarrow Set</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span></span></span></span></p>\n<p>And the idea is if a relationship is true in a category to the right, then we know it's true in a category to the left. Relationships are reflected.</p>\n<p>It's just weird to think of one conceptual object as existing in multiple categories.</p>",
        "id": 471406971,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1726725107
    },
    {
        "content": "<p>You've stumbled upon something very interesting about category theory, which is that categories are very contextual. You can think of a category as being a certain context in which we study an object, determined by which structure we are highlighting. Structure is basically some kind of information we can put on a set, and in many cases complex mathematical objects have a whole bunch of \"extra structure\" all defined on some underlying set. If we want to examine the object under the lens of one of its structures, and ignore the rest, we can switch to a context where that structure takes center stage, which is precisely the category where the morphisms are those that preserve that particular structure. The actual switching is aided by the forgetful functor, which forgets all the irrelevant structure so that the only structure left on our sets is the one we are interested in studying at that moment. Highly encourage you to visit the nlab page on <a href=\"https://ncatlab.org/nlab/show/stuff,+structure,+property\">stuff, structure, property</a> since seeing math in this philosophy is very mind opening!</p>",
        "id": 471407763,
        "sender_full_name": "John Onstead",
        "timestamp": 1726725531
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"673117\">John Onstead</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Resolving.20CT's.20Typing.20Issues/near/471403453\">said</a>:</p>\n<blockquote>\n<p>As such I find it difficult to accept an interpretation of the objects of the full image as being objects of C; rather, I see them as objects of D with the extra property that they can have the structure of objects in C equipped onto them.</p>\n</blockquote>\n<p>Most of what you say makes good sense to me, but one technical point: the middle guy in the boff factorization of a functor is not the full image, since of course the functor onto the full image is usually not bijective on objects. Instead its objects are really exactly the same as the original objects of the domain. (If you’re really “”evil””, you can define an <em>identity</em> on objects/<em>identity</em> on morphisms factorization!) (The full image comes from the essentially surjective/fully faithful factorization system, which is a 2-categorical thing in that these classes are only pseudo-orthogonal, or from the surjective on objects/injective on objects+fully faithful factorization system, which is a proper 1-categorical one.)</p>",
        "id": 471413988,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1726728225
    },
    {
        "content": "<p>It is true that the boff factorization produces categories whose morphisms are not nicely given as the structure-preserving morphisms of their objects, and that might be the glint of a where this thinking starts to bear clearer fruit. But that gets back to my second complaint, that I don’t see that your <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>-categories actually solve the problem in this sense. They might be a start at a solution, though; I think you’d want to explain what it means to have a “natural <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>-category” in the sense that its homs are somehow the “automatic” structure-preserving <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>-object of morphisms between its objects. Something like a tower of nested algebraic theories might be relevant here, or I suppose higher order theories to handle spaces.</p>",
        "id": 471414485,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1726728421
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277352\">Alex Kreitzberg</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Resolving.20CT's.20Typing.20Issues/near/471406971\">said</a>:</p>\n<blockquote>\n<p>It's just weird to think of one conceptual object as existing in multiple categories.</p>\n</blockquote>\n<p>One response to this is to say that when you have a picture of the sphere in your mind, it’s probably round, i.e. your picture includes the quantitative arrangement of its points relative to each other. It’s also smooth, eg you have no trouble identifying when a curve drawn on its surface is differentiable. So you’re picturing the sphere as an object of a category where there is shape and smoothness. The sphere is likely not a <em>specific</em> size, in which case you may be in, say, the category of Riemannian manifolds and conformal maps—your picture of the sphere is then essentially assembled from your idea of angles between curves drawn on its surface, such as latitude and longitude lines.</p>",
        "id": 471415483,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1726728803
    },
    {
        "content": "<p>It’s still quite interesting to observe that when you visualize a topological map of the sphere, you’re likely to visualize the round sphere deforming, say, getting a weird asymmetrical protuberance on one side. This is actually visualizing a homotopy between two continuous maps into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mn>3</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb R^3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span></span></span>, so something in quite a different category, but if you just look at the endpoints of the deformation then it can be viewed as visualizing a continuous map between the image of two Riemannian manifolds under the forgetful functor to topological spaces. This psychology is quite intriguing to think through and I think not many people do so very explicitly, although there are some famous examples of Bill Thurston that kind of ring a bell.</p>",
        "id": 471415879,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1726728941
    },
    {
        "content": "<p>Right, I suppose I thought to mention it here because it seems like my intuition travels between these different categories effortlessly.</p>\n<p>And I can't tell whether it's just applying functors automatically, or if it's picking the right category for the problem (like in your first example) or if key structures are getting thrased.</p>\n<p>This is interesting, but my intuition is running ahead of my understanding!</p>\n<p>I asked a non math friend what an interval mapped into a sphere looks like - and they immediately suggested a path on a sphere! They're clearly not thinking in Set and they don't know topology! </p>\n<p>If they have to parallel park, I'm sure they'll think in a Euclidean way.</p>\n<p>What does it look like when you think in both styles at the same time? What does this look like when you write stuff down?</p>\n<p>That's how I'm interpreting the difficult in the original post (but maybe they disagree with this interpretation)</p>",
        "id": 471419601,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1726730268
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"609515\">Kevin Carlson</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Resolving.20CT's.20Typing.20Issues/near/471413988\">said</a>:</p>\n<blockquote>\n<p>the middle guy in the boff factorization of a functor is not the full image, since of course the functor onto the full image is usually not bijective on objects</p>\n</blockquote>\n<p>Hmm, the <a href=\"https://ncatlab.org/nlab/show/full+image\">nlab page</a> says of full image that \"it is the object through which the (bo,ff) factorization of a functor factors\". Maybe there's different notions of \"full image\"?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"609515\">Kevin Carlson</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Resolving.20CT's.20Typing.20Issues/near/471414485\">said</a>:</p>\n<blockquote>\n<p>that I don’t see that your M-categories actually solve the problem in this sense. They might be a start at a solution, though; I think you’d want to explain what it means to have a “natural M-category” in the sense that its homs are somehow the “automatic” structure-preserving M-object of morphisms between its objects.</p>\n</blockquote>\n<p>In an M-category defined via the factorization of a faithful/forgetful functor U: C -&gt; D, the hom HomTight(-, -) is automatically defined to be the structure preserving morphisms of the objects of C simply because HomTight(-, -) ~ HomC(-, -). If you are wondering how we know the morphisms of C are the correct notion of structure preserving morphism for the objects of C in the first place, you can use something like model theory. In this case, find the theory that describes your mathematical object, find the functor category of model functors into Set, and see if there's an equivalence between that and C. If so, then indeed you have the \"correct\" notion of structure preserving map in C, and so by default the M-category will also have this.<br>\nThe goal of using the M-category is to have a concept of non structure preserving map between objects while still keeping track of the structure on those objects. In this way, the loose morphisms act as the non structure preserving map (like the morphisms in a \"full image\") while the tight morphisms are the structure preserving maps that are there to help us keep track of what the structure is. They kind of act like labels, constantly reminding us what the structure on our objects are, even as we zoom around along the non structure preserving maps.</p>",
        "id": 471442406,
        "sender_full_name": "John Onstead",
        "timestamp": 1726737273
    },
    {
        "content": "<p>Yes, the nLab's definition of \"full image\" is actually the category in the bo-ff factorization.  But there's another definition, which Kevin presumably has in mind, where the objects are a subset of the objects in the codomain.  However, the two definitions are equivalent categories (assuming the axiom of choice).</p>",
        "id": 471505948,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1726757994
    },
    {
        "content": "<p>I agree with Kevin that there is no <em>technical</em> problem here, and that you'll rub people the wrong way by claiming to be solving a \"key flaw\" in category theory.  But it's true that we do often change the names of categories and their objects whenever we change the <em>morphisms</em> even if at a technical level the set of objects didn't change.</p>\n<p>For instance, the opposite of the category of frames is called the category of locales, and the opposite of the category of commutative rings is called the category of affine schemes.  And more closely related to your examples, the category whose objects are metric spaces and whose morphisms are continuous maps is arguably better known as the category of <em>metrizable</em> spaces: since the morphisms are only continuous, they only preserve topology and not metric nature, so we should really think of the objects as only \"having\" topological structure with the <em>property</em> that it <em>could</em> have come from a metric.  Similarly, the category of topological vector spaces and continuous maps could be called the category of \"vectorizable topological spaces\".</p>",
        "id": 471513380,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1726760222
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"673117\">John Onstead</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Resolving.20CT's.20Typing.20Issues/near/471442406\">said</a>:</p>\n<blockquote>\n<p>Hmm, the <a href=\"https://ncatlab.org/nlab/show/full+image\">nlab page</a> says of full image that \"it is the object through which the (bo,ff) factorization of a functor factors\". Maybe there's different notions of \"full image\"?</p>\n</blockquote>\n<p>Ah, annoying; the nLab has a strong preference to work up to equivalence but I would prefer to have the full image be an actual subcategory, which the boff factorization is not. But whatever you call it, the point holds that its objects are by definition literally objects of the domain.</p>",
        "id": 471514616,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1726760597
    },
    {
        "content": "<p>Oh yeah, Mike has already said pretty much that.</p>",
        "id": 471514730,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1726760638
    },
    {
        "content": "<p>But it does seem to me like the difference between the category of metric spaces and continuous maps and the category of metrizable spaces, which is nothing more than making a bunch of isomorphic copies of each object for every choice of specific metric (and similarly for “vectorizable” spaces), while usually insignificant, is relevant to the kind of concerns you’re having here.</p>",
        "id": 471515173,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1726760755
    },
    {
        "content": "<p>One way to make that distinction more real is to work in homotopy type theory.  A category in HoTT has a <em>type</em> of objects plus <em>sets</em> (0-types) of morphisms.  The type of objects can rarely be supposed to also be a set, so its identity types are <em>a priori</em> additional data vis-a-vis categories defined in set theory.</p>\n<p>We get a theory that's closest to traditional category theory by requiring categories to be \"univalent\", meaning that for objects <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span>, the identity type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x=y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> is equivalent to the type of <em>isomorphisms</em> from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> (defined using the hom-sets) -- these are so important I usually prefer to call them simply \"categories\", and use \"precategory\" for the version without a condition on the identity type of the type of objects.</p>\n<p>(Univalent) categories are closed under most category-theoretic constructions, and in particular most \"naturally defined\" categories of structured objects are univalent.  But they're <em>not</em> closed under the obvious analogue of the bo-ff factorization.  So if you start from the univalent category of metric spaces with its forgetful functor to the univalent category of topological spaces and perform the bo-ff factorization, you'll get a (pre)category whose <em>type</em> of objects is the <em>type</em> of metric spaces, and hence whose identity types consist (up to equivalence) of <em>isometries</em>, but whose hom-sets consist of continuous maps.  This is <em>not</em> equivalent to the full subcategory of metrizable topological spaces.</p>",
        "id": 471518837,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1726761853
    },
    {
        "content": "<p>This is, of course, very similar to the M-category or double-category approach: a precategory whose types of objects are 1-types (which is always what you get from the bo-ff factorization applied to univalent categories) is, from a classical point of view, basically an M-category whose tight morphisms are all isomorphisms.</p>",
        "id": 471519096,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1726761940
    },
    {
        "content": "<p>Wait, to see if I understand, there's a sense where you can track that objects are the same shape under isometries - while emphasizing you care about continuous transformations between them? And that's different than a metrizable subcategory of Top?</p>",
        "id": 471522575,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1726763076
    },
    {
        "content": "<p>Mike's precategory of metric spaces and continuous maps has the property that an equality <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>=</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X=Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> between two metric spaces is exactly an <em>isometry</em> between them, while an isomorphism is a homeomorphism. Homotopy type theory frees up equality from the usually-irrelevant set-theoretic equality, so here (if you're OK with precategories) you can use equality for your stricter notion of isomorphism. It's worth noting that this precategory doesn't remember the non-invertible metric space maps; that would need directed type theory, which is an ongoing project but more bleeding edge.</p>",
        "id": 471524112,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1726763590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277352\">Alex Kreitzberg</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Resolving.20CT's.20Typing.20Issues/near/471406971\">said</a>:</p>\n<blockquote>\n<p>It's just weird to think of one conceptual object as existing in multiple categories.</p>\n</blockquote>\n<p>No, it's not weird.  This is how math works.  First, \"the sphere\" is <strong>NOT</strong> one conceptual object in any sort of precise sense.   There are many spheres:</p>\n<ul>\n<li>\n<p>There's the 'metric space sphere' where we can measure distances between points.  In fact there are at least 2 really important metric space spheres: one where we measure distances along the surface of there sphere, and one where we measure distances in the ambient <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mn>3</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span></span></span>.    This sphere has a 3-dimensional Lie group of symmetries.</p>\n</li>\n<li>\n<p>There's the 'topological space sphere' where we only equip the sphere with a topology, not a metric.  This sphere has a huge infinite-dimensional topological group of symmetries.</p>\n</li>\n<li>\n<p>There's the 'smooth manifold sphere' where we make the sphere into a manifold.  This sphere has a infinite-dimensional Frechet Lie group of symmetries, which is huge - but tiny compared to the symmetry group of the topological space sphere.</p>\n</li>\n<li>\n<p>There's the 'set sphere' where we treat the sphere as a set.  This has an even larger symmetry group, of cardinality greater than the continuum, consisting of all permutation of points on the sphere.</p>\n</li>\n<li>\n<p>There's the 'complex analytic sphere' where we treat the sphere as a complex analytic manifold of complex dimension 1.  This has a 6-dimensional real Lie group of symmetries (which is a 3-dimensional <em>complex</em> Lie group).</p>\n</li>\n</ul>\n<p>And so on: you need to separately learn theorems about each of these objects.</p>",
        "id": 471531829,
        "sender_full_name": "John Baez",
        "timestamp": 1726766258
    },
    {
        "content": "<p>As you guessed, all these different objects in different categories are related by <em>functors</em> between those different categories.</p>",
        "id": 471532047,
        "sender_full_name": "John Baez",
        "timestamp": 1726766351
    },
    {
        "content": "<p><strong>Math does not operate solely within one category at a time!</strong>  Except for very limited tasks, we need to be working with <em>a bunch</em> of categories , and functors between them, and natural transformations between those.  When we study 'the sphere' or 'the integers' or 'the real numbers', we are looking at not a single object, but <em>multiple</em> objects, in different categories, that are mapped to each other by functors.</p>\n<p>Most mathematicians do this naturally and almost unconsciously, saying things like \"the sphere has a 3d real Lie group of symmetries that preserve its metric, but a 3d complex Lie group of symmetries that preserve its complex structure\". </p>\n<p>One of the jobs of the category theorist is to formalize what's going on here - but not scold the mathematicians who do all this naturally.   That would be like scolding a dolphin for not having taken swimming lessons.</p>",
        "id": 471532529,
        "sender_full_name": "John Baez",
        "timestamp": 1726766545
    },
    {
        "content": "<p>And there's also a 'homotopy sphere' which we treat as an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">∞</span></span></span></span>-groupoid, which has an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">∞</span></span></span></span>-group of symmetries.</p>",
        "id": 471532797,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1726766651
    },
    {
        "content": "<p>Yes, that's a wonderful sphere.   We don't even know all the homotopy groups of this homotopy 2-sphere.  But here's a cool way to describe them.</p>\n<p>Let's say a braid is \"Brunnian\" if when you remove any one strand, the remaining braid becomes the identity: you can straighten out all the remaining strands to make them vertical. It's a fun little exercise to check that Brunnian braids form a subgroup of all braids. So, we have an n-strand Brunnian braid group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><msub><mi>B</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">BB_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.   </p>\n<p>A braid is a bunch of points moving around on a plane as time goes by.  We can also define 'spherical braids' where they move around on a sphere.  And we can define spherical Brunnian braids.  Let's call the group of n-strand spherical Brunnian braids <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><msub><mi>B</mi><mi>n</mi></msub><mo stretchy=\"false\">(</mo><msup><mi>S</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">BB_n(S^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>.</p>\n<p>There's an obvious map</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>B</mi><msub><mi>B</mi><mi>n</mi></msub><mo>→</mo><mi>B</mi><msub><mi>B</mi><mi>n</mi></msub><mo stretchy=\"false\">(</mo><msup><mi>S</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> f: BB_n \\to BB_n(S^2) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<p>coming from the inclusion of the plane in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>S</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">S^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> (the sphere is the plane plus a point at infinity).</p>\n<p>And then we have</p>\n<p><strong>Theorem.</strong>  The nth homotopy group of the sphere, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>π</mi><mi>n</mi></msub><mo stretchy=\"false\">(</mo><msup><mi>S</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\pi_n(S^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, is isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><msub><mi>B</mi><mi>n</mi></msub><mo stretchy=\"false\">(</mo><msup><mi>S</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mrow><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">m</mi></mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">BB_n(S^2)/ \\mathrm{im}(f)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathrm\">im</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 471534726,
        "sender_full_name": "John Baez",
        "timestamp": 1726767485
    },
    {
        "content": "<p>This was proved here:</p>\n<ul>\n<li>Jie Wu, <a href=\"https://www.researchgate.net/publication/228917097_Combinatorial_descriptions_of_homotopy_groups_of_certain_spaces\">On combinatorial descriptions of the homotopy groups of certain spaces</a>, <em>Math. Proc. Camb. Phil. Soc.</em> 130 (2001), 489-513.</li>\n</ul>",
        "id": 471534863,
        "sender_full_name": "John Baez",
        "timestamp": 1726767560
    },
    {
        "content": "<p>This is one of the most shocking facts I know.</p>",
        "id": 471535223,
        "sender_full_name": "John Baez",
        "timestamp": 1726767697
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Resolving.20CT's.20Typing.20Issues/near/471518837\">said</a>:</p>\n<blockquote>\n<p>One way to make that distinction more real is to work in homotopy type theory. A category in HoTT has a <em>type</em> of objects plus <em>sets</em> (0-types) of morphisms. The type of objects can rarely be supposed to also be a set, so its identity types are <em>a priori</em> additional data vis-a-vis categories defined in set theory.<br>\nSo if you start from the univalent category of metric spaces with its forgetful functor to the univalent category of topological spaces and perform the bo-ff factorization, you'll get a (pre)category whose <em>type</em> of objects is the <em>type</em> of metric spaces, and hence whose identity types consist (up to equivalence) of <em>isometries</em>, but whose hom-sets consist of continuous maps. This is <em>not</em> equivalent to the full subcategory of metrizable topological spaces.</p>\n</blockquote>\n<p>This is a very interesting construction and I think it's also a really good way to do what I wanted. I'm a little surprised that, when trying to think about ways of keeping track of types in category theory, I didn't use, well, types and type theory! But this approach makes sense to me- the typing on the objects of a category tell you how to interpret those objects in a purely mathematical way, no external interpretation needed. So even when you do switch up the morphisms (like moving to the full image under a faithful functor), the \"tag\" is still there to tell you what the objects of your category are supposed to be! It also seems to be more efficient than using all the structure preserving maps as the \"tag\" instead, although as pointed out later, it might be a challenge to \"mix\" structure preserving and non structure preserving maps in a type theory category like you can do in an M-category.</p>\n<p>Though I do have some lingering questions about this. I don't know much about type theory, so I'm not sure if the \"tag\" a type gives to a collection of objects is just a purely declarative syntactic statement or if it can encode deeper meaning. That is, if it's either just a way to say \"Hey! These objects have a vector space structure\", but then leave exactly what a \"vector space structure\" is to the imaginations of the mathematicians, or if it's possible to associate the actual construction or axioms of a vector space structure with that particular type. My second question would be: what is the difference between a precategory or univalent category, and a category internal to a category of types?</p>",
        "id": 471547847,
        "sender_full_name": "John Onstead",
        "timestamp": 1726772872
    },
    {
        "content": "<p>Well, each type in type theory has a definition.  So \"the type of vector spaces\" is a type whose elements are sets along with addition, scalar multiplication, etc.  In that sense the type is associated to the definition of a vector space.</p>\n<p>However, if I work with an <em>arbitrary</em> (pre)category, then its type of objects is just a type.  It just has elements and equalities between them (and equalities between those, etc.), it doesn't have any other general notion of \"structure\" on its elements that would specialize in particular cases to, say \"the structure of a vector space\".</p>\n<p>This is the same as set theory, by the way: any <em>particular</em> set has particular elements that may be structured, but an <em>abstract</em> set just has elements without knowing anything about them.</p>",
        "id": 471550145,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1726773874
    },
    {
        "content": "<p>As for your second question, a precategory is very much like a category internal to the category of types.  In HoTT there isn't a 1-category of all types, but there is at least morally an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-category of them, and a precategory is basically the same as an internal category in that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-category whose hom-types are sets.  (And under that restriction, you can define it without needing to refer to the entire <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-category, which is a good thing since we don't know how to do that in vanilla HoTT.)  The definition of precategory is formulated with hom-types dependent on the object type rather than in the usual internal-category style, but they're equivalent.</p>",
        "id": 471550546,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1726774023
    },
    {
        "content": "<p>I now want to expand on this subject a bit. With either the M-category or type theory idea, for forgetful functor U: C -&gt; D you can define a D-map between two C-objects, but what if you want to define a D-map from a D object into a C object, or from a C object into a D object? It seems you need to do this a lot as well sometimes (such as if, for instance, you wanted to define a continuous map from a topological space into a topological vector space to see whether or not it is differentiable or smooth). The M-category approach I gave above will not suffice, and neither will the type theory approach (since all objects in such a category will of course need to be of the same type). I've come up with the following idea but I don't know exactly what it is or if it has been discovered before.</p>\n<p>First, we need to define a category with both the objects of D and the full image of U, and I'll call it UD. We could do a disjoint union, but I want it so that HomUD(a, b) ~ HomD(F(a), b) for a in Im(U), b in D, and F: Im(U) -&gt; D the fully faithful functor part of the bo/ff factorization. I guess it's like a disjoint union, but you are then freely adding isomorphisms between a and F(a) for all a in Im(U). I'm going to just assume there's a canonical projection (perhaps associated to the universal property defining UD if it exists) C -&gt; UD which sends C into the Im(U) part of UD in exactly the same way as the bijective on objects functor from the bo/ff factorization. But this time the functor is no longer bijective on objects, so we have to fix that to get this into being an M category again.</p>",
        "id": 471579912,
        "sender_full_name": "John Onstead",
        "timestamp": 1726789920
    },
    {
        "content": "<p>We can do this by freely adding the rest of the objects of D to C, which takes the form of a disjoint union C u Disc(D), where Disc(D) is the category D when we remove all non-identity morphisms. We get the canonical projection C -&gt; C u Disc(D). We can then define a bijective on objects and faithful functor C u Disc(D) -&gt; UD that maps C into the Im(U) part of UD (just as the original bijective on objects functor C -&gt; Im(U) ) when composed with the projection C -&gt; C u Disc(D), and that maps all the other objects floating around in C u Disc(D) to some object of D in a one to one way. The end result is an M-category where the objects are both the objects of C and D, the tight morphisms are all the ones in C, and the loose morphisms are all the ones in D. You can now define a D-morphism between a D-object d and a C-object c, and even D-morphisms between the underlying object U(c) of c in C and c itself (of which will include a D-isomorphism). </p>\n<p>Have you ever encountered such a construction as UD and the functor C u Disc(D) -&gt; UD before? Let me know!</p>",
        "id": 471580083,
        "sender_full_name": "John Onstead",
        "timestamp": 1726790040
    },
    {
        "content": "<p>I didn't follow your definition entirely, but it looks a lot like the <a href=\"https://ncatlab.org/nlab/show/cograph%20of%20a%20functor\">[[cograph of a functor]]</a>.</p>",
        "id": 471584990,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1726793630
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Resolving.20CT's.20Typing.20Issues/near/471584990\">said</a>:</p>\n<blockquote>\n<p>I didn't follow your definition entirely, but it looks a lot like the <a href=\"https://ncatlab.org/nlab/show/cograph%20of%20a%20functor\">[[cograph of a functor]]</a>.</p>\n</blockquote>\n<p>The cograph looks almost like what I'm trying, it's just missing morphisms going the other way. Hom(x, y) in the cograph of a functor F, for x in the domain and y in the codomain category of F, is bijective with Hom(F(x), y) in the codomain of F, which indeed is what I'm looking for. However, there is an empty hom set going the opposite way, whereas in my construction Hom(y, x) in the construction would also be bijective with Hom(y, F(x)) in the codomain. This would allow D-morphisms both into and out of objects of C. So it seems related, it could be some sort of a localization of the cograph.</p>",
        "id": 471587631,
        "sender_full_name": "John Onstead",
        "timestamp": 1726795616
    },
    {
        "content": "<p>And the morphisms in your category between two objects in the domain <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">F:C\\to D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> are the morphisms between their images in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>?</p>",
        "id": 471588268,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1726796164
    },
    {
        "content": "<p>If so, then what you have is the \"categorical mapping cylinder\".  I don't think it has an nLab page, but it is a (cofibration, trivial fibration) factorization in the <a href=\"https://ncatlab.org/nlab/show/canonical%20model%20structure%20on%20Cat\">[[canonical model structure on Cat]]</a>.  Classically, it's equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>, but I guess its precategory version in HoTT isn't.</p>",
        "id": 471588417,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1726796288
    },
    {
        "content": "<p>This seems right, but I really do wish that a full definition was written down so I could confirm! I couldn't find any resources on it though, only resources talking about the topological or homotopical mapping cylinder.</p>\n<p>The construct would be equivalent to D since while we are adding in extra objects to D (all the objects of C), we are setting an isomorphism from each of them into an object in D. Though this really does bring up a whole other side to this discussion of typing in category theory when it comes to how to interpret equivalence of categories. Essentially, if two categories are equivalent, does that mean the objects of those categories are the same as well? I've seen cases where the objects are treated as \"the same\", for instance if you have multiple ways of defining the same mathematical object, you can check they do define the same object if the category of models of the theories for each way of defining it are equivalent. This might be called a \"Morita equivalence\" or something like that but I may be misremembering. Of course, we are meant to interpret the objects as \"the same\" via the principle of equivalence. <br>\nHowever, sometimes we are asked to treat two sides of an equivalence as a duality rather then direct equality. So the objects are meant to be interpreted as being different, just that there's some operation we can do to switch back and forth between them. In fact, many interesting connections between branches of math (such as what was recently proven with the geometric Langlands conjecture) involve proving an equivalence of categories, but obviously the objects in both categories are meant to be different or else the equivalence would be so obvious it wouldn't need to be proven in the first place! Since M-categories might not help here, I'm guessing distinguishing between equivalences for same and not same objects would require the type theory interpretation, where the type categories can be non-equivalent even when their \"underlying\" normal categories are.</p>",
        "id": 471604384,
        "sender_full_name": "John Onstead",
        "timestamp": 1726804398
    },
    {
        "content": "<p>There's an explicit definition on p4 of Rezk's note <a href=\"https://ncatlab.org/nlab/files/Rezk_ModelCategoryForCategories.pdf\">A model category for categories</a>.</p>",
        "id": 471606693,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1726805261
    },
    {
        "content": "<blockquote>\n<p>if two categories are equivalent, does that mean the objects of those categories are the same as well?</p>\n</blockquote>\n<p>They're not identical: if I have an object of one category, it isn't itself an object of the other category, although it corresponds to one under the equivalence.  When treating equivalent categories as \"the same\", we likewise treat each object as \"the same\" as its correspondent(s) on the other side, but formally speaking there is a \"transport\" involved replacing one by the other.</p>",
        "id": 471607300,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1726805469
    },
    {
        "content": "<p>In classical set-theoretic foundations, there's no sense in which the sets of objects of two equivalent categories are \"the same\" other than the sense expressed by the equivalence of categories itself.  In particular, the two sets of objects could even have different cardinalities.</p>",
        "id": 471607473,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1726805546
    },
    {
        "content": "<p>But in HoTT, when two <em>univalent</em> categories are equivalent, then their types of objects are equivalent as types.</p>",
        "id": 471607877,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1726805713
    },
    {
        "content": "<p>However, they're not definitionally equal: you still have to apply the equivalence to get from an object of one category to an object of the other one.</p>",
        "id": 471607969,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1726805756
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229136-theory.3A-category-theory/topic/Resolving.20CT's.20Typing.20Issues/near/471606693\">said</a>:</p>\n<blockquote>\n<p>There's an explicit definition on p4 of Rezk's note <a href=\"https://ncatlab.org/nlab/files/Rezk_ModelCategoryForCategories.pdf\">A model category for categories</a>.</p>\n</blockquote>\n<p>Thanks, this turned out to be exactly what I was looking for. It seems from that article that this is constructed by a pushout in Cat that \"looks like\" the pushout in Top that generates the mapping cylinder there, which gives me the universal property I wanted as well!</p>",
        "id": 471746713,
        "sender_full_name": "John Onstead",
        "timestamp": 1726842540
    }
]