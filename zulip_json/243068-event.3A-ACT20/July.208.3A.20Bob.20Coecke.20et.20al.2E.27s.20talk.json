[
    {
        "content": "<p>Hello all! This is the thread of discussion for the talk of Giovanni de Felice, Alexis Toumi and Bob Coecke, \"DisCoPy: Monoidal Categories in Python\".<br>\nDate and time: Wednesday July 8, 11:40 UTC.<br>\nZoom meeting: <a href=\"https://mit.zoom.us/j/7055345747\">https://mit.zoom.us/j/7055345747</a><br>\nYouTube live stream: <a href=\"https://www.youtube.com/watch?v=AaaoUxUx-SQ&amp;list=PLCOXjXDLt3pZDHGYOIqtg1m1lLOURjl1Q\">https://www.youtube.com/watch?v=AaaoUxUx-SQ&amp;list=PLCOXjXDLt3pZDHGYOIqtg1m1lLOURjl1Q</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"AaaoUxUx-SQ\" href=\"https://www.youtube.com/watch?v=AaaoUxUx-SQ&amp;list=PLCOXjXDLt3pZDHGYOIqtg1m1lLOURjl1Q\"><img src=\"https://i.ytimg.com/vi/AaaoUxUx-SQ/default.jpg\"></a></div>",
        "id": 202643821,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1593655921
    },
    {
        "content": "<p>10 minutes!</p>",
        "id": 203256549,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1594207822
    },
    {
        "content": "<p>Here are my slides for the talk! <a href=\"/user_uploads/21317/pMNDA9lwKWQEAbL0RNjj2vRv/presentation.pdf\">presentation.pdf</a></p>",
        "id": 203259490,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594210066
    },
    {
        "content": "<p>Also a link to the github repo for DisCoPy: <a href=\"https://github.com/oxford-quantum-group/discopy\">https://github.com/oxford-quantum-group/discopy</a></p>",
        "id": 203259552,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594210087
    },
    {
        "content": "<p>Fun stuff! I suppose there's plenty of work in hand-drawn circuit recognition?  It would be helpful I suppose to ask people to stick close enough to a drawing convention, albeit at a cost of creativity :)</p>",
        "id": 203259606,
        "sender_full_name": "Filip Buric",
        "timestamp": 1594210153
    },
    {
        "content": "<p>There seems to be some papers on circuit recognition for the particular case of electric circuits, but I'm sure no-one has tried doing it with arbitrary monoidal categories yet! As for drawing convention, one can hope that with sufficient training data, a machine learning algorithm would be able to adapt to different conventions.</p>",
        "id": 203260759,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594211084
    },
    {
        "content": "<p>Here is a link to the reference for normal forms of string diagrams: <a href=\"https://arxiv.org/abs/1804.07832\">https://arxiv.org/abs/1804.07832</a></p>",
        "id": 203261397,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594211580
    },
    {
        "content": "<p>Cool! Sure, but it's also a question of finding the appropriate architecture, hyperparameter space and search procedure etc. More data doesn't always help. One can get quite robust recognition of shapes, but there will of course be  limits and edge cases. Even for hand-drawn digits the performance is &lt;100% (mostly due to human ambiguity I believe). But maybe it's easier with diagrams. I was just thinking of edge case like e.g. where nodes are drawn as large circles and they would be recognized as small loops. Still, seems doable :)</p>",
        "id": 203261405,
        "sender_full_name": "Filip Buric",
        "timestamp": 1594211586
    },
    {
        "content": "<p>Yep, for sure more data isn't gonna solve everything, but a minimum of training data should be enough to recognise different lighting conditions, hand writings, etc.</p>",
        "id": 203261586,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594211704
    },
    {
        "content": "<p>Thanks for the ref! I sometimes work with biochemical networks graphically so this looks quite interesting!</p>",
        "id": 203261627,
        "sender_full_name": "Filip Buric",
        "timestamp": 1594211740
    },
    {
        "content": "<p>Oh absolutely, yes.</p>",
        "id": 203261636,
        "sender_full_name": "Filip Buric",
        "timestamp": 1594211746
    },
    {
        "content": "<p>I'll put this here, because it might have gotten lost in Zoom: <span class=\"user-mention\" data-user-id=\"294964\">@Alexis Toumi</span> <span class=\"user-mention\" data-user-id=\"294989\">@Giovanni de Felice</span> Did you guys play with hooking this up to pyzx already? It would be nice, especially for ZX-calculus tutorials to have monoidal-category type notation for creating ZX-diagrams from generators . Currently, there is only QASM and friends, as well as a sortof hack called SQASM (spider-QASM) which does some automatic post-selection + spider fusion.</p>",
        "id": 203261690,
        "sender_full_name": "Aleks Kissinger",
        "timestamp": 1594211775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"279226\">Filip Buric</span> <a href=\"#narrow/stream/243068-ACT-2020/topic/July.208.3A.20Bob.20Coecke.20et.20al.2E's.20talk/near/203261405\">said</a>:</p>\n<blockquote>\n<p>Cool! Sure, but it's also a question of finding the appropriate architecture, hyperparameter space and search procedure etc. More data doesn't always help. One can get quite robust recognition of shapes, but there will of course be  limits and edge cases. Even for hand-drawn digits the performance is &lt;100% (mostly due to human ambiguity I believe). But maybe it's easier with diagrams. I was just thinking of edge case like e.g. where nodes are drawn as large circles and they would be recognized as small loops. Still, seems doable :)</p>\n</blockquote>\n<p>I think monoidal categories and Joyal-Street's work on the geometry of tensor calculus (<a href=\"http://www.math.mq.edu.au/~street/PlanarDiags.pdf\">http://www.math.mq.edu.au/~street/PlanarDiags.pdf</a>) should help tremendously for designing the architecture of a diagram recognition machine.</p>",
        "id": 203261775,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594211857
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"295673\">@Aleks Kissinger</span> for now, you can get from DisCoPy diagrams to PyZX by going through pytket, but it works for circuits only, not for arbitrary ZX diagrams</p>",
        "id": 203261912,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594211927
    },
    {
        "content": "<p>I remember we started working on a direct translation, but we had a hard time figuring out what were the input and output types for ZX diagrams</p>",
        "id": 203261994,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594211993
    },
    {
        "content": "<p>also, it would be a lot better if we kept track of planar positions for the diagrams, so that a tensor product would actually look like the two diagrams side by side</p>",
        "id": 203262075,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594212043
    },
    {
        "content": "<p>the main type in PyZX is just an undirected graph with a bit of extra data. The extra data consists of: typing (Z, X, H, boundary), phases, lists of boundary-typed nodes that should be treated as inputs and outputs, and numbers \"row\" and \"qubit\" assigned to each node. The last piece of data pretty much only effects drawing (with a couple of exceptions), so for most purposes, you can read \"row\" and \"qubit\" as \"X coordinate\" and \"Y coordinate\".</p>",
        "id": 203264712,
        "sender_full_name": "Aleks Kissinger",
        "timestamp": 1594213739
    },
    {
        "content": "<p>I have a question, I think this was sort of implicit in the talk. You talked about defining a diagram by specifying it as a term in the language of monoidal categories (which in my experience gets quite painful very quickly), and then by inference from the diagram. What about things in between? For a specific example, take the DSL from my talk. There is a compiler that turns that code into the language of monoidal categories (specifically by foliation, so each line of code turns into a slice of the diagram containing one nontrivial node plus a lot of plumbing). I imagine this would be quite easy to build on top of your libraries, is that right?</p>",
        "id": 203270926,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1594217037
    },
    {
        "content": "<p>Here's the video!<br>\n<a href=\"https://www.youtube.com/watch?v=kPar2nQVFnY&amp;list=PLCOXjXDLt3pYot9VNdLlZqGajHyZUywdI\">https://www.youtube.com/watch?v=kPar2nQVFnY&amp;list=PLCOXjXDLt3pYot9VNdLlZqGajHyZUywdI</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"kPar2nQVFnY\" href=\"https://www.youtube.com/watch?v=kPar2nQVFnY&amp;list=PLCOXjXDLt3pYot9VNdLlZqGajHyZUywdI\"><img src=\"https://i.ytimg.com/vi/kPar2nQVFnY/default.jpg\"></a></div>",
        "id": 203287699,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1594224694
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"275901\">@Jules Hedges</span>  Indeed writing down terms in the language of monoidal categories by hand does get very painful very quick! As you mention, we use the diagram data structure for discopy (pre-monoidal diagrams with one node per layer) as a kind of low-level language that we compile into. It would be very easy to write a higher-level DSL that then compiles down to diagram, to some extent this is what a pregroup grammar really is.</p>",
        "id": 203369201,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594289059
    },
    {
        "content": "<p>Also I should mention that in order to define a category in discopy it is enough to subclass Box and override the methods for identity, composition and tensor. So for instance these could output the haskell code for composition and tensor of open games. Then given any Diagram instance (seen syntactically, i.e. a morphism in the free monoidal category) you can define a functor and you get for any diagram the corresponding open game written in haskell. <br>\nHere's an example defining monoids as a subclass of Box: <a href=\"https://github.com/oxford-quantum-group/discopy/blob/master/notebooks/monoid-delooping.ipynb\">https://github.com/oxford-quantum-group/discopy/blob/master/notebooks/monoid-delooping.ipynb</a></p>",
        "id": 203372774,
        "sender_full_name": "Giovanni de Felice",
        "timestamp": 1594292437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"294964\">Alexis Toumi</span> <a href=\"#narrow/stream/243068-ACT-2020/topic/July.208.3A.20Bob.20Coecke.20et.20al.2E's.20talk/near/203369201\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"275901\">Jules Hedges</span>  Indeed writing down terms in the language of monoidal categories by hand does get very painful very quick! As you mention, we use the diagram data structure for discopy (pre-monoidal diagrams with one node per layer) as a kind of low-level language that we compile into. It would be very easy to write a higher-level DSL that then compiles down to diagram, to some extent this is what a pregroup grammar really is.</p>\n</blockquote>\n<p>Does Python support this kind of metaprogramming nicely, embedding a DSL with its own syntax? (This is part of me trying to understand the benefits of DisCoPy vs Catlab)</p>",
        "id": 203373217,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1594292850
    },
    {
        "content": "<p>Python does not support meta programming</p>",
        "id": 203374275,
        "sender_full_name": "James Fairbanks",
        "timestamp": 1594293832
    },
    {
        "content": "<p>Of course you could put the DSL code in a string literal and then parse it by hand.</p>",
        "id": 203374468,
        "sender_full_name": "James Fairbanks",
        "timestamp": 1594293973
    },
    {
        "content": "<p>Python doesn't have the kind of meta programming that Julia implements, but in practice you can get similar results using higher-order constructions like decorators. A beautiful example is automatic differentiation and just-in-time compilation with jax <a href=\"https://github.com/google/jax\">https://github.com/google/jax</a></p>",
        "id": 203376367,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594295647
    },
    {
        "content": "<p>So for example you could implement something similar to Catlab's natural syntax for cartesian morphisms with a decorator, so that it takes a python-defined function and compiles it down to a DisCoPy diagram. We haven't done that yet because we mainly focused on non-cartesian settings like quantum and linguistics for now.</p>",
        "id": 203376608,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594295834
    },
    {
        "content": "<p>I don’t think that reflects an accurate understanding of how macros work. Jules, I’m happy to work with you and Toby on how to get open games into Catlab.</p>",
        "id": 203377890,
        "sender_full_name": "James Fairbanks",
        "timestamp": 1594296801
    },
    {
        "content": "<p>Thanks both! This is helpful</p>",
        "id": 203377999,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1594296866
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275927\">James Fairbanks</span> <a href=\"#narrow/stream/243068-ACT-2020/topic/July.208.3A.20Bob.20Coecke.20et.20al.2E's.20talk/near/203377890\">said</a>:</p>\n<blockquote>\n<p>I don’t think that reflects an accurate understanding of how macros work.</p>\n</blockquote>\n<p><a href=\"https://www.youtube.com/watch?v=pWdd6_ZxX8c\">https://www.youtube.com/watch?v=pWdd6_ZxX8c</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"pWdd6_ZxX8c\" href=\"https://www.youtube.com/watch?v=pWdd6_ZxX8c\"><img src=\"https://i.ytimg.com/vi/pWdd6_ZxX8c/default.jpg\"></a></div>",
        "id": 203380246,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594298574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275927\">James Fairbanks</span> <a href=\"#narrow/stream/243068-ACT-2020/topic/July.208.3A.20Bob.20Coecke.20et.20al.2E's.20talk/near/203377890\">said</a>:</p>\n<blockquote>\n<p>I don’t think that reflects an accurate understanding of how macros work. Jules, I’m happy to work with you and Toby on how to get open games into Catlab.</p>\n</blockquote>\n<p>Open secret: in a past life, I wrote Python bindings for a GPGPU linear algebra library... <a href=\"http://viennacl.sourceforge.net/pyviennacl/doc/\">http://viennacl.sourceforge.net/pyviennacl/doc/</a></p>",
        "id": 203380989,
        "sender_full_name": "Toby Smithe",
        "timestamp": 1594299017
    }
]