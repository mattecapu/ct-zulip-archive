[
    {
        "content": "<p>Hi all! This is the thread of discussion for Fabrizio's tutorial, \"An introduction to string diagrams.\"</p>",
        "id": 201018918,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1592316008
    },
    {
        "content": "<p>Abstract:<br>\nWe will introduce the basic concepts of surface diagrams for 1-, 2- and n- categories. From there, we will introduce string diagrams for various flavors of monoidal categories (monoidal, compact closed, traced, ...). There are no prerequisites.</p>",
        "id": 201018953,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1592316021
    },
    {
        "content": "<p>still, a pre-talk reading would be useful. thanks in advance.</p>",
        "id": 202318655,
        "sender_full_name": "eric brunner",
        "timestamp": 1593441433
    },
    {
        "content": "<p>When and where: Sunday July 5, 15:00 UTC (11 am EDT)<br>\nZoom meeting: <a href=\"https://mit.zoom.us/j/7055345747\">https://mit.zoom.us/j/7055345747</a><br>\nSee also <a href=\"https://act2020.mit.edu/#tutorialday\">the main website</a>.</p>",
        "id": 202645330,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1593658006
    },
    {
        "content": "<p>We start in 5 min!</p>",
        "id": 202924785,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1593960931
    },
    {
        "content": "<p>Here are the links given by Fabrizio.<br>\nMarsden: Category Theory using string diagrams <a href=\"https://arxiv.org/abs/1401.7220\">https://arxiv.org/abs/1401.7220</a><br>\nSelinger: A survey of graphical languages for mon cat <a href=\"https://arxiv.org/abs/0908.3347\">https://arxiv.org/abs/0908.3347</a></p>",
        "id": 202925354,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1593961809
    },
    {
        "content": "<p>He also mentioned this paper by Joyal and Street, where they essentially prove that using string diagrams is valid.<br>\n<a href=\"https://www.sciencedirect.com/science/article/pii/000187089190003P\">https://www.sciencedirect.com/science/article/pii/000187089190003P</a></p>",
        "id": 202925391,
        "sender_full_name": "Joe Moeller",
        "timestamp": 1593961914
    },
    {
        "content": "<p>How does one draw a parallel pair <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⇉</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\rightrightarrows B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.86413em;vertical-align:-0.1808em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⇉</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> (no 2-morphisms between them) with this graphical representation of 2-categories?</p>",
        "id": 202926072,
        "sender_full_name": "Daniel Plácido",
        "timestamp": 1593963044
    },
    {
        "content": "<p>Let's ask this question at the end :)</p>",
        "id": 202926085,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1593963116
    },
    {
        "content": "<p>A single string diagram only depicts a single morphism. What I mean is that you can have many morphisms depicted, but they must be composed somehow to get it all down to a single (composite) morphism.</p>",
        "id": 202926141,
        "sender_full_name": "Joe Moeller",
        "timestamp": 1593963170
    },
    {
        "content": "<p>So if you want two different morphisms, but you don't want to talk about composing them, you just have to draw two different diagrams.</p>",
        "id": 202926148,
        "sender_full_name": "Joe Moeller",
        "timestamp": 1593963193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275989\">Paolo Perrone</span> <a href=\"#narrow/stream/243068-ACT-2020/topic/Tutorial.3A.20String.20Diagrams.20(Fabrizio.20Genovese)/near/202926085\">said</a>:</p>\n<blockquote>\n<p>Let's ask this question at the end :)</p>\n</blockquote>\n<p>Ok, thanks! I wrote it here because the Zoom chat is flowing too fast. I'll save my questions for later.</p>",
        "id": 202926156,
        "sender_full_name": "Daniel Plácido",
        "timestamp": 1593963234
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275914\">Joe Moeller</span> <a href=\"#narrow/stream/243068-ACT-2020/topic/Tutorial.3A.20String.20Diagrams.20(Fabrizio.20Genovese)/near/202926148\">said</a>:</p>\n<blockquote>\n<p>So if you want two different morphisms, but you don't want to talk about composing them, you just have to draw two different diagrams.</p>\n</blockquote>\n<p>That makes sense. Thanks.</p>",
        "id": 202926202,
        "sender_full_name": "Daniel Plácido",
        "timestamp": 1593963261
    },
    {
        "content": "<p>Someone took notes here, that also includes a bunch of links: <a href=\"https://codi.lassul.us/HqlF3K2CR0eYcpUbiOnneA\">https://codi.lassul.us/HqlF3K2CR0eYcpUbiOnneA</a></p>",
        "id": 202928120,
        "sender_full_name": "Kartik",
        "timestamp": 1593966562
    },
    {
        "content": "<p>I'm still around if there are more questions btw <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 202928970,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1593967953
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276438\">@Fabrizio Genovese</span> , from the different 'extensions' of SMC (braided, traced, etc) where does Petri Nets fall?</p>",
        "id": 202929311,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1593968478
    },
    {
        "content": "<p>Heh! It turns out that Petri nets can be thought of as presentations of monoidal categories</p>",
        "id": 202929377,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1593968541
    },
    {
        "content": "<p>There are many different flavors of petri nets and many different flavors of monoidal categories, but roughly:</p>",
        "id": 202929391,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1593968569
    },
    {
        "content": "<p>Petri nets can be linked to commutative and symmetric monoidal categories, depending who you ask to. Relevan papers are: <br>\n<a href=\"https://arxiv.org/abs/1808.05415\">https://arxiv.org/abs/1808.05415</a><br>\n<a href=\"https://link.springer.com/chapter/10.1007/3-540-59293-8_205\">https://link.springer.com/chapter/10.1007/3-540-59293-8_205</a></p>",
        "id": 202929458,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1593968647
    },
    {
        "content": "<p>Then there are generalizations, such as:<br>\n<a href=\"https://arxiv.org/abs/1805.05988\">https://arxiv.org/abs/1805.05988</a><br>\n<a href=\"https://www.researchgate.net/publication/221138189_Pre-nets_Read_Arcs_and_Unfolding_A_Functorial_Presentation/link/09e41511e079fab475000000/download\">https://www.researchgate.net/publication/221138189_Pre-nets_Read_Arcs_and_Unfolding_A_Functorial_Presentation/link/09e41511e079fab475000000/download</a></p>",
        "id": 202929467,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1593968677
    },
    {
        "content": "<p>Hey all! Here's the video.<br>\n<a href=\"https://www.youtube.com/watch?v=LY5H9uY7Gns&amp;list=PLCOXjXDLt3pYPE63bVbsVfA41_wa3sZOh\">https://www.youtube.com/watch?v=LY5H9uY7Gns&amp;list=PLCOXjXDLt3pYPE63bVbsVfA41_wa3sZOh</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"LY5H9uY7Gns\" href=\"https://www.youtube.com/watch?v=LY5H9uY7Gns&amp;list=PLCOXjXDLt3pYPE63bVbsVfA41_wa3sZOh\"><img src=\"https://i.ytimg.com/vi/LY5H9uY7Gns/default.jpg\"></a></div>",
        "id": 202947625,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1594000688
    },
    {
        "content": "<p>Given a string diagram in an SMC, I'm trying to picture algorithms for converting them into expressions involving tensoring, composition and identities.   Let's assume there are no loops.  Then the process nodes are partially ordered by the relation where A &lt;= B means that A outputs to wire X, and X inputs to B.   Then form a topological sort of the process nodes.   We can use this to get an expression for the whole diagram, which is a sequential composition of expressions, one per process node.  This corresponds to  morphing the diagram by sliding the process nodes around, so that in the result, no two process nodes are drawn concurrently.   Then every intermediate stage in the sequential pipeline is a tensoring of all the parallel wires that go from one stage to the next.   Each node inputs some wires from the outputs of its predecessor node, and some wires which are \"carried over\" from earlier stages in the chain.   So the expression for that node is the tensoring of the morphism associated with that node, with identities for all of the wires which are carrried over.</p>",
        "id": 203052132,
        "sender_full_name": "David Tanzer",
        "timestamp": 1594077365
    },
    {
        "content": "<p>This construction seems to work, but it involves what looks like an artificial sequentialization of the diagram.</p>",
        "id": 203052182,
        "sender_full_name": "David Tanzer",
        "timestamp": 1594077434
    },
    {
        "content": "<p>Maybe this is just one of those things, stemming ultimately from the fact that whereas the string diagram involves a DAG-like structure, any representing expression must be a tree.</p>",
        "id": 203052853,
        "sender_full_name": "David Tanzer",
        "timestamp": 1594078019
    },
    {
        "content": "<p>You  are tapping into a very complicated problem. It seems to me that you want to find a data structure that represents well a string diagram, that is, a data structure which is invariant wrt the topological deformations you do with diagrams.</p>",
        "id": 203055920,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594081000
    },
    {
        "content": "<p>This is pretty much what we tried to do at Statebox for one year. We absolutely needed such a data structure to get a formally verified implementation of free SMCs in Idris</p>",
        "id": 203055933,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594081053
    },
    {
        "content": "<p>Then this paper came out: <a href=\"http://cartographer.id/cartographer-calco-2019.pdf\">http://cartographer.id/cartographer-calco-2019.pdf</a></p>",
        "id": 203055981,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594081088
    },
    {
        "content": "<p>Pawel, Paul and Fabio worked out a data structure that is not quite what we want, but very very close to it. From there, we were able to edit it here and there to finally obtain a data structure that represents string diagrams invariantly</p>",
        "id": 203056011,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594081145
    },
    {
        "content": "<p>In general, for some  \"easier\" stuff (e.g. manipulating string diagrams in the graphical interface) we just store the diagram as a tree. This is what we do in edit.statebox.cloud, and you can see the tree corresponding to a diagram in the bottom part of the window.</p>",
        "id": 203056095,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594081218
    },
    {
        "content": "<p>Clearly, there are many different trees depicting the same diagram. We do not pick any particular normal form, the tree you get depends on how you specify the morphisms. This is ok because then we convert such a tree into our invariant data structure in the formally verified idris \"core\", where the actual computations are carried out</p>",
        "id": 203056135,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594081281
    },
    {
        "content": "<p>Maybe all this is a bit handwavy, but long story short: Representing string diagrams in a computationally satisfying way is not easy, nor intuitive. This is very similar to what happens with graphs. Mathematicians working with graphs may think \"well it's just a graph\" but there are many different ways of storing a graph as data, which have absolutely inequivalent properties. Simply put, rivers of words have been written on the problem of computing with graphs, and with string diagrams the situation is similar if not worse <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 203056249,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594081396
    },
    {
        "content": "<blockquote>\n<p>Maybe this is just one of those things, stemming ultimately from the fact that whereas the string diagram involves a DAG-like structure, any representing expression must be a tree.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"275965\">@Evan Patterson</span> implemented a function from StringDiagrams to Expressions in Catlab. It does require arbitrary choices about ordering the diagram in order to force a DAG into a tree. Different choices yield different properties of the resulting trees. That is part of the motivation for unbiased languages for SMCs based on Operads of Wiring Diagrams, which is an ongoing development topic in Catlab.</p>",
        "id": 203057363,
        "sender_full_name": "James Fairbanks",
        "timestamp": 1594082691
    },
    {
        "content": "<p>Thanks James, Catlab does have an algorithm for converting wiring diagrams into expression trees. It is inspired by known algorithms for decomposing <a href=\"https://en.wikipedia.org/wiki/Series-parallel_graph\">series-parallel digraphs</a> (graphs that really wish they were SMCs). The algorithm prefers parallelism, i.e., it favors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo>⋅</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mo stretchy=\"false\">(</mo><mi>h</mi><mo>⋅</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(f \\cdot g) \\otimes (h \\cdot k)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">h</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span> over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo>⊗</mo><mi>h</mi><mo stretchy=\"false\">)</mo><mo>⋅</mo><mo stretchy=\"false\">(</mo><mi>g</mi><mo>⊗</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(f \\otimes h)\\cdot (g \\otimes k)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">h</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span> in the interchange law. To deal with the arbitrariness of order in tensor products (think <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>⊗</mo><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">f \\otimes g</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span></span></span></span> vs <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>⊗</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">g \\otimes f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7777700000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span></span></span></span>) simple heuristics for minimizing edge crossings are used.</p>\n<p>That said, I do not understand the mathematical properties of the algorithm. I do not know whether it is \"optimal\" in finding parallelism or even that it works in all cases, as tricky special cases have a habit of cropping up. So, as Fabrizio said, it is a hard problem.</p>\n<p>Personally, I find myself moving away from this approach towards working in fully unbiased structures like wiring diagrams. However, as the Cartographer paper illustrates, the problem of extracting expressions is closely related to the layout of diagrams for drawing, and it is used for that purpose in Catlab, being one of two layout algorithms supported. (The other layout algorithm is Graphviz dot, a layered graph drawing algorithm.) So there will always be uses for such techniques.</p>",
        "id": 203059520,
        "sender_full_name": "Evan Patterson",
        "timestamp": 1594085570
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"276438\">@Fabrizio Genovese</span> , <span class=\"user-mention\" data-user-id=\"275927\">@James Fairbanks</span> and <span class=\"user-mention\" data-user-id=\"275965\">@Evan Patterson</span>  for your informative replies!</p>",
        "id": 203064482,
        "sender_full_name": "David Tanzer",
        "timestamp": 1594093618
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> <a href=\"#narrow/stream/243068-ACT-2020/topic/Tutorial.3A.20String.20Diagrams.20(Fabrizio.20Genovese)/near/203056011\">said</a>:</p>\n<blockquote>\n<p>Pawel, Paul and Fabio worked out a data structure that is not quite what we want, but very very close to it. From there, we were able to edit it here and there to finally obtain a data structure that represents string diagrams invariantly</p>\n</blockquote>\n<p>I'm interested in what you mean by \"invariant\" here. One of the things that was always a pain Quantomatic was dealing concretely with graphs and graph rewriting, which are iso-invariant. This involves lots of fiddling with \"names\" of vertices and edges, with much of the code devoted to renaming and finding fresh names e.g to do direct sums and the like. Does your implementation get around those problems?</p>",
        "id": 203085944,
        "sender_full_name": "Aleks Kissinger",
        "timestamp": 1594116822
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295673\">Aleks Kissinger</span> <a href=\"#narrow/stream/243068-ACT-2020/topic/Tutorial.3A.20String.20Diagrams.20(Fabrizio.20Genovese)/near/203085944\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> <a href=\"#narrow/stream/243068-ACT-2020/topic/Tutorial.3A.20String.20Diagrams.20(Fabrizio.20Genovese)/near/203056011\">said</a>:</p>\n<blockquote>\n<p>Pawel, Paul and Fabio worked out a data structure that is not quite what we want, but very very close to it. From there, we were able to edit it here and there to finally obtain a data structure that represents string diagrams invariantly</p>\n</blockquote>\n<p>I'm interested in what you mean by \"invariant\" here. One of the things that was always a pain Quantomatic was dealing concretely with graphs and graph rewriting, which are iso-invariant. This involves lots of fiddling with \"names\" of vertices and edges, with much of the code devoted to renaming and finding fresh names e.g to do direct sums and the like. Does your implementation get around those problems?</p>\n</blockquote>\n<p>What i mean is that, for instance, you can write the same string diagram as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo separator=\"true\">;</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mo stretchy=\"false\">(</mo><mi>h</mi><mo separator=\"true\">;</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(f;g) \\otimes (h;k)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">h</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span> and as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo>⊗</mo><mi>h</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">;</mo><mo stretchy=\"false\">(</mo><mi>g</mi><mo>⊗</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(f \\otimes h);(g \\otimes k)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">h</span><span class=\"mclose\">)</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>. If you write a string diagram as a tree of tensors and compositions, those two things will be different trees. Instead, you want a data structure where those are literally the same thing.</p>",
        "id": 203089570,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594120190
    },
    {
        "content": "<p>E.g, lists are naturally associative: If I denote a composition of morphisms as a list, then <code>[f,g,h]</code> both stands for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo separator=\"true\">;</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">;</mo><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">(f;g);h</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">h</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo separator=\"true\">;</mo><mo stretchy=\"false\">(</mo><mi>g</mi><mo separator=\"true\">;</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f;(g;h)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">h</span><span class=\"mclose\">)</span></span></span></span>. In this sense, the list is naturally invariant wrt associativity</p>",
        "id": 203089646,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594120238
    },
    {
        "content": "<p>So, in your data structure, are any two descriptions of the same string diagram literally equal? Or are they equal upto some equivalence (e.g. alpha-conversion)?</p>",
        "id": 203090740,
        "sender_full_name": "Aleks Kissinger",
        "timestamp": 1594121185
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295673\">Aleks Kissinger</span> <a href=\"#narrow/stream/243068-ACT-2020/topic/Tutorial.3A.20String.20Diagrams.20(Fabrizio.20Genovese)/near/203090740\">said</a>:</p>\n<blockquote>\n<p>So, in your data structure, are any two descriptions of the same string diagram literally equal? Or are they equal upto some equivalence (e.g. alpha-conversion)?</p>\n</blockquote>\n<p>Literally equal would be the dream. Actually the cartographer data structure goes very close to this modulo some slight reindexing</p>",
        "id": 203095463,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594124998
    },
    {
        "content": "<p>So what we did is implementing everything in idris, and then we <strong>postulated</strong> that two terms are equal modulo reindexing</p>",
        "id": 203095557,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125036
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276438\">@Fabrizio Genovese</span>  I'd be interested to know how things developed since the last time we had a chat about this in Tallinn!<br>\nDid you have a chance to get into nominal string diagrams? They felt like a good fix to the problem of alpha conversion etc. <a href=\"https://arxiv.org/abs/1904.07534\">https://arxiv.org/abs/1904.07534</a></p>",
        "id": 203095562,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594125040
    },
    {
        "content": "<p>It's quite fiddly, but in the end we managed to make it work <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 203095584,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125061
    },
    {
        "content": "<p>So the idea is that you create a type called \"open hypegraph from l to m\". This type is a record, so a term of this type is made of a bunch of other terms. Among those, there is this \"wiring\" which is just a permutation from a set of nats to another</p>",
        "id": 203095693,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125133
    },
    {
        "content": "<p>These nats represent indexings of boundaries and more importantly internal nodes. So you can re-index the internal nodes in any way you want, if you change the permutation accordingly you get the same thing</p>",
        "id": 203095732,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125166
    },
    {
        "content": "<p>so in the end we had to postulate this properties for idris typechecker not to complain.</p>",
        "id": 203095753,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125181
    },
    {
        "content": "<p>Let me see if we opened up our code already</p>",
        "id": 203095774,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125198
    },
    {
        "content": "<p>So this encoding works for hypergraph categories? or symmetric monoidal in general?</p>",
        "id": 203095814,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594125227
    },
    {
        "content": "<p><a href=\"https://github.com/statebox/fsm-oracle/blob/master/src/Cartographer/GoodHypergraphCategory.idr\">https://github.com/statebox/fsm-oracle/blob/master/src/Cartographer/GoodHypergraphCategory.idr</a></p>",
        "id": 203095887,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125270
    },
    {
        "content": "<p>So, <code>goodhypergraphSMC</code> is the free symmetric strict monoidal category on a signature</p>",
        "id": 203095910,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125285
    },
    {
        "content": "<p>this is based on <code>goodHypegraph</code> which is a restriction of the <code>hypegraph</code> data structure, which is the one I was talking about.</p>",
        "id": 203095928,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125303
    },
    {
        "content": "<p>This is the <code>hypegraph</code></p>",
        "id": 203095950,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125332
    },
    {
        "content": "<p><a href=\"https://github.com/statebox/fsm-oracle/blob/master/src/Cartographer/Hypergraph.idr\">https://github.com/statebox/fsm-oracle/blob/master/src/Cartographer/Hypergraph.idr</a></p>",
        "id": 203095954,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125334
    },
    {
        "content": "<p>The postulate is on line 69.</p>",
        "id": 203095964,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125341
    },
    {
        "content": "<p>I think I remember this \"good\" business from the last time you explained this stuff. It's checking that each wire is connected to a single port on both ends?</p>",
        "id": 203095972,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594125351
    },
    {
        "content": "<p>Yes, the idea is this: cartographer graphs can also form feedback loops, and we don't want them</p>",
        "id": 203096043,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125376
    },
    {
        "content": "<p>So we notice that: <br>\nA singleton hypegraph is free of loops<br>\nPermutations (hypegraphs with no internal nodes) are free of loops<br>\nAny composition and tensoring of those two building blocks is free of loops</p>",
        "id": 203096123,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125429
    },
    {
        "content": "<p>Do you know how much of this invariant encoding would work for non-symmetric cases?</p>",
        "id": 203096133,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594125438
    },
    {
        "content": "<p>Like, you don't want symmetries around?</p>",
        "id": 203096166,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125459
    },
    {
        "content": "<p>This MAY make things easier, since the whole permutation business is a nightmare</p>",
        "id": 203096205,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125478
    },
    {
        "content": "<p>Maybe you could just rule the permutations bit out</p>",
        "id": 203096251,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125488
    },
    {
        "content": "<p>I'm wondering if the problem gets any easier if you solve it in two stages, first non-symmetric monoidal then symmetry and permutation nightmares?</p>",
        "id": 203096257,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594125491
    },
    {
        "content": "<p>Nope, it doesn't</p>",
        "id": 203096278,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125508
    },
    {
        "content": "<p>because the problem IS the permutation nightmare xD</p>",
        "id": 203096294,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125514
    },
    {
        "content": "<p>So, for instance, our code is:</p>\n<div class=\"codehilite\"><pre><span></span><code>data GoodHypergraph : {s : Type} -&gt; {ai, ao : s -&gt; List o} -&gt; (g : Hypergraph s ai ao k l) -&gt; Type where\n    Singleton : (edge : s) -&gt; GoodHypergraph (singleton edge)\n    Permutation : (p : Perm k l) -&gt; GoodHypergraph (permutation p)\n    HComp : (a : GoodHypergraph g)\n         -&gt; (b : GoodHypergraph h)\n         -&gt; GoodHypergraph (compose g h)\n    VComp : (a : GoodHypergraph g)\n         -&gt; (b : GoodHypergraph h)\n         -&gt; GoodHypergraph (add g h)\n</code></pre></div>",
        "id": 203096320,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125535
    },
    {
        "content": "<p>If you don't want to allow permutations you just rule them out in the record substituting them wit <code>Identities</code></p>",
        "id": 203096341,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125552
    },
    {
        "content": "<p>So you want an identity datatype which is way easier than a permutation</p>",
        "id": 203096358,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125565
    },
    {
        "content": "<p>Don't you end up with factorial explosions when you try to handle permutations explicitly? Or did you manage to make the code lazy enough that it never actually run through all of them?</p>",
        "id": 203096522,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594125658
    },
    {
        "content": "<p>So in this type signature <code>s</code> is the type of nodes (basic blocks), <code>ai</code> and <code>ao</code> are arity functions telling you inputs and outputs of wires, etc</p>",
        "id": 203096553,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125682
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"294964\">Alexis Toumi</span> <a href=\"#narrow/stream/243068-ACT-2020/topic/Tutorial.3A.20String.20Diagrams.20(Fabrizio.20Genovese)/near/203096522\">said</a>:</p>\n<blockquote>\n<p>Don't you end up with factorial explosions when you try to handle permutations explicitly? Or did you manage to make the code lazy enough that it never actually run through all of them?</p>\n</blockquote>\n<p>You don't, because you don't deal with them explicitly</p>",
        "id": 203096573,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125696
    },
    {
        "content": "<p>Cool!</p>",
        "id": 203096593,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594125710
    },
    {
        "content": "<p>I'm still curious whether/how nominal sets of wires would help for this nightmare</p>",
        "id": 203096604,
        "sender_full_name": "Alexis Toumi",
        "timestamp": 1594125718
    },
    {
        "content": "<p>If I write <code>append to list :: a -&gt; [a] -&gt; [a]</code> I'm not considering all lists over type <code>a</code> at once</p>",
        "id": 203096652,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125726
    },
    {
        "content": "<p>Nominal sets just hide permutations under the rug using a group action</p>",
        "id": 203096681,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125750
    },
    {
        "content": "<p>but guess what, we have to implement the group action anyway xD</p>",
        "id": 203096693,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125758
    },
    {
        "content": "<p>So at this point it was easier to use idris permutation library xD</p>",
        "id": 203096721,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125775
    },
    {
        "content": "<p>What would really help is HoTT</p>",
        "id": 203096742,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125787
    },
    {
        "content": "<p>Cos we could just use truncated types and define SMCs without constructing all this explicitly</p>",
        "id": 203096765,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125803
    },
    {
        "content": "<p>Which we did btw, actually <span class=\"user-mention\" data-user-id=\"277960\">@Fredrik Nordvall Forsberg</span>  did it for us: <a href=\"https://github.com/statebox/idris-ct/pull/32/files\">https://github.com/statebox/idris-ct/pull/32/files</a></p>",
        "id": 203096960,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594125939
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276438\">Fabrizio Genovese</span> <a href=\"#narrow/stream/243068-ACT-2020/topic/Tutorial.3A.20String.20Diagrams.20(Fabrizio.20Genovese)/near/203095463\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"295673\">Aleks Kissinger</span> <a href=\"#narrow/stream/243068-ACT-2020/topic/Tutorial.3A.20String.20Diagrams.20(Fabrizio.20Genovese)/near/203090740\">said</a>:</p>\n<blockquote>\n<p>So, in your data structure, are any two descriptions of the same string diagram literally equal? Or are they equal upto some equivalence (e.g. alpha-conversion)?</p>\n</blockquote>\n<p>Literally equal would be the dream. Actually the cartographer data structure goes very close to this modulo some slight reindexing</p>\n</blockquote>\n<p>Yeah, this is basically what quanto does as well. I see Cartographer has a \"HyperEdgeId\" type, which is basically an int, which serves to give the hyperedge a unique (but meaningless) name, then you are always working modulo renaming. I don't know if there's really any way around that. There may even be some kind of \"no free lunch\" principle when it comes to data structures representing string diagrams</p>",
        "id": 203111481,
        "sender_full_name": "Aleks Kissinger",
        "timestamp": 1594133039
    },
    {
        "content": "<p>i've experimented some with representing string diagrams as Penrose abstract tensor systems (formalised using nominal algebra). theoretically, this looks quite nice. in practice, i lost weeks proving little lemmas about finite supports and equivarience in nominal isabelle, and never quite got it to understand the \"obvious\" way you can do equational reasoning with the abstract tensor notation.</p>",
        "id": 203112204,
        "sender_full_name": "Aleks Kissinger",
        "timestamp": 1594133375
    },
    {
        "content": "<p>I think there is no way until we have a type theory that supports quotients well, like HoTT.</p>",
        "id": 203114357,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1594134311
    }
]