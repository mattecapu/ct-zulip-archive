[
    {
        "content": "<p>Ultimately it's a very simple thing: a space (or infinity-groupoid, or simplicial set, or homotopy type) where there's a multiplication that's associative up to homotopy, with the homotopy obeying all the rules you could imagine, up to homotopy, etc.</p>",
        "id": 213942783,
        "sender_full_name": "John Baez",
        "timestamp": 1603210663
    },
    {
        "content": "<p>And such a thing is best defined inside a similar thing.</p>",
        "id": 213942890,
        "sender_full_name": "John Baez",
        "timestamp": 1603210693
    },
    {
        "content": "<p>Probably not well. It looks like it'd have the same unknowns as defining an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,1)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-category.</p>",
        "id": 213942922,
        "sender_full_name": "Dan Doel",
        "timestamp": 1603210712
    },
    {
        "content": "<p>Yes, there's a nice discussion on Michael Harris where Jacob Lurie says he doesn't think homotopy type theory solves this sort of problem (yet).</p>",
        "id": 213943129,
        "sender_full_name": "John Baez",
        "timestamp": 1603210804
    },
    {
        "content": "<p>Riehl and Verity's <a href=\"http://www.math.jhu.edu/~eriehl/HoTTEST.pdf\">\"synthetic theory of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,1)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-categories\"</a> may be a better way to go.</p>",
        "id": 213943341,
        "sender_full_name": "John Baez",
        "timestamp": 1603210916
    },
    {
        "content": "<p>Basically there's no way of writing down \"and ever so on,\" and no known finitary description, I think.</p>",
        "id": 213943437,
        "sender_full_name": "Dan Doel",
        "timestamp": 1603210941
    },
    {
        "content": "<p>I'm not sure what you mean by \"finitary description\".  You can certainly write down a precise formula of finite length that describes how it goes on forever; every good homotopy theorist or n-category theorist knows at least one way to do this.</p>",
        "id": 213944848,
        "sender_full_name": "John Baez",
        "timestamp": 1603211610
    },
    {
        "content": "<p>Part of it might be that the sorts of 'descriptions' you can use are artificially limited, and there are ways that can be relaxed, but they're not widely adopted. However, I think there are additional unknowns about what sorts of \"higher\" stuff should actually be allowed.</p>",
        "id": 213944863,
        "sender_full_name": "Dan Doel",
        "timestamp": 1603211616
    },
    {
        "content": "<p>The inductive definitions used in HoTT and other implemented type theories are based on e.g. Haskell, where you have to write down all the constructors and whatnot in a finite source file. There is no way to <em>compute</em> the description of the inductive type. So, unless you can find an alternate characterization of the \"and so on\" in terms of finitely many (higher) constructors, there's no way to write it down in that framework.</p>",
        "id": 213945275,
        "sender_full_name": "Dan Doel",
        "timestamp": 1603211772
    },
    {
        "content": "<p>Or if you can do it in some other way than a direct definition of that sort. Like, there's no way to write down all n-spheres that way, but you can instead define them all as the n-fold suspension or something, by recursion on n.</p>",
        "id": 213945524,
        "sender_full_name": "Dan Doel",
        "timestamp": 1603211892
    },
    {
        "content": "<p>You're taking a more computational view than I do.   How is what you're saying fundamentally different from the fact that we can't write a program that prints out all the natural numbers?  We have a systematic procedure, but it can never run to completion.</p>",
        "id": 213945600,
        "sender_full_name": "John Baez",
        "timestamp": 1603211930
    },
    {
        "content": "<p>I'm not trying to be snarky, I'm trying to get what you're saying.</p>",
        "id": 213945819,
        "sender_full_name": "John Baez",
        "timestamp": 1603212013
    },
    {
        "content": "<p>I don't see how you can not take a 'computational' approach to what definitions are allowed or not in a particular formal system, which is the 'problem' with defining <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">∞</span></span></span></span>-categories in HoTT.</p>",
        "id": 213947192,
        "sender_full_name": "Dan Doel",
        "timestamp": 1603212612
    },
    {
        "content": "<p>It's not good enough to say that there is a systematic (meta-)procedure for writing down all the coherences necessary to define one, because there is no formal rule for defining a type based on such a (meta-)procedure.</p>",
        "id": 213947450,
        "sender_full_name": "Dan Doel",
        "timestamp": 1603212734
    },
    {
        "content": "<p>At some level, what is going on is that internalizing mathematician's use of \"...\" in definitions is very hard.</p>",
        "id": 213947472,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1603212746
    },
    {
        "content": "<p>Especially when you're in the middle of defining something, and you're at the same time implicitly defining another part using \"...\". That kind of definitional recursion at the level of definitions gets tricky very quickly.</p>",
        "id": 213947597,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1603212818
    },
    {
        "content": "<p>It'd be like an ω-rule. I mean, the approach I mentioned is related to not being so limited, and allowing internally definable 'procedures' to introduce types, but that is not how most formal systems implemented today work.</p>",
        "id": 213947626,
        "sender_full_name": "Dan Doel",
        "timestamp": 1603212834
    },
    {
        "content": "<p>For example: the notion of 'homomorphism' is well understood, so well that humans pattern match on structure definitions and write out the obvious notion of homomorphism thus induced.  Right now, there are no formal systems (outside of a couple of prototypes that I've written) that internalize this. In large part because you're just not allowed to fold over syntax and then reify the result as a new definition at the top level.</p>",
        "id": 213947816,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1603212922
    },
    {
        "content": "<p>I guess a really simple example is: <code>data ℕ where Zero ; Suc : ℕ -&gt; ℕ</code> is a valid inductive definition. <code>data ℕ where 0 : ℕ ; 1 : ℕ ; 2 : ℕ ; ...</code> is not a valid inductive definition, even though there is a systematic procedure for outputting it. The problem is that no one knows how to define an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">∞</span></span></span></span>-category except in the latter way.</p>",
        "id": 213948784,
        "sender_full_name": "Dan Doel",
        "timestamp": 1603213372
    },
    {
        "content": "<p>Exactly!</p>",
        "id": 213949733,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1603213832
    },
    {
        "content": "<p>I've often wanted to implement something like the calculus of inductive constructions but where inductive types are first class, in that you can construct them as normal terms, return them from functions, etc... If that doesn't lead to inconsistency, maybe you can just make it so the constructor list is allowed to be infinite and this would be OK? Not sure how you'd eliminate such a type though, unless you just do a wildcard after some point.</p>",
        "id": 213950020,
        "sender_full_name": "Shea Levy",
        "timestamp": 1603213966
    },
    {
        "content": "<p>There is work on that kind of thing. <a href=\"https://jmchapman.io/papers/levitation.pdf\">This for instance.</a></p>",
        "id": 213950140,
        "sender_full_name": "Dan Doel",
        "timestamp": 1603214028
    },
    {
        "content": "<p>I'm not sure about actual infinite lists of constructors, though.</p>",
        "id": 213950258,
        "sender_full_name": "Dan Doel",
        "timestamp": 1603214073
    },
    {
        "content": "<p>That paper is just the beginning, really. I think there's been considerably more done since then.</p>",
        "id": 213950341,
        "sender_full_name": "Dan Doel",
        "timestamp": 1603214111
    },
    {
        "content": "<p>Actually I guess you'd want your case statement to be a function from ctor index to case, so you could still do it infintely?</p>",
        "id": 213950431,
        "sender_full_name": "Shea Levy",
        "timestamp": 1603214151
    },
    {
        "content": "<p>Anyhow, there are basically two steps, I guess. The first is internalizing the notion of a 'description' of one of these types, so that you can define a description in terms of arbitrary other objects in the theory. The second is adding additional valid descriptions that wouldn't have even made sense before that.</p>",
        "id": 213950834,
        "sender_full_name": "Dan Doel",
        "timestamp": 1603214297
    },
    {
        "content": "<p>If my memory serves me right 'matita' had a variant of CIC that allowed that.</p>",
        "id": 213950987,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1603214371
    },
    {
        "content": "<p>I.E. you can't have an ω-rule-type until you have internalized things so that you can have an ω-description in the theory. But most implementations aren't even there yet. And also, people have to figure out what ω-rules make sense. :)</p>",
        "id": 213951386,
        "sender_full_name": "Dan Doel",
        "timestamp": 1603214511
    },
    {
        "content": "<p>I guess it's not just inductive types, though. For instance, there's a paper on the elimination principle for propositional truncation that shows that you can eliminate into any type via a 'coherently constant' map. However, I don't think anyone knows how to write down 'coherently constant' in HoTT, for similar reasons.</p>",
        "id": 213951916,
        "sender_full_name": "Dan Doel",
        "timestamp": 1603214733
    },
    {
        "content": "<p>There is a systematic way of writing down the coherence conditions, but not an obvious internal way.</p>",
        "id": 213952222,
        "sender_full_name": "Dan Doel",
        "timestamp": 1603214820
    }
]