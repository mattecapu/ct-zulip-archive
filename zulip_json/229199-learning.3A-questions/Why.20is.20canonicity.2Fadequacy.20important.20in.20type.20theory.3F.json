[
    {
        "content": "<p>For example, why do we care if every term of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>nat</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{nat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord text\"><span class=\"mord\">nat</span></span></span></span></span> is syntactically either of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">S(m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span> for some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>:</mo><mtext>nat</mtext></mrow><annotation encoding=\"application/x-tex\">m:\\text{nat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord text\"><span class=\"mord\">nat</span></span></span></span></span>, when we can easily prove by induction that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>n</mi><mo>:</mo><mtext>nat</mtext><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>=</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi mathvariant=\"normal\">∃</mi><mi>m</mi><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>=</mo><mi>S</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall n:\\text{nat}, (n=0) + \\exists m, (n=S(m))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">nat</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">))</span></span></span></span>?  I know that this property is important for computational reasons, but I don't know what these reasons are. (cross-posted to the <a href=\"https://hott.zulipchat.com/#narrow/stream/313289-Learning-questions/topic/Why.20is.20canonicity.2Fadequacy.20important.20in.20type.20theory.3F/near/405541327\">HoTT Zulip</a>)</p>",
        "id": 405540968,
        "sender_full_name": "Joshua Meyers",
        "timestamp": 1701528822
    },
    {
        "content": "<p>to quote folklore, canonicity allows equality of terms, and hence type checking, to be decidable; however, there are practical type theories that lack decidability of type checking, such as NuPRL - extensional type theories.  Those have their own problems, such as not being able to normalize under binders, but naively it doesn't seem like those problems are directly due to lack of canonicity.  Spending a lot of time programming in Coq makes it obvious why axioms are 'less good' than theorems, but I'm hoping people can speak to other reasons.</p>",
        "id": 405560134,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1701545145
    },
    {
        "content": "<p>What is the difference between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding=\"application/x-tex\">\\sqrt{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.1328em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9072em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">2</span></span></span><span style=\"top:-2.8672em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1328em;\"><span></span></span></span></span></span></span></span></span><br>\n​ and 1.41421356237... where by \"1.41421356237...\" I refer to the output of a program that accepts a natural number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> and outputs the first <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> digits of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding=\"application/x-tex\">\\sqrt{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.1328em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9072em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">2</span></span></span><span style=\"top:-2.8672em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1328em;\"><span></span></span></span></span></span></span></span></span>.<br>\n​ up to a sufficiently large value of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding=\"application/x-tex\">\\sqrt{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.1328em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9072em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">2</span></span></span><span style=\"top:-2.8672em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1328em;\"><span></span></span></span></span></span></span></span></span> at which point the computer crashes.</p>",
        "id": 405566945,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1701551282
    },
    {
        "content": "<p>There are many features of the string \"1.41421356237...\" that make it more tangible or concrete somehow than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding=\"application/x-tex\">\\sqrt{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.1328em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9072em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">2</span></span></span><span style=\"top:-2.8672em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1328em;\"><span></span></span></span></span></span></span></span></span>.</p>\n<p>For example, \"1.414\" is obviously greater than 1.4 and obviously less than 1.5. This can be seen at a moment's glance. It is not obvious without doing some math that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding=\"application/x-tex\">\\sqrt{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.1328em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9072em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">2</span></span></span><span style=\"top:-2.8672em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1328em;\"><span></span></span></span></span></span></span></span></span> ​ is greater than 1.4.</p>",
        "id": 405566994,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1701551317
    },
    {
        "content": "<p>I hope you would agree that \"What is the value of the expression <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mn>19430687236</mn></msqrt></mrow><annotation encoding=\"application/x-tex\">\\sqrt{19430687236}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.1328em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9072em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">19430687236</span></span></span><span style=\"top:-2.8672em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1328em;\"><span></span></span></span></span></span></span></span></span>​\" is a sensible question whose answer is not immediately obvious, and \"What is the value of the expression 139394\" is perhaps sensible but whose answer is immediately obvious - i.e., it is 139394.</p>",
        "id": 405567018,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1701551363
    },
    {
        "content": "<p>That is, I personally draw some kind of philosophical distinction between expressions and values. An expression denotes a value but it is not itself necessarily a value; we can compute an expression to determine its value. In the case of real numbers we cannot compute values in a finite amount of time but if I have an algorithm which gives me an open interval <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(a,b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>r</mi><mo>&lt;</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a&lt;r&lt;b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a,b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> rational, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>&lt;</mo><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">(b−a)&lt;2^{−n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 405567081,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1701551406
    },
    {
        "content": "<p>In both classical and constructive mathematics, there is a distinction we can draw between expressions and values. The difference between classical and constructive mathematics is that classical mathematics admits expressions which we cannot associate a value to in practice (even though platonically it denotes a value) and constructive mathematics where from every expression we can compute a value.</p>",
        "id": 405567246,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1701551557
    },
    {
        "content": "<p>If you think of a closed term of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> as an expression denoting a value, and a numeral as a value properly speaking, then canonicity implies that \"every expression which denotes a natural number can be reduced to the value of that natural number\" which can be interpreted as a criterion for the constructivity of the system. In classical mathematics we can give abstract descriptions of natural numbers and prove they are unique but not denote them by numerals, so this is one sense in which classical mathematics fails to be constructive.</p>",
        "id": 405567264,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1701551576
    },
    {
        "content": "<p>For example if you take the result here - <br>\n<a href=\"https://homotopytypetheory.org/2022/06/09/the-brunerie-number-is-2/\">https://homotopytypetheory.org/2022/06/09/the-brunerie-number-is-2/</a><br>\nwhen we say \"we have computed this number and it is -2\" what that means is that we proved that the group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>π</mi><mn>4</mn></msub><mo stretchy=\"false\">(</mo><msup><mi>S</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\pi_4(S^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> is cyclic of order <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, and from that we can talk about \"the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>π</mi><mn>4</mn></msub><mo stretchy=\"false\">(</mo><msup><mi>S</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\pi_4(S^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> is cyclic of order <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>\", and that is an expression. Normalizing that expression denotes a value, which is in this case -2. In classical mathematics it would not follow immediately that we can know the value of -2 just because we know \"there exists <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>π</mi><mn>4</mn></msub><mo stretchy=\"false\">(</mo><msup><mi>S</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\pi_4(S^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> is cyclic of order <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>\", but because of canonicity we know that by repeatedly beta-reducing the expression \"the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>π</mi><mn>4</mn></msub><mo stretchy=\"false\">(</mo><msup><mi>S</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\pi_4(S^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> is cyclic of order <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>\" we will eventually get a numeral.</p>",
        "id": 405567726,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1701552020
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281326\">Ryan Wisnesky</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Why.20is.20canonicity.2Fadequacy.20important.20in.20type.20theory.3F/near/405560134\">said</a>:</p>\n<blockquote>\n<p>To quote folklore, canonicity allows equality of terms, and hence type checking, to be decidable...</p>\n</blockquote>\n<p>Technically speaking that's normalization, not canonicity.  Canonicity (for natural numbers) says that every term of type Nat that's \"closed\" (i.e. defined in the empty context) is definitionally equal to a numeral.  Normalization says that in <em>any</em> context, any term of any type is definitionally equal to a special kind of term called a normal form, such that if two terms are definitionally equal then their normal forms are identical.</p>\n<p>Normalization is an important ingredient in a typechecking algorithm for dependent type theory, since it gives us an algorithm to test whether two terms are definitionally equal: compute their normal forms and check whether they're identical.  I'm not an expert on NuPRL, but I'm dubious of any claim that anyone's actually ever implemented any type theory that <em>doesn't</em> have decidable type-checking; it seems to me it's more likely that they specified a fragment of the theory that does have decidable typechecking and implemented that.</p>\n<p>We usually think of normalization as a stronger property than canonicity, because as long as the normal forms of type Nat are the numerals, normalization implies canonicity.  However, there are type theories with normalization but not canonicity, e.g. just add any axiom to a more familiar type theory.  Since adding an axiom is equivalent to working in a nonempty context, it doesn't break normalization, but it sure can break canonicity.</p>",
        "id": 405571837,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1701556121
    },
    {
        "content": "<p>My short answer to the original question is that only with canonicity does it make sense to think of a type theory as being a programming language.  If you write a function in, say, C++, of type int, and run it, you expect to actually get out a concrete integer.</p>",
        "id": 405571943,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1701556227
    },
    {
        "content": "<p>In general, many type theories do not satisfy canonicity, such as a type theory with function extensionality or the univalence axiom. Furthermore, there exists type theories, such as <a href=\"https://arxiv.org/abs/2102.00905\">objective type theory</a>, for which it is simply impossible to even express the notion of canonicity - because the theories don't even have a judgmental equality. </p>\n<p>More important in these cases would be <em>homotopy canonicity</em>, where every term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>:</mo><mrow><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">n:\\mathrm{nat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">nat</span></span></span></span></span> in the empty context is propositionally equal to a canonical term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>:</mo><mrow><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">m:\\mathrm{nat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">nat</span></span></span></span></span>. Kapulkin and Sattler have proven, for example, that the type theory in the 2013 HoTT textbook satisfy homotopy canonicity, despite it not satisfying canonicity. Homotopy canonicity suffices for most purposes because one could get [types or terms indexed by] canonical terms via transport and application across propositional equalities to the canonical terms in the natural numbers. </p>\n<p>Canonicity itself is relevant for a different reason: having every term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>:</mo><mrow><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">n:\\mathrm{nat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">nat</span></span></span></span></span> in the empty context judgmentally reduce down a canonical term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>:</mo><mrow><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">m:\\mathrm{nat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">nat</span></span></span></span></span> makes the resulting syntax and proofs simpler to deal with in the language - you don't have to constantly transport or ap across propositional equalities in the natural numbers to get [something indexed by] the canonical term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>:</mo><mrow><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">m:\\mathrm{nat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">nat</span></span></span></span></span> if your theory has judgmental equality and canonicity; everything just reduces. </p>\n<p>It's the same reason why somebody might want to define function extensionality or univalent universes using equivalences with judgmental left-inverse and right-inverse equalities. One doesn't have to deal with either transport or ap across the left-inverse and right-inverse family of propositional equalities for weak equivalences, or the coherence datum of weak equivalences, because taking the inverse function of the equivalence evaluated at the term just reduces to the original term, making many proofs easier.</p>",
        "id": 405707966,
        "sender_full_name": "Madeleine Birchfield",
        "timestamp": 1701645758
    },
    {
        "content": "<p>It's not really clear to me that homotopy canonicity is useful for anything in its own right.  It's interesting metatheoretically as an argument that some axiom like funext or univalence is \"morally constructive\", but to do anything with canonicity in practice one needs a reduction algorithm.</p>",
        "id": 405711993,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1701648837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"280784\">Joshua Meyers</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Why.20is.20canonicity.2Fadequacy.20important.20in.20type.20theory.3F/near/405540968\">said</a>:</p>\n<blockquote>\n<p>For example, why do we care if every term of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>nat</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{nat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord text\"><span class=\"mord\">nat</span></span></span></span></span> is syntactically either of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">S(m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span> for some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>:</mo><mtext>nat</mtext></mrow><annotation encoding=\"application/x-tex\">m:\\text{nat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord text\"><span class=\"mord\">nat</span></span></span></span></span></p>\n</blockquote>\n<p>By the way, just as a point of terminology, I would tend to use \"syntactically\" to refer to an equality that is <em>finer</em> than definitional equality, such as mere <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span>-equivalence, or maybe even strict identity of terms with named variables.  Canonicity says that every term is \"definitionally\" or \"judgmentally\" equal to a numeral, but not \"syntactically\" in this sense, e.g. I would say that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> is syntactically distinct from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> even though they are definitionally/judgmentally equal.</p>",
        "id": 405712379,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1701649093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Why.20is.20canonicity.2Fadequacy.20important.20in.20type.20theory.3F/near/405571837\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281326\">Ryan Wisnesky</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Why.20is.20canonicity.2Fadequacy.20important.20in.20type.20theory.3F/near/405560134\">said</a>:</p>\n<blockquote>\n<p>To quote folklore, canonicity allows equality of terms, and hence type checking, to be decidable...</p>\n</blockquote>\n<p>Technically speaking that's normalization, not canonicity.  Canonicity (for natural numbers) says that every term of type Nat that's \"closed\" (i.e. defined in the empty context) is definitionally equal to a numeral.  Normalization says that in <em>any</em> context, any term of any type is definitionally equal to a special kind of term called a normal form, such that if two terms are definitionally equal then their normal forms are identical.</p>\n<p>Normalization is an important ingredient in a typechecking algorithm for dependent type theory, since it gives us an algorithm to test whether two terms are definitionally equal: compute their normal forms and check whether they're identical.  I'm not an expert on NuPRL, but I'm dubious of any claim that anyone's actually ever implemented any type theory that <em>doesn't</em> have decidable type-checking; it seems to me it's more likely that they specified a fragment of the theory that does have decidable typechecking and implemented that.</p>\n<p>We usually think of normalization as a stronger property than canonicity, because as long as the normal forms of type Nat are the numerals, normalization implies canonicity.  However, there are type theories with normalization but not canonicity, e.g. just add any axiom to a more familiar type theory.  Since adding an axiom is equivalent to working in a nonempty context, it doesn't break normalization, but it sure can break canonicity.</p>\n</blockquote>\n<p>My first thought is that normalization seems too strong -- if what we really want is for testing whether two terms are judgmentally equal to be efficiently computable, normalization is clearly sufficient but is it necessary?</p>\n<p>A second thought: if we have some crazy non-canonical term, isn't it easy to tell that it is not judgementally equal to, say, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>?  I mean, perhaps we could do some work to evaluate it and ultimately get <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>, but in that case, it would be equal to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> propositionally, not judgmentally.</p>\n<p>I want to learn more about these matters.  What should I read? (Also <a href=\"https://cstheory.stackexchange.com/questions/48112/proof-relevance-vs-proof-irrelevance/48114?noredirect=1#comment119093_48114\">see here</a> for the kind of references I am looking for.)</p>",
        "id": 405744669,
        "sender_full_name": "Joshua Meyers",
        "timestamp": 1701665445
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Why.20is.20canonicity.2Fadequacy.20important.20in.20type.20theory.3F/near/405571943\">said</a>:</p>\n<blockquote>\n<p>My short answer to the original question is that only with canonicity does it make sense to think of a type theory as being a programming language.  If you write a function in, say, C++, of type int, and run it, you expect to actually get out a concrete integer.</p>\n</blockquote>\n<p>Right, but why should we necessarily care about type theory being a programming language if we are using it for mathematical foundations or formal verification?  If I want to construct and reason about a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>nat</mtext><mo>→</mo><mtext>nat</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{nat}\\to\\text{nat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord text\"><span class=\"mord\">nat</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord text\"><span class=\"mord\">nat</span></span></span></span></span> I don't see why it should have to output a concrete integer.</p>",
        "id": 405744891,
        "sender_full_name": "Joshua Meyers",
        "timestamp": 1701665600
    },
    {
        "content": "<p>\"I'm dubious of any claim that anyone's actually ever implemented any type theory that doesn't have decidable type-checking\"</p>\n<p>Why is decidable type-checking important?  In ordinary (proof-irrelevant) math we will often write things like \"consider the group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><mi>m</mi><mo separator=\"true\">,</mo><mi>e</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(G,m,e)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mclose\">)</span></span></span></span>\" --- to check that this is well-typed we must check whether the given structure satisfies the group axioms, which I don't think is decidable.  The reader is expected to check the group axioms, and a conscientious author will give them hints to do so if it is not straightforward -- they might include a parenthetical such as \"(to check associativity consider _____)\", or a citation such as \"this group has been described in more detail in \\cite{...}\".  Why would we be so averse to setting a similar expectation for a compilier?</p>",
        "id": 405750951,
        "sender_full_name": "Joshua Meyers",
        "timestamp": 1701669598
    },
    {
        "content": "<blockquote>\n<p>If we have some crazy non-canonical term, isn't it easy to tell that it is not definitionally equal to, say, 2? I mean, perhaps we could do some work to evaluate it and ultimately get 2, but in that case, it would be equal to 2 judgmentally, not definitionally.</p>\n</blockquote>\n<p>I don't know what you mean here. There are a lot of people who use \"judgemental equality\" and \"definitional equality\" synonymously so if you are distinguishing between those you have to clarify</p>",
        "id": 405757853,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1701672857
    },
    {
        "content": "<p>Sorry!  Just fixed</p>",
        "id": 405758213,
        "sender_full_name": "Joshua Meyers",
        "timestamp": 1701673006
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"280784\">Joshua Meyers</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Why.20is.20canonicity.2Fadequacy.20important.20in.20type.20theory.3F/near/405744891\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Why.20is.20canonicity.2Fadequacy.20important.20in.20type.20theory.3F/near/405571943\">said</a>:</p>\n<blockquote>\n<p>My short answer to the original question is that only with canonicity does it make sense to think of a type theory as being a programming language.  If you write a function in, say, C++, of type int, and run it, you expect to actually get out a concrete integer.</p>\n</blockquote>\n<p>Right, but why should we necessarily care about type theory being a programming language if we are using it for mathematical foundations or formal verification?  If I want to construct and reason about a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>nat</mtext><mo>→</mo><mtext>nat</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{nat}\\to\\text{nat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord text\"><span class=\"mord\">nat</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord text\"><span class=\"mord\">nat</span></span></span></span></span> I don't see why it should have to output a concrete integer.</p>\n</blockquote>\n<p>This is just fundamentally what constructive mathematics is about imo. Not all your math has to be constructive but to the extent that you want to do any kind of constructive mathematics whatsoever you have to have the ability to write programs which can compute and evaluate. If you genuinely don't care about constructivity whatsoever that's also fine, but even systems based on classical logic have directed rewriting automation tools which repeatedly rewrite and simplify according to a set of formulas, for example replacing a term by its definition, making chains of additions left-associative and so on, some kind of computation in this sense of automated directed rewriting is still necessary.</p>",
        "id": 405758467,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1701673124
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"280784\">Joshua Meyers</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Why.20is.20canonicity.2Fadequacy.20important.20in.20type.20theory.3F/near/405750951\">said</a>:</p>\n<blockquote>\n<p>\"I'm dubious of any claim that anyone's actually ever implemented any type theory that doesn't have decidable type-checking\"</p>\n<p>Why is decidable type-checking important?  In ordinary (proof-irrelevant) math we will often write things like \"consider the group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><mi>m</mi><mo separator=\"true\">,</mo><mi>e</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(G,m,e)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mclose\">)</span></span></span></span>\" --- to check that this is well-typed we must check whether the given structure satisfies the group axioms, which I don't think is decidable.  The reader is expected to check the group axioms, and a conscientious author will give them hints to do so if it is not straightforward -- they might include a parenthetical such as \"(to check associativity consider _____)\", or a citation such as \"this group has been described in more detail in \\cite{...}\".  Why would we be so averse to setting a similar expectation for a compilier?</p>\n</blockquote>\n<p>It sounds like you're saying that you're saying we should call a powerful automated theorem prover to resolve typing issues, which has been done, for example, here. <a href=\"https://arxiv.org/abs/2305.15382\">https://arxiv.org/abs/2305.15382</a></p>\n<p>But more generally like. It should be obvious that this is a hard problem right? Like you're suggesting \"Why don't we just let the computer take care of the easy parts, like checking the group axioms?\". This is what we've been trying to do with interactive theorem provers for decades, and we're getting there slowly, but easy is in the eye of the beholder.</p>",
        "id": 405760036,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1701673782
    },
    {
        "content": "<p>Checking that a given group structure satisfies the axioms is not part of type-checking, that's proof search.  Type-checking is (among other things) checking that a <em>given proof</em> that a given group structure satisfies the axioms is <em>is correct</em>.</p>",
        "id": 405776564,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1701680175
    },
    {
        "content": "<p>The whole point of formal verification is to, well, <em>verify</em> the correctness of a proof.  And that's part of typechecking, so you really have to have a typechecking algorithm.  The only wiggle room I can see is that maybe it's only semidecidable, i.e. your algorithm might spin forever on some inputs without deciding whether the proof is correct or not.  But the more common that is in practice, the less useful your proof assistant will be.</p>",
        "id": 405776849,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1701680275
    },
    {
        "content": "<p>It's true that in theory, one might have an equality-checking algorithm that doesn't proceed by normalization.  In fact, technically this is the case in many real-world proof assistants, which use a type-directed equality-checking algorithm that sort of normalizes each term bit by bit, checking equality as it goes, rather than normalizing both terms all the way and then afterwards checking whether they're equal.  However, in practice I'm not aware of any equality-checking algorithm that isn't essentially a normalization algorithm at heart.</p>",
        "id": 405777353,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1701680418
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"280784\">Joshua Meyers</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Why.20is.20canonicity.2Fadequacy.20important.20in.20type.20theory.3F/near/405744891\">said</a>:</p>\n<blockquote>\n<p>Right, but why should we necessarily care about type theory being a programming language if we are using it for mathematical foundations or formal verification?  If I want to construct and reason about a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>nat</mtext><mo>→</mo><mtext>nat</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{nat}\\to\\text{nat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord text\"><span class=\"mord\">nat</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord text\"><span class=\"mord\">nat</span></span></span></span></span> I don't see why it should have to output a concrete integer.</p>\n</blockquote>\n<p>You didn't specify in your original question what your context was.  Being a programming language is indeed not directly important for foundations or verification.  In particular, therefore, people are free to assume axioms (like excluded middle and choice) when doing foundations and verification, which break canonicity.  But importantly, they don't break normalization or decidability of typechecking.  So from that pure perspective, canonicity is not perhaps important on its own, except as a signal that a theory being developed seems computational and it's worth the effort of trying to find a normalization algorithm.</p>",
        "id": 405778057,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1701680593
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"280784\">Joshua Meyers</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Why.20is.20canonicity.2Fadequacy.20important.20in.20type.20theory.3F/near/405744669\">said</a>:</p>\n<blockquote>\n<p>A second thought: if we have some crazy non-canonical term, isn't it easy to tell that it is not judgementally equal to, say, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>?  I mean, perhaps we could do some work to evaluate it and ultimately get <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>, but in that case, it would be equal to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> propositionally, not judgmentally.</p>\n</blockquote>\n<p>I still can't figure out what you mean here.  If you just have some random type theory, then no, it's not easy to check whether two terms are judgmentally equal, since judgmental equality is defined as a transitive closure, so they could in principle be connected by some long string of equalities that go throurgh a bunch of other apparently unrelated terms.  Having a normalization/canonicity algorithm solves this problem by saying there is a specific sequence of equalities that's enough to check.</p>",
        "id": 405778404,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1701680701
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Why.20is.20canonicity.2Fadequacy.20important.20in.20type.20theory.3F/near/405778057\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"280784\">Joshua Meyers</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Why.20is.20canonicity.2Fadequacy.20important.20in.20type.20theory.3F/near/405744891\">said</a>:</p>\n<blockquote>\n<p>Right, but why should we necessarily care about type theory being a programming language if we are using it for mathematical foundations or formal verification?  If I want to construct and reason about a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>nat</mtext><mo>→</mo><mtext>nat</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{nat}\\to\\text{nat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord text\"><span class=\"mord\">nat</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord text\"><span class=\"mord\">nat</span></span></span></span></span> I don't see why it should have to output a concrete integer.</p>\n</blockquote>\n<p>You didn't specify in your original question what your context was.  Being a programming language is indeed not directly important for foundations or verification.  In particular, therefore, people are free to assume axioms (like excluded middle and choice) when doing foundations and verification, which break canonicity.  But importantly, they don't break normalization or decidability of typechecking.  So from that pure perspective, canonicity is not perhaps important on its own, except as a signal that a theory being developed seems computational and it's worth the effort of trying to find a normalization algorithm.</p>\n</blockquote>\n<p>Why wouldn't these axioms break normalization?  Maybe it would help if I could see a definition of \"normal form\" in a given context.</p>",
        "id": 406094559,
        "sender_full_name": "Joshua Meyers",
        "timestamp": 1701792977
    },
    {
        "content": "<p>Adding an axiom, of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> say, doesn't break normalization because it's essentially equivalent to just always working in an extended context with an extra variable of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>, and normalization is a statement about all contexts.</p>",
        "id": 406099186,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1701794036
    },
    {
        "content": "<p>In particular, a variable appearing in the context is always a normal form in that context.</p>",
        "id": 406099307,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1701794057
    },
    {
        "content": "<p>Intuitively, a normal form is a term that contains no \"redexes\", subterms to which reduction rules could be applied, such as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>b</mi><mo stretchy=\"false\">)</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">(\\lambda x. b)a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">a</span></span></span></span> which reduces to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo stretchy=\"false\">[</mo><mi>a</mi><mi mathvariant=\"normal\">/</mi><mi>x</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">b[a/x]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">a</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">]</span></span></span></span>.  Formally, normal forms are defined inductively and mutually with a subclass of themselves called \"neutral terms\" rather than defined by this \"negative\" property.</p>",
        "id": 406099737,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1701794156
    },
    {
        "content": "<p>In particular, if we have an axiom or variable <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo>:</mo><mrow><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">E</mi><mi mathvariant=\"normal\">M</mi></mrow></mrow><annotation encoding=\"application/x-tex\">D:\\rm LEM</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">LEM</span></span></span></span></span>, i.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi>P</mi><mo>:</mo><mrow><mi mathvariant=\"normal\">P</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">p</mi></mrow><mo stretchy=\"false\">)</mo><mo>→</mo><mi>P</mi><mo>+</mo><mi mathvariant=\"normal\">¬</mi><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">D : (P:\\mathrm{Prop}) \\to P+\\neg P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Prop</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">¬</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span>, then a term like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"sans-serif\">i</mi><mi mathvariant=\"sans-serif\">f</mi></mrow><mtext> </mtext><mo stretchy=\"false\">(</mo><mi>D</mi><mtext> </mtext><mi>P</mi><mo stretchy=\"false\">)</mo><mtext> </mtext><mrow><mi mathvariant=\"sans-serif\">t</mi><mi mathvariant=\"sans-serif\">h</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">n</mi></mrow><mtext> </mtext><mo>⋯</mo><mtext> </mtext><mrow><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">l</mi><mi mathvariant=\"sans-serif\">s</mi><mi mathvariant=\"sans-serif\">e</mi></mrow><mtext> </mtext><mo>⋯</mo></mrow><annotation encoding=\"application/x-tex\">\\mathsf{if}~(D~P)~\\mathsf{then}~\\cdots~\\mathsf{else}~\\cdots</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathsf\" style=\"margin-right:0.06944em;\">if</span></span><span class=\"mspace nobreak\"> </span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace nobreak\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span><span class=\"mspace nobreak\"> </span><span class=\"mord\"><span class=\"mord mathsf\">then</span></span><span class=\"mspace nobreak\"> </span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace nobreak\"> </span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">else</span></span><span class=\"mspace nobreak\"> </span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span></span></span></span> is a normal form (as long as the branches are): the \"if\" is only a redex if its argument is syntactically of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">i</mi><mi mathvariant=\"sans-serif\">n</mi><mi mathvariant=\"sans-serif\">l</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{inl}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">inl</span></span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">i</mi><mi mathvariant=\"sans-serif\">n</mi><mi mathvariant=\"sans-serif\">r</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{inr}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6794em;\"></span><span class=\"mord\"><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">inr</span></span></span></span></span>.</p>",
        "id": 406100296,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1701794267
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Why.20is.20canonicity.2Fadequacy.20important.20in.20type.20theory.3F/near/406099737\">said</a>:</p>\n<blockquote>\n<p>Intuitively, a normal form is a term that contains no \"redexes\", subterms to which reduction rules could be applied, such as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>b</mi><mo stretchy=\"false\">)</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">(\\lambda x. b)a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">a</span></span></span></span> which reduces to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo stretchy=\"false\">[</mo><mi>a</mi><mi mathvariant=\"normal\">/</mi><mi>x</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">b[a/x]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">a</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">]</span></span></span></span>.  Formally, normal forms are defined inductively and mutually with a subclass of themselves called \"neutral terms\" rather than defined by this \"negative\" property.</p>\n</blockquote>\n<p>Do you know a good reference to see how normal forms are defined for some type theory?</p>",
        "id": 406164170,
        "sender_full_name": "Joshua Meyers",
        "timestamp": 1701812474
    },
    {
        "content": "<p>here is a recent result that gives decidability for the lambda calculus corresponding to bi-cartesian closed categories, proceeding via normal forms <a href=\"https://arxiv.org/abs/1610.01213\">https://arxiv.org/abs/1610.01213</a></p>",
        "id": 406170056,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1701815314
    },
    {
        "content": "<p>Here's an expository note describing a \"normalization by evaluation\" algorithm, including the definition of normal and neutral forms, and its connection to category-theoretic \"gluing\": <a href=\"https://arxiv.org/abs/1809.08646\">https://arxiv.org/abs/1809.08646</a></p>",
        "id": 406174372,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1701817445
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Why.20is.20canonicity.2Fadequacy.20important.20in.20type.20theory.3F/near/405571837\">said</a>:</p>\n<blockquote>\n<p>I'm dubious of any claim that anyone's actually ever implemented any type theory that <em>doesn't</em> have decidable type-checking[.]</p>\n</blockquote>\n<p>This would require checking, but I think the <a href=\"https://github.com/rlepigre/pml/\">PML</a> prover has semi-decidable type checking.</p>\n<p>Quoting from Rodolphe Lepigre's <a href=\"https://lepigre.fr/\">home page</a>:</p>\n<blockquote>\n<p>Type checking (verifying that a given term inhabits a given type) and type inference (finding a type that is inhabited by a given term) tend to be undecidable in Curry-style languages like System F or PML₂. As a consequence, these system are sometimes considered impractical, although practicality and decidability are two different problems. The main issue with Curry-style languages is that their type systems are generally not syntax-directed, meaning that they cannot be easily implemented. In particular, there is no canonical way of deciding what typing rule should be applied first when attempting to prove a typing judgment. To solve this problem, we designed (with Christophe Raffalli) a framework based on subtyping [LepRaf2019]. The main, innovating idea is to use a ternary relation t ∈ A ⊆ B instead of the usual binary relation A ⊆ B. We interpret the former as the implication “if the term t has type A, then it also has type B”, while the latter is interpreted as the inclusion “every element of type A is an element of type B”. In the obtained system, only one typing rule applies for every term constructor, and only one subtyping rule applies for every pair of types (up to commutation). In particular, the connectives that do not have algorithmic contents (those that are not reflected in the syntax of the terms) are handled using subtyping exclusively. Such connectives include the quantifiers, but also the equality types of PML₂ and the least and greatest fixpoint constructors used by inductive and coinductive types.</p>\n</blockquote>\n<p>It's not entirely clear whether this means that type-checking in PML is syntax-directed or decidable, so I'm relying on memories of discussions with Rodolphe here. Maybe <span class=\"user-mention\" data-user-id=\"665763\">@Pierre Hyvernat</span> would know better?</p>\n<p>Also, <span class=\"user-mention\" data-user-id=\"278816\">@Greta Coraglia</span>  and <span class=\"user-mention\" data-user-id=\"590522\">@Jacopo Emmenegger</span> might be interested in this, since the ternary judgement t ∈ A ⊆ B looks related to their work on the semantics of subtyping.</p>",
        "id": 406250158,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1701849037
    },
    {
        "content": "<p>I had a longish conversation about decidability of typechecking with various folks on the nCafe <a href=\"https://golem.ph.utexas.edu/category/2016/08/what_is_a_formal_proof.html\">here</a>.  The upshot was that I ended up getting convinced that, as I mentioned above, semidecidability is enough for an implementation.  Although I do think that, as I also said above, in practice you want things to terminate as much as possible.</p>",
        "id": 406339975,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1701879439
    },
    {
        "content": "<p>Personally, I think I still prefer a proof assistant that distinguishes between a \"core language\" that has decidable typechecking and all the extra bells and whistles that might not.  I like knowing that if I wanted to, I could write out a term in complete explicit gory detail and be certain that it would typecheck in finite time.</p>",
        "id": 406340332,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1701879567
    },
    {
        "content": "<p>Although, of course, as was also pointed out in that thread, in practice decidability isn't much use without efficiency.  Knowing that something will theoretically terminate isn't much help if that termination requires more time or space than is available in the observable universe.</p>",
        "id": 406355460,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1701884691
    },
    {
        "content": "<p>Sure, I didn't mean to claim any preference whatsoever, only to point out a proof assistant with semidecidable typechecking.</p>",
        "id": 406376691,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1701892858
    }
]