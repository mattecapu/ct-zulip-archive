[
    {
        "content": "<p>There is a known Free Groupoid Functor from Graphs to the category of Groupoids. It is given as the example in the <a href=\"https://ncatlab.org/nlab/show/free+groupoid\">nlab article on free Groupoids</a>.  I would like to create such an adjunction between the category of Groupoids and the category of, perhaps finite, Sets.  I just picture doing this by taking any set or set of sets and attaching every isomorphism in sight.  Then, you just see the sets and isomorphisms as objects and morphisms of a given Groupoid.  Does this work?  Could it work if we restrict the category of Groupoids to contain only Groupoids that are categories that are finely presented?</p>",
        "id": 225584389,
        "sender_full_name": "Ben Sprott",
        "timestamp": 1612807776
    },
    {
        "content": "<p>Do you mean you want to add an isomorphism between every pair of elements of the set, considered as objects of the category?</p>",
        "id": 225602121,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1612815806
    },
    {
        "content": "<p>The forgetful functor from categories to sets has a right adjoint, given by sending each set to the <a href=\"https://ncatlab.org/nlab/show/indiscrete+category\">codiscrete category</a> on that set (which is precisely adding isomorphisms between each pair of elements). This functor factors through the category of groupoids. (Note that the categories in the image of this functor are all equivalent to the terminal category, though.)</p>",
        "id": 225602400,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1612815924
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276092\">@Nathanael Arkor</span> </p>\n<blockquote>\n<p>Do you mean you want to add an isomorphism between every pair of elements of the set, considered as objects of the category?</p>\n</blockquote>\n<p>Yes.  So the objects of the categories(groupoids) are the sets and the morphisms of the categories are every isomorphism of the set to itself.  I am picturing being able to do this with sets of sets and then you have categories with more than one object and you just add to the Category all the endo-isos and all isos between all of the sets.</p>",
        "id": 225624148,
        "sender_full_name": "Ben Sprott",
        "timestamp": 1612826351
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276092\">@Nathanael Arkor</span> </p>\n<blockquote>\n<p>The forgetful functor from categories to sets has a right adjoint, given by sending each set to the <a href=\"https://ncatlab.org/nlab/show/indiscrete+category\">codiscrete category</a> on that set (which is precisely adding isomorphisms between each pair of elements). This functor factors through the category of groupoids. (Note that the categories in the image of this functor are all equivalent to the terminal category, though.)</p>\n</blockquote>\n<p>So does this mean there is a construction like I'm describing, but it's trivial?</p>",
        "id": 225624253,
        "sender_full_name": "Ben Sprott",
        "timestamp": 1612826416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308261\">Ben Sprott</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Groupoids.20and.20Sets/near/225624148\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276092\">Nathanael Arkor</span> </p>\n<blockquote>\n<p>Do you mean you want to add an isomorphism between every pair of elements of the set, considered as objects of the category?</p>\n</blockquote>\n<p>Yes.  So the objects of the categories(groupoids) are the sets and the morphisms of the categories are every isomorphism of the set to itself.  I am picturing being able to do this with sets of sets and then you have categories with more than one object and you just add to the Category all the endo-isos and all isos between all of the sets.</p>\n</blockquote>\n<p>What you describe here sounds like the category of sets and bijections. But this is a specific category. (Also, \"set of sets\" doesn't make sense: the collection of all sets forms a proper class, not a set.)</p>",
        "id": 225624365,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1612826514
    },
    {
        "content": "<p>While Ben said </p>\n<blockquote>\n<p>Yes.</p>\n</blockquote>\n<p>his answer to Nathanaels' question actually seems to be \"No\".   Remember Nathanael's question:</p>\n<blockquote>\n<p>Do you mean you want to add an isomorphism between every pair of elements of the set, considered as objects of the category?</p>\n</blockquote>\n<p>This one of two famous ways to turn a set into a groupoid.  In this way, you take the objects of the groupoid to be elements of your set, and put in one isomorphism from each object to each other object.</p>",
        "id": 225627358,
        "sender_full_name": "John Baez",
        "timestamp": 1612828699
    },
    {
        "content": "<p>Since Ben was originally asking about how to get an adjunction between the category of groupoids and the category of finite sets, Nathanael's question was a good one.  Nathanael was talking about one of the two famous ways to do this.</p>",
        "id": 225627551,
        "sender_full_name": "John Baez",
        "timestamp": 1612828810
    },
    {
        "content": "<p>But then, Ben's comment:</p>\n<blockquote>\n<p>So the objects of the categories (groupoids) are the sets and the morphisms of the categories are every isomorphism of the set to itself. I am picturing being able to do this with sets of sets and then you have categories with more than one object and you just add to the Category all the endo-isos and all isos between all of the sets.</p>\n</blockquote>\n<p>shoots off in a completely different direction.  So I can no longer tell what he was asking about.</p>\n<p>He seems now to be talking about a specific groupoid: the groupoid with sets as objects and bijections as morphisms.</p>",
        "id": 225627964,
        "sender_full_name": "John Baez",
        "timestamp": 1612829082
    },
    {
        "content": "<p>I have been accused many times of going on \"fishing expeditions\".  I get some intuition, usually from my experiences as a physicist, and I try to phrase it mathematically with my tiny toolbox.</p>\n<p><span class=\"user-mention\" data-user-id=\"275920\">@John Baez</span> </p>\n<blockquote>\n<p>He seems now to be talking about a specific groupoid: the groupoid with sets as objects and bijections as morphisms.</p>\n</blockquote>\n<p>Perhaps this better describes what I am thinking of.  I may be thinking of the functor from Set to the groupoid of sets and bijections.   This functor works by forgetting every function except the isomorphisms.  Could this have an adjoint?  Does it extend to a functor from Cat to Groupoid which works by forgetting every morphism in every category except the isomorphisms.  Does this have an adjoint?</p>",
        "id": 225750770,
        "sender_full_name": "Ben Sprott",
        "timestamp": 1612901779
    },
    {
        "content": "<p><a href=\"https://ncatlab.org/nlab/show/core\">I this this the core?</a></p>",
        "id": 225751116,
        "sender_full_name": "Ben Sprott",
        "timestamp": 1612901961
    },
    {
        "content": "<p>You can't define a functor from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"normal\">B</mi><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">j</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Set} \\to \\mathrm{Bij}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">t</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">B</span><span class=\"mord mathrm\">i</span><span class=\"mord mathrm\">j</span></span></span></span></span> by \"forgetting noninvertible functions\", because a functor has to map every morphism in the domain to a morphism in the codomain. There is, however, a functor in the other direction <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">B</mi><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">j</mi></mrow><mo>↪</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Bij} \\hookrightarrow \\mathrm{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">B</span><span class=\"mord mathrm\">i</span><span class=\"mord mathrm\">j</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↪</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">t</span></span></span></span></span> including sets and bijections into sets and functions. (And this indeed extends to a functor from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">G</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">d</mi></mrow><mo>↪</mo><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Gpd} \\hookrightarrow \\mathrm{Cat}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">G</span><span class=\"mord mathrm\">p</span><span class=\"mord mathrm\">d</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↪</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">C</span><span class=\"mord mathrm\">a</span><span class=\"mord mathrm\">t</span></span></span></span></span>).</p>",
        "id": 225751148,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1612901985
    },
    {
        "content": "<p>And yes, the core gives a right adjoint to this inclusion <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">G</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">d</mi></mrow><mo>↪</mo><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Gpd} \\hookrightarrow \\mathrm{Cat}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">G</span><span class=\"mord mathrm\">p</span><span class=\"mord mathrm\">d</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↪</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">C</span><span class=\"mord mathrm\">a</span><span class=\"mord mathrm\">t</span></span></span></span></span>.</p>",
        "id": 225751303,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1612902048
    },
    {
        "content": "<p>Does this adjunction generate a monad on Groupoid?  If so, what is that monad?  What about on Cat?</p>",
        "id": 225773197,
        "sender_full_name": "Ben Sprott",
        "timestamp": 1612913289
    },
    {
        "content": "<p>Every adjunction induces a monad on the domain of the left adjoint, and a comonad on the codomain. These functors are very simple, so it would be a good exercise to work out what they are yourself.</p>",
        "id": 225776887,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1612915671
    }
]