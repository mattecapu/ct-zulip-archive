[
    {
        "content": "<p>Suraaj K S<a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/450998286\">10:48 AM</a></p>\n<p>I've been trying to learn a little bit about how category connects to logic and type theory.<br>\nBackground wise, I'm familiar with category theory at the level of Awodey / Leinser's book, and axiomatic set theory (ZFC). I think that it's safe to assume that I know very little about type theory.</p>\n<p>Here are some books/ resources I came across:</p>\n<ul>\n<li>Categorical Logic and Type Theory - B. Jacobs</li>\n<li>Categories for Types - Roy L. Crole</li>\n<li>Awodey's course notes: <a href=\"https://awodey.github.io/catlog/notes/\">https://awodey.github.io/catlog/notes/</a></li>\n<li>Mike Shulman's Notes - <a href=\"https://mikeshulman.github.io/catlog/catlog.pdf\">https://mikeshulman.github.io/catlog/catlog.pdf</a></li>\n<li>Evan Patterson's video / thesis - <a href=\"https://youtu.be/-_Yg-A8_lIY?si=j676scjeNnX_e_dk\">https://youtu.be/-_Yg-A8_lIY?si=j676scjeNnX_e_dk</a><div class=\"youtube-video message_inline_image\"><a data-id=\"-_Yg-A8_lIY\" href=\"https://youtu.be/-_Yg-A8_lIY?si=j676scjeNnX_e_dk\"><img src=\"https://uploads.zulipusercontent.net/0e3d089a6fbab1ca6f82aff8876ffca2efac4e43/68747470733a2f2f692e7974696d672e636f6d2f76692f2d5f59672d41385f6c49592f64656661756c742e6a7067\"></a></div></li>\n</ul>\n<p>I am sure that there an many other resources.</p>\n<p>Something that I was quite surprised about was that these books seemed to give 'start off' with things which are quite different:</p>\n<ul>\n<li>Jacobs book starts with something called \"Fibred category theory\"</li>\n<li>Mike Shulman's notes use \"Multicategories\"</li>\n<li>Evan Patternson's video says that categorical logic is purely '2-Categorical' (which I think is different from being a multicategory)</li>\n<li>And there are many resources that seem to start with something called a \"Topos\"</li>\n</ul>\n<p>I was wondering how similar / different all these approaches are? <br>\nIs there a 'standard' approach that people use, and which book / resource would be a good starting point for that?<br>\nHow to these other approaches (maybe using Multicategories) relate to the standard approach?</p>",
        "id": 450999677,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1720796023
    },
    {
        "content": "<p>I guess which reference you're looking for depends on what, precisely, you mean when you say \"logic\". </p>\n<p>I'm going to recommend \"Introduction to Higher Order Categorical Logic\" by Lambek and Scott. If any book is a standard reference in categorical logic it is that one. I think it should be pretty approachable given your background.</p>",
        "id": 451005789,
        "sender_full_name": "Chad Nester",
        "timestamp": 1720797247
    },
    {
        "content": "<p>The book spends a lot of time on the correspondence between the simply-typed lambda calculus and cartesian closed categories. I think if you're looking to learn some basic type theory this would be a good way to do it.</p>",
        "id": 451006270,
        "sender_full_name": "Chad Nester",
        "timestamp": 1720797359
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"690871\">@Chad Nester</span> , thanks for your response. I'd still be a little curious as to <em>why</em> so many different approaches are used, and whether all of them are different ways of looking at the same thing..</p>",
        "id": 451009554,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1720797986
    },
    {
        "content": "<p>This is naturally going to be a bit sloppy because of space constraints, but here's the general idea. As a tl;dr, yes I think these people are all more-or-less talking about the same thing.</p>\n<p>First, we have to realize there are multiple interesting \"logics\" one can study. There's a LOT to say here, but one quick observation is that \"weak\" logics can't say much, but what they can say is true in a lot of settings, whereas \"strong\" logics can say lots of things, but what they can say only matters in more limited circumstances. </p>\n<p>For instance, if you're working with \"equational logic\", where all your axioms have to be equations between terms, you can interpret models inside any category with finite products. This gives you access to models in LOTS of settings (which is freeing!), but you can only express equational things (which is limiting!). Contrast this with, say \"geometric logic\", where your axioms can be much more flexible, so you can express lots of interesting properties (which is freeing!), but now you only get models inside topoi (which is limiting).</p>\n<p>How does this work? In broad strokes, you think of an object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> in your category as a \"context\". That means the expressions your write down are allowed to have a variable \"of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>\". A colloquial example might be </p>\n<p>\"let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>v</mi><mo>⃗</mo></mover><mo>:</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">\\vec{v} :V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.714em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.2077em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.471em\" height=\"0.714em\" style=\"width:0.471em\" viewBox=\"0 0 471 714\" preserveAspectRatio=\"xMinYMin\"><path d=\"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z\"/></svg></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>w</mi><mo>⃗</mo></mover><mo>:</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">\\vec{w} : V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.714em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1522em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.471em\" height=\"0.714em\" style=\"width:0.471em\" viewBox=\"0 0 471 714\" preserveAspectRatio=\"xMinYMin\"><path d=\"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z\"/></svg></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>. Then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>v</mi><mo>⃗</mo></mover><mo>+</mo><mover accent=\"true\"><mi>w</mi><mo>⃗</mo></mover><mo>=</mo><mover accent=\"true\"><mi>w</mi><mo>⃗</mo></mover><mo>+</mo><mover accent=\"true\"><mi>v</mi><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{v} + \\vec{w} = \\vec{w} + \\vec{v}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7973em;vertical-align:-0.0833em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.2077em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.471em\" height=\"0.714em\" style=\"width:0.471em\" viewBox=\"0 0 471 714\" preserveAspectRatio=\"xMinYMin\"><path d=\"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z\"/></svg></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.714em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1522em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.471em\" height=\"0.714em\" style=\"width:0.471em\" viewBox=\"0 0 471 714\" preserveAspectRatio=\"xMinYMin\"><path d=\"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z\"/></svg></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7973em;vertical-align:-0.0833em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1522em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.471em\" height=\"0.714em\" style=\"width:0.471em\" viewBox=\"0 0 471 714\" preserveAspectRatio=\"xMinYMin\"><path d=\"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z\"/></svg></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.714em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.2077em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.471em\" height=\"0.714em\" style=\"width:0.471em\" viewBox=\"0 0 471 714\" preserveAspectRatio=\"xMinYMin\"><path d=\"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z\"/></svg></span></span></span></span></span></span></span></span></span></span>.\"</p>\n<p>The context is \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>v</mi><mo>⃗</mo></mover><mo>:</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">\\vec{v} :V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.714em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.2077em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.471em\" height=\"0.714em\" style=\"width:0.471em\" viewBox=\"0 0 471 714\" preserveAspectRatio=\"xMinYMin\"><path d=\"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z\"/></svg></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>w</mi><mo>⃗</mo></mover><mo>:</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">\\vec{w} : V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.714em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1522em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.471em\" height=\"0.714em\" style=\"width:0.471em\" viewBox=\"0 0 471 714\" preserveAspectRatio=\"xMinYMin\"><path d=\"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z\"/></svg></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>\". It tells you what variables you have access to. Then <em>in this context</em> we're able to ask the question <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>v</mi><mo>⃗</mo></mover><mo>+</mo><mover accent=\"true\"><mi>w</mi><mo>⃗</mo></mover><mo>=</mo><mover accent=\"true\"><mi>w</mi><mo>⃗</mo></mover><mo>+</mo><mover accent=\"true\"><mi>v</mi><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{v} + \\vec{w} = \\vec{w} + \\vec{v}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7973em;vertical-align:-0.0833em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.2077em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.471em\" height=\"0.714em\" style=\"width:0.471em\" viewBox=\"0 0 471 714\" preserveAspectRatio=\"xMinYMin\"><path d=\"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z\"/></svg></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.714em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1522em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.471em\" height=\"0.714em\" style=\"width:0.471em\" viewBox=\"0 0 471 714\" preserveAspectRatio=\"xMinYMin\"><path d=\"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z\"/></svg></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7973em;vertical-align:-0.0833em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1522em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.471em\" height=\"0.714em\" style=\"width:0.471em\" viewBox=\"0 0 471 714\" preserveAspectRatio=\"xMinYMin\"><path d=\"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z\"/></svg></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.714em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.2077em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.471em\" height=\"0.714em\" style=\"width:0.471em\" viewBox=\"0 0 471 714\" preserveAspectRatio=\"xMinYMin\"><path d=\"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z\"/></svg></span></span></span></span></span></span></span></span></span></span>, which has some truth value. We can interpret the context (with two variables of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>) as the object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>×</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V \\times V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> in our category. We think about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>v</mi><mo>⃗</mo></mover><mo>+</mo><mover accent=\"true\"><mi>w</mi><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{v} + \\vec{w}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7973em;vertical-align:-0.0833em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.2077em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.471em\" height=\"0.714em\" style=\"width:0.471em\" viewBox=\"0 0 471 714\" preserveAspectRatio=\"xMinYMin\"><path d=\"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z\"/></svg></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.714em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1522em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.471em\" height=\"0.714em\" style=\"width:0.471em\" viewBox=\"0 0 471 714\" preserveAspectRatio=\"xMinYMin\"><path d=\"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z\"/></svg></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>w</mi><mo>⃗</mo></mover><mo>+</mo><mover accent=\"true\"><mi>v</mi><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{w} + \\vec{v}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7973em;vertical-align:-0.0833em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1522em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.471em\" height=\"0.714em\" style=\"width:0.471em\" viewBox=\"0 0 471 714\" preserveAspectRatio=\"xMinYMin\"><path d=\"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z\"/></svg></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.714em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.2077em;\"><span class=\"overlay\" style=\"height:0.714em;width:0.471em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.471em\" height=\"0.714em\" style=\"width:0.471em\" viewBox=\"0 0 471 714\" preserveAspectRatio=\"xMinYMin\"><path d=\"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z\"/></svg></span></span></span></span></span></span></span></span></span></span> as being two arrows <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>×</mo><mi>V</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V \\times V \\to V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>, and we want these arrow to be equal (which we can express by the commutativity of a diagram).</p>\n<p>This brings us to the first thing you explicitly asked about, namely \"multicategories\". Instead of working with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>×</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V \\times V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> in order to get an arrow with multiple inputs (read: a context with multiple variables), it would be nice if we natively had access to arrows with multiple sources in the <em>definition</em> of a category. This is because things in the definition of a category are the only things <em>guaranteed</em> to be strict, and this allows us to sidestep some potentially annoying \"coherence issues\" that are a frequent problem in categorical logic. A <strong>multicategory</strong> is just a category where we allow arrows to have multiple inputs.</p>\n<p>How, I hear you asking, do we interpret more general propositions? Well, we assign to every type (read: object) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> a lattice <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> of \"propositions on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>\". These are supposed to be \"compatible\" in the sense that whenever we have a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f : A \\to B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and a proposition <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>∈</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\varphi(b) \\in P(B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">φ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span>, we should get a proposition on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> defined by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\varphi(f(a))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">φ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">))</span></span></span></span> (we say this is defined \"by pullback\"). This data is exactly a <strong>fibred category</strong>, where the fibre over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> in your category is exactly the lattice <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span>, and the arrows in the total category come from these pullback operations.</p>\n<p>To connect this with topoi, every topos has a natural <strong>subobject fibration</strong>, where we assign to the object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> the lattice <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Sub</mtext><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{Sub}(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">Sub</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> of subobjects of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>. This functor is represented by the \"subobject classifier\" <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Ω</mi></mrow><annotation encoding=\"application/x-tex\">\\Omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Ω</span></span></span></span>, which is (part of) why you see the subobject classifier get so much attention.</p>\n<p>Lastly, you ask why category theory is \"naturally 2-categorical\". Here Evan is getting at Lawvere's <strong>functorial semantics</strong>. Going back to equational theories because they're simpler, every theory has a \"classifying category\" <br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">C</mi><mi mathvariant=\"double-struck\">T</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{C}_\\mathbb{T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3322em;\"><span style=\"top:-2.55em;margin-left:-0.0583em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathbb mtight\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> so that models of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">T</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">T</span></span></span></span> in some category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">E</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{E}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.08944em;\">E</span></span></span></span> are exactly functors from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">C</mi><mi mathvariant=\"double-struck\">T</mi></msub><mo>→</mo><mi mathvariant=\"script\">E</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{C}_\\mathbb{T} \\to \\mathcal{E}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3322em;\"><span style=\"top:-2.55em;margin-left:-0.0583em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathbb mtight\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.08944em;\">E</span></span></span></span>! But the models are only half the story, where are the homomorphisms? It turns out that homomorphisms are exactly natural transformations between these functors!! So in order to get the whole category of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">T</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">T</span></span></span></span>-models in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">E</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{E}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.08944em;\">E</span></span></span></span>, you need access to the full 2-categorical structure of categories, functors, <em>and</em> natural transformations.</p>\n<p>So we see that these topics are all closely related, but they solve different problems that arise in the field.</p>\n<hr>\n<p>I hope this helps ^_^</p>",
        "id": 451037332,
        "sender_full_name": "Chris Grossack (they/them)",
        "timestamp": 1720806090
    },
    {
        "content": "<p>I was reading the wikepedia article on Categorical Logic: <a href=\"https://en.wikipedia.org/wiki/Categorical_logic\">https://en.wikipedia.org/wiki/Categorical_logic</a>.</p>\n<p>It says that there are 3 'themes' to categorical logic:</p>\n<ul>\n<li>Categorical Semantics</li>\n<li>Internal Languages</li>\n<li>Term-model constructions</li>\n</ul>\n<p>I was wondering if these three themes are 'independent', or interconnected? <br>\nA brief look seems to indicate that at least the first 2 (Categorical semantics and Internal languages) are quite independent ideas..</p>\n<p>For instance, Mike Shulman's notes: <a href=\"https://mikeshulman.github.io/catlog/catlog.pdf\">https://mikeshulman.github.io/catlog/catlog.pdf</a> seem to be about the second theme (type theories as internal languages). Moreover, searching for 'functorial semantics' in the pdf yields nothing!</p>\n<p>On the other hand, Steve Awodey's notes: <a href=\"https://awodey.github.io/catlog/notes/\">https://awodey.github.io/catlog/notes/</a> seem to be about the first theme.</p>\n<p>I don't really know what the third theme means, but it looks like it should just be part of the first theme, as indicated by the phrase </p>\n<blockquote>\n<p>In many cases, the categorical semantics of a logic provide a basis for establishing ...</p>\n</blockquote>\n<p>So, am I right in assuming that these are two separate ideas, and Categorical Logic is in some sense, an overloaded term?</p>",
        "id": 464368358,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1724331728
    },
    {
        "content": "<p>\"Introduction to Higher Order Categorical Logic\" by Lambek and Scott is my fav and best book ever!</p>",
        "id": 464371317,
        "sender_full_name": "Federica Pasqualone",
        "timestamp": 1724332123
    },
    {
        "content": "<p>'Logic' is an overloaded term. Categorical logic is at least cutting it down to a subset where categories are used in more-or-less essential ways :-)</p>",
        "id": 464382708,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1724333958
    },
    {
        "content": "<p>What about Suraaj's first question: are \"categorical semantics,\" \"internal languages\" and \"term-model constructions\" independent or interconnected?</p>\n<p>I know nothing about the third, but I'd hope that at least the first two are deeply connected.   For example geometric functors between topoi are part of categorical semantics, while every topos has its own internal language.   But these aren't independent ideas: a geometric functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">F: C \\to D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> should map models of geometric theories formulated in the internal language of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> to those formulated in the internal language of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>.   Or something like that - maybe an expert could say this more accurately.</p>",
        "id": 464387414,
        "sender_full_name": "John Baez",
        "timestamp": 1724335235
    },
    {
        "content": "<p>re: the third, you could call this \"initial model constructions\". the reason computer scientists call those \"term models\" is that the most direct route to construct them is from the \"terms\" (syntax) of the logic.  Anyway, in e.g. equational logic and many others you can always find a distinguished initial model of a theory via a universal property etc.  In fact in CQL we compute these all the time.</p>",
        "id": 464390018,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1724336049
    },
    {
        "content": "<p>Thanks!   If \"term models\" are initial models constructed synactically, which sounds completely believable,  then these are definitely closely connected to the theme of internal languages.   </p>\n<p>So now I will claim all 3 topics in the Wikipedia article on categorical logic are tightly connected, and the article should be rewritten to explain how.</p>",
        "id": 464392197,
        "sender_full_name": "John Baez",
        "timestamp": 1724336686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726654\">Suraaj K S</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/464368358\">said</a>:</p>\n<blockquote>\n<p>I was reading the wikepedia article on Categorical Logic: <a href=\"https://en.wikipedia.org/wiki/Categorical_logic\">https://en.wikipedia.org/wiki/Categorical_logic</a>.</p>\n<p>It says that there are 3 'themes' to categorical logic:</p>\n<ul>\n<li>Categorical Semantics</li>\n<li>Internal Languages</li>\n<li>Term-model constructions</li>\n</ul>\n<p>I was wondering if these three themes are 'independent', or interconnected? <br>\nA brief look seems to indicate that at least the first 2 (Categorical semantics and Internal languages) are quite independent ideas..</p>\n<p>For instance, Mike Shulman's notes: <a href=\"https://mikeshulman.github.io/catlog/catlog.pdf\">https://mikeshulman.github.io/catlog/catlog.pdf</a> seem to be about the second theme (type theories as internal languages). Moreover, searching for 'functorial semantics' in the pdf yields nothing!</p>\n<p>On the other hand, Steve Awodey's notes: <a href=\"https://awodey.github.io/catlog/notes/\">https://awodey.github.io/catlog/notes/</a> seem to be about the first theme.</p>\n<p>I don't really know what the third theme means, but it looks like it should just be part of the first theme, as indicated by the phrase </p>\n<blockquote>\n<p>In many cases, the categorical semantics of a logic provide a basis for establishing ...</p>\n</blockquote>\n<p>So, am I right in assuming that these are two separate ideas, and Categorical Logic is in some sense, an overloaded term?</p>\n</blockquote>\n<p>Check out my <a href=\"https://diliberti.notion.site/Suggested-Readings-4b5a05f6f26647cfb543d320edc3e358\">suggested reading</a>s.</p>",
        "id": 464408112,
        "sender_full_name": "Ivan Di Liberti",
        "timestamp": 1724340194
    },
    {
        "content": "<p>I would say that the \"categorical semantics\" of a logic consists in describing a category of structured categories that is related to the category of theories in that logic by an adjunction, where the two functors in the adjunction are the \"internal language\" of a category and the \"term model\" of a theory.</p>",
        "id": 464423640,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724343567
    },
    {
        "content": "<p>Nice, that ties it up neatly.</p>",
        "id": 464425058,
        "sender_full_name": "John Baez",
        "timestamp": 1724343901
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/464423640\">said</a>:</p>\n<blockquote>\n<p>I would say that the \"categorical semantics\" of a logic consists in describing a category of structured categories that is related to the category of theories in that logic by an adjunction, where the two functors in the adjunction are the \"internal language\" of a category and the \"term model\" of a theory.</p>\n</blockquote>\n<p>Thanks a lot! That seems concise enough to be put on a bumper sticker ;)<br>\nI was wondering if there are books / resources which mention this? IMHO, my ideal book on Categorial Logic would mention this at the very beginning, and the rest of the book would be various examples of this adjunction...</p>\n<p>Also, am I right when I think of the 'classic' 'equivalence' of Cartesian Closed Categories and STLC <strong>as an adjunction</strong> as mentioned above (with CCCs being the 'structured categories', and the category of theories in that logic being the category of STLC theories)?</p>",
        "id": 464888191,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1724525805
    },
    {
        "content": "<p>My unfinished notes, which you mentioned in the original post, are certainly written from that point of view, although I didn't emphasize that particular terminology.</p>",
        "id": 464918766,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724548306
    },
    {
        "content": "<p>One thing that's confusing is that we sometimes sloppily say that a logic or type theory X is \"an internal language for\" structured categories Y when they are related by a categorical-semantics adjunction, but that's a different meaning of \"internal language\" than when that phrase describes the right adjoint in the adjunction.</p>",
        "id": 464918898,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724548417
    },
    {
        "content": "<p>Also, it's worth noting that many people (but not me) would prefer that the adjunction is an equivalence.</p>",
        "id": 464918957,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724548445
    },
    {
        "content": "<p>I see. Thanks a lot for the explanation.</p>\n<p>I am a little curious about the following sentence - </p>\n<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/464423640\">said</a>:</p>\n<blockquote>\n<p>the \"categorical semantics\" of a logic consists in describing a category of structured categories that is related to the category of theories in that logic .</p>\n</blockquote>\n<p>Here, examples of 'logic' would be equational logic, STLC, FOL, etc., right?<br>\nAnd are 'theories in that logic' simply a pair consisting of a signature and a set of axioms. For instance, ZFC is a 'theory' of FOL. (I'm curious what the morphisms between two theories are...)<br>\nOne also talks about 'models' (sometimes called algebras?), but I guess that the category of structured categories takes this role? That is, for each 'theory' we have a category of models (which is an object of the category of structured categories...)</p>",
        "id": 465291831,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1724717385
    },
    {
        "content": "<p>Yes, those are examples of what I meant by \"logics\".  Whatever we call it, the class of objects in question also includes type theories (like STLC and MLTT); sometimes these are also called \"doctrines\" or \"2-theories\".  Note that in general each such \"logic\" is multi-sorted.</p>",
        "id": 465519874,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724781323
    },
    {
        "content": "<p>And yes, a signature and a set of axioms is basically what I mean by a \"theory\" in a logic.  Defining the morphisms between theories is part of where you get into the question of whether the adjunction is an equivalence.  I would choose a morphism of theories <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>→</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">S\\to T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> to consist of maps of signatures and axioms, sending each base type of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> to a base type of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>, each function symbol of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> to a function symbol of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>, and each axiom of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> to an axiom of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>.  But there are successive weakenings of this where you first allow axioms of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> to go to <em>theorems</em> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> rather than axioms, then allow function symbols to go to arbitrary terms, then allow base types to go to arbitrary types.  The fully relaxed version is what tends to get you an equivalence between theories and categories, but it remembers much less about what distinguishes a theory from its term model.</p>",
        "id": 465520691,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724781513
    },
    {
        "content": "<p>As for models, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> is a theory and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> is a structured category, then a model of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> is a structured functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">m</mi></mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Tm}(T) \\to C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Tm</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>, or equivalently a theory morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>→</mo><mrow><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">g</mi></mrow><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T \\to \\mathrm{Lang}(C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\" style=\"margin-right:0.01389em;\">Lang</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span>.  (In the latter case it doesn't really matter which morphisms of theories you take, since theories of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">g</mi></mrow><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Lang}(C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\" style=\"margin-right:0.01389em;\">Lang</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span> are \"saturated\" in that every theorem is an axiom, every term is represented by a function symbol, and every type is isomorphic to a base type.)  Although the choice of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">m</mi></mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Tm}(T) \\to C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Tm</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> is usually better since then you get without any extra work the whole <em>category</em> of models, since a category of structured categories is actually a 2-category, whereas the category of theories is less obviously anything other than a 1-category.</p>",
        "id": 465521319,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724781661
    },
    {
        "content": "<p>Thanks for the explanation!</p>\n<p>In Jacob's book: <a href=\"https://people.mpi-sws.org/~dreyer/courses/catlogic/jacobs.pdf\">https://people.mpi-sws.org/~dreyer/courses/catlogic/jacobs.pdf</a>, I think what's happening is that what we call \"logics\" / \"doctrines\" , etc. seem to be <em>split</em> into a 'logic' part and a 'type theory' part. For instance, in section 0.1, we have \"a logic is always a logic over a type theory\". Moreover, it seems like we can 'mix and match' different 'logics' and 'type theories'(according to Jacob's) to form different 'doctrines' (the previous discussion).</p>\n<p>Moreover, in that book, we have the following sentence: \"Categorically this will correspond to one (\"total\") category, capturing the logic, being fibred over another (\"base\") category, capturing the type theory\".</p>\n<p>I was wondering how this 'fibred' category maps to our previous discussion where we have:</p>\n<ol>\n<li>a category of structured categories (lets call it Str)</li>\n<li>a category of theories (lets call it Th)</li>\n<li>an adjunction between Tm: Th → Str and Lang: Str → Th</li>\n</ol>\n<p>Is the 'fibred' category simply a particular object in Str?</p>",
        "id": 465754016,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1724848988
    },
    {
        "content": "<p>Yes, that's right.  Sometimes a \"structured category\" means a category together with a fibration over it, or even something more like two fibrations, etc.  In that case the corresponding doctrine has two classes of types, one or more of which might be called \"propositions\", and the part of the doctrine pertaining to terms belonging to \"propositions\" is traditionally called the \"logic\".</p>",
        "id": 465822945,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724867711
    },
    {
        "content": "<p>Thanks a lot for your patience and response! I hope this was not too annoying.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/465822945\">said</a>:</p>\n<blockquote>\n<p>In that case the corresponding doctrine has two classes of types, one or more of which might be called \"propositions\", and the part of the doctrine pertaining to terms belonging to \"propositions\" is traditionally called the \"logic\".</p>\n</blockquote>\n<p>This reminds me a little bit about how we have <code>Prop</code> and <code>Set</code>, etc. in Coq. I was wondering if this is related?</p>",
        "id": 465828120,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1724870009
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/465520691\">said</a>:</p>\n<blockquote>\n<p>a signature and a set of axioms is basically what I mean by a \"theory\" in a logic</p>\n</blockquote>\n<p>Hopefully, this is my last question (for now ;)). I'm guessing that a 'signature' here is a collection of sorts and <strong>first order</strong> function symbols (with constants being a special case). </p>\n<p>I also think CT cannot handle 'higher order' function symbols, which (I think) was the point of the discussion here: <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Did.20Category.20Theory.20catch.20up.3F/near/453035014\">https://categorytheory.zulipchat.com/#narrow/stream/229199-learning.3A-questions/topic/Did.20Category.20Theory.20catch.20up.3F/near/453035014</a>...</p>",
        "id": 465828589,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1724870210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726654\">Suraaj K S</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/465828120\">said</a>:</p>\n<blockquote>\n<p>This reminds me a little bit about how we have <code>Prop</code> and <code>Set</code>, etc. in Coq. I was wondering if this is related?</p>\n</blockquote>\n<p>Yes, it's related.  It's not exactly the same because Coq is a <em>dependent</em> type theory so that everything is all mixed up, with <code>Prop</code> and <code>Set</code> not being judgment forms but <em>types</em> themselves.  But if you replace <code>A : Prop</code> with a judgment <code>A prop</code> and so on, you get the judgmental structure of a fibred logic of this sort, as in chapter 4 of my notes.</p>",
        "id": 465829878,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724870718
    },
    {
        "content": "<p>I like the fibrational perspective because I think toposes can sometimes bake in too much of a tight connection between propositions and types. For example, I don't think in the setting of a fibration modelling higher order logic, we have (for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo separator=\"true\">,</mo><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">P, Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>∧</mo><mi>Q</mi><mo>→</mo><mi mathvariant=\"normal\">⊥</mi></mrow><annotation encoding=\"application/x-tex\">P \\land Q \\to \\bot</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">⊥</span></span></span></span>)</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>∣</mo><mi>P</mi><mi>x</mi><mo>∨</mo><mi>Q</mi><mi>x</mi><mo stretchy=\"false\">}</mo><mo>≅</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>∣</mo><mi>P</mi><mi>x</mi><mo stretchy=\"false\">}</mo><mo>+</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>∣</mo><mi>Q</mi><mi>x</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{ x : A  \\mid P x \\lor Q x \\} \\cong \\{ x  :A \\mid Px \\} + \\{ x : A \\mid Qx \\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∨</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">}</span></span></span></span><br>\nWhereas this is true in a topos.</p>\n<p>To me, this seems like not something you would not to follow automatically. Toposes are a little bit too strong in that regard.</p>",
        "id": 465830780,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1724871118
    },
    {
        "content": "<p>I love fibrations, but I don't really intuit why one might expect your example to ever fail to be true.</p>",
        "id": 465830964,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724871209
    },
    {
        "content": "<p>As for the meaning of \"signature\", in general it depends on the doctrine.  A signature for a doctrine (which I would prefer to define in general to include the \"axioms\", since axioms are \"really\" just higher-dimensional generators) should consist of \"generators\" for all the sorts of the doctrine.  So, for instance, in STLC, a signature consists of generating types, generating terms, and generating equalities (= 2-cells = relations between terms).</p>\n<p>A \"generating term\" is also known as a function symbol, which has types as its input(s) and output(s).  But you can make different choices about whether those input and output types must be <em>generating</em> types or <em>arbitrary</em> types.  If they are required to be generating types, then the function symbol is \"first-order\", whereas if they are allowed to be arbitrary types (and the doctrine contains higher-order type-formers like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>→</mo></mrow><annotation encoding=\"application/x-tex\">\\to</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">→</span></span></span></span>) then the function symbol is \"higher-order\".  There's no problem with higher-order function symbols or their semantics in categories with higher-order structure.</p>",
        "id": 465831224,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724871322
    },
    {
        "content": "<p>I didn't read that other thread carefully, but I gathered the point was that there's no good notion of non-invertible morphism between models of a higher-order theory due to contravariance.  This seems to me like just a fact, and I'm not quite sure why one would think that there should be such a notion.  In any case there's no problem with higher-order function symbols in a doctrine that has higher-order type formers, although the construction of the adjunction is somewhat more involved (it goes like the one for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>×</mo></mrow><annotation encoding=\"application/x-tex\">\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">×</span></span></span></span>-presentations in section 1.7.3 of my notes).</p>",
        "id": 465831582,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724871471
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/465830964\">said</a>:</p>\n<blockquote>\n<p>I love fibrations, but I don't really intuit why one might expect your example to ever fail to be true.</p>\n</blockquote>\n<p>Hahahaha, yes, I agree it is a bit common sense,  it's not that I have a counterexample semantics in mind that is persuasive to me, it's just that I don't like the proof and the way it relies on theorems about topos theory, the fact that it fails in a general higher order fibration makes me suspect that there's some blurring of logic and semantics going on in the topos theoretic proof where we \"cheat\" by passing to the semantics to establish what should be a logical theorem.</p>\n<p>I am sure there are formulations of intuitionistic higher-order logic that are complete for topos theory, but since this fails in fibrations, it seems that completeness  for the topos theoretic semantics is not robust with respect to small changes in the proof calculus for intuitionistic higher order logic.</p>",
        "id": 465832042,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1724871641
    },
    {
        "content": "<p>Well, personally I think a better internal language for toposes is dependent type theory.  You can more or less code all of mathematics in IHOL, but there are parts of it (like category theory!) that are much more natural in DTT.  And in DTT, your example is provable.</p>",
        "id": 465832740,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724871915
    },
    {
        "content": "<p>I think one thing (perhaps the main thing?) that fails in a general higher-order fibration relative to a topos, and which is related to your example, is function comprehension, a.k.a. unique choice: from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo>:</mo><mi>A</mi><mi mathvariant=\"normal\">∃</mi><mo stretchy=\"false\">!</mo><mi>y</mi><mo>:</mo><mi>B</mi><mi mathvariant=\"normal\">.</mi><mi>φ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall x:A \\exists! y:B. \\varphi(x,y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord\">∃</span><span class=\"mclose\">!</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">φ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span> we can't deduce the existence of a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f:A\\to B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo>:</mo><mi>A</mi><mi mathvariant=\"normal\">.</mi><mi>φ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall x:A. \\varphi(x,f(x))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">φ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span></span></span></span>.  Again, this is a pretty unintuitive failure, and the most common thing we do with a higher- order fibration that fails it is construct a category in which it does hold, e.g. the tripos-to-topos construction.</p>",
        "id": 465833150,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724872087
    },
    {
        "content": "<p>Thanks a lot. This has been very enlightening. <br>\nI guess my initial confusions arose because I thought there was a 'unique way' to do Categorical semantics for a logic, stemming from 'cool CT things' like the 'Curry-Howard-Lambek' correspondence, etc. where people say that STLC and CCCs 'are the same thing'. I guess that I thought that every doctrine (eg. STLC) would be 'the same as' some structured category (eg. CCC). However, it seems like it's not the case. It seems like we could choose some other Structured Category - For instance, it seems like we could use both Fibred categories as well as Topoi as our 'structured categories' for some doctrine (Idk which doctrine was being discussed exactly. Or maybe the point is that they work for all of them...). Now, I'm curious about things like soundness/completeness though.. Do we only have 'completeness' when the adjunction is an equivalence?</p>",
        "id": 465868358,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1724889744
    },
    {
        "content": "<p>Completeness, in the categorical sense, basically follows from the construction of the term model.  If something is true in all structured categories, then it's true in the term model, and therefore it's provable in the theory since the term model is constructed so that the things true in it are precisely those provable in the theory.  (Classically, completeness sometimes refers more specifically to completeness relative to <em>one specific</em> structured category such as Set; that's a much more special property that only holds for some doctrines and theories.)</p>",
        "id": 465880606,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724898789
    },
    {
        "content": "<p>It's true in general that a single syntactic doctrine can correspond to more than one kind of structured category.  Patrick and I were talking about the syntactic doctrine of Intuitionistic Higher-Order Logic, which has semantics both in a kind of \"higher-order fibration\" and also in toposes.  I'm not sure how special of a situation this is.</p>\n<p>In a certain sense the higher-order fibrations are the more \"natural\" semantics of IHOL, since they represent its judgmental structure more directly, e.g. they have two classes of objects corresponding to the two judgments \"is a type\" and \"is a proposition\" of IHOL.  It's usually possible to write down a \"natural\" semantics of any syntactic theory in this way by simply translating judgments to objects and morphisms.  But if you take it seriously, sometimes what you get isn't what most people think of!  E.g. the \"natural\" semantics of STLC is not really cartesian closed <em>categories</em> but rather cartesian closed <em>multicategories</em>.  Of course CCCs and CCMCs are \"equivalent\" in a certain sense.</p>\n<p>On the other hand, for highly structured categories like toposes and LCCCs, there doesn't seem to be a syntactic doctrine for which they are exactly the \"natural\" semantics.  So instead we pass through an intermediate structure, like a higher-order fibration or a \"category with families\", that is the natural semantics of a doctrine like IHOL or DTT.</p>",
        "id": 465881688,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724899421
    },
    {
        "content": "<p>And my last two messages are a bit contradictory: completeness is only really \"automatic\" in the case of the \"natural\" semantics, since that's the case when the term model can be constructed directly out of the judgments in the theory.  So Patrick's point was in general well-taken, that for, e.g., the semantics of IHOL in toposes, there may be things that hold in all topos models but aren't provable syntactically.  IIRC I think this doesn't precisely happen for IHOL and toposes, because the things that hold in all toposes but not all higher-order fibrations (like Patrick's example) aren't expressible internally in the syntax of IHOL; but even if I'm right about that, it's sort of an accident.</p>",
        "id": 465882003,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724899568
    },
    {
        "content": "<p>(Or, one might say, a consequence of the very special nature of toposes.)</p>",
        "id": 465882144,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724899627
    },
    {
        "content": "<p>(Or, another one might say, the impoverished syntax of IHOL.)</p>",
        "id": 465882197,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1724899654
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/465880606\">said</a>:</p>\n<blockquote>\n<p>Completeness, in the categorical sense, basically follows from the construction of the term model</p>\n</blockquote>\n<p>Just to confirm, this is the sentence which is not exactly correct? Completeness 'basically follows' only when we have the 'natural semantics'?</p>",
        "id": 466275428,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1725026525
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 466309188,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1725036835
    },
    {
        "content": "<p>Another thing that I think happens is that these 'doctrines' can be <em>programming languages</em> too, and you can similarly give categorical semantics to programming languages too? And in many cases (I think), that these PL 'doctrines' are lousy logics because they are inconsistent (because nonterminating programs are 'proofs' of ⊥)? I think this book: <a href=\"https://www.cambridge.org/core/books/categories-for-types/258841251C62FED1DACD20884E59E61C\">https://www.cambridge.org/core/books/categories-for-types/258841251C62FED1DACD20884E59E61C</a> takes that view?</p>",
        "id": 466384041,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1725060982
    },
    {
        "content": "<p>Yes, many doctrines have a computational interpretation, and so many programming languages have corresponding doctrines.  And yes, if the programming language is Turing-complete, then every type in the doctrine will be inhabited by some term, which means that the corresponding categories can't have strict initial objects the way topos-like categories usually do.  Instead, the corresponding categories are those arising from domain theory.  As you say, it's hard to use a naive propositions-as-types interpretation of logic when all types are inhabited, but there may be things you can do.</p>",
        "id": 466386600,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1725062466
    },
    {
        "content": "<p>Why does Turing completeness imply inhabitedness of all types? If I consider the unityped lambda calculus, which is Turing complete, and add a second type with no term formers, the calculus can still compute every Turing-computable function, so I would have thought this would be considered Turing complete without having all types inhabited.</p>",
        "id": 466478153,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1725088465
    },
    {
        "content": "<p>Usually you add a fixed point combinator of type fix_X : (X-&gt;X)-&gt;X and then every type would be inhabited by \"fix id\", or show that such a construction can be emulated already (in the case of the untyped lambda calculus the Y combinator plays the role of fix for example).  It's an interesting exercise to write a term of type \"Void\" in Haskell for example.</p>",
        "id": 466542865,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1725112431
    },
    {
        "content": "<p>Yes, I was thinking of Turing-completeness at every type, according to which the empty function is one of the partial functions that would be required to be represented.  I guess it's true that you could have a language that's Turing-complete at some types and not others.</p>",
        "id": 466566746,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1725118507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281326\">Ryan Wisnesky</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/466542865\">said</a>:</p>\n<blockquote>\n<p>It's an interesting exercise to write a term of type \"Void\" in Haskell for example.</p>\n</blockquote>\n<p>Do you mean in some more complicated way than</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>e :: Void<br>\ne = e</p>\n</div></div>\n<p>?</p>",
        "id": 466571783,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1725120022
    },
    {
        "content": "<p>that's indeed what I meant; the pedagogy is in discovering why you can't write that same definition in e.g. Coq, how recursion is implicit in Haskell, and how axioms such as letrec can lead to terms in types that at first appear to have no constructors (such as Void).</p>",
        "id": 466573834,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1725120591
    },
    {
        "content": "<p>Ah, yes.  Sorry, it sounded to me like you were suggesting that writing such a term required using a fixpoint combinator.</p>",
        "id": 466604654,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1725136781
    },
    {
        "content": "<p>I'm a little curious if / how <strong>Logical Relations</strong> might fit into this framework?</p>",
        "id": 466781143,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1725236748
    },
    {
        "content": "<p>Logical Relations basically consist of interpreting a theory in a special sort of diagram/glued category.  I wrote an old <a href=\"https://golem.ph.utexas.edu/category/2013/04/scones_logical_relations_and_p.html\">blog post</a> about it from that point of view.</p>",
        "id": 466956993,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1725284667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/466956993\">said</a>:</p>\n<blockquote>\n<p>Logical Relations basically consist of interpreting a theory in a special sort of diagram/glued category.  I wrote an old <a href=\"https://golem.ph.utexas.edu/category/2013/04/scones_logical_relations_and_p.html\">blog post</a> about it from that point of view.</p>\n</blockquote>\n<p>I see. I was wondering if this also follows the 'general shape' of categorical semantics (with a category of structured categories, a category of theories, and an adjunction?), where these 'diagram/glued categories' are the 'structured categories'?</p>",
        "id": 466962011,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1725285727
    },
    {
        "content": "<p>The diagram/glued category (for a particular shape of logical relations) is <em>one</em> of the structured categories.</p>",
        "id": 466968707,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1725287225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/466968707\">said</a>:</p>\n<blockquote>\n<p>The diagram/glued category (for a particular shape of logical relations) is <em>one</em> of the structured categories.</p>\n</blockquote>\n<p>Oh yes. Okay, that makes sense...</p>",
        "id": 467039362,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1725307440
    },
    {
        "content": "<p>I'm also guessing that we can use the same ideas with \"fancier\" type theories / doctrines like HoTT?</p>\n<p>On a related note, if I understand correctly, we have an adjunction between the category of infinity groupoids (the category of structured categories), and the theories of MLTT?</p>",
        "id": 467040079,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1725307681
    },
    {
        "content": "<p>Yes, you can do the same thing with HoTT and so on, but there are two different ways to do it.  On one hand, you can work with 1-categorical presentations of structured higher categories like categories with families, and then you can expect an ordinary 1-adjunction just like for ordinary type theories.  On the other hand, you can work with a higher category of structured higher categories, but then things get a bit more fraught and you may need to invert some \"weak equivalence\" theory morphisms.</p>",
        "id": 467044865,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1725309168
    },
    {
        "content": "<p>For MLTT, the structured categories are \"directly\" categories with families with the appropriate type structure.  The more indirect version is locally cartesian closed <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-categories (for intensional MLTT with funext), although technically that is still a conjecture.  The <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-category of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">∞</span></span></span></span>-groupoids is <em>one</em> such structured category.</p>",
        "id": 467045322,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1725309274
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/467044865\">said</a>:</p>\n<blockquote>\n<p>On one hand, you can work with 1-categorical presentations of structured higher categories like categories with families, and then you can expect an ordinary 1-adjunction just like for ordinary type theories. On the other hand, you can work with a higher category of structured higher categories, but then things get a bit more fraught and you may need to invert some \"weak equivalence\" theory morphisms.</p>\n</blockquote>\n<p>I was wondering if there are pros / cons of both approaches? The first does seem simpler / easier</p>",
        "id": 467048902,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1725310982
    },
    {
        "content": "<p>I'm curious if 'theories' of doctrines 'can be' docrines themselves?</p>\n<p>For instance, in this thread: <a class=\"stream-topic\" data-stream-id=\"229199\" href=\"/#narrow/stream/229199-learning.3A-questions/topic/Higher-order.20logic.20as.20a.20.27theory.27.20of.20STLC\">#learning: questions &gt; Higher-order logic as a 'theory' of STLC</a> , we discuss how HOL is a <em>theory</em> of STLC (the doctrine). Being a logic, would one consider HOL a doctrine as well? </p>\n<p>I guess that an extension to that question would be - can something like Set Theory (maybe ZFC / ETCS), which is a theory of first order logic, considered a doctrine as well?</p>",
        "id": 468246013,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1725643510
    },
    {
        "content": "<p>Do we have a 5 stars hard old book on doctrines?</p>",
        "id": 468293852,
        "sender_full_name": "Federica Pasqualone",
        "timestamp": 1725659023
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726654\">Suraaj K S</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/467048902\">said</a>:</p>\n<blockquote>\n<p>I was wondering if there are pros / cons of both approaches? The first does seem simpler / easier</p>\n</blockquote>\n<p>Sorry, I guess I missed this question at first.  The first is indeed easier, and in fact most current ways to do the second actually go through the first, by establishing an equivalence between an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-category of structured <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-categories and a localization of some 1-category of CwF-like objects and then applying the first approach to the latter.</p>\n<p>One disadvantage of the first approach is that it requires using a coherence theorem to strictify your structured higher categories into an appropriate kind of CwF.  It's not always clear how to do this, or if it's even possible (e.g. strictifying univalent universes was an open problem for a while).  Moreover, such strictification theorems generally rely heavily on a set-theoretic metatheory (meaning ZFC or ETCS, but not HoTT).  Of course, insofar as one does the second approach via the first approach, it inherits the same problem, but at least in theory one might imagine a version of the second approach that doesn't require strictification.</p>\n<p>One disadvantage of the second approach is that it's less clear how to formulate it as an adjunction rather than an equivalence, because syntactic theories naturally form only a 1-category, and we can't really expect to have an \"internal language\" <em>functor</em> from an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-category of structured <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-categories to a 1-category of theories.  If we invert some theory weak equivalences we can make an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-category of theories, but this seems to usually end up <em>equivalent</em> to that of structured <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\infty,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-categories.</p>\n<p>However, all of this is pretty speculative, since the second approach hasn't been pursued very much so there isn't much that we can say about it for sure.  Perhaps if someone takes it seriously, they'll find that I'm totally wrong.  (-:</p>",
        "id": 468458813,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1725734590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726654\">Suraaj K S</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/468246013\">said</a>:</p>\n<blockquote>\n<p>I'm curious if 'theories' of doctrines 'can be' docrines themselves?</p>\n<p>For instance, in this thread: <a class=\"stream-topic\" data-stream-id=\"229199\" href=\"/#narrow/stream/229199-learning.3A-questions/topic/Higher-order.20logic.20as.20a.20.27theory.27.20of.20STLC\">#learning: questions &gt; Higher-order logic as a 'theory' of STLC</a> , we discuss how HOL is a <em>theory</em> of STLC (the doctrine). Being a logic, would one consider HOL a doctrine as well? </p>\n</blockquote>\n<p>One sense in which theories can be doctrines is with a dimension shift.  A doctrine (= 1-doctrine) is the same as a 2-theory, which lives in some 2-doctrine (= 3-theory).  And so a 1-theory can be considered a 0-doctrine, in which we have 0-theories.  For example, if we regard the 1-theory of groups as a 0-doctrine, then the 0-theories in that 0-doctrine are (presentations of) particular groups.</p>",
        "id": 468460602,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1725735100
    },
    {
        "content": "<p>However, I don't think this is what you have in mind.  It sounds to me as though what you're thinking of is closer to a \"co-slice doctrine\".  For example, if we consider the semantic doctrine of CCCs (whose syntactic doctrine is STLC), then in that doctrine we have the theory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">G</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">p</mi></mrow><annotation encoding=\"application/x-tex\">\\rm Grp</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Grp</span></span></span></span></span> of group objects.  Semantically, this is a particular CCC <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">[</mo><mrow><mi mathvariant=\"normal\">G</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">p</mi><mo stretchy=\"false\">]</mo></mrow></mrow><annotation encoding=\"application/x-tex\">T[\\rm Grp]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathrm\">Grp</span><span class=\"mclose\">]</span></span></span></span></span> that is freely generated by a group object, so that CCC morphisms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">[</mo><mrow><mi mathvariant=\"normal\">G</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">p</mi></mrow><mo stretchy=\"false\">]</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">T[{\\rm Grp}] \\to C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Grp</span></span></span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> are equivalent to group objects in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>.  Now if we consider the co-slice 2-category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">[</mo><mrow><mi mathvariant=\"normal\">G</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">p</mi></mrow><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mrow><mi mathvariant=\"sans-serif\">C</mi><mi mathvariant=\"sans-serif\">C</mi><mi mathvariant=\"sans-serif\">C</mi></mrow></mrow><annotation encoding=\"application/x-tex\">T[{\\rm Grp}] / \\mathsf{CCC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Grp</span></span></span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathsf\">CCC</span></span></span></span></span>, we can regard this as the semantic doctrine of \"CCCs containing a group object\".  It has a corresponding syntactic doctrine, which is obtained from STLC by adding the <em>constants and axioms</em> of the syntactic theory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">G</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">p</mi></mrow><annotation encoding=\"application/x-tex\">\\rm Grp</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Grp</span></span></span></span></span> as <em>rules</em> to the doctrine.</p>",
        "id": 468460633,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1725735108
    },
    {
        "content": "<p>The description in the other thread of \"HOL as a theory of STLC\" seems to be thinking of something like this, of obtaining the doctrine HOL by adding the rules relating to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Ω</mi></mrow><annotation encoding=\"application/x-tex\">\\Omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Ω</span></span></span></span> to the doctrine STLC, and thinking of those rules as a \"theory\" in STLC.  I don't think this is quite correct, though, because the the quantifier rules like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span> have to be parametrized over <em>arbitrary types</em>, and that's not something you can do inside a theory.  So I would say rather than HOL is an <em>extension</em> of STLC obtained by adding one base type and several rules relating to it.</p>",
        "id": 468461127,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1725735243
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726654\">Suraaj K S</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/468246013\">said</a>:</p>\n<blockquote>\n<p>I'm curious if 'theories' of doctrines 'can be' docrines themselves?</p>\n</blockquote>\n<p>I thought about this question a lot. in its time, many people asked various versions of the question: </p>\n<p>what follows from the fact that category theory streamlines mathematical theories into corresponding universes (category of sets, category of groups, etc) and category theory itself is a mathematical theory that can be streamlined like that? what does it mean logically that category theory itself satisfies the axioms of a 2-category?</p>\n<p>lawvere tried to axiomatize that. street had his theory of cosmoi, etc. in your terms, if we formalize the theory of doctrines as 2-monads, is there a 2-monad of doctrines?</p>\n<p>the answer that mike shulman sketched is that there is a dimension shift: the \"doctrine\" of 2-monads would be a 3-monad. which is clear already on the basic case of \"category\" of categories being a 2-category.</p>\n<p>BUT I think that this shift is a consequence of asking the question in terms of <em>algebraic</em> theories. category theory is essentially algebraic and categorical algebra covers a great part of categorical practice, so it seemed natural to ask the question in terms of monads and 2-monads. but in in higher-order logic, all theories become algebraic...</p>\n<p>i think it is worth dwelling on the question as it stands BECAUSE if we find a format of categorical logic where category theory is an instance of a categorical theory THEN category theory becomes a <em>programming language</em>, in the sense that the logical theories are programs, and any formalization of category theory itself within category theory is a <em>universal interpreter</em> of that programming language. </p>\n<p>i think THAT point of view displays what we actually do when we do category theory.</p>\n<p>the success of machine learning and the realization of AI that we witness these days shows that our logical practices in general are based on such universal interpreters in various forms at various levels of language... (I can say more if it is of interest.)</p>",
        "id": 468466399,
        "sender_full_name": "dusko",
        "timestamp": 1725738334
    },
    {
        "content": "<p>one example of a categorical programming language is the theory of sketches. there is a sketch of all sketches, and a sketch of their models...</p>",
        "id": 468466559,
        "sender_full_name": "dusko",
        "timestamp": 1725738412
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/465832740\">said</a>:</p>\n<blockquote>\n<p>Well, personally I think a better internal language for toposes is dependent type theory.  </p>\n</blockquote>\n<p>lawvere's logic for toposes was the language of hyperdoctrines. note that the top of the doctrinal diagram is dependent type theory, or at least the sums and the products as adjoints of the substitution. the bottom is quantifiers-as-adjoints. with all predicates at the bottom being substitution instances of Truth, the doctrinal diagram gives Girard's F-omega. with the <em>comprehension</em> adjunctioin between the top and the bottom, lawvere's doctrinal diagram describes a type theory equivalent with coquand-huet's calculus of constructions.</p>\n<p>it is interesting that his <em>equational</em> hyperdoctrines put a sort of a straitjacket on identity types. he did not pursue the question of relating the equality predicate that he defined using the existential quantifier and the leibniz equality, defined using second-order universal quantifier. that is what thomas streicher did, and they found the groupoids :)</p>",
        "id": 468470661,
        "sender_full_name": "dusko",
        "timestamp": 1725740767
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/468461127\">said</a>:</p>\n<blockquote>\n<p>The description in the other thread of \"HOL as a theory of STLC\" seems to be thinking of something like this, of obtaining the doctrine HOL by adding the rules relating to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Ω</mi></mrow><annotation encoding=\"application/x-tex\">\\Omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Ω</span></span></span></span> to the doctrine STLC, and thinking of those rules as a \"theory\" in STLC.  I don't think this is quite correct, though, because the the quantifier rules like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span> have to be parametrized over <em>arbitrary types</em>, and that's not something you can do inside a theory.  So I would say rather than HOL is an <em>extension</em> of STLC obtained by adding one base type and several rules relating to it.</p>\n</blockquote>\n<p>This makes sense, and I think this is what I thought too... I guess I was confused when this book: <a href=\"https://mitpress.mit.edu/9780262133210/foundations-for-programming-languages/\">https://mitpress.mit.edu/9780262133210/foundations-for-programming-languages/</a> (specifically example 4.4.7) which explicitly says, \"we can present higher-order logic as a λ→ theory\". The 'signature' of this theory has infinitely many types of the form ∀&lt;σ&gt;, apparently..</p>",
        "id": 468476827,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1725746323
    },
    {
        "content": "<p>It's not just about having infinitely many <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span> operators, it's that you want to have a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span> for <em>all types</em>, and you can't say that in a theory.  Even if you add a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span> operator to the theory for each specific type that exists in the theory, it won't follow that a <em>model</em> of that theory has a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span> operator for every type (object) that exists in the <em>model</em>.</p>",
        "id": 468476985,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1725746433
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/468476985\">said</a>:</p>\n<blockquote>\n<p>It's not just about having infinitely many <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span> operators, it's that you want to have a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span> for <em>all types</em>, and you can't say that in a theory.  Even if you add a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span> operator to the theory for each specific type that exists in the theory, it won't follow that a <em>model</em> of that theory has a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span> operator for every type (object) that exists in the <em>model</em>.</p>\n</blockquote>\n<p>I see.. I think that the book was maybe just showing a 'cute' syntactic trick, where you can 'encode' and 'do' HOL in STLC...</p>",
        "id": 468477166,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1725746602
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/466956993\">said</a>:</p>\n<blockquote>\n<p>Logical Relations basically consist of interpreting a theory in a special sort of diagram/glued category.  I wrote an old <a href=\"https://golem.ph.utexas.edu/category/2013/04/scones_logical_relations_and_p.html\">blog post</a> about it from that point of view.</p>\n</blockquote>\n<p>Another thing that I seem to keep coming back to is this discussion. It does seem like CT 'can handle' logical relations and parametricity.</p>\n<p>However, <a href=\"https://www.cs.bham.ac.uk/~udr/papers/logical-relations-and-parametricity.pdf\">https://www.cs.bham.ac.uk/~udr/papers/logical-relations-and-parametricity.pdf</a> seems to talk about how CT 'cannot handle' parametricity, and we need a CT 2.0. </p>\n<p>We have had a thread of discussion on this in the past, but I'm a little bit confused as to what the resolution was... Is it safe to say that we do have a satisfactory answer to the questions put forth in the paper? Or does the paper actually demonstrate a 'real' limitation that exists even today?</p>",
        "id": 468479846,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1725747858
    },
    {
        "content": "<p>I think that's an exaggeration of what that paper says.  For one thing, they describe in that very paper two ways in which category theory can handle parametricity, and their reflexive-graph categories are pretty much the same as one of the diagram categories I referred to.</p>",
        "id": 468487894,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1725753829
    },
    {
        "content": "<p>That makes sense.<br>\nI think that I was confused by some other comments made by the paper's author here: <a href=\"https://cs.stackexchange.com/questions/9769/what-is-the-relation-between-functors-in-sml-and-category-theory\">https://cs.stackexchange.com/questions/9769/what-is-the-relation-between-functors-in-sml-and-category-theory</a> and <a href=\"https://cs.stackexchange.com/questions/9818/what-is-meant-by-category-theory-doesnt-yet-know-how-to-deal-with-higher-order\">https://cs.stackexchange.com/questions/9818/what-is-meant-by-category-theory-doesnt-yet-know-how-to-deal-with-higher-order</a>, the specific comment being \"Category Theory doesn't know how to deal with higher-order functions. Maybe someday, it will\"</p>",
        "id": 468493323,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1725758593
    },
    {
        "content": "<p>Yeah, those comments are pretty nonsensical.</p>",
        "id": 468508180,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1725768988
    },
    {
        "content": "<p>I was reading <a href=\"https://plato.stanford.edu/entries/goedel-incompleteness/\">https://plato.stanford.edu/entries/goedel-incompleteness/</a>. </p>\n<p>In the article, there seems to be a particular section about 'the method of interpretations' (particularly section 1.2.2). I was wondering if what is being referred to there was simply the idea of 'constructing a model' of one theory in another?</p>\n<p>There also seems to be a notion of interpretability (<a href=\"https://en.wikipedia.org/wiki/Interpretability\">https://en.wikipedia.org/wiki/Interpretability</a>), which seems to be another way of relating a theory to another.</p>\n<p>I was wondering if there is some connection between the two notions?<br>\nMoreover, I'm also curious what notion the article is referring to?</p>",
        "id": 472064288,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1727024968
    },
    {
        "content": "<p>I'm not sure exactly what that SEP article is referring to, but it could be either \"constructing a model of one theory from a model of another\" or the sort of \"interpretation\" referred to on that WP page.  However, there is a close connection between the two: if you can construct a model of T from any model of S in a \"uniform\" or \"elementary\" way (I'm not sure how to make that precise), then that construction also gives a way to translate formulas in T to formulas in S by sending an T-formula <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span></span></span></span> to the S-formula \"the T-model constructed from the present S-model satisfies <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span></span></span></span>.\"</p>",
        "id": 472075711,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1727031957
    },
    {
        "content": "<p>Indeed, the semantic notion (constructing a model of S inside a model of T in a 'nice' way) and the syntactic notion (map each relation symbol of S to a formula in T preserving satisfaction) agree. The idea is just we interpret each atomic formula in one language as a formula in another, which gives a \"uniform\" choice of definable set in each model. So what the SEP article is talking about is the same notion as in the wiki article. See for instance 1.3 of Marker's Model Theory or 2.6 of Hodges's Model Theory. Note that an interpretation of S into T gives a functor Mod(T) to Mod(S) between the categories of models (see \"Glymour &amp; Quine on theoretical equivalence\" and \"Morita equivalence\" by Barrett and Halvorson).</p>",
        "id": 472077762,
        "sender_full_name": "Evan Washington",
        "timestamp": 1727033745
    },
    {
        "content": "<p>Thanks!  I guess there is some way of making \"in a nice way\" precise?</p>",
        "id": 472079986,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1727035715
    },
    {
        "content": "<p>Also, I would be inclined to talk about constructing a model of S <em>from</em> a model of T rather than \"inside\" it, since the latter sounds to me like doing it internally in such a way that T would prove the consistency of S.  Do model theorists use \"inside\" for the former instead?</p>",
        "id": 472080061,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1727035800
    },
    {
        "content": "<p>My understanding (which might be wrong!) is that they tend to use \"inside\" in that way because the notion of interpretation really does give relative consistency. If there's an interpretation of S in T, then if T is consistent, S is consistent too. I'm not sure about the best way to say \"in a nice way\" purely semantically; it really means: interpret each relation symbol as a definable subset and extend in the usual way by induction. So maybe \"definable interpretation\" is a better description of what's going on.</p>",
        "id": 472096121,
        "sender_full_name": "Evan Washington",
        "timestamp": 1727047568
    },
    {
        "content": "<p>Ah, yes, \"definable interpretation\" makes sense.</p>",
        "id": 472096824,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1727048380
    },
    {
        "content": "<p>To be clear,  there seem to be two ways of 'comparing' one theory T with another theory S.</p>\n<ul>\n<li>'Usual' model theory - This is pretty well known (I think). For instance, you can find a model of <em>Group theory</em> in ZFC (a set theory).</li>\n<li>Interpretations - This is what is mentioned in the Wikipedia article and the SEP article. I don't think I understand it completely... However, it seems to me to be a way of 'doing / simulating' proofs of one theory in another. For instance, I think we could <em>do</em> ZFC in something simpler like PA, because we use things like Godel encodings to encode the syntax and proof system of ZFC in PA, and we then could have PA predicates like <code>ZFC_proves(φ)</code>. Is this right?</li>\n</ul>\n<p>If what I said was correct, then it seems to me that the second way (Interpretations) should be much easier than the first. All you need to do is 'hack up/encode' the proof system of one theory in another. Moreover, I think that it would always be possible to use this method of interpretations for <strong>any</strong> theory in PA by using things like Godel encodings.. Is this correct? Or is the wikepedia article mentioning yet another way of comparing one theory with another..</p>",
        "id": 472242684,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1727100410
    },
    {
        "content": "<p>No, I don't think that's what's meant by interpretations.  You seem to be basically describing using one theory as the metatheory for another.  I think \"interpretation\" means instead that both theories are in the same metatheory, and you construct a translation from formulas of one to formulas of the other (or from models of one to models of the other, in the other direction).</p>",
        "id": 472282986,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1727110487
    },
    {
        "content": "<p>There's a standard concept of 'interpretation' in (classical, non-category theoretic) model theory, described here:</p>\n<ul>\n<li>Wikipedia, <a href=\"https://en.wikipedia.org/wiki/Interpretation_(model_theory)\">Interpretation (model theory)</a>.</li>\n</ul>",
        "id": 472302977,
        "sender_full_name": "John Baez",
        "timestamp": 1727116802
    },
    {
        "content": "<p>There must be many other concepts called 'interpretation'....</p>",
        "id": 472303269,
        "sender_full_name": "John Baez",
        "timestamp": 1727116914
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/468461127\">said</a>:</p>\n<blockquote>\n<p>The description in the other thread of \"HOL as a theory of STLC\" seems to be thinking of something like this, of obtaining the doctrine HOL by adding the rules relating to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Ω</mi></mrow><annotation encoding=\"application/x-tex\">\\Omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Ω</span></span></span></span> to the doctrine STLC, and thinking of those rules as a \"theory\" in STLC.  I don't think this is quite correct, though, because the the quantifier rules like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span> have to be parametrized over <em>arbitrary types</em>, and that's not something you can do inside a theory.  So I would say rather than HOL is an <em>extension</em> of STLC obtained by adding one base type and several rules relating to it.</p>\n</blockquote>\n<p>I was doing some reading and found this answer on the internet: <a href=\"https://cstheory.stackexchange.com/a/47313/73876\">https://cstheory.stackexchange.com/a/47313/73876</a>. I was wondering if what you meant was also something similar?</p>",
        "id": 473451022,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1727617833
    },
    {
        "content": "<p>Yes, that's what I was thinking \"HOL as a theory of STLC\" meant, and what I was responding to.  But Andrej generally knows what he's talking about, so if he's willing to call it a theory then I wonder whether I'm missing something.</p>",
        "id": 473464880,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1727626858
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/473464880\">said</a>:</p>\n<blockquote>\n<p>Yes, that's what I was thinking \"HOL as a theory of STLC\" meant, and what I was responding to.  But Andrej generally knows what he's talking about, so if he's willing to call it a theory then I wonder whether I'm missing something.</p>\n</blockquote>\n<p>Something worth mentioning might be that the answer does talk about both 'a theory of STLC' as well as 'a slight extension of STLC'...</p>",
        "id": 474148108,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1727826771
    },
    {
        "content": "<p>When one talks about STLC (and how its equivalent to the category of Cartesian Closed (Multi) Categories), you assume 0,x,→ as the type constructors. </p>\n<p>However, in introductory PL courses, we are usually taught λ→, that is, just with function types. (I am still talking about the typed λ calculus here.) </p>\n<p>I was wondering how / if λ→ is treated in categorical logic. Something that seems to bug me a little bit is that you need products in your categories to define exponentials, and λ→ does not have product types..</p>",
        "id": 475705486,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1728437372
    },
    {
        "content": "<p>The categorical counterpart of λ→ is <em>closed cartesian multicategories</em>.  That is, a <a href=\"https://ncatlab.org/nlab/show/cartesian%20multicategory\">[[cartesian multicategory]]</a> that is closed in the multicategorical sense that it has internal hom-objects with a universal property</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>C</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo separator=\"true\">;</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>≅</mo><mi>C</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator=\"true\">;</mo><mo stretchy=\"false\">[</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">C(x_1,\\dots,x_n; y) \\cong C(x_1,\\dots,x_{n-1}; [x,y]).</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">])</span><span class=\"mord\">.</span></span></span></span></span></p>\n<p>In generaly, multicategories are the context in which you can define exponentials without products, corresponding to how syntax can have multiple variables in the <em>context</em> even if there aren't product types.</p>",
        "id": 475742355,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728448570
    },
    {
        "content": "<p>Note that we can also define exponentials without there being cartesian products, using representability instead</p>",
        "id": 475823105,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1728470261
    },
    {
        "content": "<p>This should coincide with the approach via closed cartesian multicategories: since <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>C</mi><mo stretchy=\"true\">^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\widehat C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9233em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9233em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span><span class=\"svg-align\" style=\"width:calc(100% - 0.1667em);margin-left:0.1667em;top:-3.6833em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span style=\"height:0.24em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"0.24em\" viewBox=\"0 0 1062 239\" preserveAspectRatio=\"none\"><path d=\"M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z\"/></svg></span></span></span></span></span></span></span></span></span> is cartesian closed, it is in particular a closed cartesian multicategory, and we can take the full sub cartesian multicategory spanned by representables. The condition for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>X</mi><mi>Y</mi></msup></mrow><annotation encoding=\"application/x-tex\">X^Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">Y</span></span></span></span></span></span></span></span></span></span></span> to exist in the category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> (without assuming products with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> exist in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>) will be the condition that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>X</mi><mi>Y</mi></msup></mrow><annotation encoding=\"application/x-tex\">X^Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">Y</span></span></span></span></span></span></span></span></span></span></span> exists in the cartesian multicategory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>. In other words, every category is the underlying category of a canonical cartesian multicategory, and asking for exponentials in the representable sense is the same as asking for exponentials in the canonical cartesian multicategory.</p>",
        "id": 475846834,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1728476813
    },
    {
        "content": "<p>I would say it's a particular <em>case</em> of closed cartesian multicategories.  A general closed cartesian multicategory won't be \"canonical\" in that sense; in fact it seems rare to me that it would be except in the case when it also has finite products.</p>",
        "id": 475873102,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728482741
    },
    {
        "content": "<p>are you saying there are closed cartesian multicategories that are not equivalent to that canonical one given by Arkor using representable presheaves?</p>",
        "id": 475876967,
        "sender_full_name": "Max New",
        "timestamp": 1728483603
    },
    {
        "content": "<p>Yes.  The main \"naturally occurring\" one that I can think of is the syntactic category of λ→, in which the objects are types and the multi-morphisms are terms in a finite context.  I don't see any reason why for types <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo separator=\"true\">,</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">A,B,C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>, every natural transformation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>よ</mtext><mi>A</mi><mo>×</mo><mtext>よ</mtext><mi>B</mi><mo>→</mo><mtext>よ</mtext><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">よA \\times よB \\to よC</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord cjk_fallback\">よ</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord cjk_fallback\">よ</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord cjk_fallback\">よ</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> would be represented by a term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>:</mo><mi>B</mi><mo>⊢</mo><mi>t</mi><mo>:</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">x:A, y:B \\vdash t:C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>.</p>",
        "id": 475896957,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728487573
    },
    {
        "content": "<p>Note that here \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>よ</mtext><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">よC</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord cjk_fallback\">よ</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>\" is the representable presheaf on the <em>underlying ordinary category</em>, so it only knows about terms in length-1 contexts.</p>",
        "id": 475897231,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728487637
    },
    {
        "content": "<p>what if you took presheaves on the category of contexts instead?</p>",
        "id": 475949663,
        "sender_full_name": "Max New",
        "timestamp": 1728505159
    },
    {
        "content": "<p>The category of contexts in  λ→ is a CCC.</p>",
        "id": 475951042,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728505764
    },
    {
        "content": "<p>So, yes, its cartesian multicategory structure is the canonical one, as it is for any category with finite products.</p>",
        "id": 475951287,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728505836
    },
    {
        "content": "<p>In categorical logic / type theory, the judgements seem to be of equality. For example, you have the beta equality rule in STLC, etc. </p>\n<p>On the other hand, for computation, you want rules for directed reduction. For instance, you have a beta reduction rule in STLC too. These reduction rules need to 'play well' with the equality rules, and are often directed versions of equality rules, but not always (for example eta reduction).</p>\n<p>I'm wondering if there is some 'method to this madness'? Something like, given a type theory with equality judgements, can one automatically derive 'the right' reduction rules?</p>",
        "id": 476478462,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1728694922
    },
    {
        "content": "<p>Oh, would that that were true!  Finding a good way to \"orient\" the equality rules to make them reduction steps is one of the trickiest, if not the trickiest, parts of turning a \"declarative\" type theory into a computational one.  And proving that such a choice \"works\", which goes by names like \"canonicity\" and \"normalization\", is generally one of the more difficult and substantial metatheorems to establish about a new type theory.</p>",
        "id": 476510493,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728725963
    },
    {
        "content": "<p>People have established good intuitions, heuristics, and general techniques that help a lot.  But there's no automatic way to produce reduction rules from equality rules; and if you consider the space of all possible \"declarative type theories\", the ones that admit a computational interpretation are, I think, going to be quite sparse.  It's just that those tend to also be the most interesting and useful ones, so we're more familiar with them.  That's not <em>entirely</em> a coincidence, but it still feels kind of magical to me on some days.</p>",
        "id": 476510635,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728726109
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/476510493\">said</a>:</p>\n<blockquote>\n<p>Oh, would that that were true!  Finding a good way to \"orient\" the equality rules to make them reduction steps is one of the trickiest, if not the trickiest, parts of turning a \"declarative\" type theory into a computational one.  And proving that such a choice \"works\", which goes by names like \"canonicity\" and \"normalization\", is generally one of the more difficult and substantial metatheorems to establish about a new type theory.</p>\n</blockquote>\n<p>I see. That makes sense.. <br>\nI'm curious whether 'canonicity' and 'normalization' are synonyms? From what I understand:</p>\n<ul>\n<li>Normalization has to do with the reduction relation terminating, and isn't directly related to equality rules. </li>\n<li>I'm not entirely sure what canonicity is...</li>\n<li>There's another 'obvious' way to link reduction and equality: If <code>m → m'</code>, then <code>m=m'</code>.  That is, reduction 'agrees with' equality. For instance, the beta reduction and beta equality rules in STLC agree.</li>\n<li>You could take the previous idea further, by using reduction to define a <em>new notion</em> of equality called contextual/observational equality. Then you'd want your <em>axiomatic equality</em> to agree with <em>observational equality</em>. I think one does this when thinking about programming languages though, so maybe this doesn't make that much sense in a logic setting.</li>\n</ul>",
        "id": 476531135,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1728746246
    },
    {
        "content": "<p>Your property that \"If <code>m → m'</code>, then <code>m=m'</code>\" is what I would call \"soundness\" of the reduction system: it doesn't violate the judgmental equality.  That's sort of a \"bare minimum\" requirement of any notion of reduction to be sensible.</p>",
        "id": 476533836,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728748774
    },
    {
        "content": "<p>Normalization is, roughly, about the converse.  It says that there is an algorithm that computes from any term (<em>in any context</em>) a \"normal form\" (which we often think of as another term, although it doesn't have to be) with the property that two terms are judgmentally equal <em>if and only if</em> their normal forms are <em>exactly</em> equal.  This allows you to algorithmically test judgmental equality by reducing both terms to normal form and then checking them syntactically for equality.  The traditional sort of normalization algorithm consists in applying primitive \"reduction steps\" one by one until the algorithm terminates (termination being part of what one has to prove), but more modern treatments tend to use a fancier sort of algorithm called \"normalization by evaluation\".</p>",
        "id": 476534080,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728748959
    },
    {
        "content": "<p>Canonicity is technically a statement only about the judgmental equality, and is stated for a particular concrete type like the natural numbers: it says that for any term <code>t</code> <em>in the empty context</em> belonging to the natural numbers type, there is a term <code>c</code> in canonical form -- which in the case of the natural numbers means it is a \"numeral\" of the form <code>S(S(S(S...(S(0)))))</code> -- and a judgmental equality <code>t=s</code>.</p>\n<p>However, usually we ask for an algorithm that computes <code>c</code> from <code>t</code>, and this algorithm is usually very similar to the normalization algorithm.  Specifically, <em>if</em> every <em>normal form</em> belonging to the natural numbers in the empty context is a numeral, then canonicity follows from normalization.  (However, you can do things like add arbitrary axioms, which preserve normalization since they are equivalent to prepending variables to the context, but do not generally preserve canonicity.)  On the other hand, while canonicity obviously does not actually <em>imply</em> normalization, and is often significantly easier to prove, in practice it's quite hard to think of type theories that satisfy canonicity but not normalization, although usually canonicity is proven first since it's easier and to point the way towards how to prove normalization.</p>",
        "id": 476534563,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728749447
    },
    {
        "content": "<p>That makes sense!</p>\n<p>Does one think of things like 'observational'/'contextual' equivalence too, when doing categorical logic? Or is that 'just' a programming language thing?</p>",
        "id": 476537252,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1728751865
    },
    {
        "content": "<p>Also, does one consider the description of 'what normal and canonical forms are', a part of the core type theory? or are they 'add-ons' which are useful for proving things about the core type theory?</p>",
        "id": 476537444,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1728752061
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726654\">Suraaj K S</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/476537252\">said</a>:</p>\n<blockquote>\n<p>Does one think of things like 'observational'/'contextual' equivalence too, when doing categorical logic? Or is that 'just' a programming language thing?</p>\n</blockquote>\n<p>For the most part, \"algorithmic\" equality isn't relevant to categorical logic, except insofar as it coincides with judgmental equality.  Some people have tried to formulate categorical structures that \"see\" it, such as 2-categories whose 2-cells represent reductions, but this is generally in the vein of \"how can we come up with a categorical description of the algorithmic behavior\" rather than the reduction steps meaning anything directly in naturally-occurring categories.</p>\n<p>Of course, when normalization holds, then algorithmic equality does coincide with judgmental equality, and this is very useful for coding proof assistants since it gives a way to test equality algorithmically.  In a dependent type theory, testing equality is essential to having a decidable typechecking algorithm.  So for practical use in a proof assistant, this sort of thing is important, even if it isn't needed for the mathematical theory of categorical semantics.</p>",
        "id": 476539640,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728754101
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726654\">Suraaj K S</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/476537444\">said</a>:</p>\n<blockquote>\n<p>Also, does one consider the description of 'what normal and canonical forms are', a part of the core type theory? or are they 'add-ons' which are useful for proving things about the core type theory?</p>\n</blockquote>\n<p>I think most people would consider them add-ons, but I'm not positive.  They certainly are closely associated with the theory.</p>",
        "id": 476539672,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728754149
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726654\">Suraaj K S</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/476537444\">said</a>:</p>\n<blockquote>\n<p>Also, does one consider the description of 'what normal and canonical forms are', a part of the core type theory? or are they 'add-ons' which are useful for proving things about the core type theory?</p>\n</blockquote>\n<p>I think most people would consider them add-ons, but I'm not positive.  They certainly are closely associated with the theory.</p>",
        "id": 476539681,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728754164
    },
    {
        "content": "<p>When you say algorithmic equality, do you just mean reduction rules made into an equivalence relation?</p>\n<p>When I was talking about 'observational' equivalence between t1 and t2, the notion is more about whether a context can distinguish between t1 and t2. Here, a context is a program with a 'hole' in it.</p>\n<p>Let's take the untyped lambda calculus for example. We can say that <code>t1</code> is contextually equivalent to <code>t2</code> iif for all contexts c, <code>c[t1]</code> terminates iif <code>c[t2]</code> terminates.</p>",
        "id": 476546456,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1728760729
    },
    {
        "content": "<p>Yes, I'm aware that people study \"contextual\" equalities like that, but that's not what I was talking about.  I meant the equality given by a normalization algorithm (which, again, in a modern context might not be simply repeated applications of reduction rules).  I thought that's what you meant too since you said up above</p>\n<blockquote>\n<p>You could take the previous idea further, by using reduction to define a <em>new notion</em> of equality called contextual/observational equality.</p>\n</blockquote>",
        "id": 476555540,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728770429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/476555540\">said</a>:</p>\n<blockquote>\n<p>I meant the equality given by a normalization algorithm (which, again, in a modern context might not be simply repeated applications of reduction rules)</p>\n</blockquote>\n<p>Oh wow, I did not know that! I always thought that the reduction rules were the algorithm..</p>",
        "id": 476561584,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1728777759
    },
    {
        "content": "<p>Reduction rules give a \"small-step operational semantics\", from which you can also extract a \"big-step operational semantics\".  However you can get a big-step operational semantics by other means.  \"Normalization by evaluation\" means extracting a big-step operational semantics from a denotational semantics!</p>",
        "id": 476562238,
        "sender_full_name": "James Deikun",
        "timestamp": 1728778590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"438995\">James Deikun</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/476562238\">said</a>:</p>\n<blockquote>\n<p>\"Normalization by evaluation\" means extracting a big-step operational semantics from a denotational semantics!</p>\n</blockquote>\n<p>While true, I feel this is a bit misleading, because it makes it sound magic, whereas in fact I think all the work of constructing a normalization algorithm is just moved into constructing a denotational semantics.  (-:</p>",
        "id": 476563880,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728780707
    },
    {
        "content": "<p>Although maybe that would be obvious to a computer scientist.</p>",
        "id": 476563956,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728780748
    },
    {
        "content": "<p>Here's another question that I was wondering about: <br>\nIn a few introduction to CT courses / books (for example: Awodey, <a href=\"https://www.cs.uoregon.edu/research/summerschool/summer23/_lectures/Introduction_to_Category_Theory_notes.pdf\">https://www.cs.uoregon.edu/research/summerschool/summer23/_lectures/Introduction_to_Category_Theory_notes.pdf</a>, etc.), a connection between <strong>monads</strong> and <strong>algebras</strong> is introduced. If I understand correctly, an 'algebraic theory' (which is traditionally a signature and a set of axioms) 'is just a monad'... For instance, the last section in the linked OPLSS lecture notes talks about this.</p>\n<p>What I'm curious whether there is a link to the style of categorical logic as we were discussing in this thread (an adjunction between a category of theories and a category of structured categories)?</p>",
        "id": 476565560,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1728782700
    },
    {
        "content": "<p>Are you thinking specifically of relating these notions of \"theory\"?</p>",
        "id": 476565689,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728782850
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/476565689\">said</a>:</p>\n<blockquote>\n<p>Are you thinking specifically of relating these notions of \"theory\"?</p>\n</blockquote>\n<p>Yes. I think that would be a good start...</p>",
        "id": 476566068,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1728783255
    },
    {
        "content": "<p>I was just wondering if the monads as algebraic theories idea was a 'neat' idea, or whether it was 'just' an instance of some deeper concept in categorical logic</p>",
        "id": 476566208,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1728783410
    },
    {
        "content": "<p>In categorical logic, a model is a functor in the category of structured categories. <br>\nOn the other hand, an algebra over a monad T is an object A, along with a morphism a : TA → A, subject to a few conditions</p>",
        "id": 476566453,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1728783737
    },
    {
        "content": "<p>Here's another monad related question: </p>\n<p>In categorical logic, we have an adjunction between </p>\n<ul>\n<li>A category of structured categories</li>\n<li>A category of theories of a doctrine</li>\n</ul>\n<p>We also discussed that doctrines could be 'programming languages' too, and 'models' give a denotational semantics of programming languages. For instance, I think that <a href=\"https://www.cambridge.org/core/books/categories-for-types/258841251C62FED1DACD20884E59E61C\">https://www.cambridge.org/core/books/categories-for-types/258841251C62FED1DACD20884E59E61C</a> talks about such categorical semantics for programming languages.</p>\n<p>What I was wondering about is the following: Moggi's seminal work (<a href=\"https://www.cs.cmu.edu/~crary/819-f09/Moggi91.pdf\">https://www.cs.cmu.edu/~crary/819-f09/Moggi91.pdf</a>) gives a 'monadic' semantics for programming languages with effects. I was wondering if this would fit cleanly in the framework of categorical semantics as we have been discussing so far? </p>\n<p>For instance, I'm curious what the 'category of structured categories' would be in this case?</p>",
        "id": 476623175,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1728840821
    },
    {
        "content": "<p>To the second question, if the doctrine involves the monad as an explicit operator, then the \"structured categories\" would be categories equipped with a monad.</p>",
        "id": 476624250,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728841879
    },
    {
        "content": "<p>Otherwise, it might be something like a <a href=\"https://ncatlab.org/nlab/show/Freyd%20category\">[[Freyd category]]</a>.</p>",
        "id": 476624263,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728841903
    },
    {
        "content": "<p>To the first question, there's some overlap in the notions of \"theory\" but they're not identical.  The theories in the doctrine of finite products are <em>multi-sorted</em>, <em>finitary</em> algebraic theories, while monads on Set are <em>single-sorted</em>, <em>infinitary</em> algebraic theories.  The intersection consists of single-sorted finitary algebraic theories.</p>",
        "id": 476624374,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728841994
    },
    {
        "content": "<p>A multi-sorted theory does also induce a monad, but rather than on Set, this monad is on the category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><mi>S</mi></msup></mrow><annotation encoding=\"application/x-tex\">{\\rm Set}^S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9146em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Set</span></span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9146em;\"><span style=\"top:-3.1362em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span></span></span></span></span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is the set of sorts (i.e. base types).</p>",
        "id": 476626957,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728844344
    },
    {
        "content": "<p>I don't know of a direct categorical connection between the category of finite-product theories and the collection of monads on powers of Set, although I suppose there probably is one.</p>",
        "id": 476626997,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728844395
    },
    {
        "content": "<p>And for other doctrines, there isn't much of a connection to monads in general.</p>",
        "id": 476627023,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728844435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/476624374\">said</a>:</p>\n<blockquote>\n<p>To the first question, there's some overlap in the notions of \"theory\" but they're not identical.  The theories in the doctrine of finite products are <em>multi-sorted</em>, <em>finitary</em> algebraic theories, while monads on Set are <em>single-sorted</em>, <em>infinitary</em> algebraic theories.  The intersection consists of single-sorted finitary algebraic theories.</p>\n</blockquote>\n<p>I see. If I understand correctly, these 'theories' are objects of the 'category of theories of the doctrine', right? And you'd have an adjunction with some other 'category of structured categories' in both cases?</p>\n<p>Moreover, could we call 'monads on Set' a doctrine? I guess that the sentence says that the theories of this doctrine  are <code>single-sorted, infinitary algebraic theories</code>. What'd be the 'category of structured categories' in this case? Furthermore, could we have models in categories <strong>other than Sets</strong>?</p>\n<p>I'm sorry for the barrage of questions :(</p>",
        "id": 476629854,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1728846868
    },
    {
        "content": "<p>The multi-sorted finitary algebraic theories are the objects of the category of theories of the doctrine of finite products, yes.  But single-sorted theories don't really fit well into the doctrinal framework.  You can, of course, consider the full subcategory of the category of multi-sorted theories determined by those that have only one sort, but that category doesn't have an adjunction to a category of structured categories, since the \"internal language\" theory of a structured category is multi-sorted (its sorts are the objects of the category).</p>",
        "id": 476636971,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728852917
    },
    {
        "content": "<p>In general a doctrine specifies the kinds of <em>operations</em> that are allowed on types and terms, and a theory in that doctrine gives particular generating types, terms, and axioms.  So single-sortedness is really a property of a theory rather than an aspect of a doctrine.</p>",
        "id": 476637054,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728853009
    },
    {
        "content": "<p>Also I wasn't very precise in saying \"infinitary\".  In general a monad can have \"infinitary operations\" but I don't think there is an explicit notion of \"infinitary theory\" that's equivalent to a monad on Set.  There is a notion of <a href=\"https://ncatlab.org/nlab/show/infinitary%20Lawvere%20theory\">[[infinitary Lawvere theory]]</a> but it's not well-understood as far as I know, in particular it isn't known whether every such gives rise to a monad, or whether every monad arises from such a thing.</p>\n<p>What you can say is that for any regular cardinal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>, there's a notion of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>-ary algebraic theory, and the single-sorted ones of those are equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>-accessible monads on Set.  But there are also inaccessible monads on Set, like the one whose algebras are compact Hausdorff spaces.</p>",
        "id": 476637978,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728853959
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/476637978\">said</a>:</p>\n<blockquote>\n<p>I don't think there is an explicit notion of \"infinitary theory\" that's equivalent to a monad on Set.  There is a notion of <a href=\"https://ncatlab.org/nlab/show/infinitary%20Lawvere%20theory\">[[infinitary Lawvere theory]]</a> but it's not well-understood as far as I know, in particular it isn't known whether every such gives rise to a monad, or whether every monad arises from such a thing.</p>\n</blockquote>\n<p>Perhaps I'm misunderstanding something, but I would have thought an \"infinitary Lawvere theory\" is precisely what Linton calls a \"varietal theory\", i.e. an identity-on-objects product-preserving functor from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mtext>Set</mtext><mtext>op</mtext></msup></mrow><annotation encoding=\"application/x-tex\">\\text{Set}^{\\text{op}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7376em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Set</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7376em;\"><span style=\"top:-3.1362em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord text mtight\"><span class=\"mord mtight\">op</span></span></span></span></span></span></span></span></span></span></span></span></span>, and these are trivially equivalent to monads on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Set</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{Set}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord\">Set</span></span></span></span></span>.</p>",
        "id": 476639538,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1728855700
    },
    {
        "content": "<p>(Of course, characterising the presentations that correspond to varietal theories is not at all straightforward.)</p>",
        "id": 476639729,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1728855932
    },
    {
        "content": "<p>Ok, that's what <a href=\"https://nforum.ncatlab.org/discussion/1673/question-on-size-matters-in-algebraic-theories/?Focus=14666#Comment_14666\">I thought</a> 14 years ago, but then Toby Bartels disagreed and I never really paid attention to the discussion that followed, and the resulting nLab page is ambiguous.  If you're confident about that, maybe you could edit the nLab page?</p>",
        "id": 476651089,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728868209
    },
    {
        "content": "<p>But in any case, you're right that it doesn't really help with the connection to doctrines, since the \"local smallness\" condition isn't syntactic.</p>",
        "id": 476651102,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728868247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276092\">Nathanael Arkor</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/476639538\">said</a>:</p>\n<blockquote>\n<p>Perhaps I'm misunderstanding something, but I would have thought an \"infinitary Lawvere theory\" is precisely what Linton calls a \"varietal theory\", i.e. an identity-on-objects product-preserving functor from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mtext>Set</mtext><mtext>op</mtext></msup></mrow><annotation encoding=\"application/x-tex\">\\text{Set}^{\\text{op}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7376em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Set</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7376em;\"><span style=\"top:-3.1362em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord text mtight\"><span class=\"mord mtight\">op</span></span></span></span></span></span></span></span></span></span></span></span></span>, and these are trivially equivalent to monads on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Set</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{Set}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord\">Set</span></span></span></span></span>.</p>\n</blockquote>\n<p>I’ve not read the discussion Mike is alluding to but my understanding was: this would only cover the single-sorted case (maybe that’s fine) and also (I think) requires choice to present each set as isomorphic to a small coproduct of a fixed singleton set (edit: so that coproducts of these presentations are strictly associative). I’d thought the point was that it is not enough to merely have small products but we also need to _choose_ them for the notion of model. If this is accurate, the usual notion of (single-sorted) Lawvere theory would more closely correspond to a product preserving identity-on-objects functor from the opposite of the category of cardinal numbers and functions between them. The multi-sorted case would then follow by taking powers.</p>",
        "id": 476693335,
        "sender_full_name": "Nathan Corbyn",
        "timestamp": 1728888990
    },
    {
        "content": "<p>Every set is canonically and constructively isomorphic to a small coproduct of copies of a fixed singleton: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>≅</mo><msub><mo>∐</mo><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow></msub><mo stretchy=\"false\">{</mo><mo>∗</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">A \\cong \\coprod_{a\\in A} \\{\\ast\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0771em;vertical-align:-0.3271em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∐</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">a</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\">A</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3271em;\"><span></span></span></span></span></span></span><span class=\"mopen\">{</span><span class=\"mord\">∗</span><span class=\"mclose\">}</span></span></span></span>.  That doesn't require any choice.</p>",
        "id": 476694401,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728889279
    },
    {
        "content": "<p>Sorry, I meant in such a way that e.g., coproducts of these presentations are strictly associative</p>",
        "id": 476696107,
        "sender_full_name": "Nathan Corbyn",
        "timestamp": 1728889671
    },
    {
        "content": "<p>I don't understand, why would you need that?</p>",
        "id": 476698109,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728890147
    },
    {
        "content": "<p>I’d thought it would be essentially the same reason that a Lawvere theory is defined as an IOO functor out of the _skeleton_ of finite sets (op’d): you have a single representative of each arity and structure is preserved strictly.</p>",
        "id": 476698895,
        "sender_full_name": "Nathan Corbyn",
        "timestamp": 1728890327
    },
    {
        "content": "<p>(Not that I necessarily think these are good reasons, I was just trying to make sense of what was on the nLab page in terms of my understanding of the finitary case)</p>",
        "id": 476699594,
        "sender_full_name": "Nathan Corbyn",
        "timestamp": 1728890473
    },
    {
        "content": "<p>Ah.  I don't think that's necessary in the finitary case either, it just makes some people happier to have only one object of each arity rather than a bunch of isomorphic copies.  I think the fact that you'd need AC to get it in the infinitary case is a good reason to drop that requirement, as the nLab definition does.</p>",
        "id": 476704414,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728891547
    },
    {
        "content": "<p>That makes sense</p>",
        "id": 476704911,
        "sender_full_name": "Nathan Corbyn",
        "timestamp": 1728891657
    },
    {
        "content": "<p>Perhaps I'm missing part of the discussion, but wouldn't complete Boolean algebras be considered an infinitary algebraic theory? Those don't come from a monad; in fact the left adjoint to the forgetful functor to sets doesn't have a left adjoint (free complete Boolean algebras do not generally exist; they exist only on finite sets).</p>",
        "id": 476810922,
        "sender_full_name": "Todd Trimble",
        "timestamp": 1728919604
    },
    {
        "content": "<p>I personally would refer to that as a \"large algebraic theory\", but reserve \"infinitary algebraic theory\" for the notion corresponding to arbitrary monads on Set. But different authors have made different terminological choices.</p>",
        "id": 476814101,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1728920761
    },
    {
        "content": "<p>There are four notions (in the one-sorted case for simplicity):</p>\n<ol>\n<li>A large collection of function symbols, of arbitrary arities, and axioms.</li>\n<li>A (large) category with arbitrary products generated under such products by a single object.</li>\n<li>As in (2), but the category must be locally small.</li>\n<li>A monad on Set.</li>\n</ol>\n<p>Obviously any (1) generates a (2), and we can think of (2) as the \"extensional essense\" of a (1).  And every (4) generates a (3), namely the opposite of its Kleisli category, while there is an argument that every (3) induces a (4) that it would be nice to have spelled out in more detail (or perhaps it's in some reference, maybe the Linton mentioned above?).  Complete Boolean algebras are a (1)+(2) but not a (3)+(4).</p>\n<p>So what do we call what?  I can see arguments for either (2) or (3) being an \"infinitary Lawvere theory\"; (2) is the more straightforward modification of the usual notion, but lacks the correspondence to (4) that's an essential part of the theory of ordinary Lawvere theories.  I do see a pretty strong argument for an \"infinitary algebraic theory\" being a (1), since \"algebraic theory\" suggests to me something that can be presented syntactically, and there's no clear syntactic counterpart of the local smallness condition in (3).  But, as Nathanael said, different people may make different choices.</p>",
        "id": 476824738,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728925221
    },
    {
        "content": "<blockquote>\n<p>or perhaps it's in some reference, maybe the Linton mentioned above?</p>\n</blockquote>\n<p>(Yes, that's right.)</p>",
        "id": 476827936,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1728926888
    },
    {
        "content": "<p>I was reading the appendix of <a href=\"https://mikeshulman.github.io/catlog/catlog.pdf\">https://mikeshulman.github.io/catlog/catlog.pdf</a>.</p>\n<p>There is the following sentence: \"Similarly, an equality judgment like x : A |- M ≡ N : B is shorthand for (x.M) ≡ (x.N) : (A |- B)\".</p>\n<p>If the notes are taking the view that <em>terms</em> are 'just' annotations, I'm a little confused as to what exactly the <strong>real</strong> judgement is? Are they the sorts (which are defined to be judgements) of the form Σ^≡ (as shown in A.3)? Or are they 'simpler' sorts? I think I'm a little bit confused when 'term annotations' are introduced...</p>\n<p>I've also never seen deductive systems presented this way. I was wondering if this is standard? or something novel?</p>",
        "id": 476880757,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1728959779
    },
    {
        "content": "<p>I wrote in A.4 that a \"judgment\" is a sort in one of the signatures in a dependency sequence, which is therefore defined in some unspecified way from the initial algebras of the previous ones.  In the case of something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">Σ</mi><mo>≡</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\Sigma^\\equiv</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6876em;\"></span><span class=\"mord\"><span class=\"mord\">Σ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6876em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mrel mtight\">≡</span></span></span></span></span></span></span></span></span></span></span>, so that we're talking about \"equality judgments\", these sorts are pair of \"derivations\" of some other judgment in a previous signature, so that they could potentially be equated.  For example, in the case of categories, we start with a signature whose sorts are written <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊢</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\vdash B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, and so the sorts of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">Σ</mi><mo>≡</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\Sigma^\\equiv</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6876em;\"></span><span class=\"mord\"><span class=\"mord\">Σ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6876em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mrel mtight\">≡</span></span></span></span></span></span></span></span></span></span></span> are triples <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>g</mi><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(f,g,(A\\vdash B))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">))</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> are derivations of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊢</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\vdash B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>.  The perspective I'm taking in that appendix is that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">x.M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">x.N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> are just notations for two such derivations <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span>.</p>",
        "id": 476918218,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728976328
    },
    {
        "content": "<p>I wouldn't say this presentation is \"standard\", as I don't think I've seen it written down like that before.  But I don't think it's all that novel either; what I wrote was an attempt to describe what I had learned (or thought I learned) about how some type theorists think about what's going on in many cases, even if they aren't that precise about it.</p>",
        "id": 476918464,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1728976412
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/476918218\">said</a>:</p>\n<blockquote>\n<p>sorts of Σ≡ are triples (f,g,(A⊢B))</p>\n</blockquote>\n<p>I think that to match the notes exactly, they need to be ((A⊢B),f,g)?<br>\nHowever, I think I understand it a little better now</p>",
        "id": 477038212,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729013271
    },
    {
        "content": "<p>Also, I was curious if there were plans to extend those notes to include dependent type theories and polymorphic type theories?</p>",
        "id": 477068706,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729025525
    },
    {
        "content": "<p>It depends.  Does a \"plan\" have to be time-bound?  (-:O</p>",
        "id": 477073914,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729027828
    },
    {
        "content": "<p>I've a small question about 'term systems' as defined by those notes (Definition A.5.2): </p>\n<p>It says that a \"term system for Σ is a Σ-algebra...\". However, there is an example in the previous page where the 'term system' for a cut-ful type theory of categories (where the sorts are pairs of objects in the category) is a <strong>single sorted free algebra</strong> of untyped terms. I'm wondering if I'm missing something here?</p>",
        "id": 477081441,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729031748
    },
    {
        "content": "<p>The example is also followed by a parenthetical that says</p>\n<blockquote>\n<p>For technical reasons,<br>\nrather than a single set of terms as here, in the general case we will allow each<br>\njudgment of our intended theory to be assigned a different set of “potential<br>\nterms”; see below.</p>\n</blockquote>",
        "id": 477087471,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729034488
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/477087471\">said</a>:</p>\n<blockquote>\n<p>The example is also followed by a parenthetical that says</p>\n<blockquote>\n<p>For technical reasons,<br>\nrather than a single set of terms as here, in the general case we will allow each<br>\njudgment of our intended theory to be assigned a different set of “potential<br>\nterms”; see below.<br>\n</p>\n</blockquote>\n</blockquote>\n<p>I think I was just wondering as to whether the single sorted term algebra example 'could be adapted' to the multisorted case.</p>",
        "id": 477090281,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729036200
    },
    {
        "content": "<p>Well, I didn't develop any of the examples very precisely, but I <em>think</em> what I had in mind was that (in the absence of binding) to define a term system, you would first define a single-sorted signature, usually with one operation corresponding to each (typed) operation of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Σ</mi></mrow><annotation encoding=\"application/x-tex\">\\Sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Σ</span></span></span></span>, consider the initial algebra for that signature, and then use that same set as the (possibly ill-typed) terms at <em>all</em> judgments.</p>",
        "id": 477090989,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729036662
    },
    {
        "content": "<p>In the presence of binding, I would probably take the possibly-ill-typed terms to nevertheless be well-scoped, so that for a judgment with a context of length n the terms would be those with n free variables.</p>",
        "id": 477091086,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729036716
    },
    {
        "content": "<p>This is mentioned later in section A.6:</p>\n<blockquote>\n<p>in a simple type theory (chapter 2) the terms for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma\\vdash B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> should have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span><br>\nvariable bindings outermost, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> is the length of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Γ</span></span></span></span> (this is why in §A.5 we<br>\nallowed different judgments to have different sets of potential terms).</p>\n</blockquote>",
        "id": 477091188,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729036793
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/477090989\">said</a>:</p>\n<blockquote>\n<p>Well, I didn't develop any of the examples very precisely, but I <em>think</em> what I had in mind was that (in the absence of binding) to define a term system, you would first define a single-sorted signature, usually with one operation corresponding to each (typed) operation of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Σ</mi></mrow><annotation encoding=\"application/x-tex\">\\Sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Σ</span></span></span></span>, consider the initial algebra for that signature, and then use that same set as the (possibly ill-typed) terms at <em>all</em> judgments.</p>\n</blockquote>\n<p>And is the idea that you then give a Σ-algebra structure on this (family of sets which are really the same set)? The notes say that a \"term system for Σ is a Σ-algebra\"...</p>",
        "id": 477094879,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729038861
    },
    {
        "content": "<p>I think that the appendix is quite interesting because I really haven't seen precise definitions of what is 'deductive system' is. And we seem to use them all over the place: logics, programming languages (type judgements, operational semantics, and even syntax!)</p>",
        "id": 477095070,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729038971
    },
    {
        "content": "<p>Yes, that's right, you give a (non-free) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Σ</mi></mrow><annotation encoding=\"application/x-tex\">\\Sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Σ</span></span></span></span>-algebra structure on that family of sets, using the way you chose the single-sorted signature for which the set of terms is the free algebra.</p>",
        "id": 477096313,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729039877
    },
    {
        "content": "<p>Often, these 'inference rule systems' also have inference rules with 'side conditions' which can be semantic. Would it be safe to say that the deductive systems in the notes don't handle those systems?</p>",
        "id": 477227609,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729088557
    },
    {
        "content": "<p>What sort of conditions are you thinking of?</p>",
        "id": 477239066,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729091105
    },
    {
        "content": "<p>Here's an example: <a href=\"https://www.cs.cornell.edu/courses/cs6110/2023sp/lectures/lec08.pdf\">https://www.cs.cornell.edu/courses/cs6110/2023sp/lectures/lec08.pdf</a>. In section 3.1, you have the side condition -- <code>(where n2 is the sum of n0 and n1)</code></p>",
        "id": 477244269,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729092521
    },
    {
        "content": "<p>Moreover, in <a href=\"https://www.cs.cornell.edu/courses/cs6110/2023sp/lectures/lec06.pdf\">https://www.cs.cornell.edu/courses/cs6110/2023sp/lectures/lec06.pdf</a>, section 5, formula (4) is one definition of what an inference rule is..</p>",
        "id": 477244643,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729092628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726654\">Suraaj K S</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/477244269\">said</a>:</p>\n<blockquote>\n<p>Here's an example: <a href=\"https://www.cs.cornell.edu/courses/cs6110/2023sp/lectures/lec08.pdf\">https://www.cs.cornell.edu/courses/cs6110/2023sp/lectures/lec08.pdf</a>. In section 3.1, you have the side condition -- <code>(where n2 is the sum of n0 and n1)</code></p>\n</blockquote>\n<p>I would fit that in my framework by saying that there are actually an infinite family of judgments <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>σ</mi><mo stretchy=\"false\">⟩</mo><msub><mo>⇓</mo><mi>a</mi></msub><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\langle a,\\sigma\\rangle \\Downarrow_a n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mclose\">⟩</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\">⇓</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, one for each external integer <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, and what looks like one rule with a side condition is shorthand for infinitely many rules, one for each triple of external integers <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>n</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>n</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>n</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(n_0,n_1,n_2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">n_0+n_1=n_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 477249841,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729094271
    },
    {
        "content": "<p>There are certainly different formal definitions of \"deductive system\" that one might give, and the one you cited is indeed different from mine.  That one appears to be focused on inductive definitions of <em>subsets</em> of some previously fixed set, whereas mine is focused more on inductively defining <em>new</em> sets.  With the latter end in mind, I needed to insist that the entire structure be <em>algebraic</em>, which means there are no \"side conditions\" in a formal sense, although as in this case many \"side conditions\" can be reexpressed as talking about parametrized families of judgments and rules.</p>",
        "id": 477250814,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729094552
    },
    {
        "content": "<p>Another thing that I'm noting (which might be incorrect) is that while the definition of deductive systems in your notes seems to restrict the kinds of systems you can build, you can always go overboard and define whatever you want. What I'm thinking might be better expressed using an example like the follows:</p>\n<p>Let your Σ1 be a signature with one sort and a single nullary operator <code>unit</code>. WΣ1 has only one element.<br>\nI think you could define Σ2 with the following sorts - each sort is a pair &lt;r, unit&gt; where r is a real number and unit is the element of WΣ1. Now, your set of sorts is isomorphic to the reals.</p>\n<p>Is there anything that prevents me from defining such a 'weird' deductive system?</p>",
        "id": 477264257,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729099320
    },
    {
        "content": "<p>Nope!  That's perfectly fine.</p>",
        "id": 477318946,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729121480
    },
    {
        "content": "<p>I remember feeling a sense of shock when I first realized real vector spaces are algebras of a Lawvere theory.   That was a case of having uncountably many operations rather than sorts.   </p>\n<p>I remember feeling a similar sense of shock when I read about <a href=\"https://plato.stanford.edu/entries/logic-infinitary/#1\">infinitary logic</a>, which allows certain formulas of infinite length, e.g. conjunctions and disjunctions of up to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> many formulas.</p>\n<p>My feeling was something like \"hey, syntax isn't supposed to be so big!\"</p>",
        "id": 477320971,
        "sender_full_name": "John Baez",
        "timestamp": 1729122842
    },
    {
        "content": "<p>Of course, if one actually wants to implement a type theory in a proof assistant or as a programming language, then the syntax has to be finitely generated.</p>",
        "id": 477322553,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729123921
    },
    {
        "content": "<p>Another way that the notes seem to differs from typical descriptions of type theories is as follows (I think)...</p>\n<p>I think that one traditionally thinks of judgements of the form <code>λx.x : Nat → Nat</code>, the notes above would treat the judgement as <strong>just</strong> <code>Nat → Nat</code>, and <code>λx.x</code> is a 'term'. I guess you could also have another deductive system (as defined in the notes) where the judgements are really 'traditional judgements' too?? Going a little further, maybe you even have some freedom / cleverness in actually choosing what part of a 'traditional judgement' you consider a 'term' and the rest is the judgement..</p>",
        "id": 477330358,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729129641
    },
    {
        "content": "<p>I don't know what's \"traditional\", but it's true that I made a choice to regard terms as notations for derivations of judgments as much as possible, rather than regarding typing judgments as a property of terms.  My reason for that is that it makes it easier to define categorical semantics by induction over derivations.  However, as you say, the formal setup of my Appendix A works just as well for a deductive system with typing judgments as a property of terms.</p>",
        "id": 477334152,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729131665
    },
    {
        "content": "<p>I see. I also think that, in your framework, if you think of things like <code>λx.x : Nat → Nat</code> as judgements (which are sorts), then you'd end up having at most one operator for each sort (where the sort appears as the 'target' of the operator), which is ?trivial? and maybe not that useful..</p>",
        "id": 477455238,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729174740
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/477320971\">said</a>:</p>\n<blockquote>\n<p>I remember feeling a sense of shock when I first realized real vector spaces are algebras of a Lawvere theory.   That was a case of having uncountably many operations rather than sorts.   </p>\n<p>I remember feeling a similar sense of shock when I read about <a href=\"https://plato.stanford.edu/entries/logic-infinitary/#1\">infinitary logic</a>, which allows certain formulas of infinite length, e.g. conjunctions and disjunctions of up to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> many formulas.</p>\n<p>My feeling was something like \"hey, syntax isn't supposed to be so big!\"</p>\n</blockquote>\n<p>Alternatively, one could shift over to a notion of multi-sorted Lawvere theory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">T</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.25417em;\">T</span></span></span></span>, involving a sort symbol <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> for the ground ring (usually a field) and a sort symbol <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> for the module (or vector space), and tame that syntax back under control. This is not just a stylistic choice. For example, this is the right choice to make if you want to interpret a topological vector space as a product-preserving functor from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">T</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.25417em;\">T</span></span></span></span> to topological spaces: you want the interpretation to give a continuous map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo>×</mo><mi>V</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R} \\times V \\to V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7722em;vertical-align:-0.0833em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>, a stronger requirement than just having the uncountably many scalar operations <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo>⋅</mo><mo>−</mo><mo>:</mo><mi>V</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">r \\cdot -: V \\to V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> be continuous.</p>",
        "id": 477509268,
        "sender_full_name": "Todd Trimble",
        "timestamp": 1729192702
    },
    {
        "content": "<p>That's a good point.  In the end I actually enjoyed the shock of thinking about theories that are too big to write down.   There's some logician who talked about the \"sacred\" versus \"profane\" attitudes toward logic, where in the sacred approach you are struggling to come close as possible to absolute certainty, and thus want to found everything on rules for manipulating finite strings drawn from a finite alphabet, while in the \"profane\" approach you treat it more like other mathematics, so you're more willing to countenance the use of infinite structures to study logic.</p>",
        "id": 477519362,
        "sender_full_name": "John Baez",
        "timestamp": 1729196960
    },
    {
        "content": "<p>First time I'd had to deal with infinitary logic was when Steve Vickers and Ming Ng wrote a series of papers on real analysis and Ostrowski's theorem and informally using the internal logic of a Grothendieck topos in their papers. </p>\n<p>I had a hard time wrapping my head around it because the infinitary nature of the internal logic meant that it was nigh impossible to come up with a finite set of rules to formalise said logic, and it was hard to accept that some things cannot be formalised using inference rules from scratch.</p>\n<p>I guess this can be formalised by adding an auxillary level and judgments representing the base topos, like the actual definition of a Grothendieck topos and similar to the multi-sorted Lawvere theories mentioned above, but at the time I was trying to avoid such multi-level theories.</p>",
        "id": 477522576,
        "sender_full_name": "Madeleine Birchfield",
        "timestamp": 1729198397
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277611\">Todd Trimble</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/477509268\">said</a>:</p>\n<blockquote>\n<p>For example, this is the right choice to make if you want to interpret a topological vector space as a product-preserving functor from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">T</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.25417em;\">T</span></span></span></span> to topological spaces: you want the interpretation to give a continuous map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo>×</mo><mi>V</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R} \\times V \\to V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7722em;vertical-align:-0.0833em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>, a stronger requirement than just having the uncountably many scalar operations <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo>⋅</mo><mo>−</mo><mo>:</mo><mi>V</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">r \\cdot -: V \\to V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> be continuous.</p>\n</blockquote>\n<p>Of course, that choice has the consequence that its algebras are topological modules over any topological ring, rather than specifically over the real numbers.</p>\n<p>A way to get specifically topological real vector spaces is to use John's original theory but regard it as topologically enriched, so that the product-preserving functors to spaces have to also be topologically enriched.</p>",
        "id": 477535927,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729205520
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726654\">Suraaj K S</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/477455238\">said</a>:</p>\n<blockquote>\n<p>I see. I also think that, in your framework, if you think of things like <code>λx.x : Nat → Nat</code> as judgements (which are sorts), then you'd end up having at most one operator for each sort (where the sort appears as the 'target' of the operator), which is ?trivial? and maybe not that useful..</p>\n</blockquote>\n<p>Yes, that's true, but I don't think that necessarily makes it trivial or unuseful.</p>",
        "id": 477536014,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729205558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/477519362\">said</a>:</p>\n<blockquote>\n<p>That's a good point.  In the end I actually enjoyed the shock of thinking about theories that are too big to write down.   There's some logician who talked about the \"sacred\" versus \"profane\" attitudes toward logic, where in the sacred approach you are struggling to come close as possible to absolute certainty, and thus want to found everything on rules for manipulating finite strings drawn from a finite alphabet, while in the \"profane\" approach you treat it more like other mathematics, so you're more willing to countenance the use of infinite structures to study logic.</p>\n</blockquote>\n<p>I think it might have been <span class=\"user-mention\" data-user-id=\"302507\">@David Corfield</span>  at the n-Category Cafe who spoke of \"sacred\" (which I just misspelled as \"scared\", ha!) versus \"profane\". I like it. Model theorists must be very profane. There's a standard trick where you start with a model of a theory and then create a new theory with a constant term for every element of that model, and that feels like a profane tactic in this sense.</p>",
        "id": 477541411,
        "sender_full_name": "Todd Trimble",
        "timestamp": 1729209346
    },
    {
        "content": "<p>Mike wrote </p>\n<blockquote>\n<p>A way to get specifically topological real vector spaces is to use John's original theory but regard it as topologically enriched, so that the product-preserving functors to spaces have to also be topologically enriched.</p>\n</blockquote>\n<p>Ah yes, where the parameter object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">T</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal{T}(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.25417em;\">T</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> of unary operations has the topological structure of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>.</p>",
        "id": 477543591,
        "sender_full_name": "Todd Trimble",
        "timestamp": 1729210808
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277611\">Todd Trimble</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/477541411\">said</a>:</p>\n<blockquote>\n<p>I think it might have been <span class=\"user-mention silent\" data-user-id=\"302507\">David Corfield</span>  at the n-Category Cafe who spoke of \"sacred\" (which I just misspelled as \"scared\", ha!) versus \"profane\". I like it. </p>\n</blockquote>\n<p>Actually I learned about this \"sacred/profane\" distinction from James Dolan, who has several times told me that the terminology goes back to some famous logician.   Unfortunately he can never remember which logician.</p>",
        "id": 477544560,
        "sender_full_name": "John Baez",
        "timestamp": 1729211474
    },
    {
        "content": "<p><a href=\"https://golem.ph.utexas.edu/category/2010/01/the_sacred_and_the_profane.html\">This</a> is the Cafe post by David. I wonder if James (who also goes by \"Jim\", which I've settled on having heard him give this name in a coffee shop once, but who doesn't commit to a definitive choice if you ask him) had in mind Dirk van Dalen, the author of this quotation from David's post: </p>\n<blockquote>\n<p>Logic appears in a ‘sacred’ and in a ‘profane’ form; the sacred form is dominant in proof theory, the profane form in model theory. The phenomenon is not unfamiliar, one observes this dichotomy also in other areas, e.g. set theory and recursion theory. Some early catastrophes such as the discovery of the set theoretical paradoxes or the definability paradoxes make us treat a subject for some time with the utmost awe and diffidence. Sooner or later, however, people start to treat the matter in a more free and easy way. Being raised in the ‘sacred’ tradition my first encounter with the profane tradition was something like a culture shock. Hartley Rogers introduced me to a more relaxed world of logic by his example of teaching recursion theory to mathematicians as if it were just an ordinary course in, say, linear algebra or algebraic topology. In the course of time I have come to accept this viewpoint as the didactically sound one: before going into esoteric niceties one should develop a certain feeling for the subject and obtain a reasonable amount of plain working knowledge. For this reason this introductory text sets out in the profane vein and tends towards the sacred only at the end. (p. V)</p>\n</blockquote>",
        "id": 477545568,
        "sender_full_name": "Todd Trimble",
        "timestamp": 1729212200
    },
    {
        "content": "<p>Abraham Robinson was probably someone who was relaxed and profane. Tarski: definitely not.</p>",
        "id": 477545701,
        "sender_full_name": "Todd Trimble",
        "timestamp": 1729212282
    },
    {
        "content": "<p>I bet Jim read this quote!  Thanks - I'll ask him.</p>",
        "id": 477549035,
        "sender_full_name": "John Baez",
        "timestamp": 1729214729
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277611\">Todd Trimble</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/477545568\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://golem.ph.utexas.edu/category/2010/01/the_sacred_and_the_profane.html\">This</a> is the Cafe post by David</p>\n</blockquote>\n<p>Good to revisit that discussion. </p>\n<p>With the use of categorical logic now <a href=\"https://blog.algebraicjulia.org/post/2022/09/ai-planning-cset/\">to plan one's breakfast</a> have we reached the full extent of the profane, or do we recover a sense of the sacred in the everyday?</p>",
        "id": 477608663,
        "sender_full_name": "David Corfield",
        "timestamp": 1729241784
    },
    {
        "content": "<p>Yes, this seems to be where James Dolan heard this story (and then recounted it to me):</p>\n<blockquote>\n<p>yes, a lot of the specifics seem as i remember it, for example having grown up in the sacred tradition but then converting under hartley rogers's influence, seeing logic taught \"as though like any other mathematical field\", etc ....</p>\n</blockquote>",
        "id": 477683303,
        "sender_full_name": "John Baez",
        "timestamp": 1729266147
    },
    {
        "content": "<p>This sentence is on the Wikipedia article on Model theory too!</p>\n<p><a href=\"https://en.m.wikipedia.org/wiki/Model_theory\">https://en.m.wikipedia.org/wiki/Model_theory</a></p>",
        "id": 477692684,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729269375
    },
    {
        "content": "<p>Sorry for the off-topic, but this sentence from David Corfield </p>\n<blockquote>\n<p>With the use of categorical logic now <a href=\"https://blog.algebraicjulia.org/post/2022/09/ai-planning-cset/\">to plan one's breakfast</a> have we reached the full extent of the profane, or do we recover a sense of the sacred in the everyday? </p>\n</blockquote>\n<p>inevitably reminds me of the historian of religions Mircea Eliade, who wrote often about <a href=\"https://en.wiktionary.org/wiki/hierophany\">hierophanies</a> of the sacred breaking into the everyday and quotidian, typically in camouflaged form. I just wonder whether David was also recalling him, when he wrote that sentence. </p>\n<p>I suppose category theory is my religion, and I probably often sound that way, too, with the Yoneda lemma being a holy of holies. On the other hand, when I'm doing a categorical calculation at home, it just feels like an ordinary piece of algebra, without any feeling of \"awe and diffidence\".  So I guess I don't practice what I preach. ;-)</p>",
        "id": 477741619,
        "sender_full_name": "Todd Trimble",
        "timestamp": 1729289573
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277611\">Todd Trimble</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/477741619\">said</a>:</p>\n<blockquote>\n<p>I just wonder whether David was also recalling him, when he wrote that sentence.</p>\n</blockquote>\n<p>Someone recently recommended Eliade to me, but I haven't started yet.</p>\n<p>I think it was part Buddhist (\"Show me where the Buddha isn't, and I'll spit there\") and part reflection on the ingenuity that allowed everything to come together in the same place to be able to make that breakfast, right back to the domestication of wheat and the rise of metalworking.</p>",
        "id": 477791701,
        "sender_full_name": "David Corfield",
        "timestamp": 1729331043
    },
    {
        "content": "<p>\"Show me where the Buddha isn't, and I'll spit there\" &lt;-- what a completely fantastic utterance, almost like a koan. It reminds me of a question a student asked after a talk by Bernie Glassman, a Zen teacher/roshi, something on the order of \"how can I fully live in the here and now?\", and Glassman replied, \"Will anyone who is not here now please stand up!\".</p>",
        "id": 477801105,
        "sender_full_name": "Todd Trimble",
        "timestamp": 1729340214
    },
    {
        "content": "<p>I was reading \"Notions of Computation and Monads\" (<a href=\"https://www.cs.cmu.edu/~crary/819-f09/Moggi91.pdf\">https://www.cs.cmu.edu/~crary/819-f09/Moggi91.pdf</a>).   Here, the author talks about three semantic-based approaches to prove equivalence of programs - operational, denotational, and logical.</p>\n<p>I think it's safe to say that there's no clear categorical semantics analog of program equivalence using operational semantics, which, if I understand correctly, is defined in terms of 'contextual/observational equivalence' of program terms.</p>\n<p>On the other hand, I think that the logical approach might just be the game of categorical semantics (an adjunction between a category of structured categories and the category of theories, although I don't know whether the programming language would be the doctrine or a theory).</p>\n<p>Denotational semantics is also probably a part of this framework, where your <strong>intended model</strong> is just a structured category (or maybe a functor too, I'm not too sure)?</p>\n<ul>\n<li>Is this right?</li>\n<li>A natural question to ask would be to ask what makes a good denotational semantcs? Clearly, we have to choose <strong>an intended model</strong>. Maybe we want to choose something 'initial', etc.?</li>\n</ul>",
        "id": 477936952,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729467330
    },
    {
        "content": "<blockquote>\n<p>I think it's safe to say that there's no clear categorical semantics analog of program equivalence using operational semantics, which, if I understand correctly, is defined in terms of 'contextual/observational equivalence' of program terms.</p>\n</blockquote>\n<p>If there isn't, it could be that category theorists have work left to do!  There are definitely papers that try to understand operational semantics using category theory.  However, since I'm not an expert on operational semantics, I'm not sure how close they come to capturing the concepts that experts in operational semantics want captured!</p>",
        "id": 477938421,
        "sender_full_name": "John Baez",
        "timestamp": 1729468637
    },
    {
        "content": "<p>I'm not enough of a computer scientist to be entirely confident in my answer, but reading what he says, it does sound like what he calls the \"logical approach\" is indeed just what we call categorical semantics, and what he calls the \"denotational approach\" is just a special case of that for a particular \"intended\" model.</p>",
        "id": 477942845,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729472875
    },
    {
        "content": "<p>I think usually the \"intended model\" in denotational semantics is some kind of category of domains.  You can try <a href=\"https://en.wikipedia.org/wiki/Denotational_semantics\">https://en.wikipedia.org/wiki/Denotational_semantics</a> to start with.</p>",
        "id": 477942929,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729472947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/477942929\">said</a>:</p>\n<blockquote>\n<p>I think usually the \"intended model\" in denotational semantics is some kind of category of domains.  You can try <a href=\"https://en.wikipedia.org/wiki/Denotational_semantics\">https://en.wikipedia.org/wiki/Denotational_semantics</a> to start with.</p>\n</blockquote>\n<p>Would it be correct to say that the intended model is just a category of domains? Or does it also include the interpretation functor (which is a morphism in the category of structured categories)?</p>",
        "id": 478065848,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729518532
    },
    {
        "content": "<p>It includes the functor.</p>",
        "id": 478169089,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729553141
    },
    {
        "content": "<p>The view I take on operational semantics is that it gives a recipe for building a categorical semantics via some sort of realizability model. There are <em>lots</em> of knobs you can turn here, but the basic plan typically follows the following shape:</p>\n<ul>\n<li>Pick some abstract theory of computation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">T</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">T</span></span></span></span> (partial combinatory algebras, basic combinatorial objects, etc).</li>\n<li>Give some construction that turns models of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">T</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">T</span></span></span></span> into well-behaved categories.</li>\n<li>Once you have your hands on a category, you can use the usual tools of categorical logic.</li>\n</ul>\n<p>This is all rather hand-wavy, so let's work through a concrete example. Our first move is to pick a theory of computation: I'm going to go with Hoffstra's basic combinatorial objects (BCOs), as they nicely model small-step operational semantics. In particular, a BCO consists of:</p>\n<ul>\n<li>A carrier set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>, which we should think of as a set of terms in some programming language</li>\n<li>A preorder <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⇝</mo></mrow><annotation encoding=\"application/x-tex\">\\leadsto</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.3779em;\"></span><span class=\"mrel amsrm\">⇝</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>, which we should think of as the reflexive-transitive closure of some small-step operational semantics.</li>\n<li>A subset <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>⊆</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo>⇀</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R \\subseteq (A \\rightharpoonup A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇀</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> of partial endofunctions on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> such that every <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">f \\in R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is monotone wrt <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⇝</mo></mrow><annotation encoding=\"application/x-tex\">\\leadsto</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.3779em;\"></span><span class=\"mrel amsrm\">⇝</span></span></span></span>, and also has a downwards closed domain. We should think of elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> as computable partial functions on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>. Downwards closure ensures that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span></span></span></span> is defined for every <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> that reduces to an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> where $f(b)$ is defined, and monotonicity ensures that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> respects reduction.</li>\n<li>A partial function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">i \\in R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6986em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> such that for every <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">a : A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">i(a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span></span></span></span> is defined and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>⇝</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">i(a) \\leadsto a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">⇝</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span>. We should think of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> as being a computable identity function.</li>\n<li>For every <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo separator=\"true\">,</mo><mi>g</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">f, g \\in R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, a partial function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>∈</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">c(f, g) \\in R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> such that </li>\n</ul>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>a</mi><mo>∈</mo><mi>d</mi><mi>o</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>g</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>∈</mo><mi>d</mi><mi>o</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>⇒</mo><mi>a</mi><mo>∈</mo><mi>d</mi><mi>o</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>∧</mo><mi>c</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>⇝</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall a \\in dom(g), g(a) \\in dom(f) \\Rightarrow a \\in dom(c(f,g)) \\land c(f,g)(a) \\leadsto f(g(a))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.0391em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">⇝</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">))</span></span></span></span></span></p>\n<p>We should think of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>g</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">c(f,g)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span></span></span></span> as being a sort of computable weak composite of two computable functions.</p>\n<p>A nice example of a BCO is the untyped lambda calculus equipped with a call-by-value operational semantics:</p>\n<ul>\n<li>The carrier set is the set of untyped lambda terms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Λ</mi></mrow><annotation encoding=\"application/x-tex\">\\Lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Λ</span></span></span></span></li>\n<li>The preorder is given by the reflexive-transitive closure <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mo>⇝</mo><mo lspace=\"0em\" rspace=\"0em\">∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\leadsto^{*}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mrel\"><span class=\"mrel amsrm\">⇝</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">∗</span></span></span></span></span></span></span></span></span></span></span></span> of the small-step reduction relation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⇝</mo></mrow><annotation encoding=\"application/x-tex\">\\leadsto</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.3779em;\"></span><span class=\"mrel amsrm\">⇝</span></span></span></span>.</li>\n<li>The computable endomaps are partial maps of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>↦</mo><mi>e</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a \\mapsto e a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.522em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">a</span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo>∈</mo><mi mathvariant=\"normal\">Λ</mi></mrow><annotation encoding=\"application/x-tex\">e \\in \\Lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Λ</span></span></span></span>. Monotonicity and downwards closure unfolds to </li>\n</ul>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>e</mi><mi>b</mi><mo>↓</mo><mtext> </mtext><mo>⇒</mo><mi>a</mi><msup><mo>⇝</mo><mo lspace=\"0em\" rspace=\"0em\">∗</mo></msup><mi>b</mi><mo>⇒</mo><mi>e</mi><mi>a</mi><mo>↓</mo><mo>∧</mo><mtext> </mtext><mi>e</mi><mi>a</mi><msup><mo>⇝</mo><mo lspace=\"0em\" rspace=\"0em\">∗</mo></msup><mi>e</mi><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">e b \\downarrow\\ \\Rightarrow a \\leadsto^{*} b \\Rightarrow e a \\downarrow \\land\\ e a \\leadsto^{*} e b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↓</span><span class=\"mspace\"> </span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7387em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel amsrm\">⇝</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7387em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">∗</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↓</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7387em;\"></span><span class=\"mord\">∧</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel amsrm\">⇝</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7387em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">∗</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">b</span></span></span></span></span></p>\n<p>which is pretty straightforward to show.</p>\n<ul>\n<li>The computable identity map is given by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda x. x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">x</span></span></span></span>, and the composition of two computable endomaps is given by their composition as lambda terms.</li>\n</ul>\n<p>Finally, let's show how we can link up to categorical logic by showing how to turn a BCO <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> into a fibration of preorders <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">P</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">d</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">A</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\rm{Pred}(A) \\to \\rm{Set}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Pred</span></span><span class=\"mopen\">(</span><span class=\"mord mathrm\">A</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Set</span></span></span></span></span></span></span> of $A$-valued predicates.</p>\n<ul>\n<li>Objects of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mi>r</mi><mi>e</mi><mi>d</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Pred(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\">re</span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> over a set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> are given by functions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>X</mi><mo>→</mo><mover accent=\"true\"><mi>A</mi><mo>^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\phi : X \\to \\hat{A}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9468em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9468em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">A</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1111em;\"><span class=\"mord\">^</span></span></span></span></span></span></span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>A</mi><mo>^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\hat{A}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9468em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9468em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">A</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1111em;\"><span class=\"mord\">^</span></span></span></span></span></span></span></span></span></span> is the set of down-sets of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>. We should think of such a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span></span></span></span> specifying a predicate on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> that can be witnessed by some computable evidence from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>.</li>\n<li>Given two predicates <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi><mo separator=\"true\">,</mo><mi>ψ</mi><mo>:</mo><mi>X</mi><mo>→</mo><mover accent=\"true\"><mi>A</mi><mo>^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\phi, \\psi : X \\to \\hat{A}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9468em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9468em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">A</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1111em;\"><span class=\"mord\">^</span></span></span></span></span></span></span></span></span></span>, we say that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi><mo>≤</mo><mi>ψ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi \\leq \\psi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span></span></span></span> when there (merely) exists a computable endomap <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">r \\in R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> such that </li>\n</ul>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo>∈</mo><mi>X</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">∀</mi><mi>a</mi><mo>∈</mo><mi>d</mi><mi>o</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mi>r</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mi>ϕ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>⇒</mo><mi>ψ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>r</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">  \\forall x \\in X. \\forall a \\in dom(r). \\phi(x, a) \\Rightarrow \\psi(x, r(a))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.0391em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">.∀</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">ϕ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">))</span></span></span></span></span></p>\n<p>In more intuitive terms, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi><mo>≤</mo><mi>ψ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi \\leq \\psi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span></span></span></span> whenever we have an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-computable function that turns <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-computable evidence of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span></span></span></span> into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-computable evidence of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding=\"application/x-tex\">\\psi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span></span></span></span>.</p>\n<p>From here, we can use the normal tools of categorical logic to build even more interesting fibrations from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">P</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">d</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\rm{Pred}(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Pred</span></span><span class=\"mopen\">(</span><span class=\"mord mathrm\">A</span><span class=\"mclose\">)</span></span></span></span></span>, use the internal logic of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">P</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">d</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\rm{Pred}(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Pred</span></span><span class=\"mopen\">(</span><span class=\"mord mathrm\">A</span><span class=\"mclose\">)</span></span></span></span></span>, etc. What this ends up buying us is the ability to prove that certain programs (a) exist and (b) obey some specification.</p>",
        "id": 478972631,
        "sender_full_name": "Reed Mullanix",
        "timestamp": 1729882495
    },
    {
        "content": "<p>Would you say that such a realizability model could then be considered an \"intended\" model and thereby become a \"denotational\" semantics?</p>",
        "id": 478988876,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729890547
    },
    {
        "content": "<p>To be honest, I don't really like the term \"denotational\". Typically, it's defined as \"constructing a bunch of mathematical objects that describe the meaning of programs\", but this includes <em>any</em> notion of semantics lol. </p>\n<p>Putting terminological gripes aside, here's my understanding of what the linked PDF is trying to get across. In the \"denotational approach\", we are doing all of our work within a single category (the \"intended model\"). This is typically how we'd work when using some sort of domain-theoretic semantics, as the category of domains is typically rich enough that we don't need to leave. Conversely, in the \"logical approach\", we are working in a doctrine rather than a single category. A more apt description might be \"petit\"/\"gros\".</p>",
        "id": 478997694,
        "sender_full_name": "Reed Mullanix",
        "timestamp": 1729895927
    },
    {
        "content": "<p>Realizability models kind of break this distinction, as you tend to do a lot of work inside a realizability model, but you also are interested in relating it to <em>other</em> models.</p>",
        "id": 478998241,
        "sender_full_name": "Reed Mullanix",
        "timestamp": 1729896274
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276059\">Reed Mullanix</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/478997694\">said</a>:</p>\n<blockquote>\n<p>To be honest, I don't really like the term \"denotational\". Typically, it's defined as \"constructing a bunch of mathematical objects that describe the meaning of programs\", but this includes <em>any</em> notion of semantics lol. </p>\n</blockquote>\n<p>Oh good, I'm glad I'm not the only one who feels that way.</p>",
        "id": 479005092,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729901463
    },
    {
        "content": "<p>I tend to consider semantics \"denotational\" when there's a more-or-less-compositional mapping that is doing most of the work.</p>",
        "id": 479006147,
        "sender_full_name": "James Deikun",
        "timestamp": 1729902527
    },
    {
        "content": "<p>Doesn't a \"compositional mapping\" just mean that it's a functor, which is true of any notion of semantics?</p>",
        "id": 479007206,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729903602
    },
    {
        "content": "<p>One more plausible definition is that you are looking at models in concrete categories; perhaps “concrete semantics” is a better descriptor?</p>",
        "id": 479007462,
        "sender_full_name": "Reed Mullanix",
        "timestamp": 1729903816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/479007206\">said</a>:</p>\n<blockquote>\n<p>Doesn't a \"compositional mapping\" just mean that it's a functor, which is true of any notion of semantics?</p>\n</blockquote>\n<p>If I understand my PL right, I think that a compositional map is defined inductively over the syntax of the programming language.</p>",
        "id": 479007600,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729903936
    },
    {
        "content": "<p>My platonic ideal of denotational semantics is that it's basically defined by structural recursion on the syntax, yeah.</p>",
        "id": 479007618,
        "sender_full_name": "James Deikun",
        "timestamp": 1729903953
    },
    {
        "content": "<p>The more you need some fancy recursion scheme that can't be explained as \"structural\" the less denotational it is.</p>",
        "id": 479007820,
        "sender_full_name": "James Deikun",
        "timestamp": 1729904163
    },
    {
        "content": "<p>Would it be fair to say that the 'structured categories' in the Moggi paper are categories with monads?</p>\n<p>I guess 'computational λ-calculus' is the doctrine?</p>",
        "id": 479007894,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729904255
    },
    {
        "content": "<p>I'm failing to see how you could define a notion of semantics other than by recursion on the syntax. Can you give an example?</p>",
        "id": 479007971,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729904367
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276059\">Reed Mullanix</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/479007462\">said</a>:</p>\n<blockquote>\n<p>One more plausible definition is that you are looking at models in concrete categories; perhaps “concrete semantics” is a better descriptor?</p>\n</blockquote>\n<p>Do you mean \"concrete\" in the precise sense of \"admitting a faithful functor to Set\"?</p>",
        "id": 479008043,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729904420
    },
    {
        "content": "<p>A big-step or small-step operational semantics will often recurse on the same piece of syntax many times or even no times.  This is recursion but it's not <em>structural</em> recursion.</p>",
        "id": 479008067,
        "sender_full_name": "James Deikun",
        "timestamp": 1729904451
    },
    {
        "content": "<p>Sorry, I still don't get it.  Are you talking about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction steps?</p>",
        "id": 479011311,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729908028
    },
    {
        "content": "<p>Yes. I think that James is talking about β reduction steps.</p>",
        "id": 479012611,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729909320
    },
    {
        "content": "<p>If I understand correctly, in small-step operational semantics (also called transitional semantics), you define <strong>the next step relation/function</strong> using recursion on the syntax (and I think that this 'syntax' is not just the syntax of the programming language, but you could have additional things like 'stores'/'memories', etc.). For instance, we could be giving the definition of a function <code>step: (Program, Store) → (Program, Store)</code>.<br>\nThe 'real' semantics is then defined using the <strong>next step relation</strong>. 'Real' semantics should (imo) be a function which maps Programs to some semantic domain. For instance, in our example above, <code>real_semantics : Program → [Store → (Store + 'diverge')]</code>.</p>",
        "id": 479013049,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729909825
    },
    {
        "content": "<p>On the other hand, when we want to give a compositional (aka denotational aka fixedpoint) semantics, we 'directly' define the 'real_semantics' by recursion on the syntax of programs. Moreover, I think that often, you'd need fancy semantic domains to be able to do this.</p>",
        "id": 479013308,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729910141
    },
    {
        "content": "<p>Hi I learnt that there are three forms of semantics of programming languages: operational, denotational and axiomatic. I think I learnt it from  <a href=\"https://www.inf.ed.ac.uk/teaching/courses/lsi/sempl.pdf\">Andy Pitts' lecture notes</a>, slide 3. The three forms can be related via various theorems but they have different aims and people don't always state or prove them.</p>",
        "id": 479037381,
        "sender_full_name": "Sam Staton",
        "timestamp": 1729935996
    },
    {
        "content": "<p>In his lecture notes, Andy does talk about equivalence. But I think often operational semantics often doesn't focus on equivalence of programs, e.g. this is only very briefly hinted at in the operational semantics in the <a href=\"https://smlfamily.github.io/sml97-defn.pdf\">definition of Standard ML</a>. When I started out, it seemed that a lot of people were mainly proving the theorems in the style of <a href=\"https://doi.org/10.1006/inco.1994.1093\">Wright and Felleisen</a>, which was very influential.</p>",
        "id": 479037417,
        "sender_full_name": "Sam Staton",
        "timestamp": 1729936065
    },
    {
        "content": "<p>Let's consider the doctrine which is the following: λ-calculus, with a base type <strong>o</strong> and function types only. In this doctrine, I think that theories are just sets of equations, where an equation is a 4 tuple (H, M, N, τ), where H is a context, τ is a type, and M, N are (well-typed) terms.</p>\n<p>In this 'doctrine', there is a notion of soundness and completeness with respect to 'type frames' (for example, as defined here: <a href=\"https://fsl.cs.illinois.edu/teaching/2021/cs522/CS522-Fall-2021-Simply-Typed-Lambda-Calculus.pdf\">https://fsl.cs.illinois.edu/teaching/2021/cs522/CS522-Fall-2021-Simply-Typed-Lambda-Calculus.pdf</a> page 33). </p>\n<p>I'm wondering whether we can consider 'type frames' as structured categories (as one does in the adjunction/equivalence between the category of structured categories and the category of theories)?</p>",
        "id": 479084053,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729982286
    },
    {
        "content": "<p>Normally I would consider function types to be part of the doctrine, but the base type <code>o</code> to be part of a theory.</p>",
        "id": 479086092,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729984720
    },
    {
        "content": "<p>In general a theory can contain any number of base types, any number of undefined term symbols, as well as axioms.</p>",
        "id": 479086123,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729984768
    },
    {
        "content": "<p>Would it be safe to say that categorical models are a generalization of these 'type frame' models? I think people do say this, but I'm not really sure what this means</p>",
        "id": 479087164,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1729986015
    },
    {
        "content": "<p>I expect with a bit of work, a 'type frame' can be turned into a model in Set, since it associates each type to a set.</p>",
        "id": 479087389,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1729986350
    },
    {
        "content": "<p>Here's a question which is particularly vague (mostly because I don't understand it things well enough), but here it goes. </p>\n<p>There seem to be 'type-theory' style proof assistants. These include coq, agda, nuprl, etc. These have dependent types. The Curry-Howard correspondence also applies here. Proofs are programs / morphisms into some proposition object. Propositions are types.</p>\n<p>There are also 'logic' style proof assistants. For instance, Isabelle/HOL. Here, propositions are <strong>terms</strong>, and what you need to prove is <code>p = true</code>, for a proposition p. Here, proofs <strong>are not</strong> first class objects that you can manipulate, like you can do in dependent type theories.</p>\n<p>Here's my vague question: Does the framework of categorical logic only apply to the first kind of doctrine? Maybe a related question is as follows: when you have the doctrine / type theory for first order logic, is a proof a morphism to a proof object (the first style), or is a proof a demonstration that two morphisms are equal (the second style)?</p>",
        "id": 479525616,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1730220984
    },
    {
        "content": "<p>Well, for one thing, I don't think the dichotomy is as sharp as that.  Most dependent type theory based proof assistants have Russell-style universes, in which case propositions, like all types, are <em>also</em> terms, namely terms belonging to some universe.  And some such proof assistants now have universes of proof-irrelevant propositions (\"SProp\") such that any two proofs of such a proposition are definitionally identical, so while they are still technically first-class objects you never need to know or think about them beyond whether or not there is one.</p>",
        "id": 479528898,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730222053
    },
    {
        "content": "<p>I would say the main difference is in whether the judgmental/dependency structure is \"stratified\" or not: whether propositions belong to the same \"world\" of types so that types can depend on propositions as well as vice versa, or whether propositions are allowed to depend on types but not the other way around.  These two choices correspond to two different kinds of categorical structure: in one case the fibration of types/propositions has \"comprehension\" whereas in the other it doesn't.  But both have a categorical semantics.</p>",
        "id": 479529237,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730222195
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/479529237\">said</a>:</p>\n<blockquote>\n<p>I would say the main difference is in whether the judgmental/dependency structure is \"stratified\" or not: whether propositions belong to the same \"world\" of types so that types can depend on propositions as well as vice versa, or whether propositions are allowed to depend on types but not the other way around.  These two choices correspond to two different kinds of categorical structure: in one case the fibration of types/propositions has \"comprehension\" whereas in the other it doesn't.  But both have a categorical semantics.</p>\n</blockquote>\n<p>If propositions are allowed to depend on types, but not the other way around, I'm guessing that that would correspond to 'logic'-style (perhaps this is bad terminology), where you typically want to prove <code>p=true</code>?</p>",
        "id": 479531088,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1730222868
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726654\">Suraaj K S</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/479525616\">said</a>:</p>\n<blockquote>\n<p>Here's my vague question: Does the framework of categorical logic only apply to the first kind of doctrine?</p>\n</blockquote>\n<p>Certainly not. Lawvere's work on hyperdoctrines is I think the original \"categorical logic\" and it is models first-order logic.</p>",
        "id": 479536733,
        "sender_full_name": "Max New",
        "timestamp": 1730224976
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726654\">Suraaj K S</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/479531088\">said</a>:</p>\n<blockquote>\n<p>If propositions are allowed to depend on types, but not the other way around, I'm guessing that that would correspond to 'logic'-style (perhaps this is bad terminology), where you typically want to prove <code>p=true</code>?</p>\n</blockquote>\n<p>Whether you phrase the proof rules as \"proving <code>p</code>\" or \"proving <code>p=true</code>\" is an irrelevant detail of syntax, it doesn't change the categorical semantics.</p>",
        "id": 479538246,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730225579
    },
    {
        "content": "<p>I am a little curious about the following - theories of doctrines don't need to have a special sort <code>Prop</code>, right? However, I'm guessing that when people say first order logic, they are referring to a theory which has <code>Prop</code> in <strong>the first order logic</strong> doctrine? Or does the doctrine itself have <code>Prop</code> built in?</p>",
        "id": 479546258,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1730228739
    },
    {
        "content": "<p>A doctrine can stipulate the existence of certain special types like Prop, in addition to whatever base types are specified by different theories in that doctrine.  However, when I think of first-order logic, I <em>don't</em> think of Prop as being a type but rather a judgment.  When Prop is a type, then that's more like higher-order logic.</p>",
        "id": 479547532,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730229265
    },
    {
        "content": "<p>I see. That makes sense. I was reading <a href=\"https://www.google.com/books/edition/Theories_of_Programming_Languages/X_ToAwAAQBAJ?hl=en&amp;gbpv=1&amp;pg=PA1&amp;printsec=frontcover\">https://www.google.com/books/edition/Theories_of_Programming_Languages/X_ToAwAAQBAJ?hl=en&amp;gbpv=1&amp;pg=PA1&amp;printsec=frontcover</a>. </p>\n<p>The book starts off with the syntax and semantics of predicate logic (section 1.1-1.2). Here is a summary of the syntax:</p>\n<ul>\n<li>The syntactic forms are <strong>integer expressions</strong> and <strong>assertions</strong>. If we'd like to view syntax as a multisorted algebraic signature, we can view the syntax as a two-sorted signature.</li>\n<li><strong>integer expressions</strong> include integer constants (formally, a familiy nullary operations of the target sort of <strong>integer expressions</strong>, for each number), <strong>variables</strong> (another nullary operation family), sums (a binary operation), etc. Fairly standard stuff.</li>\n<li><strong>assertions</strong> include 'and', 'or', 'universal quantifier', 'existentian quantifier', 'integer comparison', etc.</li>\n</ul>\n<p>The next section defines denotational semantics. </p>\n<ul>\n<li>The semantic function for <strong>integer expressions</strong> maps integer expressions to functions of type <code>&lt;Var&gt; → Nat → Nat</code>.  That is, a semantic domain maps <strong>a state</strong> to a value</li>\n<li>Similarly, the semantic domain for <strong>assertions</strong> maps  states to <strong>booleans</strong>.</li>\n</ul>\n<p>It is fairly straightforward to define these semantic functions.</p>\n<p>If we want to view this using the lens of categorical semantics, I would say that the text described <strong>a theory</strong> in a <strong>doctrine</strong>, and not a doctrine itself. We would want to be able to have other theories in the doctrine, besides the theory of natural numbers, I guess.<br>\nWhat would be the 'right' doctrine in this case?</p>\n<p>Another thing that I notice is that the next doesn't really give axioms, but just gives an intended model. On the other hand, the description of doctrines must (?) have axioms too?</p>",
        "id": 479558349,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1730233242
    },
    {
        "content": "<p>One small note is that variables are not nullary operations, but just a standard term-constructor.  All theories contain variables, so they aren't specified as part of the theory the way constants and operations like <code>+</code> are.</p>",
        "id": 479566483,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730236465
    },
    {
        "content": "<p>Overall, I haven't looked at the book, but from your description it looks like the doctrine is just first-order logic.  The theory in this doctrine then has <em>one</em> sort (called \"integers\").  As I said, in first-order logic, assertions/propositions are another judgment, not a sort.</p>",
        "id": 479566721,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730236570
    },
    {
        "content": "<p>As for axioms, a theory in a doctrine is <em>allowed</em> to contain axioms, but it could decline to exercise that right (or, equivalently, have an empty set of axioms).</p>",
        "id": 479566863,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730236652
    },
    {
        "content": "<p>So it looks to me as though this is a description of a particular theory in the doctrine of first-order logic (with the doctrine and the theory a bit mixed together in the presentation), with one sort called \"integers\" and some operation symbols (nullary constants, binary plus, etc.).</p>",
        "id": 479567010,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730236718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/479566483\">said</a>:</p>\n<blockquote>\n<p>One small note is that variables are not nullary operations, but just a standard term-constructor.  All theories contain variables, so they aren't specified as part of the theory the way constants and operations like <code>+</code> are.</p>\n</blockquote>\n<p>Oh yes. That makes sense. The book has &lt;IntExp&gt; := 0|1.... | x | y ... , etc. which I blindly translated..</p>",
        "id": 479567666,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1730237054
    },
    {
        "content": "<p>The text however doesn't have 'assertions' variables too, like it does for 'integer expression' variables. Maybe that doesn't make it as clean as it should be</p>",
        "id": 479568190,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1730237320
    },
    {
        "content": "<p>No, I wouldn't expect it to.</p>",
        "id": 479569003,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730237675
    },
    {
        "content": "<p>That goes along with propositions being a judgment and not a sort: you can't (in ordinary first-order logic) hypothesize an arbitrary proposition.</p>",
        "id": 479569039,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730237698
    },
    {
        "content": "<p>There seems to be three notions of what 'an algebra' is:</p>\n<ul>\n<li>There's the categorical logic version - An algebraic theory is a theory in the doctrine of equational logic. An algebra is a structure preserving functor from the syntactic category of the theory into another structured category.</li>\n<li>There's a monad version. For instance, the last section of <a href=\"https://www.cs.uoregon.edu/research/summerschool/summer23/_lectures/Introduction_to_Category_Theory_notes.pdf\">https://www.cs.uoregon.edu/research/summerschool/summer23/_lectures/Introduction_to_Category_Theory_notes.pdf</a> talks about this. Here, I think that an 'algebraic' theory is a monad, and there's the notion of an algebra for an monad.</li>\n<li>Then, there also just seems to be an endofunctor version, as seen here <a href=\"https://golem.ph.utexas.edu/category/2008/11/coalgebraically_thinking.html\">https://golem.ph.utexas.edu/category/2008/11/coalgebraically_thinking.html</a>. Then there's a notion of an algebra for an endofunctor. </li>\n</ul>\n<p>I was wondering if the above notions of 'algebra' are related? Maybe the endofunctor version is just a generalization of the monad version? I'm not sure how this links to the categorical logic version, though..</p>",
        "id": 479912277,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1730390885
    },
    {
        "content": "<p>I don't know what \"just a generalization\" means, but algebras of monads seem quite different from algebras of endofunctors.    Note that if a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> is a monad, an algebra of the <em>monad</em> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> is not the same as an algebra of the underlying <em>endofunctor</em> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>.  </p>\n<p>I don't know a way to systematically convert a monad <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> into an endofunctor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> such that algebras of the endofunctor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> are equivalent to algebras of the endofunctor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>.   Nor do I know a way to systematically convert an endofunctor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> into a monad <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> such that algebras of the monad <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> are equivalent to algebras of the endofunctor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span>.    (If such processes exist, even under special conditions, I'd love to know about it!)</p>",
        "id": 479915826,
        "sender_full_name": "John Baez",
        "timestamp": 1730391964
    },
    {
        "content": "<p>On the other hand, there's a famous result due to Lawvere that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> is a <em>finitary</em> monad on the category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Set}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Set</span></span></span></span></span>, then there's a Lawvere theory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Θ</mi></mrow><annotation encoding=\"application/x-tex\">\\Theta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Θ</span></span></span></span> such that algebras of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Θ</mi></mrow><annotation encoding=\"application/x-tex\">\\Theta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Θ</span></span></span></span> are equivalent to algebras of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>.  And this is reversible: for any Lawvere theory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Θ</mi></mrow><annotation encoding=\"application/x-tex\">\\Theta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Θ</span></span></span></span> we can find a finitary monad on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Set}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Set</span></span></span></span></span> with the same algebras.</p>",
        "id": 479916509,
        "sender_full_name": "John Baez",
        "timestamp": 1730392190
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/479915826\">said</a>:</p>\n<blockquote>\n<p>Nor do I know a way to systematically convert an endofunctor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> into a monad <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> such that algebras of the monad <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> are equivalent to algebras of the endofunctor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span>.</p>\n</blockquote>\n<p>This is called the <a href=\"https://ncatlab.org/nlab/show/algebraically-free%20monad\">[[algebraically-free monad]]</a> generated by the endofunctor, and exists under mild conditions such as for an accessible endofunctor on a locally presentable category.</p>",
        "id": 479917798,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730392602
    },
    {
        "content": "<p>Are 'Lawvere theories' a synonym for \"theories in the doctrine of equational logic\"?</p>",
        "id": 479920462,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1730393469
    },
    {
        "content": "<p><a href=\"https://ncatlab.org/nlab/show/Lawvere+theory\">https://ncatlab.org/nlab/show/Lawvere+theory</a> seems to tell me that. I just want to make sure that I'm not misunderstanding</p>",
        "id": 479921169,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1730393708
    },
    {
        "content": "<p>Perhaps because I don't share your background, I don't know what you think \"equational logic\" includes.   Lawvere theories only describe <em>n-ary operations</em> obeying universal equational laws.</p>",
        "id": 479952325,
        "sender_full_name": "John Baez",
        "timestamp": 1730405421
    },
    {
        "content": "<p>A Lawvere theory is sort of the \"extensional essense\" of a single-sorted theory in the doctrine of equational logic.  It doesn't privilege any particular generating operations or axioms, but includes all the derivable operations and equations between them on the same footing.</p>",
        "id": 479974651,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730418168
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/479952325\">said</a>:</p>\n<blockquote>\n<p>Perhaps because I don't share your background, I don't know what you think \"equational logic\" includes.   Lawvere theories only describe <em>n-ary operations</em> obeying universal equational laws.</p>\n</blockquote>\n<p>What I'd meant was what people call 'algebraic theories', etc. For example, as seen here: <a href=\"https://awodey.github.io/catlog/notes/catlog1.pdf\">https://awodey.github.io/catlog/notes/catlog1.pdf</a></p>",
        "id": 479975998,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1730419225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/479974651\">said</a>:</p>\n<blockquote>\n<p>A Lawvere theory is sort of the \"extensional essense\" of a single-sorted theory in the doctrine of equational logic.  It doesn't privilege any particular generating operations or axioms, but includes all the derivable operations and equations between them on the same footing.</p>\n</blockquote>\n<p>I see that makes sense. So, from every single-sorted theory of equational logic, I'm guessing that you 'can create' a lawvere theory. It does seem to be related to the 'syntactic' category that the theory gets mapped to  under the 'term-model' functor of the adjunction. If I understand correctly, the syntactic category is also freely built this way..</p>",
        "id": 479976767,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1730419857
    },
    {
        "content": "<p>This answer: <a href=\"https://math.stackexchange.com/questions/1520546/difference-between-lawvere-theory-and-its-syntactic-category\">https://math.stackexchange.com/questions/1520546/difference-between-lawvere-theory-and-its-syntactic-category</a> seems to say that they (lawvere theory and the syntactic category) are the same</p>",
        "id": 479987266,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1730429108
    },
    {
        "content": "<p>Yes, that's right: the Lawvere theory associated to a syntactic theory is the syntactic category, at least when it's regarded as a theory in the doctrine of finite-product categories.  (You can also regard an equational theory as living in the doctrine of cartesian multicategories, in which case its syntactic (multi)category contains the same information but isn't exactly what is usually referred to as a \"Lawvere theory\".)</p>",
        "id": 479999182,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730439276
    },
    {
        "content": "<p>More on your original question about the three notions of theory:</p>\n<ul>\n<li>As I mentioned, every nice endofunctor gives rise to a monad that has the same algebras.  The converse is not true; most monads don't have a corresponding endofunctor with the same algebras.</li>\n<li>Every single-sorted equational theory gives rise to a Lawvere theory, and every Lawvere theory gives rise to a monad on Set. Indeed, Lawvere theories are essentially equivalent to \"finitary\" monads on Set.  The resulting monad is the one associated to an endofunctor essentially when the original theory has only operations and no axioms.</li>\n<li>A multi-sorted equational theory similarly gives rise to a multi-sorted Lawvere theory, which in turn is equivalent to a finitary monad on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><mi>S</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Set}^S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9146em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Set</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9146em;\"><span style=\"top:-3.1362em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span></span></span></span></span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is the set of sorts.</li>\n</ul>\n<p>So you can see that the three notions are closely related, though not identical.</p>",
        "id": 479999409,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730439449
    },
    {
        "content": "<p>I'm curious if something like CiC (Calculus of <strong>inductive constructions</strong>) would fit in the doctrinal framework. </p>\n<p>So far, we have been thinking about doctrines like equational logic, STLC, etc. I am guessing that the <strong>Calculus of Constructions</strong> can also be thought of as a doctrine. This is the 'topmost' point of the lambda cube. Furthermore, I am guessing that we could have 'theories' in this doctrine, such as the theory of natural numbers, binary trees, etc. </p>\n<p>The <strong>Calculus of Inductive Constructions</strong> (baby coq), in some sense has infinitely many datatypes (in that you can define new datatypes). Can we still consider this as a 'theory' of CoC? Or would CiC be a doctrine in its own right? In that case, what would its theories be?</p>\n<p>Note: I picked CiC arbitrarily, and I could have probably asked the same question about Agda, etc...</p>",
        "id": 480348390,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1730678186
    },
    {
        "content": "<p>STLC already has infinitely many types, generated by the rule <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>A</mi><mtext> </mtext><mrow><mi mathvariant=\"sans-serif\">t</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow><mspace width=\"1em\"/><mi>B</mi><mtext> </mtext><mrow><mi mathvariant=\"sans-serif\">t</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow></mrow><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mtext> </mtext><mrow><mi mathvariant=\"sans-serif\">t</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{A\\,\\mathsf{type} \\quad B\\,\\mathsf{type}}{A\\to B \\, \\mathsf{type}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.4055em;vertical-align:-0.4811em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9244em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">A</span><span class=\"mrel mtight\">→</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace mtight\" style=\"margin-right:0.1952em;\"></span><span class=\"mord mtight\"><span class=\"mord mathsf mtight\">type</span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.4461em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">A</span><span class=\"mspace mtight\" style=\"margin-right:0.1952em;\"></span><span class=\"mord mtight\"><span class=\"mord mathsf mtight\">type</span></span><span class=\"mspace mtight\" style=\"margin-right:1.4286em;\"></span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace mtight\" style=\"margin-right:0.1952em;\"></span><span class=\"mord mtight\"><span class=\"mord mathsf mtight\">type</span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4811em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>.  I don't see the inductive datatype-forming operation in CIC as fundamentally different, although of course it's more complicated.</p>",
        "id": 480366175,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730694721
    },
    {
        "content": "<p>Rules that generate new types are never part of a theory, though; they have to be specified in the doctrine.  So CiC is a doctrine that extends CoC.</p>",
        "id": 480366232,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730694771
    },
    {
        "content": "<p>Theories in CiC would be, like theories in any other doctrine, specified by giving some <em>generating</em> types, terms, and axioms.</p>",
        "id": 480366281,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730694808
    },
    {
        "content": "<p>BTW, saying \"CiC\" has an advantage for this discussion over saying \"Coq\" or \"Agda\" in that it is closer to precisely mathematically specified than any real-world proof assistant is.</p>",
        "id": 480366347,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730694859
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/480366281\">said</a>:</p>\n<blockquote>\n<p>Theories in CiC would be, like theories in any other doctrine, specified by giving some <em>generating</em> types, terms, and axioms.</p>\n</blockquote>\n<p>That makes sense. Would it be correct to say that the doctrine of CiC has all inductive datatypes built-in? So things like the Natural numbers, etc. exist for all theories in the doctrine of CiC. </p>\n<p>This 'base' theory in the doctrine with no sorts and axioms is probably what the core of Gallina is. Is it possible to 'do' other theories with more sorts in Gallina? The <code>axiom</code> keyword lets us add axioms. Is there a way to add sorts?</p>",
        "id": 480470183,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1730734239
    },
    {
        "content": "<p>Yes, that's right.  If by \"sort\" you mean the same thing as a \"type\", then you can add generating types in Coq with <code>Axiom A : Type</code>.</p>",
        "id": 480474536,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1730735505
    },
    {
        "content": "<p>One way you'd do this is to add:</p>\n<ol>\n<li>A new sort of inductive descriptions</li>\n<li>A judgement describing the formation rules for inductive descriptions</li>\n<li>A type former <code>inductive d</code> that lifts descriptions into types</li>\n<li>introduction/elimination rules for <code>inductive d</code>, along with associated beta laws (you could add eta laws, but this immediately makes typechecking the resulting theory undecidable)</li>\n</ol>\n<p>Basically every system follows the same pattern for steps 1,2, and 4; the variations typically have to do with how inductive descriptions are turned into types. For instance, CiC does not have an <code>inductive d</code> type former; instead, they modify all their judgements to be parameterized by an extra context of datatype descriptions. This is typically done to ensure that equality of inductive types is not structural. For instance, the following two types are <em>not</em> equal in CiC.</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">nat</span> <span class=\"o\">:</span> <span class=\"kt\">Set</span> <span class=\"o\">:=</span>\n<span class=\"o\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">.</span>\n<span class=\"o\">|</span> <span class=\"n\">suc</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Inductive</span> <span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"kt\">Set</span> <span class=\"o\">:=</span>\n<span class=\"o\">|</span> <span class=\"n\">zilch</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">.</span>\n<span class=\"o\">|</span> <span class=\"n\">plus_one</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">.</span>\n</code></pre></div>\n<p>That being said, both the extra inductive context and type-former approaches can be expressed as generalized algebraic theories.</p>",
        "id": 480827306,
        "sender_full_name": "Reed Mullanix",
        "timestamp": 1730856264
    },
    {
        "content": "<p>I'm curious to know whether the doctrinal framework can be used with <strong>the untyped lambda calculus</strong> as a doctrine too? I was wondering, for example, if Dana Scott's notion of a model of the untyped lambda calculus  can be thought of as some structure preserving functor from a syntactic category to another?</p>",
        "id": 482821606,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1731810732
    },
    {
        "content": "<p>Generally speaking, from a doctrinal/categorical/type-theoretic perspective, anything \"untyped\" is really \"unityped\", which is a property of a theory rather than a doctrine.</p>",
        "id": 482877808,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1731862350
    },
    {
        "content": "<p>Yes, it's kinda like the self-proclaimed \"untyped\" theories think they're not using types, but the view from outside is that they're using just one type - and that's the right view if you're trying to relate those \"untyped\" theories to the rest of the world.</p>",
        "id": 482882112,
        "sender_full_name": "John Baez",
        "timestamp": 1731865812
    },
    {
        "content": "<p>And with that said, then yes, models of the untyped lambda calculus are special cases of models of theories in the <em>typed</em> lambda calculus.</p>",
        "id": 482937805,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1731910391
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/On.20Categorical.20Logic/near/482937805\">said</a>:</p>\n<blockquote>\n<p>And with that said, then yes, models of the untyped lambda calculus are special cases of models of theories in the <em>typed</em> lambda calculus.</p>\n</blockquote>\n<p>That makes sense. <br>\nI'm wondering if we can consider the untyped lambda calculus be a theory of a weaker doctrine like equational logic as well? <br>\nNaively, I think that nothing stops us from doing so, as we could include a whole bunch of axioms that makes the theory 'just work'.</p>",
        "id": 483045586,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1731942209
    },
    {
        "content": "<p>I don't think that's possible with a naive approach, since equational logic doesn't have a notion of \"variable binding\" that you would need to describe lambda-abstractions.  But you could perhaps encode combinatory logic instead.</p>",
        "id": 483076100,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1731949591
    },
    {
        "content": "<p>Sorry to come late again. Just to add, <em>enriched</em> equational logic / enriched Lawvere theories / enriched monads can allow variable binding. For the simplest case, enrich in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mrow><mi mathvariant=\"bold\">F</mi><mi mathvariant=\"bold\">i</mi><mi mathvariant=\"bold\">n</mi><mi mathvariant=\"bold\">S</mi><mi mathvariant=\"bold\">e</mi><mi mathvariant=\"bold\">t</mi></mrow><mo separator=\"true\">,</mo><mrow><mi mathvariant=\"bold\">S</mi><mi mathvariant=\"bold\">e</mi><mi mathvariant=\"bold\">t</mi></mrow><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[\\mathbf{FinSet},\\mathbf{Set}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathbf\">FinSet</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Set</span></span><span class=\"mclose\">]</span></span></span></span>. I call the syntax `<a href=\"https://www.cs.ox.ac.uk/people/samuel.staton/papers/fossacs13.pdf\">parameterized algebraic theories</a>', and we included the theory of untyped lambda calculus very briefly at the end of our paper about <a href=\"https://www.cs.ox.ac.uk/people/samuel.staton/papers/lics2014-substitution.pdf\">jumps</a>.</p>",
        "id": 485055482,
        "sender_full_name": "Sam Staton",
        "timestamp": 1732872270
    },
    {
        "content": "<p>I was learning type theory from one of Andrej Bauer's courses here:  <a href=\"https://youtu.be/OEGXNEPddYw?si=nUXvg7xmQSxkbL9E\">https://youtu.be/OEGXNEPddYw?si=nUXvg7xmQSxkbL9E</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"OEGXNEPddYw\" href=\"https://youtu.be/OEGXNEPddYw?si=nUXvg7xmQSxkbL9E\"><img src=\"https://uploads.zulipusercontent.net/dfa239d4c218d041c505470ec5472c5590bd73ad/68747470733a2f2f692e7974696d672e636f6d2f76692f4f4547584e4550646459772f64656661756c742e6a7067\"></a></div><p>I thought it was pretty good, and I was wondering about whether I could get some further explanation about something.</p>\n<p>In the lectures, <strong>type theory</strong> is introduced (informally) as an alternative to 'traditional' set theory (which is a theory of first order logic). </p>\n<p>Type theory is stated to not depend on an 'underlying' foundational logic, and is supposed to be the a 'logic-free' formalism for manipulating sets (types), 'without logic'.</p>\n<p>Now, in order to 'do logic' in type theory (<a href=\"https://youtu.be/OEGXNEPddYw?si=i-0NuD7PAgHqqJZH&amp;t=4909\">https://youtu.be/OEGXNEPddYw?si=i-0NuD7PAgHqqJZH&amp;t=4909</a>), two options are presented:</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"OEGXNEPddYw\" href=\"https://youtu.be/OEGXNEPddYw?si=i-0NuD7PAgHqqJZH&amp;t=4909\"><img src=\"https://uploads.zulipusercontent.net/dfa239d4c218d041c505470ec5472c5590bd73ad/68747470733a2f2f692e7974696d672e636f6d2f76692f4f4547584e4550646459772f64656661756c742e6a7067\"></a></div><ul>\n<li>Have a 'set' / type called <code>Prop = {⊥,⊤}</code> and axiomatize 'things'</li>\n<li>Use propositions as types</li>\n</ul>\n<p>The lecture says that it is <strong>not</strong> going to use the first approach, and is going to rely on the second approach. </p>\n<p>I was wondering however, how the first approach would look like? I'm thinking of things like Isabelle/HOL taking the first option, but this is just a guess. Any elaboration would be very helpful!</p>",
        "id": 496203987,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1738008696
    },
    {
        "content": "<p>On a lighter(?) note, Bourbaki's One Big Theorem: <a href=\"https://conceptualmathematics.wordpress.com/2022/11/26/nirvana-samsara/\">Nirvana = Samsara</a> might inform the above question of <span class=\"user-mention\" data-user-id=\"302507\">@David Corfield</span>  <a href=\"https://grahampriest.net/\">Graham Priest</a> provides all the logic of this \"0 = 1\".  Full Disclosure: Nagarjuna, the Buddhist monk, to whom the above big theorem is credited, belongs to my state of Andhra Pradesh (or, so we think ;)</p>",
        "id": 514196548,
        "sender_full_name": "Posina Venkata Rayudu",
        "timestamp": 1745518499
    }
]