[
    {
        "content": "<p>I've been reading Tom Leinster's course notes on Axiomatic Set theory, which treats ETCS as the foundational theory, rather than ZFC. We know that ZFC is a <strong>single sorted first order theory</strong>, with the one sort being for  'sets', and one binary predicate <code>∈</code> for membership (This is all we need if I understand correctly. Although perhaps one could also give a theory with a nullary operation for empty set, etc.)</p>\n<p>My question is about ETCS, as described in the lecture notes. I think that the theory is <strong>not single sorted</strong> - there are 'things' which are sets, and there are 'things' which are functions too. I do think that ETCS is a multisorted first-order theory, though. My question is: what precisely would be the sorts, predicates, and operators for ETCS?</p>",
        "id": 491076415,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1735377076
    },
    {
        "content": "<p>Well, I guess, we don't even need to go to ETCS. Perhaps the essence of the question is just about 'the theory of categories'</p>",
        "id": 491076829,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1735377441
    },
    {
        "content": "<p>The most natural way to do it is to say the objects have one sort, and then for each pair of objects, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, there's a sort <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Hom}(A,B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Hom</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span> of functions from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>. The operator <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Hom}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Hom</span></span></span></span></span> is a 'dependent sort'. The extremely relevant paper is <a href=\"https://www.math.mcgill.ca/makkai/folds/foldsinpdf/FOLDS.pdf\">First Order Logic with Dependent Sorts, with Applications to Category Theory</a>.</p>",
        "id": 491076851,
        "sender_full_name": "Oscar Cunningham",
        "timestamp": 1735377476
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276945\">Oscar Cunningham</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Is.20ETCS.20a.20two-sorted.20first.20order.20theory.3F/near/491076851\">said</a>:</p>\n<blockquote>\n<p>The most natural way to do it is to say the objects have one sort, and then for each pair of objects, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, there's a sort <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Hom}(A,B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Hom</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span> of functions from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>. The operator <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Hom}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Hom</span></span></span></span></span> is a 'dependent sort'. The extremely relevant paper is <a href=\"https://www.math.mcgill.ca/makkai/folds/foldsinpdf/FOLDS.pdf\">First Order Logic with Dependent Sorts, with Applications to Category Theory</a>.</p>\n</blockquote>\n<p>I see, so the doctrine / underlying logic for the theory would not be first-order logic.</p>",
        "id": 491076950,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1735377557
    },
    {
        "content": "<p>Perhaps not first-order logic as it's usually defined. But any theory with dependent sorts can be made into an equivalent one without, in this case by putting all the morphisms in a single sort like you said originally, and then having a predicate that says when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is a morphism from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>. So all the usual theorems about first-order logic still hold.</p>",
        "id": 491077336,
        "sender_full_name": "Oscar Cunningham",
        "timestamp": 1735377846
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276945\">Oscar Cunningham</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Is.20ETCS.20a.20two-sorted.20first.20order.20theory.3F/near/491077336\">said</a>:</p>\n<blockquote>\n<p>Perhaps not first-order logic as it's usually defined. But any theory with dependent sorts can be made into an equivalent one without, in this case by putting all the morphisms in a single sort like you said originally, and then having a predicate that says when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is a morphism from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>. So all the usual theorems about first-order logic still hold.</p>\n</blockquote>\n<p>I see. In this case, the 'theory of categories' would be a 2-sorted first-order theory (one sort for objects, another sort for morphisms). </p>\n<p>I'm wondering if you'd define the composition operation as a binary operation on the sort of morphisms? In this case, it seems like there can be many 'ill-typed' terms. How does one enforce that domains and codomains match?</p>",
        "id": 491078223,
        "sender_full_name": "Suraaj K S",
        "timestamp": 1735378638
    },
    {
        "content": "<p>Yes, an advantage of dependent sorts is that you don't have to worry about these ill-typed terms. In the 2-sorted theory it would probably be easiest to just have a predicate '<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is the composite of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span>' which is false when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span> aren't compatible.</p>",
        "id": 491078520,
        "sender_full_name": "Oscar Cunningham",
        "timestamp": 1735378923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726654\">Suraaj K S</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Is.20ETCS.20a.20two-sorted.20first.20order.20theory.3F/near/491078223\">said</a>:</p>\n<blockquote>\n<p>I'm wondering if you'd define the composition operation as a binary operation on the sort of morphisms? In this case, it seems like there can be many 'ill-typed' terms. How does one enforce that domains and codomains match?</p>\n</blockquote>\n<p>Another equivalence of FOLDS or Generalized FOL is with Essentially First-Order Logic (usually seen only in the Algebraic Theories case, with GATs vs. EATs), which does not have \"dependent\" sorts (I.e. non-atomic sorts formed from Terms) but rather partial function symbols! That gives you the composition one <span aria-label=\"blush\" class=\"emoji emoji-1f60a\" role=\"img\" title=\"blush\">:blush:</span></p>",
        "id": 491084242,
        "sender_full_name": "Vincent R.B. Blazy",
        "timestamp": 1735384414
    },
    {
        "content": "<p>Probably worth noting that categories can also be defined without reference to objects, with identities standing in (due to Freyd), e.g., here: <a href=\"https://math.stackexchange.com/questions/17469/category-theory-with-and-without-objects\">https://math.stackexchange.com/questions/17469/category-theory-with-and-without-objects</a></p>",
        "id": 491094037,
        "sender_full_name": "Spencer Breiner",
        "timestamp": 1735393685
    },
    {
        "content": "<p>More directly, <a href=\"https://ncatlab.org/nlab/show/single-sorted%20definition%20of%20categories\">[[single-sorted definition of categories]]</a>. I'm not absolutely sure it's due to Freyd, but it might be. It appears in Categories for the Working Mathematician. (Edit: Apparently also in Freyd's Abelian Categories, which now makes me think it <em>is</em> due to Freyd -- sorry I seemed to be doubtful a few sentences ago.)</p>",
        "id": 491094214,
        "sender_full_name": "Todd Trimble",
        "timestamp": 1735393909
    },
    {
        "content": "<p>FOLDS as formulated by Makkai doesn't actually have function symbols, only relation symbols.  He had a good reason for doing it that way, but it sort of defeats part of the purpose here since you still have to encode composition by a relation instead of a dependently typed function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>y</mi><mo separator=\"true\">,</mo><mi>z</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mi>hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\hom(y,z) \\times \\hom(x,y) \\to \\hom(x,z)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">hom</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">hom</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">hom</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span></span></span></span>.  Unfortunately I don't know of a place where \"dependently typed first-order logic\" that does include function symbols is written down precisely, but it should be easy to do.</p>",
        "id": 491105239,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1735404818
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"726654\">@Suraaj K S</span>  did you look at the paper?<br>\n<a href=\"http://www.tac.mta.ca/tac/reprints/articles/11/tr11.pdf\">http://www.tac.mta.ca/tac/reprints/articles/11/tr11.pdf</a></p>",
        "id": 491296055,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1735572999
    },
    {
        "content": "<p>ETCS is a first-order theory with a single sort called the sort of \"mappings\". The object x is identified with the identity morphism id_x.</p>",
        "id": 491296133,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1735573054
    },
    {
        "content": "<p>composition is a partially defined function, which it is easy to model as a ternary relation on morphisms: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>g</mi><mo separator=\"true\">,</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R(f, g, h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">)</span></span></span></span> holds if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi><mo>=</mo><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">g\\circ f=h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span></p>",
        "id": 491296318,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1735573159
    }
]