[
    {
        "content": "<p>Not sure if there was already a topic for asking about specific references, so I made one (please move it if I'm wrong).</p>",
        "id": 218223805,
        "sender_full_name": "John van de Wetering",
        "timestamp": 1606674718
    },
    {
        "content": "<p>I'm looking for the canonical reference for Frobenius algebras</p>",
        "id": 218223847,
        "sender_full_name": "John van de Wetering",
        "timestamp": 1606674727
    },
    {
        "content": "<p>Would anyone here happen to know what that would be?</p>",
        "id": 218223852,
        "sender_full_name": "John van de Wetering",
        "timestamp": 1606674735
    },
    {
        "content": "<p>What I've found so far: In this 1987 paper they have a notion of 'discrete' object that is a Frobenius algebra <a href=\"https://www.sciencedirect.com/science/article/pii/0022404987901216\">https://www.sciencedirect.com/science/article/pii/0022404987901216</a><br>\nBut, in this 1969 Lawvere paper, he already has a notion called Frobenius algebra that seems to be equivalent:  <a href=\"https://link.springer.com/content/pdf/10.1007/BFb0083085.pdf\">https://link.springer.com/content/pdf/10.1007/BFb0083085.pdf</a><br>\nThe way he defines it makes me think that there must be an even older paper using the categorical definition of a Frobenius algebra</p>",
        "id": 218268610,
        "sender_full_name": "John van de Wetering",
        "timestamp": 1606731489
    },
    {
        "content": "<p>Dd you try <span class=\"user-mention\" data-user-id=\"276625\">@Joachim Kock</span>'s <a href=\"http://mat.uab.es/~kock/TQFT.html#history\">history of Frobenius algebras</a>?   He writes:</p>\n<blockquote>\n<p>Bill Lawvere knew about the categorical characterisation of Frobenius algebras in 1967, but he did not explicitly write the Frobenius equation. In Chapter 2, I write that the first explicit appearance of the Frobenius equation is in the lecture notes of Quinn (published in 1995, lectures from 1991). This turns out to be wrong...</p>\n</blockquote>",
        "id": 218317675,
        "sender_full_name": "John Baez",
        "timestamp": 1606757132
    },
    {
        "content": "<p>I was expecting this to be a straightforward question, I didn't realise the answer was this complicated :P</p>",
        "id": 218354432,
        "sender_full_name": "John van de Wetering",
        "timestamp": 1606774695
    },
    {
        "content": "<p>Guess I will have to cite more then one paper then</p>",
        "id": 218354462,
        "sender_full_name": "John van de Wetering",
        "timestamp": 1606774714
    },
    {
        "content": "<p>Hi all. Does anyone know where I can refer to the adjunction between operads and monoidal categories? I didn't see it in a cursory look through Leinster or Yau, though it's probably in one of those two somewhere. Thanks!</p>",
        "id": 234584316,
        "sender_full_name": "Spencer Breiner",
        "timestamp": 1618438014
    },
    {
        "content": "<p>Any variant will probably do, but symmetric monoidal categories and multicategories/colored operads is most relevant.</p>",
        "id": 234584392,
        "sender_full_name": "Spencer Breiner",
        "timestamp": 1618438053
    },
    {
        "content": "<p>The canonical reference is Hermida's <a href=\"https://www.sciencedirect.com/science/article/pii/S0001870899918777\">Representable Multicategories</a>.</p>",
        "id": 234585048,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1618438394
    },
    {
        "content": "<p>A general version is in section 9 of <a href=\"http://tac.mta.ca/tac/volumes/24/21/24-21abs.html\">A unified framework for generalized multicategories</a>.</p>",
        "id": 234601593,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1618449450
    },
    {
        "content": "<p>Thanks <span class=\"user-mention silent\" data-user-id=\"276092\">Nathanael Arkor</span> &amp; <span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span>!</p>",
        "id": 234705438,
        "sender_full_name": "Spencer Breiner",
        "timestamp": 1618502897
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculi are equivalent to cartesian closed categories. similarly <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>-calculi <em>with equality types</em> should be equivalent to cartesian closed categories with equalizers (aka \"properly CCCs\" in the Elephant). anyone know a reference for this?</p>",
        "id": 235753835,
        "sender_full_name": "Christian Williams",
        "timestamp": 1619128174
    },
    {
        "content": "<p>There's <a href=\"/user_uploads/21317/meonAHh9Esh8NSc95Dcx-4Sr/Modular-correspondence-between-dependent-t-Maria-Emilia-Maietti.pdf\">this paper</a> which gives a dependent type theory corresponding to categories with finite limits. It seems fairly straightforward to just add function types to obtain what you want.</p>",
        "id": 235759993,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1619131540
    },
    {
        "content": "<p>What do you mean by \"equality types\"?  If you mean equality types in a <em>dependent</em> type theory, then it's not so easy to formulate a dependent type theory corresponding to cartesian closed categories that aren't locally cartesian closed.  Just asking for non-dependent function-types <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> instead of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Π</mi></mrow><annotation encoding=\"application/x-tex\">\\Pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Π</span></span></span></span>-types isn't good enough: since type formers can be applied in any context, semantically this already requires that all slice categories are cartesian closed, which is equivalent to local cartesian closure.</p>",
        "id": 235779760,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1619147143
    },
    {
        "content": "<p>The best theory I can think of for CCCs with finite limits would be a logic with equality over STLC, so that you have equality propositions but not equality types.</p>",
        "id": 235779845,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1619147204
    },
    {
        "content": "<p>I think I'm seeing in Jacobs Ch3 what you're referring to, but I'm confused why we need to bring in logic over STLC. why isn't Eq just another type former like product?</p>",
        "id": 235785968,
        "sender_full_name": "Christian Williams",
        "timestamp": 1619152836
    },
    {
        "content": "<p>I guess it's different because it's parameterized by terms rather than types.</p>",
        "id": 235786556,
        "sender_full_name": "Christian Williams",
        "timestamp": 1619153341
    },
    {
        "content": "<p>so it looks like the codomain fibration of a finitely complete category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>d</mi><mi>C</mi></msub><mo>:</mo><mo stretchy=\"false\">[</mo><mi>I</mi><mo separator=\"true\">,</mo><mi>C</mi><mo stretchy=\"false\">]</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">cod_C:[I,C]\\to C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> has \"fibered equality\", and I think that should give STLC+equality.</p>",
        "id": 235786782,
        "sender_full_name": "Christian Williams",
        "timestamp": 1619153596
    },
    {
        "content": "<p>oh, maybe just the subobject fibration, yeah.</p>",
        "id": 235786803,
        "sender_full_name": "Christian Williams",
        "timestamp": 1619153640
    },
    {
        "content": "<p>I wasn't expecting to have to bring in this extra structure, but I guess that's fine. thanks for the pointer.</p>",
        "id": 235786849,
        "sender_full_name": "Christian Williams",
        "timestamp": 1619153654
    },
    {
        "content": "<p>it feels weird to say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mi>q</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mi>P</mi><mi>r</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">Eq(f,g):Prop</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">p</span></span></span></span> when there is no Prop, no subobject classifier.</p>",
        "id": 235787340,
        "sender_full_name": "Christian Williams",
        "timestamp": 1619154094
    },
    {
        "content": "<p>I guess Prop just refers to the total category of the subobject fibration.</p>",
        "id": 235787690,
        "sender_full_name": "Christian Williams",
        "timestamp": 1619154401
    },
    {
        "content": "<p>any way, I can see that the answer is here, but it is often not easy to find things in Jacobs. it has a lot but it's all mixed together.</p>",
        "id": 235787727,
        "sender_full_name": "Christian Williams",
        "timestamp": 1619154440
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"341237\">Fawzi Hreiki</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.20request/near/235759993\">said</a>:</p>\n<blockquote>\n<p>There's <a href=\"/user_uploads/21317/meonAHh9Esh8NSc95Dcx-4Sr/Modular-correspondence-between-dependent-t-Maria-Emilia-Maietti.pdf\">this paper</a> which gives a dependent type theory corresponding to categories with finite limits. It seems fairly straightforward to just add function types to obtain what you want.</p>\n</blockquote>\n<p>thanks for the reference; it looks good. but I'm having trouble understanding how these rules encode an equalizer:<br>\n<a href=\"/user_uploads/21317/rzLQRlyj2UI5juNo0oOpFHff/ext-equality.png\">ext-equality.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/rzLQRlyj2UI5juNo0oOpFHff/ext-equality.png\" title=\"ext-equality.png\"><img src=\"/user_uploads/21317/rzLQRlyj2UI5juNo0oOpFHff/ext-equality.png\"></a></div>",
        "id": 235788279,
        "sender_full_name": "Christian Williams",
        "timestamp": 1619154893
    },
    {
        "content": "<p>I picture the universal property and expect the inference rules to encode the property directly. though maybe it's not always that simple.</p>",
        "id": 235788446,
        "sender_full_name": "Christian Williams",
        "timestamp": 1619155018
    },
    {
        "content": "<p>I should take this to another thread.</p>",
        "id": 235788833,
        "sender_full_name": "Christian Williams",
        "timestamp": 1619155353
    },
    {
        "content": "<p>I can try to help with the type theory side of this:</p>\n<p>The third rule (E-Eq) is where the magic happens: in the formal language of type theories, it says something like “if you have a proof that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><msub><mo>=</mo><mi>C</mi></msub><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">c =_{C} d</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\">=</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span>, then you may treat <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span> as equal in the type theory”. It goes by the name equality reflection, it’s what makes the theory “extensional”. (The terminology is confusing, see <a href=\"https://ncatlab.org/nlab/show/extensional+type+theory#definitional_extensionality\">https://ncatlab.org/nlab/show/extensional+type+theory#definitional_extensionality</a> for more.)</p>\n<p>But anyways, if you know that you can treat <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span> the same (that’s what the judgment <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mo>=</mo><mi>d</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">c = d \\in C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> means, roughly speaking), then you can get stuff like Leibniz rule (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(c)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(d)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span></span></span></span> must also be the same), and I guess the universal property.</p>",
        "id": 235859388,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1619191018
    },
    {
        "content": "<p>but they're not equal; they're just a pair of parallel morphisms, and we want to specify the subobject of terms that are equalized by them.</p>",
        "id": 235867007,
        "sender_full_name": "Christian Williams",
        "timestamp": 1619194008
    },
    {
        "content": "<p>Yeah, this specifies the equality type. You can form equalizers using it along with the indexed sums: <a href=\"https://ncatlab.org/nlab/show/equalizer#in_type_theory\">https://ncatlab.org/nlab/show/equalizer#in_type_theory</a></p>",
        "id": 235873693,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1619196954
    },
    {
        "content": "<p>But it looks like they interpret the equality type via equalizers of the interpretations in the appropriate category (page 1116), so it is actually an equalizer in the interpretation even though it doesn't quite look like one internally.</p>",
        "id": 235875691,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1619197709
    },
    {
        "content": "<p>okay I see, thanks</p>",
        "id": 235875966,
        "sender_full_name": "Christian Williams",
        "timestamp": 1619197812
    },
    {
        "content": "<p>Proposition 5.11 (page 1130) gives the construction of pullbacks.</p>",
        "id": 235877555,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1619198521
    }
]