[
    {
        "content": "<p>I’m looking for a categorical way to articulate the intuition behind “the whole is greater than the sum of its parts.”<br>\nBy this I do not mean a vague holistic slogan, nor a numerical inequality. I mean a situation where:<br>\n• the data of the parts (objects, components, subobjects, factors, etc.)<br>\n• together with all pointwise or componentwise information<br>\nstill fails to determine the whole, unless additional structural or relational information is supplied.<br>\nIntuitively: the excess lives in the glue, not in the inventory.<br>\nI’m expecting answers in the neighbourhood of (but not limited to):<br>\n– limits/colimits vs products/coproduts<br>\n– pushouts vs disjoint unions<br>\n– extensions, coherence data, descent<br>\n– emergent structure not functorially recoverable from components alone<br>\nBonus points for examples where the slogan fails, i.e. contexts where the “whole really is just the sum” and no more (or even less!).</p>",
        "id": 565953629,
        "sender_full_name": "Keith Elliott Peterson",
        "timestamp": 1767244919
    },
    {
        "content": "<p>Start with 1.1 of Fong and Spivak:</p>\n<p><a href=\"/user_uploads/21317/H1XmYCXeamrJnwfFd9vYm2W2/Screenshot-2026-01-01-at-10.05.33AM.png\">Screenshot 2026-01-01 at 10.05.33 AM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/H1XmYCXeamrJnwfFd9vYm2W2/Screenshot-2026-01-01-at-10.05.33AM.png\" title=\"Screenshot 2026-01-01 at 10.05.33 AM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1094x1236\" src=\"/user_uploads/thumbnail/21317/H1XmYCXeamrJnwfFd9vYm2W2/Screenshot-2026-01-01-at-10.05.33AM.png/840x560.webp\"></a></div>",
        "id": 565983754,
        "sender_full_name": "JR",
        "timestamp": 1767279963
    },
    {
        "content": "<p>certainly in doing data integration with lifting problems (and colimits), each individual lifting problem (formula in regular logic) may be easy to understand and predict (decidable), but then taken together their behavior becomes undecidable and you have to \"run it and see\" to obtain the lift solution.</p>",
        "id": 565993549,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1767292048
    },
    {
        "content": "<p>If we are in a topos, then we can negate subobjects. However, sometimes the union/join of a subobject and its negation is less than the entire object! This can happen in toposes that are not Boolean.</p>\n<p>For example, consider a graph consisting of two vertices connected by a single directed edge. The negation of one vertex is the other vertex, but their union is not the whole graph - the \"glue\" which is missing in the union is the edge.</p>",
        "id": 565997656,
        "sender_full_name": "David Egolf (he/him)",
        "timestamp": 1767298057
    },
    {
        "content": "<p>As a different kind of example, I think any time a functor fails to preserve some colimit, then there is some degree of \"the whole is greater than the sum of the parts\". In this case, we originally had some data which forms some object via colimit, and then that relationship is disrupted by application of the functor. So some \"pieces\" which used to make up the \"whole\", no longer do after we apply our functor. If we think of our functor as an \"observation\", then the observation of the whole is not the colimit of the observations of the pieces.</p>\n<p>Although perhaps in this case we might prefer to say \"the whole is different from the sum of the parts\", instead of using the word \"greater\".</p>",
        "id": 565997780,
        "sender_full_name": "David Egolf (he/him)",
        "timestamp": 1767298244
    },
    {
        "content": "<p>As one more example, consider the case of presheaves. In a separated presheaf, if compatible local data can be stitched together, there is <em>unique</em> way to do so. So, if one started with some global data and observed it everywhere locally, then these observations would uniquely determine what we started with.</p>\n<p>I don't know how one can measure by how much or in what way a presheaf fails to be separated! But if one could do so, I guess one would have another way to describe how the parts of something fail to determine the whole.</p>",
        "id": 565998626,
        "sender_full_name": "David Egolf (he/him)",
        "timestamp": 1767299628
    },
    {
        "content": "<p>For a topological space that isn't locally connected, it isn't the disjoint union of its connected components. So for instance a totally disconnected space that isn't locally connected has singletons as its connected components, but the disjoint union of singletons is a discrete space.</p>",
        "id": 565999000,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1767300256
    },
    {
        "content": "<p>Eg Cantor space</p>",
        "id": 565999008,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1767300279
    },
    {
        "content": "<p>I just want to expand slightly on JR's answer.</p>\n<p>A category with at most one arrow between any two objects is a preorder. This lets you use the syntax <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a \\leq b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> between objects. If the category is equipped with a monotone commutative monoidal product, that allows the syntax <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a + b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> to combine objects. This is a monoidal preorder.</p>\n<p>After establishing an abstract presentation of some structured thingy, you should ask yourself \"What are the natural notions of arrows between these thingys?\" In this case we have a few natural choices, a monotone function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> between monoidal preorders is an arrow of a category provided <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is either,</p>\n<ul>\n<li>Lax: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>≤</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(a) + f(b) \\leq f(a + b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span> </li>\n<li>Strong: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>≅</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(a) + f(b) \\cong f(a + b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>Strict:  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(a) + f(b) = f(a + b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>Oplax: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>≥</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(a) + f(b) \\geq f(a + b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<p>When we think of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> as a sort of adjective or measurement, like eyeColor(Frank) = Blue, then these conditions correspond to respectively</p>\n<ul>\n<li>The whole is greater than the sum of its parts</li>\n<li>The whole is the same as the sum of its parts</li>\n<li>The definition of the whole is the same as the definition of the sum of its parts (This might be a stretch)</li>\n<li>The whole is less than the sum of its parts.</li>\n</ul>\n<p>So these adjectives are widened a little bit, in the sense that they're descriptions of arrows that systematically respect structure across an entire preorder. These get generalized to lax, strong, and oplax monoidal functors between monoidal categories.</p>\n<p>I believe all of the examples mentioned above can be subsumed by this scheme, with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>+</mo></mrow><annotation encoding=\"application/x-tex\">+</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">+</span></span></span></span> representing colimit operations between formulas, sets, graphs, and topological spaces.</p>",
        "id": 566002210,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1767305328
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"658891\">JR</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/The.20whole.20is.20greater.20than.20the.20sum.20of.20its.20parts.3F/near/565983754\">said</a>:</p>\n<blockquote>\n<p>Start with 1.1 of Fong and Spivak:</p>\n</blockquote>\n<p>They recommend Elie Adam's thesis <a href=\"https://elieadam.com/eadam_PhDThesis.pdf\">Systems, Generativity and Interactional Effects</a></p>\n<blockquote>\n<p>you might be interested in exploring some ideas in this chapter in other directions. While we won’t return to them in this book, we learned about generative effects from Elie Adam’s thesis [Ada17], and a much richer treatment of generative effect can be found there. In particular, he discusses abelian categories and cohomology, providing a way to detect generative effects in quite a general setting.</p>\n</blockquote>\n<p>I think there may be a useful way to address emergence here and in other works mentioned in <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Hoel.20et.20al.20on.20emergence\">this thread</a>.</p>",
        "id": 566002394,
        "sender_full_name": "David Corfield",
        "timestamp": 1767305564
    },
    {
        "content": "<p>I feel a lot of interesting discussions happened in this context here  <a class=\"stream-topic\" data-stream-id=\"229156\" href=\"/#narrow/channel/229156-theory.3A-applied-category-theory/topic/emergent.20behaviour.20as.20laxity/with/243567237\">#theory: applied category theory &gt; emergent behaviour as laxity</a></p>",
        "id": 566150469,
        "sender_full_name": "Adittya Chaudhuri",
        "timestamp": 1767447650
    }
]