[
    {
        "content": "<p>Where can I find a self-contained and clean proof of the fact that each polynomial endofunctor on Set has an initial algebra?</p>",
        "id": 249128782,
        "sender_full_name": "Leopold Schlicht",
        "timestamp": 1628697730
    },
    {
        "content": "<p>A fairly clean argument is sketched at <a href=\"https://ncatlab.org/nlab/show/transfinite+construction+of+free+algebras\">https://ncatlab.org/nlab/show/transfinite+construction+of+free+algebras</a>, if you accept that polynomial functors are accessible.</p>",
        "id": 249135995,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1628700959
    },
    {
        "content": "<p>Thanks for the link, but I don't know what an accessible functor is, so the page doesn't look self-contained and accessible to me. :P</p>",
        "id": 249212065,
        "sender_full_name": "Leopold Schlicht",
        "timestamp": 1628759381
    },
    {
        "content": "<p>It's probably worth giving polynomial endofunctors on Set as an example at <a href=\"https://ncatlab.org/nlab/show/accessible+functor\">https://ncatlab.org/nlab/show/accessible+functor</a>, then. </p>\n<p>For endofunctors of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">Set</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span></span></span></span> arising from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>←</mo><mi>X</mi><mo><mover><mo><mo>→</mo></mo><mi>g</mi></mover></mo><mi>Y</mi><mo>→</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1 \\leftarrow  X\\stackrel{g}{\\to} Y \\to 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">←</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.01537em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mop op-limits\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01537em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop\">→</span></span></span><span style=\"top:-3.613978em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>, we need to know <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>↦</mo><msub><mi mathvariant=\"normal\">Π</mi><mi>g</mi></msub><mo stretchy=\"false\">(</mo><mi>X</mi><mo>×</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A \\mapsto \\Pi_g (X\\times A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69433em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord\">Π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> preserves <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>-filtered colimits for some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>. This would follow from knowing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Π</mi><mi>g</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\Pi_g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord\">Π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> preserved filtered colimits, but maybe only the polynomial functor itself does. My guess is that we have to take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> to be as small as it can be, i.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi><mo>=</mo><msub><mi mathvariant=\"normal\">ℵ</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\kappa=\\aleph_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">κ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">ℵ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, and then use the fact filtered colimits commute with limits in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">Set</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span></span></span></span>.</p>",
        "id": 249221708,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1628767242
    },
    {
        "content": "<p>I'm being a little bit lazy, and a little bit busy, and not checking this myself, sorry!</p>",
        "id": 249222411,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1628767822
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Π</mi><mi>g</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\Pi_g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord\">Π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> is accessible because any right or left adjoint between locally presentable categories is accessible.</p>",
        "id": 249231504,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1628773476
    },
    {
        "content": "<p>Added the examples Mike discussed to <a href=\"https://ncatlab.org/nlab/show/accessible+functor\">https://ncatlab.org/nlab/show/accessible+functor</a></p>",
        "id": 249250546,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1628782236
    },
    {
        "content": "<p>Although I still haven't looked at the proofs, because they seem to be a bit too technical to be understandable in a short space of time, let me ask the following questions: I read (probably in the HoTT book) that some classical uses transfinite recursion can be replaced by (higher) inductive types. So I thought the proof that W-types exist must use transfinite recursion. But I just can't imagine transfinite recursion to be relevant here because all examples of W-types that come to my mind (such as natural numbers or binary trees) can simply be constructed as \"the smallest set of strings over the alphabet of constructors satisfying ...\".<br>\nIs the notion of a W-type (in Set) the same as the notion of an initial algebra of an endofunctor, or is it more general?<br>\nIf transfinite recursion is necessary for the existence of W-types: is there some special class of W-types that don't need transfinite recursion to construct?</p>",
        "id": 249752204,
        "sender_full_name": "Leopold Schlicht",
        "timestamp": 1629221705
    },
    {
        "content": "<p>If you have constructors of infinite arity then \"strings\" might not be enough. But in fact you can construct W-types in ZF for example using some kind of encoding of trees.</p>",
        "id": 249752667,
        "sender_full_name": "Reid Barton",
        "timestamp": 1629221947
    },
    {
        "content": "<p>I see. But if one has only finite arities (but maybe infinitely many constructors!) one doesn't need transfinite recursion, right?</p>\n<p>Also, what does ZF have but type theory not, that allows the first to construct W-types for itself while the latter needs to have their existence postulated via additional rules of inference?</p>",
        "id": 249754680,
        "sender_full_name": "Leopold Schlicht",
        "timestamp": 1629222984
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"408864\">Leopold Schlicht</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/249754680\">said</a>:</p>\n<blockquote>\n<p>I see. But if one has only finite arities (but maybe infinitely many constructors!) one doesn't need transfinite recursion, right?</p>\n</blockquote>\n<p>In the finite arity case, even the transfinite recursion construction doesn't need much. You only need to build a sequence <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub><mo>→</mo><msub><mi>A</mi><mn>1</mn></msub><mo>→</mo><mo>⋯</mo></mrow><annotation encoding=\"application/x-tex\">A_0 \\to A_1 \\to \\cdots</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.31em;vertical-align:0em;\"></span><span class=\"minner\">⋯</span></span></span></span> of length <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>, and doing this constructively isn't a problem.</p>\n<p>The subtlety is in the infinite arity case. In that case, the transfinite recursion construction needs to continue up to some ordinal whose cofinality exceeds the arities of all constructors, and constructing that ordinal can be a problem: even in ZF, which is a very mild sort of \"non-classicality\", it's (probably?) consistent that there is no ordinal of uncountable cofinality. Nevertheless, the construction of W-types via trees still works in ZF even in the infinite arity case.</p>",
        "id": 249850472,
        "sender_full_name": "Reid Barton",
        "timestamp": 1629294089
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"408864\">Leopold Schlicht</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/249754680\">said</a>:</p>\n<blockquote>\n<p>Also, what does ZF have but type theory not, that allows the first to construct W-types for itself while the latter needs to have their existence postulated via additional rules of inference?</p>\n</blockquote>\n<p>That probably depends on which particular type theory you consider, but one issue is the impredicative-style definition \"the smallest set such that ...\".<br>\nAlso, in a type theory context you usually want W-types to have computation rules which are definitional equalities, and it seems unlikely that you could get those through this kind of construction.</p>",
        "id": 249851043,
        "sender_full_name": "Reid Barton",
        "timestamp": 1629294355
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276480\">Reid Barton</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/249850472\">said</a>:</p>\n<blockquote>\n<p>even in ZF, which is a very mild sort of \"non-classicality\", it's (probably?) consistent that there is no ordinal of uncountable cofinality. Nevertheless, the construction of W-types via trees still works in ZF even in the infinite arity case.</p>\n</blockquote>\n<p>Just take the ordinal of size <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">P</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"script\">P</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">N</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{\\cal P}({\\cal P}(\\mathbb{N}))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.08222em;\">P</span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.08222em;\">P</span></span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">N</span><span class=\"mclose\">))</span></span></span></span>!</p>\n<p>I'm not actually sure how you'd build W-types otherwise.</p>",
        "id": 249892363,
        "sender_full_name": "Cody Roux",
        "timestamp": 1629311442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276030\">Cody Roux</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/249892363\">said</a>:</p>\n<blockquote>\n<p>the ordinal of size <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">P</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"script\">P</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">N</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{\\cal P}({\\cal P}(\\mathbb{N}))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.08222em;\">P</span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.08222em;\">P</span></span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">N</span><span class=\"mclose\">))</span></span></span></span></p>\n</blockquote>\n<p>But you need choice to know that there is an ordinal of that size, right?</p>",
        "id": 249893282,
        "sender_full_name": "Reid Barton",
        "timestamp": 1629311836
    },
    {
        "content": "<p>There is a construction of W-types in any topos with natural numbers object in <a href=\"http://matwbn.icm.edu.pl/ksiazki/fm/fm117/fm117116.pdf\">Words, free algebras, and coequalizers</a>, summarized informally starting on page 121.</p>",
        "id": 249895156,
        "sender_full_name": "Reid Barton",
        "timestamp": 1629312637
    },
    {
        "content": "<p>As Reid said, you can construct W-types <em>either</em> from transfinite recursion <em>or</em> from powersets.  In particular, the latter shows that they exist in any topos, which is much a weaker assumption than ZF.  Ordinary predicative type theory doesn't have either one, so W-types have to be postulated.  However, powersets don't suffice to construct <em>higher</em> inductive types, as some of them can't even be constructed in ZF; to get those it seems you have to use transfinite recursion or else postulate them.</p>",
        "id": 249900323,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629314938
    },
    {
        "content": "<p>It's consistent with ZF that every uncountable cardinal is singular, but that is not the same as saying they all have countable cofinality. But I'm not sure which way it falls.</p>",
        "id": 249970160,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1629371439
    },
    {
        "content": "<p>Aha, here's the answer: <a href=\"https://math.stackexchange.com/questions/416218/in-zf-does-there-exist-an-ordinal-of-provably-uncountable-cofinality\">https://math.stackexchange.com/questions/416218/in-zf-does-there-exist-an-ordinal-of-provably-uncountable-cofinality</a></p>",
        "id": 249970337,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1629371562
    },
    {
        "content": "<p>The standard law of headlines applies to that question</p>",
        "id": 249970632,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1629371766
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276480\">Reid Barton</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/249893282\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276030\">Cody Roux</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/249892363\">said</a>:</p>\n<blockquote>\n<p>the ordinal of size <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">P</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"script\">P</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">N</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{\\cal P}({\\cal P}(\\mathbb{N}))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.08222em;\">P</span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.08222em;\">P</span></span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">N</span><span class=\"mclose\">))</span></span></span></span></p>\n</blockquote>\n<p>But you need choice to know that there is an ordinal of that size, right?</p>\n</blockquote>\n<p>I don't think so: you can take the set of well-orders over some set, and that set itself is well ordered without choice, <del>of the \"right\" cardinality</del>.</p>",
        "id": 250048986,
        "sender_full_name": "Cody Roux",
        "timestamp": 1629407081
    },
    {
        "content": "<p>Wait, I guess not, per David Robert's link. Huh.</p>",
        "id": 250049159,
        "sender_full_name": "Cody Roux",
        "timestamp": 1629407165
    },
    {
        "content": "<p>But there is an ordinal with countable cofinality? I wonder why the proof doesn't generalize.</p>",
        "id": 250049211,
        "sender_full_name": "Cody Roux",
        "timestamp": 1629407194
    },
    {
        "content": "<p>The ordinal with countable cofinality, namely <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>, is asserted to exist by its own axiom.  (-:</p>",
        "id": 250065973,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629420365
    },
    {
        "content": "<p>Thanks all!</p>\n<p>What are the minimal prerequisites a Martin-Löf-type type theory needs to satisfy in order to be able to construct W-types?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/249900323\">said</a>:</p>\n<blockquote>\n<p>As Reid said, you can construct W-types <em>either</em> from transfinite recursion <em>or</em> from powersets.</p>\n</blockquote>\n<p>But isn't the proof using power sets Reid sketched also based on transfinite recursion?<br>\n<span class=\"user-mention silent\" data-user-id=\"276480\">Reid Barton</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/249752667\">said</a>:</p>\n<blockquote>\n<p>But in fact you can construct W-types in ZF for example using some kind of encoding of trees.</p>\n</blockquote>\n<p>Can you make that more precise?</p>",
        "id": 250230661,
        "sender_full_name": "Leopold Schlicht",
        "timestamp": 1629570288
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"408864\">Leopold Schlicht</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/250230661\">said</a>:</p>\n<blockquote>\n<p>What are the minimal prerequisites a Martin-Löf-type type theory needs to satisfy in order to be able to construct W-types?</p>\n</blockquote>\n<p>When working in type theory, usually we just assert that things like W-types exist.  You probably aren't going to be able to construct them with a definitional computation rule from anything else.  If you're okay with a typal computation rule, then you can construct them in the same ways you do in set theory, from transfinite recursion (using choice) or power sets (using propositional resizing).</p>\n<blockquote>\n<p>But isn't the proof using power sets Reid sketched also based on transfinite recursion?</p>\n</blockquote>\n<p>No.  Reid pointed to a proof in Blass's paper <a href=\"http://matwbn.icm.edu.pl/ksiazki/fm/fm117/fm117116.pdf\">Words, free algebras, and coequalizers</a>, and there's also a sketch in Moerdijk-Palmgren <a href=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.44.6700&amp;rep=rep1&amp;type=pdf\">Wellfounded trees in categories</a>.  In particular, they show how to encode trees using functions and powersets.</p>",
        "id": 250244578,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629591161
    },
    {
        "content": "<p>Thanks! I would really like to know the two proofs, but unfortunately I am not able to quickly extract the ideas from the two papers (I don't have the time to read them in detail).</p>",
        "id": 250392932,
        "sender_full_name": "Leopold Schlicht",
        "timestamp": 1629743707
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/250065973\">said</a>:</p>\n<blockquote>\n<p>The ordinal with countable cofinality, namely <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>, is asserted to exist by its own axiom.  (-:</p>\n</blockquote>\n<p>I'm confused about the definition of cofinality I guess: I thought <em><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Ω</mi></mrow><annotation encoding=\"application/x-tex\">\\Omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Ω</span></span></span></span></em> was the least ordinal with countable cofinality: that is the smallest ordinal such that every function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi mathvariant=\"normal\">Ω</mi></mrow><annotation encoding=\"application/x-tex\">A \\rightarrow \\Omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Ω</span></span></span></span> has an upper bound for countable <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>.</p>\n<p>Certainly this ordinal exists in ZF (Andre Hirshowitz taught me this way back in the day in Nice!)</p>",
        "id": 250416846,
        "sender_full_name": "Cody Roux",
        "timestamp": 1629755433
    },
    {
        "content": "<p>The ordinal you describe is an initial ordinal, i.e. its cofinality is itself. In particular it does not have countable cofinality. The least ordinal with countable cofinality is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>, a.k.a. the first infinite ordinal.</p>",
        "id": 250419391,
        "sender_full_name": "Zhen Lin Low",
        "timestamp": 1629757016
    },
    {
        "content": "<p>Specifically, your <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Ω</mi></mrow><annotation encoding=\"application/x-tex\">\\Omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Ω</span></span></span></span>, which is usually written <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>ω</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\omega_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, is the least ordinal with <em>uncountable</em> cofinality.</p>",
        "id": 250439425,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629776644
    },
    {
        "content": "<p>So now I'm <em>really</em> confused: I thought you could take the set of well-orders <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo>⊆</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">O\\subseteq\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>, and this set had <em>provably uncountable cofinality</em>, in ZF.</p>\n<p>This contradicts the linked result. What is failing here? Is it the \"provably\", is it the \"uncountable\" or is it \"you can take the set\" (surely not that one)?</p>",
        "id": 250495147,
        "sender_full_name": "Cody Roux",
        "timestamp": 1629816209
    },
    {
        "content": "<p>If we take what is written there at face value, what fails is \"provably\". <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>ω</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\omega_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is provably uncountable, of course.</p>",
        "id": 250496130,
        "sender_full_name": "Zhen Lin Low",
        "timestamp": 1629816595
    },
    {
        "content": "<p>I guess you mean for the well-orders <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi></mrow><annotation encoding=\"application/x-tex\">O</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span></span></span></span> to themselves be ordered by order type. Since there are distinct well-orders of the same order type, this is only a preorder. It seems plausible that this preorder has countable cofinality provably in ZF by some kind of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>×</mo><mi mathvariant=\"double-struck\">N</mi><mo>≅</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N} \\times \\mathbb{N} \\cong \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77222em;vertical-align:-0.08333em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> argument. However, when we form the quotient by the \"same order type\" relation to get a partial order (hence an actual ordinal), the result might not have countable cofinality any more. The reason is that we need choice to pass from a countable sequence in the quotient (for which we are supposed to find an upper bound) to a countable sequence in the original preorder.</p>",
        "id": 250504784,
        "sender_full_name": "Reid Barton",
        "timestamp": 1629820069
    },
    {
        "content": "<p>Aaah I see. Thanks <span class=\"user-mention\" data-user-id=\"276480\">@Reid Barton</span> !</p>",
        "id": 250505146,
        "sender_full_name": "Cody Roux",
        "timestamp": 1629820228
    },
    {
        "content": "<p>Can the transfinite recursion proof of the existence of W-types be phrased as an application of Zorn's lemma? (Can <em>each</em> transfinite recursion proof be phrased as an application of Zorn's lemma? Probably not, but due to my limited experience I haven't yet seen a counterexample.)</p>",
        "id": 250510207,
        "sender_full_name": "Leopold Schlicht",
        "timestamp": 1629822449
    },
    {
        "content": "<p>Now that I look at the SO question more closely; it only talks about <em>ordinals</em> with uncountable cofinality. Does the answer also exclude all WF posets? Your comment makes it sound like it does.</p>",
        "id": 250518562,
        "sender_full_name": "Cody Roux",
        "timestamp": 1629825976
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"408864\">Leopold Schlicht</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/250510207\">said</a>:</p>\n<blockquote>\n<p>Can the transfinite recursion proof of the existence of W-types be phrased as an application of Zorn's lemma? (Can <em>each</em> transfinite recursion proof be phrased as an application of Zorn's lemma? Probably not, but due to my limited experience I haven't yet seen a counterexample.)</p>\n</blockquote>\n<p>Most likely yes, or at least, as a consequence of Zorn's Fixed Point Theorem (<a href=\"https://golem.ph.utexas.edu/category/2012/10/the_zorn_identity.html\">see here</a>) but there are other aspects to consider, e.g. how many ordinals you can prove exist, which seem more important to me than whether or not you use choice (my previous questions/comments notwithstanding).</p>\n<p>A particularly crucial one is the predicative/impredicative distinction.</p>",
        "id": 250521484,
        "sender_full_name": "Cody Roux",
        "timestamp": 1629827201
    },
    {
        "content": "<p>Well, since Zorn's lemma is equivalent over ZF to transfinite recursion and to all other forms of the axiom of choice, the answer must be trivially yes.  But I doubt offhand that it looks very <em>natural</em> when written in terms of Zorn's lemma.</p>",
        "id": 250575473,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1629860417
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 250631846,
        "sender_full_name": "Leopold Schlicht",
        "timestamp": 1629903439
    },
    {
        "content": "<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> be a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">U</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal U</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">U</span></span></span></span>-set of constructors and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mspace></mspace><mspace width=\"0.1111111111111111em\"/><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext> ⁣</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333333333333333em\"/><mi>C</mi><mo>→</mo><mi mathvariant=\"script\">U</mi></mrow><annotation encoding=\"application/x-tex\">a\\colon C\\to\\mathcal U</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111111111111111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.16666666666666666em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333333333333333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">U</span></span></span></span> a function assigning an index set to each constructor. We want to define the W-type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> that corresponds to this \"branching signature\" <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(C,a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span></span></span></span>. We proceed by transfinite induction:</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub><mo>:</mo><mo>=</mo><mi mathvariant=\"normal\">∅</mi></mrow><annotation encoding=\"application/x-tex\">T_0:=\\empty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.80556em;vertical-align:-0.05556em;\"></span><span class=\"mord\">∅</span></span></span></span>;</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mrow><mi>α</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>:</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>c</mi><mspace></mspace><mspace width=\"0.1111111111111111em\"/><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext> ⁣</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333333333333333em\"/><mi>C</mi></mrow></msub><mi>a</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo stretchy=\"false\">)</mo><mo>→</mo><msub><mi>T</mi><mi>α</mi></msub></mrow><annotation encoding=\"application/x-tex\">T_{\\alpha+1}:=\\sum_{c\\colon C}a(c)\\to T_\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">α</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0497100000000001em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.17862099999999992em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">c</span><span class=\"mspace nobreak mtight\"></span><span class=\"mspace mtight\" style=\"margin-right:0.13011111111111112em;\"></span><span class=\"mpunct mtight\"></span><span class=\"mord mtight\"><span class=\"mrel mtight\">:</span></span><span class=\"mspace mtight\" style=\"margin-right:0.39033333333333337em;\"></span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">α</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (this can be thought of as the set of all formal expressions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><msub><mi>e</mi><mi>i</mi></msub><msub><mo stretchy=\"false\">)</mo><mrow><mi>i</mi><mspace></mspace><mspace width=\"0.1111111111111111em\"/><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext> ⁣</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333333333333333em\"/><mi>a</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo stretchy=\"false\">)</mo></mrow></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">c((e_i)_{i\\colon a(c)})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1052em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">((</span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mspace nobreak mtight\"></span><span class=\"mspace mtight\" style=\"margin-right:0.13011111111111112em;\"></span><span class=\"mpunct mtight\"></span><span class=\"mord mtight\"><span class=\"mrel mtight\">:</span></span><span class=\"mspace mtight\" style=\"margin-right:0.39033333333333337em;\"></span><span class=\"mord mathnormal mtight\">a</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">c</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span> is a constructor and the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">e_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> are elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mi>α</mi></msub></mrow><annotation encoding=\"application/x-tex\">T_\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">α</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>) for each ordinal number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span>;</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mi>λ</mi></msub><mo>:</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>α</mi><mo>&lt;</mo><mi>λ</mi></mrow></msub><msub><mi>T</mi><mi>α</mi></msub></mrow><annotation encoding=\"application/x-tex\">T_\\lambda := \\sum_{\\alpha &lt; \\lambda} T_\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">λ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.07708em;vertical-align:-0.32708000000000004em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.18639799999999984em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">α</span><span class=\"mrel mtight\">&lt;</span><span class=\"mord mathnormal mtight\">λ</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32708000000000004em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">α</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> for each limit ordinal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>.</li>\n</ul>\n<p>Then we can let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>:</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>α</mi><mspace></mspace><mspace width=\"0.1111111111111111em\"/><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext> ⁣</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333333333333333em\"/><mrow><mi mathvariant=\"normal\">O</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">d</mi></mrow></mrow></msub><msub><mi>T</mi><mi>α</mi></msub></mrow><annotation encoding=\"application/x-tex\">T:=\\sum_{\\alpha\\colon\\mathrm{Ord}} T_\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0497100000000001em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1863979999999999em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace nobreak mtight\"></span><span class=\"mspace mtight\" style=\"margin-right:0.13011111111111112em;\"></span><span class=\"mpunct mtight\"></span><span class=\"mord mtight\"><span class=\"mrel mtight\">:</span></span><span class=\"mspace mtight\" style=\"margin-right:0.39033333333333337em;\"></span><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">Ord</span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">α</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. But this <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> lives in a universe bigger than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">U</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal U</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">U</span></span></span></span>. So we need to stop our transfinite recursion at a specific ordinal number. Which one?</p>\n<p>How can such an argument be formalized in Martin-Löf type theory? Ordinal numbers are usually discussed in a material set theory. (I know that the HoTT book discusses ordinals, but as far as I can see, that approach exploits univalence, which basically enables one to define an ordinal as a well-ordered set, without needing to consider equivalence classes.) Also, how can one construct the ordinal at which one stops the transfinite recursion in MLTT?</p>\n<p>Note that the above argument uses the \"axiom of replacement\": the universe is closed under <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∑</mo></mrow><annotation encoding=\"application/x-tex\">\\sum</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span></span></span></span>. So I can't imagine that one can construct <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> just using power sets and functions (or in an arbitrary elementary topos) by encoding it as a set of trees. But as you told me this is possible. Can somebody give me a sketch of the argument?</p>",
        "id": 251134223,
        "sender_full_name": "Leopold Schlicht",
        "timestamp": 1630245345
    },
    {
        "content": "<p>You should just read the paper by Blass I linked above, starting at page 121. The construction could not be summarized more concisely here.</p>",
        "id": 251134624,
        "sender_full_name": "Reid Barton",
        "timestamp": 1630245742
    },
    {
        "content": "<p>Reid's answer pertains to your final question about sets of trees.  The construction of W-types in a topos does <em>not</em> proceed by a transfinite iteration, but \"directly\".</p>",
        "id": 251136955,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630248239
    },
    {
        "content": "<p>For the first, one must first of all assume an axiom of choice.  In this case, the standard argument works just fine for all parts of the proof.  Univalence is not needed; the only important property of \"ordinals\" in this argument is that they are well-ordered sets.</p>",
        "id": 251137034,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630248299
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/251137034\">said</a>:</p>\n<blockquote>\n<p>For the first, one must first of all assume an axiom of choice.  In this case, the standard argument works just fine for all parts of the proof.  Univalence is not needed; the only important property of \"ordinals\" in this argument is that they are well-ordered sets.</p>\n</blockquote>\n<p>Alright, thanks. But at which ordinal does the transfinite recursion I described stop?</p>",
        "id": 251454703,
        "sender_full_name": "Leopold Schlicht",
        "timestamp": 1630442044
    },
    {
        "content": "<p>At any ordinal whose cofinality is greater than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>p</mi><mi>c</mi></msub><mi mathvariant=\"normal\">∣</mi><mi>a</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">sup_c |a(c)|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">a</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span><span class=\"mord\">∣</span></span></span></span>.</p>",
        "id": 251458822,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630443613
    },
    {
        "content": "<p>Can such an ordinal be constructed more directly, so that one doesn't have to know what cofinality means? :-)</p>",
        "id": 251459362,
        "sender_full_name": "Leopold Schlicht",
        "timestamp": 1630443800
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276480\">Reid Barton</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/251134624\">said</a>:</p>\n<blockquote>\n<p>You should just read the paper by Blass I linked above, starting at page 121. The construction could not be summarized more concisely here.</p>\n</blockquote>\n<p>I don't see any mathematical construction being described in the paragraphs starting at page 121. The only very rough idea I can extract is that one encodes an element of a W-type using a set of positions and a function from that set to the set of constructors/arguments. But the example given on page 122 is totally confusing and not very enlightening: that's a tree in which each constructor has finite arity, so one could just as well encode it as a finite string. So I didn't get the point when I first skimmed through the paper. The paper goes on encoding the whole construction in an arbitrary elementary topos -- but I'd like to see the construction being carried out in ordinary mathematical language.<br>\nI doubt that's the most concise description possible. :-)</p>",
        "id": 251461903,
        "sender_full_name": "Leopold Schlicht",
        "timestamp": 1630444714
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276777\">@Mike Shulman</span> So one doesn't need replacement in the proof of the existence of W-types?</p>",
        "id": 251462042,
        "sender_full_name": "Leopold Schlicht",
        "timestamp": 1630444793
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"408864\">Leopold Schlicht</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/251459362\">said</a>:</p>\n<blockquote>\n<p>Can such an ordinal be constructed more directly, so that one doesn't have to know what cofinality means? :-)</p>\n</blockquote>\n<p>The successor cardinal of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>p</mi><mi>c</mi></msub><mi mathvariant=\"normal\">∣</mi><mi>a</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">sup_c |a(c)|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">a</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span><span class=\"mord\">∣</span></span></span></span> works.  (All assuming choice, of course.)</p>",
        "id": 251463073,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630445186
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"408864\">Leopold Schlicht</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/251462042\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> So one doesn't need replacement in the proof of the existence of W-types?</p>\n</blockquote>\n<p>One doesn't need replacement <em>to prove that</em> W-types exist.  But the <em>particular</em> proof you are talking about using a transfinite iteration <em>does</em> use replacement.</p>",
        "id": 251463165,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630445231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/251463073\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"408864\">Leopold Schlicht</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/251459362\">said</a>:</p>\n<blockquote>\n<p>Can such an ordinal be constructed more directly, so that one doesn't have to know what cofinality means? :-)</p>\n</blockquote>\n<p>The successor cardinal of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>p</mi><mi>c</mi></msub><mi mathvariant=\"normal\">∣</mi><mi>a</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">sup_c |a(c)|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">a</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span><span class=\"mord\">∣</span></span></span></span> works.  (All assuming choice, of course.)</p>\n</blockquote>\n<p>But I doubt you would be able to prove that this works without essentially invoking cofinality.</p>",
        "id": 251463275,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630445278
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"408864\">Leopold Schlicht</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/251461903\">said</a>:</p>\n<blockquote>\n<p>the example given on page 122 is totally confusing and not very enlightening: that's a tree in which each constructor has finite arity, so one could just as well encode it as a finite string.</p>\n</blockquote>\n<p>One <em>could</em>, but in this paragraph he is <em>not</em> encoding it that way.  Instead he is using it as an example to describe a general encoding that works for infinite arities as well.</p>",
        "id": 251463901,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630445554
    },
    {
        "content": "<p>Thanks!<br>\n<span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/251458822\">said</a>:</p>\n<blockquote>\n<p>At any ordinal whose cofinality is greater than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>p</mi><mi>c</mi></msub><mi mathvariant=\"normal\">∣</mi><mi>a</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">sup_c |a(c)|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">a</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span><span class=\"mord\">∣</span></span></span></span>.</p>\n</blockquote>\n<p>Really <em>any</em> ordinal greater than ...? I would think there's a problem when choosing a very big ordinal: as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> increases, the cardinality of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mi>α</mi></msub></mrow><annotation encoding=\"application/x-tex\">T_\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">α</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> gets bigger and bigger -- maybe bigger than the true <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>. (Although I don't know whether cofinality is monotone, so this could be the reason for my confusion.)<br>\n<span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/251463073\">said</a>:</p>\n<blockquote>\n<p>The successor cardinal of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>p</mi><mi>c</mi></msub><mi mathvariant=\"normal\">∣</mi><mi>a</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">sup_c |a(c)|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">a</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span><span class=\"mord\">∣</span></span></span></span> works.  (All assuming choice, of course.)</p>\n</blockquote>\n<p>Why does one need choice here?<br>\n<span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/reference.3A.20initial.20algebras/near/251463901\">said</a>:</p>\n<blockquote>\n<p>One <em>could</em>, but in this paragraph he is <em>not</em> encoding it that way.  Instead he is using it as an example to describe a general encoding that works for infinite arities as well.</p>\n</blockquote>\n<p>I see. :-)</p>",
        "id": 251569532,
        "sender_full_name": "Leopold Schlicht",
        "timestamp": 1630507012
    },
    {
        "content": "<p>Oh, I see now, your original definition of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> was wrong.  You have to take colimits at limit stages, not coproducts.  Otherwise you end up with duplicated stuff already at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>=</mo><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha=\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>.  The colimits are what prevent the size from getting out of control: you continue adding new stuff, but after a point all of it gets identified with stuff you already had.</p>",
        "id": 251572195,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630507821
    },
    {
        "content": "<p>Cofinality is not monotone: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">ℵ</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\aleph_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">ℵ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> has cofinality <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">ℵ</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\aleph_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">ℵ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, but <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">ℵ</mi><mi>ω</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\aleph_\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">ℵ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">ω</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> has cofinality <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi><mo>=</mo><msub><mi mathvariant=\"normal\">ℵ</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\omega=\\aleph_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">ℵ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 251572280,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630507851
    },
    {
        "content": "<p>One needs choice because without choice, it's possible that all infinite cardinals are singular, so there may not be any ordinal that works.</p>",
        "id": 251572431,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1630507907
    },
    {
        "content": "<p>Ah, thanks!</p>",
        "id": 251918118,
        "sender_full_name": "Leopold Schlicht",
        "timestamp": 1630691313
    }
]