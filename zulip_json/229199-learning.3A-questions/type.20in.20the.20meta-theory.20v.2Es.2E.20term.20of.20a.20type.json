[
    {
        "content": "<p>Hello, I am new to type theory, I mostly spend my time in formal category theory. I'm reading up on New and Licata's <a href=\"https://arxiv.org/abs/2210.08663\">virtual equipment type theory</a> and I realized I've just never asked the following question.  </p>\n<p>what is real the difference between \"claiming something is a type\" <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mtext>  </mtext><mtext>  </mtext><mtext>Type</mtext></mrow><annotation encoding=\"application/x-tex\">T \\;\\;\\text{Type}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord text\"><span class=\"mord\">Type</span></span></span></span></span> and saying something is a term in the type of types <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>:</mo><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">T:Type</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">e</span></span></span></span>? I'm not talking about \"size\" issues,  i.e. universes. More generally, I don't understand why we distinguish between claiming something is part of the meta-theory and typing relations.  In this paper they model the type theory of the equipment of categories and profunctors<a href=\"/user_uploads/21317/8zbLBd6D60VP1pYXm_Me959X/Screenshot-2024-04-10-at-2.47.42PM.png\">:</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/8zbLBd6D60VP1pYXm_Me959X/Screenshot-2024-04-10-at-2.47.42PM.png\" title=\":\"><img src=\"/user_uploads/21317/8zbLBd6D60VP1pYXm_Me959X/Screenshot-2024-04-10-at-2.47.42PM.png\"></a></div><p>So <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Cat</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{Cat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord\">Cat</span></span></span></span></span> is a feature of the meta theory and they write \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi><mtext>  </mtext><mtext>  </mtext><mtext>Cat</mtext></mrow><annotation encoding=\"application/x-tex\">\\mathbb C \\;\\;\\text{Cat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord text\"><span class=\"mord\">Cat</span></span></span></span></span>\" why not consider a type of categories and say something like \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi><mo>:</mo><mtext>Cat</mtext></mrow><annotation encoding=\"application/x-tex\">\\mathbb C:\\text{Cat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord\">Cat</span></span></span></span></span>\"? </p>\n<p>Do we write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mtext>  </mtext><mtext>  </mtext><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\;\\; B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is a feature of the meta theory and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is an instance of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">a:A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> just when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> a term of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>? Is there a way to write something like this <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi><mo>:</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">a:A:B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and be precise? I.e. consolidate the features of the meta-theory and the types into different \"levels\" of typing relations? Is this what two level type theories seek to do? if so why stop at 2?</p>\n<p>Why can't I write \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mo>:</mo><mi mathvariant=\"double-struck\">C</mi><mo>:</mo><mtext>Cat</mtext><mo>:</mo><mtext>equip</mtext></mrow><annotation encoding=\"application/x-tex\">c : \\mathbb C : \\text{Cat}:\\text{equip}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord\">Cat</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8623em;vertical-align:-0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\">equip</span></span></span></span></span>\" for \"an object c in the category of categories which is an equipment\" and be precise?</p>\n<p>Thank you for any insight.</p>",
        "id": 432569327,
        "sender_full_name": "Noah Chrein",
        "timestamp": 1712776357
    },
    {
        "content": "<p>The point is that a particular type theory may or may not contain a \"universe\" type whose elements are other types.  The judgment <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mtext> </mtext><mrow><mi mathvariant=\"sans-serif\">t</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow></mrow><annotation encoding=\"application/x-tex\">T \\, \\mathsf{type}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">type</span></span></span></span></span> is ontologically on the same status as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>:</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">t : T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>, but different, and doesn't require there to be any universe type.</p>",
        "id": 432570188,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712776735
    },
    {
        "content": "<p>The collection of all types in the object theory is indeed a type (or set) in the metatheory (depending on what the metatheory is), but it would be confusing to mix the typing colon of the object theory with the typing colon of the metatheory.</p>",
        "id": 432570382,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712776807
    },
    {
        "content": "<p>And there is no way to get rid of the need for a meta-theory? Because Noah asks above “why stop at level 2”.</p>",
        "id": 432570619,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712776911
    },
    {
        "content": "<p>When we reason <em>in</em> some theory, there is no need for a metatheory; we simply reason in the theory.  When we reason <em>about</em> some theory, we need to be reasoning <em>in</em> some other theory, and that other theory is the metatheory.  Usually we don't need to simultaneously reason about the theory we are using to reason about some other theory.</p>",
        "id": 432571272,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712777190
    },
    {
        "content": "<p>But one certainly could.</p>",
        "id": 432571721,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712777386
    },
    {
        "content": "<p>Isn’t it very common for there to be a type of types, in most type theories?</p>",
        "id": 432572121,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712777527
    },
    {
        "content": "<p>It's common in Martin-Lof style dependent type theories.  But it's impossible in simple type theories, and for theories in between with limited amount of dependency like VETT one has to be careful with it.  Taking such care often entails formally separating the judgment that something is a type from the judgment that it is an element of a type of types.  In particular, it's almost never the case that <em>one</em> type of types can contain <em>all</em> types as its elements, due to size paradoxes, so it's useful to have a syntactic notion of \"being a type\" that's distinct from belonging to a type of types.</p>",
        "id": 432572842,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712777843
    },
    {
        "content": "<p>Why do dependent type theories require a type of types? In order to express a “type signature” for functions on types?</p>",
        "id": 432573549,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712778132
    },
    {
        "content": "<p>They do not <em>require</em> it.</p>",
        "id": 432573568,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712778142
    },
    {
        "content": "<p>But it's useful to internally express polymorphic operations, as you suggest.</p>",
        "id": 432573650,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712778185
    },
    {
        "content": "<p>It's also used to talk generically about propositions and predicates, when represented using propositions-as-types.</p>",
        "id": 432573717,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712778220
    },
    {
        "content": "<p>If propositions are types, and terms are proofs, then predicates are second-level (dependent) types?</p>",
        "id": 432573862,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712778276
    },
    {
        "content": "<p>It can be used in \"encode-decode\" style arguments to characterize equalities and other properties of inductive types.  For instance, it ordinary MLTT without a type of types, it's not possible to prove that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo mathvariant=\"normal\">≠</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0\\neq 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>.</p>",
        "id": 432573870,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712778280
    },
    {
        "content": "<p>And in univalent type theories, it's used to build classifying spaces.</p>",
        "id": 432573900,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712778296
    },
    {
        "content": "<p>A predicate is a function to the type of propositions.</p>",
        "id": 432573930,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712778306
    },
    {
        "content": "<p>I have some more questions, when I get back to my computer I'll ask more. But thank you two for the discussion this is getting at what I'm asking</p>",
        "id": 432574115,
        "sender_full_name": "Noah Chrein",
        "timestamp": 1712778377
    },
    {
        "content": "<p>Ordinarily, a proposition <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> is actually just a variable in the set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{0, 1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span>. A predicate is sort of like a function, except it needs a quantifier. Then it becomes a function from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{0, 1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span>.</p>\n<p>If types are already propositions, what remains for predicates to “act on”? The terms are proofs of the propositions. There aren’t any “referents”.</p>",
        "id": 432575200,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712778853
    },
    {
        "content": "<p>By \"ordinarily\" I guess you mean \"in set theory\".</p>",
        "id": 432575265,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712778889
    },
    {
        "content": "<p>In type theory, a proposition is an element of a type of \"propositions\".  This might be the whole type of types, or some sub-type of it consisting only of the subsingletons, but whatever it is, let's call it <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">P</mi><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">p</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Prop}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Prop</span></span></span></span></span>.  If we assume the law of excluded middle, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">P</mi><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">p</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Prop}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Prop</span></span></span></span></span> will have exactly two elements.</p>",
        "id": 432575360,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712778941
    },
    {
        "content": "<p>A predicate on a type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is then a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mrow><mi mathvariant=\"sans-serif\">P</mi><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">p</mi></mrow></mrow><annotation encoding=\"application/x-tex\">A \\to \\mathsf{Prop}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Prop</span></span></span></span></span>, sending each element <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">x:A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> to the proposition <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> that the predicate holds of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>.</p>",
        "id": 432575433,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712778965
    },
    {
        "content": "<p>The phrase is \"propositions as types\", not \"types as propositions\".  Not every type is a proposition; even if as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">P</mi><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">p</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Prop}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Prop</span></span></span></span></span> we use the universe of all types, not every type is <em>treated</em> as a proposition in practice.  Types also play the role of sets in set theory, as the carriers of structure and the domains of predicates.</p>",
        "id": 432575568,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712779032
    },
    {
        "content": "<p>So in one single “universe of types”, we have types whose terms have varying interpretations - some are like classes of objects - others are taken to represent “proofs” of a proposition?</p>",
        "id": 432576037,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712779218
    },
    {
        "content": "<p>I'm trying to imagine a meta type theory whose \"types\" are all (oo,n)-categories for all levels n. This way one could write, as a simple example<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mo>:</mo><mi mathvariant=\"double-struck\">C</mi><mo>:</mo><mi mathvariant=\"double-struck\">C</mi><mtext>at</mtext><mo>:</mo><mn>2</mn><mi mathvariant=\"double-struck\">C</mi><mtext>at</mtext><mo>:</mo><mn>3</mn><mi mathvariant=\"double-struck\">C</mi><mtext>at</mtext></mrow><annotation encoding=\"application/x-tex\">c:\\mathbb C:\\mathbb C \\text{at}:2\\mathbb C \\text{at}:3\\mathbb C \\text{at}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span><span class=\"mord text\"><span class=\"mord\">at</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\">2</span><span class=\"mord mathbb\">C</span><span class=\"mord text\"><span class=\"mord\">at</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\">3</span><span class=\"mord mathbb\">C</span><span class=\"mord text\"><span class=\"mord\">at</span></span></span></span></span> for an object c of a category, in the 2 category of categories, all \"witnessed\" by 3 categories as<a href=\"/user_uploads/21317/RZkSMDjMs5G5Qfi1hfy3qZjK/Screenshot-2024-04-10-at-4.09.12PM.png\">:</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/RZkSMDjMs5G5Qfi1hfy3qZjK/Screenshot-2024-04-10-at-4.09.12PM.png\" title=\":\"><img src=\"/user_uploads/21317/RZkSMDjMs5G5Qfi1hfy3qZjK/Screenshot-2024-04-10-at-4.09.12PM.png\"></a></div><p>here <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∙</mo></mrow><annotation encoding=\"application/x-tex\">\\bullet</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord\">∙</span></span></span></span> is the 1 object 1category, 2category, 3category respectively. I.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∙</mo><mo><mover><mo><mo>→</mo></mo><mi>c</mi></mover></mo><mi mathvariant=\"double-struck\">C</mi><mo>:</mo><mi mathvariant=\"double-struck\">C</mi><mtext>at</mtext></mrow><annotation encoding=\"application/x-tex\">\\bullet \\overset c \\to \\mathbb C:\\mathbb C\\text{at}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9683em;\"></span><span class=\"mord\">∙</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mop op-limits\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9683em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop\">→</span></span></span><span style=\"top:-3.5669em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span><span class=\"mord text\"><span class=\"mord\">at</span></span></span></span></span> is an object of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>. So my question is more along the lines of, can I think of typing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mo>:</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">c:\\mathbb C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> as a generalized object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>? Could a type theory accommodate various levels of typing through a mechanism like this?</p>",
        "id": 432577743,
        "sender_full_name": "Noah Chrein",
        "timestamp": 1712779929
    },
    {
        "content": "<p>I would say that all types are collections of objects, and the kind of object they are a collection of depends on the type: function types are collections of functions, number types are collections of numbers, etc.  In particular, then, proposition types are collections of proofs.</p>",
        "id": 432577749,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712779932
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277976\">Noah Chrein</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/type.20in.20the.20meta-theory.20v.2Es.2E.20term.20of.20a.20type/near/432577743\">said</a>:</p>\n<blockquote>\n<p>Could a type theory accommodate various levels of typing through a mechanism like this?</p>\n</blockquote>\n<p>In theory, yes.  Indeed, ordinary dependent type theory already has towers of elements as soon as it has multiple universes, e.g. the smallest universe belongs to the next universe <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow><mn>0</mn></msub><mo>:</mo><msub><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Type}_0 : \\mathsf{Type}_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9386em;vertical-align:-0.2441em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">Type</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.207em;\"><span style=\"top:-2.4559em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2441em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9386em;vertical-align:-0.2441em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">Type</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.207em;\"><span style=\"top:-2.4559em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2441em;\"><span></span></span></span></span></span></span></span></span></span>, which belongs to the next universe <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow><mn>1</mn></msub><mo>:</mo><msub><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Type}_1 : \\mathsf{Type}_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9386em;vertical-align:-0.2441em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">Type</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.207em;\"><span style=\"top:-2.4559em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2441em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9386em;vertical-align:-0.2441em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">Type</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.207em;\"><span style=\"top:-2.4559em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2441em;\"><span></span></span></span></span></span></span></span></span></span>, etc.</p>",
        "id": 432577886,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712780015
    },
    {
        "content": "<p>yes but typically, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mtext>Type</mtext><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\text{Type}_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9275em;vertical-align:-0.2441em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Type</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0573em;\"><span style=\"top:-2.4559em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2441em;\"><span></span></span></span></span></span></span></span></span></span> carries no structure, except maybe an oo-groupoid structure or something like that. In my thoughts something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi><mtext>at</mtext><mo>:</mo><mtext>equip</mtext></mrow><annotation encoding=\"application/x-tex\">\\mathbb C \\text{at}:\\text{equip}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span><span class=\"mord text\"><span class=\"mord\">at</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8623em;vertical-align:-0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\">equip</span></span></span></span></span> should say that \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi><mtext>at</mtext></mrow><annotation encoding=\"application/x-tex\">\\mathbb C \\text{at}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span><span class=\"mord text\"><span class=\"mord\">at</span></span></span></span></span> inherits its structural properties from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>equip</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{equip}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8623em;vertical-align:-0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\">equip</span></span></span></span></span>\"</p>",
        "id": 432578167,
        "sender_full_name": "Noah Chrein",
        "timestamp": 1712780142
    },
    {
        "content": "<p>structural properties being e.g. the existence of a hom profunctor etc</p>",
        "id": 432578264,
        "sender_full_name": "Noah Chrein",
        "timestamp": 1712780170
    },
    {
        "content": "<p>In a type theory with multiple universes, you can have certain operations that only apply to certain universes.  E.g. the \"hom profunctor\" type-former could apply only to types belonging to \"equip\", therefore including in particular your Cat.</p>",
        "id": 432578379,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712780224
    },
    {
        "content": "<p>Ok. So a predicate is a function from any type to the type of propositions. It takes something, and “says something about it”. This is a function type, because there are multiple predicates, and they are all functions. Does that make predicates a dependent type, because they require you to specify the type of the domain?</p>",
        "id": 432579439,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712780703
    },
    {
        "content": "<p>okay thank you that's interesting, is there somewhere I can read up on this kind of operation, type formers only applying to certain types?</p>\n<p>I am thinking of the hom profunctor as a generalized object<a href=\"/user_uploads/21317/gfvM8IBBqYnS5-CCYjTcn9MX/Screenshot-2024-04-10-at-4.23.58PM.png\">:</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/gfvM8IBBqYnS5-CCYjTcn9MX/Screenshot-2024-04-10-at-4.23.58PM.png\" title=\":\"><img src=\"/user_uploads/21317/gfvM8IBBqYnS5-CCYjTcn9MX/Screenshot-2024-04-10-at-4.23.58PM.png\"></a></div><p>where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>↛</mo></mrow><annotation encoding=\"application/x-tex\">\\nrightarrow</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel amsrm\">↛</span></span></span></span> is like a \"walking\" profunctor virtual double category, and this generalized element is more precisely part of some a diagram encoding its universal property.</p>",
        "id": 432579592,
        "sender_full_name": "Noah Chrein",
        "timestamp": 1712780768
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"699750\">Julius Hamilton</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/type.20in.20the.20meta-theory.20v.2Es.2E.20term.20of.20a.20type/near/432579439\">said</a>:</p>\n<blockquote>\n<p>Ok. So a predicate is a function from any type to the type of propositions. It takes something, and “says something about it”. This is a function type, because there are multiple predicates, and they are all functions. Does that make predicates a dependent type, because they require you to specify the type of the domain?</p>\n</blockquote>\n<p>Each predicate is a function.  The type <em>of</em> predicates on a type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is thus a function type, namely <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mrow><mi mathvariant=\"sans-serif\">P</mi><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">p</mi></mrow></mrow><annotation encoding=\"application/x-tex\">A\\to \\mathsf{Prop}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Prop</span></span></span></span></span>.  If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is a variable belonging to the type of types, rather than a fixed type like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>, then yes this is a family of types dependent on the type of types.</p>",
        "id": 432590126,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712784776
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277976\">Noah Chrein</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/type.20in.20the.20meta-theory.20v.2Es.2E.20term.20of.20a.20type/near/432579592\">said</a>:</p>\n<blockquote>\n<p>okay thank you that's interesting, is there somewhere I can read up on this kind of operation, type formers only applying to certain types?</p>\n</blockquote>\n<p>Hmm, expressed like that it's such a generic idea that I doubt anyone's written much about it at that level.  But you might get some of the flavor of it by reading about, say, <a href=\"https://ncatlab.org/nlab/show/pure%20type%20systems\">[[pure type systems]]</a>, which have an arbitrary family of \"sorts\" along with \"rules\" for which pairs of sorts the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Π</mi></mrow><annotation encoding=\"application/x-tex\">\\Pi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Π</span></span></span></span>-type can be applied to and produce something in a third sort.</p>",
        "id": 432590377,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712784880
    },
    {
        "content": "<p>In a simple type theory, we can declare the existence of various types without claiming those types are part of a type of Types?</p>",
        "id": 432590598,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712785000
    },
    {
        "content": "<p>Will we need at least a “type operator” to form product types?</p>",
        "id": 432590732,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712785080
    },
    {
        "content": "<p>Type-formation rules are written in terms of the judgment \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mtext> </mtext><mrow><mi mathvariant=\"sans-serif\">t</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow></mrow><annotation encoding=\"application/x-tex\">A \\,\\mathsf{type}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">type</span></span></span></span></span>\" of \"being a type\".</p>",
        "id": 432592005,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712785625
    },
    {
        "content": "<p>For instance, product types are</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi>A</mi><mtext> </mtext><mrow><mi mathvariant=\"sans-serif\">t</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow><mspace width=\"2em\"/><mi>B</mi><mtext> </mtext><mrow><mi mathvariant=\"sans-serif\">t</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow></mrow><mrow><mi>A</mi><mo>×</mo><mi>B</mi><mtext> </mtext><mrow><mi mathvariant=\"sans-serif\">t</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{A \\,\\mathsf{type} \\qquad B\\,\\mathsf{type}}{A\\times B\\,\\mathsf{type}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.2408em;vertical-align:-0.8804em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3603em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">type</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">type</span></span><span class=\"mspace\" style=\"margin-right:2em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">type</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>",
        "id": 432592062,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712785659
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277976\">Noah Chrein</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/type.20in.20the.20meta-theory.20v.2Es.2E.20term.20of.20a.20type/near/432579592\">said</a>:</p>\n<blockquote>\n<p>is there somewhere I can read up on this kind of operation, type formers only applying to certain types?</p>\n</blockquote>\n<p>Here's another example, just posted on the arXiv this month: the paper <a href=\"https://arxiv.org/abs/2404.01011\">Primitive Recursive Dependent Type Theory</a> has <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Π</mi></mrow><annotation encoding=\"application/x-tex\">\\Pi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Π</span></span></span></span>-types that don't act on the smallest universe, only on the larger ones.</p>",
        "id": 432606328,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712793395
    },
    {
        "content": "<p>Is simple type theory a theory in first-order logic?</p>",
        "id": 432607640,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712794269
    },
    {
        "content": "<p>I think that first-order logic is a <em>specification</em> language. The variables are understood to take values in a domain of discourse. A collection of statements in first-order logic determine a theory.</p>",
        "id": 432608208,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712794689
    },
    {
        "content": "<p>Is the domain of discourse the “universe of types”?</p>",
        "id": 432608254,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712794737
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"699750\">Julius Hamilton</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/type.20in.20the.20meta-theory.20v.2Es.2E.20term.20of.20a.20type/near/432607640\">said</a>:</p>\n<blockquote>\n<p>Is simple type theory a theory in first-order logic?</p>\n</blockquote>\n<p>No.  All type theories are <a href=\"https://ncatlab.org/nlab/show/deductive%20systems\">[[deductive systems]]</a>, on the same ontological plane with first-order logic itself, not a theory expressed <em>in</em> it.</p>",
        "id": 432609177,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712795429
    },
    {
        "content": "<p>Wow thank you that paper looks awesome!</p>",
        "id": 432609918,
        "sender_full_name": "Noah Chrein",
        "timestamp": 1712796036
    },
    {
        "content": "<p>“<em>(1) simply having a deductive system does not in itself necessarily yield an effective procedure for enumerating valid proof trees and theorems. (2) Deductive systems which do yield such an enumeration are sometimes referred to as formal systems.</em>”</p>\n<p>Why (1)?</p>",
        "id": 432615870,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712801125
    },
    {
        "content": "<p>You left off the important first part of that sentence:</p>\n<blockquote>\n<p>Depending on the strength of the metalanguage used to define the judgments and steps</p>\n</blockquote>\n<p>The point is that a general deductive system could have uncountably many rules, or rules with infinitely many premises, which aren't effectively enumerable.</p>",
        "id": 432616293,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712801414
    },
    {
        "content": "<p>(Assuming it is specified in a metatheory that includes infinity.)</p>",
        "id": 432616320,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712801443
    },
    {
        "content": "<p>So you would have a metatheory that is capable of expressing an infinite schema of rules for a deductive system. This may still be an interesting deductive system, but it’s just not “effectively enumerable”.</p>",
        "id": 432616688,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712801767
    },
    {
        "content": "<p>And “effectively enumerable” means there is no way to “traverse” them comprehensively, right? Like, it’s ok if they are infinite, as long as you can find a procedure that would, were you to go on, “enumerate all the judgments”.</p>",
        "id": 432616838,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712801902
    },
    {
        "content": "<p>Does that mean that type theories can be either deductive systems or formal systems?</p>",
        "id": 432617009,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712802048
    },
    {
        "content": "<p>“<em>more general deductive systems are considered in proof theory and type theory, typically because by side-stepping these coding issues one can give a simpler account of computational phenomena such as cut-elimination.</em>”</p>\n<p>In what way does <em>avoiding</em> formal systems make it <em>easier</em> to define a cut-elimination rule?</p>",
        "id": 432617195,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712802236
    },
    {
        "content": "<p>\"Effectively enumerable\" means there is an algorithm that lists all the deduction trees, in the sense that it might run forever but will eventually get to any one of them.  There could be infinitely <em>many</em> of them, as long as they can be listed by an algorithm.</p>",
        "id": 432617666,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712802590
    },
    {
        "content": "<p>According to the terminology on that page (which I'm not certain is standard in the literature), \"formal systems\" are a sub-class of \"deductive systems\", and a type theory in general is a deductive system that might or might not be a formal system.</p>",
        "id": 432617788,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712802632
    },
    {
        "content": "<p>I don't know what that remark about cut-elimimination means, though.</p>",
        "id": 432617872,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712802652
    },
    {
        "content": "<p>Alright. I put it on Stack Exchange: <a href=\"https://cs.stackexchange.com/questions/167527/why-is-it-simpler-to-express-the-cut-elimination-rule-in-general-deductive-syste\">https://cs.stackexchange.com/questions/167527/why-is-it-simpler-to-express-the-cut-elimination-rule-in-general-deductive-syste</a></p>\n<p>I wonder if in a formal system you have to have a very explicit way of writing the cut elimination rule, but since deductive systems are more “relaxed”, you can write it in a more intuitive way.</p>",
        "id": 432622618,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712806583
    },
    {
        "content": "<p>So Gödel’s incompleteness theorem only applies to effectively enumerable deductive systems?</p>",
        "id": 432622767,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712806737
    },
    {
        "content": "<p>It looks like that remark was added in revision #7 in 2012 by Noam Zeilberger, so you could also ask him directly.</p>",
        "id": 432622857,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712806819
    },
    {
        "content": "<p>Maybe it will work to summon <span class=\"user-mention\" data-user-id=\"295757\">@Noam Zeilberger</span>.</p>",
        "id": 432622881,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712806848
    },
    {
        "content": "<p>I’ll have to continue this tomorrow but I was hoping to understand how the concept of judgment differs from logic vs type theory. In logic, propositions are judged true. But in type theory we attempt to form a judgment of a type inhabitant, as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">a : A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>. </p>\n<p>This makes me wonder if there is an implied metaphysics of type theory: it is all about statements of “what exists”, where “truth”(/proof) is just one of the many kinds of existing things. In logic, truth is “outside” the system, in the meta-theory. In type theory, truth is “inside” the system. Right?</p>",
        "id": 432624862,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712808451
    },
    {
        "content": "<p>I also read that in the simplest type theories, like Church’s, the only way to construct new types was with functions. Ideas like product types came later.</p>\n<p>It seems like type theories have much more formation rules, whereas logic has much more axioms. This reminds me of something I read - Hilbert-style deductive systems have extremely few formation rules (like, substitution), and lots of axioms (like for ZFC); “natural deduction” has a number of formation rules. Type theories tend to use natural deduction. Does this mean that type theories simply don’t have “axioms”, except declaring at the outset the existence of certain atomic types?</p>",
        "id": 432625251,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712808818
    },
    {
        "content": "<p>Even then, those formation rules just have to be written in the meta-theory, which is why I feel like the difference is kind of illusory. Besides, can’t it be shown that certain types theories are isomorphic to intuitionistic logic?</p>",
        "id": 432625400,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712808946
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"699750\">Julius Hamilton</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/type.20in.20the.20meta-theory.20v.2Es.2E.20term.20of.20a.20type/near/432624862\">said</a>:</p>\n<blockquote>\n<p>This makes me wonder if there is an implied metaphysics of type theory: it is all about statements of “what exists”, where “truth”(/proof) is just one of the many kinds of existing things.</p>\n</blockquote>\n<p>I would say that <em>proofs</em> (a.k.a. \"witnesses of truth\") are one of the many types of existing things.</p>\n<blockquote>\n<p>In logic, truth is “outside” the system, in the meta-theory. In type theory, truth is “inside” the system. Right?</p>\n</blockquote>\n<p>I don't know what you mean by that.  In both cases the \"truth\" judgment resides in the deductive system.  If you mean that in logic that's outside any <em>theory</em> that we might formulate <em>inside</em> the logic, then yes.</p>",
        "id": 432626068,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712809379
    },
    {
        "content": "<p>Logic is really just a kind of type theory where we ignore the witnesses of the truth judgment.</p>",
        "id": 432626111,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712809424
    },
    {
        "content": "<p>I wouldn't say that <em>logic</em> \"has axioms\".  Ordinarily what has axioms is a <em>theory</em> formulated <em>in</em> logic.</p>",
        "id": 432626187,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712809462
    },
    {
        "content": "<p>Same for type theories.  Really they should be called \"type <a href=\"https://ncatlab.org/nlab/show/doctrines\">[[doctrines]]</a>\", since one can formulate a \"theory in MLTT\" by asserting some types and terms as axioms in the same way that one can formulate a \"theory in FOL\" by asserting some propositions and statements as axioms.</p>",
        "id": 432626254,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712809533
    },
    {
        "content": "<p>I think the \"formal systems\" remark means that one can use infinitary systems to help simplify tough proofs about finitary ones, such as considering Bohm trees when analyzing lambda calculus normalization</p>",
        "id": 432626394,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1712809649
    },
    {
        "content": "<p>Re axioms vs rules:<br>\nSomewhat confusingly, there are two different uses of \"axiom\".<br>\nAs <span class=\"user-mention\" data-user-id=\"276777\">@Mike Shulman</span> explains above, when mathematicians talk about axioms, they usually mean the axioms of some first-order theory formulated inside first-order logic. However, proof theorists talk differently: in proof-theoretic parlance, an <em>axiom</em> is usually just an unconditional rule of inference of a given proof system.</p>\n<p>When we talk about a Hilbert-style deductive system, we usually talk about axioms in the latter sense.<br>\nFor example, a Hilbert system for propositional logic might have axioms such as</p>\n<ol>\n<li>Infer <code>⊢ A → B → A</code>.</li>\n<li>Infer <code>⊢ (A → B → C) → (A → B) → A → C</code>.</li>\n<li>Infer <code>⊢ ((A → B) → A) → A</code>.</li>\n<li>From <code>⊢ A</code> and <code>⊢A → B</code> infer <code>⊢B</code>.</li>\n</ol>\n<p>Among these four, one would call 1,2,3 axioms since they are unconditional, but not 4 (modus ponens), since it requires you to already have some other derivations before you use it.</p>\n<p>Similarly, in a sequent system for propositional logic, we would call the identity inference rule \"Infer <code>A ⊢ A</code>\" an axiom, whereas we would not call the negation left inference rule \"From <code>Γ ⊢A</code>infer <code>Γ,¬A⊢ Δ</code>\" an axiom.</p>\n<p>Usually, the identity rule (schema) is the only axiom in a sequent system, and modus ponens is the only conditional inference rule of a Hilbert-style system. So sequent systems tend to have lots of conditional inference rules but very few axioms, whereas Hilbert systems have many axioms but very few inference rules. Certain presentations of Prawitz-style natural deduction can do away even with the identity rule, so in a certain (handwavy!) sense these are said to have no axioms at all.</p>\n<p>Both approaches have benefits and drawbacks, depending on what you wish to prove about your logic. As is well-known, sequent systems are very convenient for proving cut-elimination results. In turn, Hilbert systems are very handy for proof translations where the inductive steps are difficult (since there are a lot fewer of them): for example, the syntactic proof of conservativity of nonstandard analysis uses a very special Hilbert system, where even the quantifier rule is eliminated in favor of additional axioms.</p>\n<blockquote>\n<p>Type theories tend to use natural deduction. Does this mean that type theories simply don’t have “axioms”, except declaring at the outset the existence of certain atomic types?</p>\n</blockquote>\n<p>MLTT is its own system, one that comes with several sorts of judgments. Of the more traditional proof-theoretic systems, its presentation most closely resembles that of natural deduction. However, in my experience, type theory practitioners rarely if ever use the word \"axiom\" for unconditional inference rules.</p>\n<blockquote>\n<p>This makes me wonder if there is an implied metaphysics of type theory: it is all about statements of “what exists”, where “truth”(/proof) is just one of the many kinds of existing things. In logic, truth is “outside” the system, in the meta-theory. In type theory, truth is “inside” the system. Right?</p>\n</blockquote>\n<p>These are all just ways of speaking, and has no philosophical/metaphysical/ontological implications whatsoever.</p>\n<p>The word \"true\" itself refers to like a hundred different things in mathematical logic, depending on context. None of these senses necessarily has anything to do with the metaphysical concept of truth, not even the Tarskian definition of truth in models. When I make the judgment that<code>⊢ ¬¬A → A</code>, I don't judge that _true_ in any sort of metaphysical sense: I just observe that I managed to derive it in whatever logic I'm considering that day... and \"truth\" is a convenient shorthand/metaphor that allows me to communicate what I actually did to others.</p>",
        "id": 432643294,
        "sender_full_name": "Zoltan A. Kocsis",
        "timestamp": 1712820496
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"699750\">Julius Hamilton</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/type.20in.20the.20meta-theory.20v.2Es.2E.20term.20of.20a.20type/near/432617195\">said</a>:</p>\n<blockquote>\n<p>“<em>more general deductive systems are considered in proof theory and type theory, typically because by side-stepping these coding issues one can give a simpler account of computational phenomena such as cut-elimination.</em>”</p>\n<p>In what way does <em>avoiding</em> formal systems make it <em>easier</em> to define a cut-elimination rule?</p>\n</blockquote>\n<p>I can't be sure whether this is what @<strong>noamzoam</strong> had in mind, but a classic example of using more general deductive systems over strictly formal systems is Buchholz <a href=\"https://link.springer.com/chapter/10.1007/3-540-63385-5_29\">explaining Gentzen's consistency proof within infinitary proof theory</a>, which gives a simple derivation of the reductions and ordinal assignment used by Gentzen uses in his consistency proof of Peano arithmetic in terms of cut-elimination for an infinitary system which has infinitely branching proof trees.</p>",
        "id": 432645388,
        "sender_full_name": "Zoltan A. Kocsis",
        "timestamp": 1712821402
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"510824\">Zoltan A. Kocsis</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/type.20in.20the.20meta-theory.20v.2Es.2E.20term.20of.20a.20type/near/432645388\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"699750\">Julius Hamilton</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/type.20in.20the.20meta-theory.20v.2Es.2E.20term.20of.20a.20type/near/432617195\">said</a>:</p>\n<blockquote>\n<p>“<em>more general deductive systems are considered in proof theory and type theory, typically because by side-stepping these coding issues one can give a simpler account of computational phenomena such as cut-elimination.</em>”</p>\n<p>In what way does <em>avoiding</em> formal systems make it <em>easier</em> to define a cut-elimination rule?</p>\n</blockquote>\n<p>I can't be sure whether this is what @_<strong>noamzoam</strong> had in mind, but a classic example of using more general deductive systems over strictly formal systems is Buchholz <a href=\"https://link.springer.com/chapter/10.1007/3-540-63385-5_29\">explaining Gentzen's consistency proof within infinitary proof theory</a>, which gives a simple derivation of the reductions and ordinal assignment used by Gentzen uses in his consistency proof of Peano arithmetic in terms of cut-elimination for an infinitary system which has infinitely branching proof trees.</p>\n</blockquote>\n<p>Since it was over a decade ago I can't be sure what I meant either, but as I remember this is exactly the kind of thing I had in mind.  In addition to Schütte's \"little omega\" rule (an infinitary rule discussed in that Buchholz paper, which allows you to conclude a universal statement <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>P</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall x.P(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> about the natural numbers given proofs of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>∈</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">n \\in \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>), there is also Buchholz's big <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Ω</mi></mrow><annotation encoding=\"application/x-tex\">\\Omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Ω</span></span></span></span>-rule that he introduced in the study of iterated inductive definitions, and which I got interested in during my PhD thesis.  If one allows those kinds of rules then proofs may be visualized as trees that are \"infinitely wide\".  But one can also consider proofs that are \"infinitely deep\", as Buchholz does in that paper making use of Grigorii Mints' \"repetition\" rule.  A proof essentially becomes a program that you can query to progressively reveal bigger and bigger portions of this infinitary proof tree.</p>",
        "id": 432653348,
        "sender_full_name": "Noam Zeilberger",
        "timestamp": 1712824362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/type.20in.20the.20meta-theory.20v.2Es.2E.20term.20of.20a.20type/near/432626254\">said</a>:</p>\n<blockquote>\n<p>Same for type theories.  Really they should be called \"type <a href=\"https://ncatlab.org/nlab/show/doctrines\">[[doctrines]]</a>\", since one can formulate a \"theory in MLTT\" by asserting some types and terms as axioms in the same way that one can formulate a \"theory in FOL\" by asserting some propositions and statements as axioms.</p>\n</blockquote>\n<p>This is perhaps another way to ask my question, can one construct a type theory (or something of a similar flavor) that includes all levels of doctrine <em>inside</em> of it? Perhaps, in such a way that the meta-theory itself can be resolved internally. There's a statement in <a href=\"https://ncatlab.org/nlab/show/propositional+resizing\">nlab: propositional resizing</a> that says </p>\n<blockquote>\n<p>it is still possible to define a well-pointed cartesian closed lextensive coherent category object with a natural numbers object inside of any well-pointed cartesian closed lextensive coherent category with a natural numbers object.</p>\n</blockquote>\n<p>That is, the meta-theory can specify its own structure and hence, in my naive understanding, handle itself internally.</p>",
        "id": 432729324,
        "sender_full_name": "Noah Chrein",
        "timestamp": 1712848459
    },
    {
        "content": "<p>Any particular sufficiently expressive theory can serve as its own metatheory.  You can study ZFC inside of ZFC, or MLTT inside of MLTT, etc.</p>",
        "id": 432731712,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712849118
    },
    {
        "content": "<p>There are still just 2 levels, it's just that the 2 levels are formally the same theory.</p>",
        "id": 432731758,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712849131
    },
    {
        "content": "<p>One could try to formulate a notion of an \"infinite tower of theories\" each serving as the metatheory of the next.  I think something like this is envisioned informally in the introduction to Cori and Lascar's book on Mathematical Logic (which also has one of the best explanations of theory/metatheory that I've seen), but I don't think I've seen it written out precisely.</p>",
        "id": 432732037,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712849197
    },
    {
        "content": "<p>What do you think it would take to make it precise?</p>",
        "id": 432732315,
        "sender_full_name": "Noah Chrein",
        "timestamp": 1712849270
    },
    {
        "content": "<p>I'm not sure what you mean.  You'd have to write out a formal mathematical definition.</p>",
        "id": 432732425,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712849293
    },
    {
        "content": "<p>What kind of structure is necessary to capture the semantics of an infinite tower of theories each serving as a meta-theory of the next? In my work I consider something like a graded quasi virtual equipment, the gradings are essentially (profunctorial) representations of (higher) morphism at each level in this tower of theory. I'm wondering if you've thought about something like this, perhaps as a means of capturing the vague intuition of n-theories.</p>",
        "id": 432732979,
        "sender_full_name": "Noah Chrein",
        "timestamp": 1712849453
    },
    {
        "content": "<p>I have not.</p>",
        "id": 432733009,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712849461
    },
    {
        "content": "<p>That's okay, I think I am looking for some acute guidance in this particular matter but I'm not sure where to look. I'll take a look at the Cori/Lascar book though and see where that leads</p>",
        "id": 432733791,
        "sender_full_name": "Noah Chrein",
        "timestamp": 1712849666
    },
    {
        "content": "<p>Don't get your hopes too high, I don't think they have a lot to say.  (-:</p>",
        "id": 432734927,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712849945
    },
    {
        "content": "<p><a href=\"/user_uploads/21317/0F6PrDU30-RLFY1tI3rmv-k9/Rene-Cori-Daniel-Lascar-Donald-H.-Pelletier-Mathematical-Logic_-A-Course-with-Exercises-Part-I_-Propositional-Calculus-Boolean-Algebras-Predicate-Calculus-Completeness-Theorems-Oxford-Universi.pdf\">Rene Cori, Daniel Lascar, Donald H. Pelletier - Mathematical Logic_ A Course with Exercises Part I_ Propositional Calculus, Boolean Algebras, Predicate Calculus, Completeness Theorems -Oxford Universi.pdf</a></p>\n<p>I have part 2 but Zulip says file is too large.</p>",
        "id": 432735465,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712850102
    },
    {
        "content": "<p>You’re concerned about the problem of <a href=\"https://ncatlab.org/nlab/show/Münchhausen+trilemma\">infinite regress</a>, right?</p>",
        "id": 432736043,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712850254
    },
    {
        "content": "<p>The passage I was thinking of is on page 3 of that file.</p>",
        "id": 432736151,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712850297
    },
    {
        "content": "<p>(I mean, the page numbered \"3\", which is the 25th page of the PDF.)</p>",
        "id": 432736363,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712850356
    },
    {
        "content": "<p>2 perspectives on philosophy of mathematics that might give Noah ideas.</p>\n<p>Chapter 12: Quine and the Web of Belief<br>\n<a href=\"/user_uploads/21317/AQswvsQFlCArdplpy_kWTAen/Stewart-Shapiro_-William-J.-Wainwright-The-Oxford-Handbook-of-Philosophy-of-Mathematics-and-Logic-OUP-USA-2005.pdf\">Stewart Shapiro_ William J. Wainwright - The Oxford Handbook of Philosophy of Mathematics and Logic-OUP USA (2005).pdf</a></p>\n<p>The idea of “coherentism”. <a href=\"https://plato.stanford.edu/entries/justep-coherence/\">https://plato.stanford.edu/entries/justep-coherence/</a></p>",
        "id": 432740316,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712851452
    },
    {
        "content": "<p>I've actually had this exact convo before at wolfram. Imo a type theory that includes all doctrines, and perhaps relaxes the \"strictness\" of typing relations to, say, structured witnesses of typing relations (i can only posit a toy model of this) could be a basis for coherentism. Nothing is \"at the top\" and one could imagine webs of typing relations instead of linear hierarchies of typing relations.</p>",
        "id": 432756702,
        "sender_full_name": "Noah Chrein",
        "timestamp": 1712857156
    },
    {
        "content": "<p>There would be a lot of logical soundness problems with doing this naively but tbh this is where my intuitions end</p>",
        "id": 432757068,
        "sender_full_name": "Noah Chrein",
        "timestamp": 1712857322
    },
    {
        "content": "<p><a href=\"/user_uploads/21317/q8cXpROd7FjxaV_r0tYL39Dy/2010.02752.pdf\">2010.02752.pdf</a></p>\n<p>Let me know if you want to read or discuss this paper together, I’ve been meaning to study Wolfram’s ‘multiway systems’ for a while</p>",
        "id": 432799286,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712875407
    },
    {
        "content": "<p>I corresponded with Wolfram for almost forty years. I think I upset him when I asked if it was appropriate for me to use my Mathematica license to create an index of  TWFs for <span class=\"user-mention\" data-user-id=\"275920\">@John Baez</span>. Wolfram recruited me to work on multiway systems, but I didn't feel like moving on the his next \"cool\" project. Plus he seems to have a large number of bright people in his orbit. He seems to be more concerned about advancing Wolfram than advancing science. I recently had a conversation about Wolfram's Principle of Computational Equivalence not having a proof or that he hasn't produced any peer-reviewed material in forty years. So I am no longer willing to work with Wolfram or Mathematica. I could say much more, but I have more useful things to attend to.</p>",
        "id": 432802172,
        "sender_full_name": "Daniel Geisler",
        "timestamp": 1712877234
    },
    {
        "content": "<p>Awesome</p>",
        "id": 432808432,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712881738
    },
    {
        "content": "<p>Is there a formal proof of the statement “any sufficiently expressive theory can serve as its own metatheory”?</p>",
        "id": 432808629,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712881898
    },
    {
        "content": "<p>Well, it's kind of implicit in the argument leading up to Godel's incompleteness theorems.</p>",
        "id": 432809195,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712882301
    },
    {
        "content": "<p>I’m not ready to understand the incompleteness theorem. Could you sketch the argument for the above statement?</p>",
        "id": 432820554,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712890541
    },
    {
        "content": "<blockquote>\n<p>The theory known as true arithmetic consists of all true statements about the standard integers in the language of Peano arithmetic. This theory is consistent and complete, and contains a sufficient amount of arithmetic. However, it does not have a recursively enumerable set of axioms, and thus does not satisfy the hypotheses of the incompleteness theorems.</p>\n</blockquote>\n<ul>\n<li><a href=\"https://en.m.wikipedia.org/wiki/Gödel%27s_incompleteness_theorems\">Wikipedia</a></li>\n</ul>\n<p><a href=\"https://en.m.wikipedia.org/wiki/True_arithmetic\">True arithmetic</a>:</p>\n<blockquote>\n<p>The central result on true arithmetic is the undefinability theorem of Alfred Tarski (1936). It states that the set Th(N) is not arithmetically definable. This means that there is no formula φ(x) in the language of first-order arithmetic such that, for every sentence θ in this language, N ⊨ θ if and only if N ⊨ φ(#(θ)) (the numeral of the canonical Gödel number of the sentence θ).</p>\n</blockquote>\n<p><a href=\"/user_uploads/21317/y8Psb07FW49Q_39N7JNyk9KM/069DAB04-4757-45FB-9B98-D006378137CA.jpg\">069DAB04-4757-45FB-9B98-D006378137CA.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/y8Psb07FW49Q_39N7JNyk9KM/069DAB04-4757-45FB-9B98-D006378137CA.jpg\" title=\"069DAB04-4757-45FB-9B98-D006378137CA.jpg\"><img src=\"/user_uploads/21317/y8Psb07FW49Q_39N7JNyk9KM/069DAB04-4757-45FB-9B98-D006378137CA.jpg\"></a></div><p>I can’t see what about these axioms would imply that the theory is not effectively enumerable.</p>\n<p>I think it’s saying that true arithmetic is not expressive enough to express the algorithm that could enumerate it.</p>\n<p>And the idea is, if we make it more expressive, it could; but then it would become incomplete?</p>",
        "id": 432821133,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1712890946
    },
    {
        "content": "<p>I was referring to the <em>proof</em> of the incompleteness theorem, which involves coding the formulas of a formal system as natural numbers, so that any theory that's expressive enough to talk about the natural numbers can also talk about any effective formal system.</p>",
        "id": 432821674,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712891357
    },
    {
        "content": "<p>If you want to talk about the incompleteness theorem itself, that should go in another topic.</p>",
        "id": 432821683,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1712891371
    }
]