[
    {
        "content": "<p>I'm thinking about the following situation, where morphisms in a category are mapped to probabilities. It can be expressed as a functor, but because of normalisation the functor needs to have a property that feels more \"global\" in nature than the properties we usually ask functors to have. My question is \"what's this an example of?\" - is there a way to think about this extra condition in a less <em>ad hoc</em> way?</p>\n<p>Suppose I have a free category on a graph. So I start with a set of objects and a distinguished set of morphisms called generators, and I form a category by freely concatenating them. I can think of this category as a state machine, where the objects are states and the morphisms are sequences of possible transitions between states, with the identities being empty sequences.</p>\n<p>Now suppose I want to make this into a Markov process, where the sequences have associated probabilities. I can do that by defining a functor from my free category to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0,1]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> as a multiplicative monoid. A sequence of transitions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mover><mo stretchy=\"true\">→</mo><mpadded lspace=\"0.3em\" width=\"+0.6em\"><mi>f</mi></mpadded></mover><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\xrightarrow{f} B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1191079999999998em;vertical-align:-0.010999999999999899em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel x-arrow\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1081079999999999em;\"><span style=\"top:-3.322em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight x-arrow-pad\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"svg-align\" style=\"top:-2.689em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"hide-tail\" style=\"height:0.522em;min-width:1.469em;\"><svg height=\"0.522em\" preserveAspectRatio=\"xMaxYMin slice\" viewBox=\"0 0 400000 522\" width=\"400em\"><path d=\"M0 241v40h399891c-47.3 35.3-84 78-110 128 -16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20  11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7  39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85 -40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5 -12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67  151.7 139 205zm0 0v40h399900v-40z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.010999999999999899em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, let's say of length <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, maps to a number, which we interpret as the probability of observing that sequence over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> time steps, conditioned on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> being the initial state. From the definition of a functor, identities (empty sequences) are assigned a probability of 1. (There's only one sequence you can observe over 0 time steps.) Concatenation maps to multiplication, which is what we should expect.</p>\n<p>However, not just any such functor will do, because we also demand that, for any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, the set of sequences of length <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> that start at a given object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> must have probabilities that sum to 1. This can be achieved by making sure that all of the generators out of a given object map to numbers that sum to 1, and it extends automatically to sequences of any length.</p>\n<p>But this is a bit of a weird property to ask a functor to have, both because the sum operation isn't part of the definition of the multiplicative monoid we're mapping to, and because we're asking about (a subset of) \"all of the morphisms pointing out of a given object\", so it depends on the hom-sets all at once, instead of one morphism at a time.</p>\n<p>So the question is what kind of thing is this - is there a way to express this sort of condition in a more satisfyingly category-theoretic way, which then might give some insight into how to generalise it?</p>",
        "id": 207748544,
        "sender_full_name": "Nathaniel Virgo",
        "timestamp": 1598142701
    },
    {
        "content": "<p>I think for this sort of thing it's better to use \"unnormalized probabilities\" - nonnegative numbers that may not sum to 1.  Whenever you have a finite set equipped with unnormalized probabilities, you can normalize them and get a probability distribution on that set.   Similar things happen in more infinite contexts (infinite sets, infinite measure spaces) if one is willing to engage in more analysis. </p>\n<p>In physics this procedure is standard; the normalizing constant is called the <a href=\"https://en.wikipedia.org/wiki/Partition_function\">partition function</a> and it plays a fundamental role in statistical mechanics.  So I think it's better to work with unnormalized probabilities until the very end.  You can get used to them.</p>",
        "id": 207757134,
        "sender_full_name": "John Baez",
        "timestamp": 1598160111
    },
    {
        "content": "<p>The category of finite sets equipped with unnormalized probabilities is very nice.</p>",
        "id": 207757175,
        "sender_full_name": "John Baez",
        "timestamp": 1598160152
    }
]