[
    {
        "content": "<p>Suppose</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>:</mo><mrow><mi mathvariant=\"sans-serif\">C</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">R</mi><mi mathvariant=\"sans-serif\">i</mi><mi mathvariant=\"sans-serif\">n</mi><mi mathvariant=\"sans-serif\">g</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\"> F : \\mathsf{CommRing} \\to \\mathsf{Set} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">CommRing</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Set</span></span></span></span></span></p>\n<p>is the functor of points associated to some scheme.    I imagine any such functor will be completely determined by its restriction to some subcategory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>⊆</mo><mrow><mi mathvariant=\"sans-serif\">C</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">R</mi><mi mathvariant=\"sans-serif\">i</mi><mi mathvariant=\"sans-serif\">n</mi><mi mathvariant=\"sans-serif\">g</mi></mrow></mrow><annotation encoding=\"application/x-tex\">C \\subseteq \\mathsf{CommRing}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">CommRing</span></span></span></span></span>.  Is there some famous subcategory that does the job and is small enough to be interesting?  (I don't want to hear <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>=</mo><mrow><mi mathvariant=\"sans-serif\">C</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">R</mi><mi mathvariant=\"sans-serif\">i</mi><mi mathvariant=\"sans-serif\">n</mi><mi mathvariant=\"sans-serif\">g</mi></mrow></mrow><annotation encoding=\"application/x-tex\">C = \\mathsf{CommRing}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">CommRing</span></span></span></span></span>, or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> is the full subcategory containing all free commutative rings.)</p>\n<p>I'm hoping some nice result like this will follow from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> being a sheaf with respect to the Zariski topology.</p>",
        "id": 260523850,
        "sender_full_name": "John Baez",
        "timestamp": 1636217355
    },
    {
        "content": "<p>If you only need schemes locally of finite presentation, then you can take finitely presented rings.</p>",
        "id": 260532619,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1636228259
    },
    {
        "content": "<p>Restricting to connected rings (no nontrivial idempotents) gives you extensive sheaves (which schemes are).</p>",
        "id": 260532649,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1636228310
    },
    {
        "content": "<p>You can't represent the category of Zariski sheaves as a presheaf category since the theory of local rings is inherently existential</p>",
        "id": 260533286,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1636228947
    },
    {
        "content": "<p>It sounds like your answer to my question might be \"connected rings\".</p>",
        "id": 260535974,
        "sender_full_name": "John Baez",
        "timestamp": 1636232591
    },
    {
        "content": "<p>But you didn't exactly come out and say that the functor of points  for any scheme is determined by its action on the full subcategory of connected rings.   Is that true?</p>",
        "id": 260536040,
        "sender_full_name": "John Baez",
        "timestamp": 1636232675
    },
    {
        "content": "<p>On any lextensive category with a superextensive topology, a representable sheaf should be determined by its restriction to the connected objects, no?</p>",
        "id": 260541498,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1636240141
    },
    {
        "content": "<p>Yes</p>",
        "id": 260542966,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1636242413
    },
    {
        "content": "<p>The functor of points for any scheme (or any Zariski sheaf for that matter) is determined by its action on connected rings</p>",
        "id": 260542982,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1636242445
    },
    {
        "content": "<p>No, that presupposes that all objects in an extensive category are disjoint unions of connected objects. This is not true for schemes, nor for topological spaces.</p>",
        "id": 260545410,
        "sender_full_name": "Zhen Lin Low",
        "timestamp": 1636246174
    },
    {
        "content": "<p>But isn’t every ring uniquely a direct product of connected rings?</p>",
        "id": 260560533,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1636271788
    },
    {
        "content": "<p>Even if that were so, infinite direct products of rings are not turned into infinite disjoint unions of schemes.</p>",
        "id": 260560557,
        "sender_full_name": "Zhen Lin Low",
        "timestamp": 1636271862
    },
    {
        "content": "<p>There is a morphism of schemes<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>⨆</mo><mrow><mi>i</mi><mo>∈</mo><mi>β</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">N</mi><mo stretchy=\"false\">)</mo></mrow></msub><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">C</mi><mo stretchy=\"false\">)</mo><mo>⟶</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><msub><mo>∏</mo><mrow><mi>k</mi><mo>∈</mo><mi mathvariant=\"double-struck\">N</mi></mrow></msub><mi mathvariant=\"double-struck\">C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\bigsqcup_{i \\in \\beta(\\mathbb{N})} \\mathrm{Spec}(\\mathbb{C}) \\longrightarrow \\mathrm{Spec}(\\prod_{k \\in \\mathbb{N}} \\mathbb{C} )</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.22471em;vertical-align:-0.47471em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⨆</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.22528999999999993em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">β</span><span class=\"mopen mtight\">(</span><span class=\"mord mathbb mtight\">N</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.47471em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">C</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟶</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.07708em;vertical-align:-0.32708000000000004em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mopen\">(</span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.18639799999999984em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathbb mtight\">N</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32708000000000004em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathbb\">C</span><span class=\"mclose\">)</span></span></span></span><br>\nwhich is a bijection on closed points. In both schemes, all points are closed, and they are given by ultrafilters, i.e. elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\beta(\\mathbb{N})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span><span class=\"mopen\">(</span><span class=\"mord mathbb\">N</span><span class=\"mclose\">)</span></span></span></span>.<br>\nIf <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> is any scheme that is a finite disjoint union of connected components, then each morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><msub><mo>∏</mo><mrow><mi>k</mi><mo>∈</mo><mi mathvariant=\"double-struck\">N</mi></mrow></msub><mi mathvariant=\"double-struck\">C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">X \\to \\mathrm{Spec}(\\prod_{k \\in \\mathbb{N}} \\mathbb{C} )</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.07708em;vertical-align:-0.32708000000000004em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mopen\">(</span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.18639799999999984em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathbb mtight\">N</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32708000000000004em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathbb\">C</span><span class=\"mclose\">)</span></span></span></span> will lift in a unique way to a morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><msub><mo>⨆</mo><mrow><mi>i</mi><mo>∈</mo><mi>β</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">N</mi><mo stretchy=\"false\">)</mo></mrow></msub><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">X \\to \\bigsqcup_{i \\in \\beta(\\mathbb{N})} \\mathrm{Spec}(\\mathbb{C})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.22471em;vertical-align:-0.47471em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⨆</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.22528999999999993em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">β</span><span class=\"mopen mtight\">(</span><span class=\"mord mathbb mtight\">N</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.47471em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">C</span><span class=\"mclose\">)</span></span></span></span>. Each connected component gets mapped to a single point.</p>\n<p>So the subcategory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> definitely has to contain affine schemes that cannot be written as a finite disjoint union of connected components. This is another reason why you cannot take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> to be the category of connected rings.</p>\n<p>As <span class=\"user-mention\" data-user-id=\"341237\">@Fawzi Hreiki</span> already mentioned, the solution is to restrict to schemes of finite presentation. For example, if you work with schemes that are of finite presentation over a field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>, then the scheme is uniquely determined by its functor of points on the connected rings.</p>",
        "id": 260561377,
        "sender_full_name": "Jens Hemelaer",
        "timestamp": 1636273181
    },
    {
        "content": "<p>Another less drastic solution would be to restrict to (locally) Noetherian schemes. Because every (locally) Noetherian scheme can be Zariski-covered by connected Noetherian affine schemes, it follows that a scheme like that will be completely determined by its functor of points on connected Noetherian rings.</p>",
        "id": 260568740,
        "sender_full_name": "Jens Hemelaer",
        "timestamp": 1636284610
    },
    {
        "content": "<p>Just out of curiosity, how often does one actually deal with schemes which are not locally of finite presentation in practice?</p>",
        "id": 260569122,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1636285206
    },
    {
        "content": "<p>Aha, I was worried about the definition of 'connected', my intuition was trying to tell me something. Thanks for picking that up <span class=\"user-mention\" data-user-id=\"416301\">@Zhen Lin Low</span></p>",
        "id": 260569297,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1636285489
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"341237\">Fawzi Hreiki</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/schemes/near/260569122\">said</a>:</p>\n<blockquote>\n<p>Just out of curiosity, how often does one actually deal with schemes which are not locally of finite presentation in practice?</p>\n</blockquote>\n<p>For example <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">Q</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Spec}(\\mathbb{Q})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">Q</span><span class=\"mclose\">)</span></span></span></span> is not locally of finite presentation over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Spec}(\\mathbb{Z})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">Z</span><span class=\"mclose\">)</span></span></span></span>. Or if you are working over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">C</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Spec}(\\mathbb{C}(t))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">C</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">))</span></span></span></span> is not locally of finite presentation.</p>",
        "id": 260569674,
        "sender_full_name": "Jens Hemelaer",
        "timestamp": 1636286045
    },
    {
        "content": "<p>Thanks, everybody!  So it seems my original question (as opposed to various modified questions) has received no (correct) answer better than the category \"free commutative rings\".</p>",
        "id": 260600900,
        "sender_full_name": "John Baez",
        "timestamp": 1636326404
    },
    {
        "content": "<p>I asked: what is a subcategory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>⊆</mo><mrow><mi mathvariant=\"sans-serif\">C</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">R</mi><mi mathvariant=\"sans-serif\">i</mi><mi mathvariant=\"sans-serif\">n</mi><mi mathvariant=\"sans-serif\">g</mi></mrow></mrow><annotation encoding=\"application/x-tex\">C \\subseteq \\mathsf{CommRing}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">CommRing</span></span></span></span></span> such that the functor of points for <em>any</em> scheme, </p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>:</mo><mrow><mi mathvariant=\"sans-serif\">C</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">R</mi><mi mathvariant=\"sans-serif\">i</mi><mi mathvariant=\"sans-serif\">n</mi><mi mathvariant=\"sans-serif\">g</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\"> F : \\mathsf{CommRing} \\to \\mathsf{Set} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">CommRing</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Set</span></span></span></span></span></p>\n<p>is determined by its restriction to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>?</p>",
        "id": 260600980,
        "sender_full_name": "John Baez",
        "timestamp": 1636326521
    },
    {
        "content": "<p>I'm pretty sure we can use the full subcategory of free commutative rings, but this answer makes no use of the fact that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> is the functor of points of a scheme; it'd be true for any functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>:</mo><mrow><mi mathvariant=\"sans-serif\">C</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">R</mi><mi mathvariant=\"sans-serif\">i</mi><mi mathvariant=\"sans-serif\">n</mi><mi mathvariant=\"sans-serif\">g</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">F : \\mathsf{CommRing} \\to \\mathsf{Set}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">CommRing</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Set</span></span></span></span></span>.</p>",
        "id": 260601056,
        "sender_full_name": "John Baez",
        "timestamp": 1636326603
    },
    {
        "content": "<p>Maybe knowing that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> is the functor of points of an (arbitrary) scheme doesn't help at all!</p>",
        "id": 260601072,
        "sender_full_name": "John Baez",
        "timestamp": 1636326626
    },
    {
        "content": "<p>That's interesting in itself, so thanks.   I also learned a lot of other things....</p>",
        "id": 260601084,
        "sender_full_name": "John Baez",
        "timestamp": 1636326662
    },
    {
        "content": "<p>Actually, I don't think the category of free commutative rings works either.</p>",
        "id": 260601089,
        "sender_full_name": "Zhen Lin Low",
        "timestamp": 1636326667
    },
    {
        "content": "<p>Okay... yeah, now my argument for that seems to be dissolving into the mist.   Thanks.</p>",
        "id": 260601646,
        "sender_full_name": "John Baez",
        "timestamp": 1636327205
    },
    {
        "content": "<p>So, right now it's a question whose best known answer is completely boring and unhelpful.</p>",
        "id": 260601676,
        "sender_full_name": "John Baez",
        "timestamp": 1636327237
    },
    {
        "content": "<p>There is the notion of a small presheaf which just means a presheaf which is a small colimit of representables. I’d imagine that the functor of points for any scheme (as defined classically) is small. </p>\n<p>This is not an answer to your question though because the domain category is still all rings but it’s just a certain class of functors.</p>",
        "id": 260602790,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1636328878
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/schemes/near/260600980\">said</a>:</p>\n<blockquote>\n<p>I asked: what is a subcategory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>⊆</mo><mrow><mi mathvariant=\"sans-serif\">C</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">R</mi><mi mathvariant=\"sans-serif\">i</mi><mi mathvariant=\"sans-serif\">n</mi><mi mathvariant=\"sans-serif\">g</mi></mrow></mrow><annotation encoding=\"application/x-tex\">C \\subseteq \\mathsf{CommRing}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">CommRing</span></span></span></span></span> such that the functor of points for <em>any</em> scheme, </p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>:</mo><mrow><mi mathvariant=\"sans-serif\">C</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">R</mi><mi mathvariant=\"sans-serif\">i</mi><mi mathvariant=\"sans-serif\">n</mi><mi mathvariant=\"sans-serif\">g</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\"> F : \\mathsf{CommRing} \\to \\mathsf{Set} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">CommRing</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Set</span></span></span></span></span></p>\n<p>is determined by its restriction to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>?</p>\n</blockquote>\n<p>Any such category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> will contain very pathological affine schemes (otherwise the schemes you build out of them will be 'nice' as well). Categories <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> that work are:</p>\n<ul>\n<li>the category of non-noetherian rings</li>\n<li>the category of rings with infinitely many idempotents</li>\n<li>the category of rings with cardinality <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≥</mo><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\geq \\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>, for some cardinal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>.</li>\n</ul>\n<p>I admit that these are not very helpful solutions to the problem. Also, they work for any functor, not only for a functor of points of a scheme.</p>",
        "id": 260626142,
        "sender_full_name": "Jens Hemelaer",
        "timestamp": 1636360043
    },
    {
        "content": "<p>I think none of those work for all functors, but only for the stupid reason that you can't get <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{ 0 \\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mclose\">}</span></span></span></span> as a retract of anything. If you restrict to functors that preserve the terminal object then I think it works.</p>",
        "id": 260629860,
        "sender_full_name": "Zhen Lin Low",
        "timestamp": 1636362317
    },
    {
        "content": "<p>Thanks, I agree. So that's one small advantage of working with the functor of points of a scheme: you know that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> sends the trivial ring to a singleton, so it isn't a problem if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> does not contain the trivial ring.</p>",
        "id": 260633430,
        "sender_full_name": "Jens Hemelaer",
        "timestamp": 1636364341
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275920\">John Baez</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/schemes/near/260523850\">said</a>:</p>\n<blockquote>\n<p>Suppose</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>:</mo><mrow><mi mathvariant=\"sans-serif\">C</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">R</mi><mi mathvariant=\"sans-serif\">i</mi><mi mathvariant=\"sans-serif\">n</mi><mi mathvariant=\"sans-serif\">g</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\"> F : \\mathsf{CommRing} \\to \\mathsf{Set} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">CommRing</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Set</span></span></span></span></span></p>\n<p>is the functor of points associated to some scheme.    I imagine any such functor will be completely determined by its restriction to some subcategory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>⊆</mo><mrow><mi mathvariant=\"sans-serif\">C</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">m</mi><mi mathvariant=\"sans-serif\">R</mi><mi mathvariant=\"sans-serif\">i</mi><mi mathvariant=\"sans-serif\">n</mi><mi mathvariant=\"sans-serif\">g</mi></mrow></mrow><annotation encoding=\"application/x-tex\">C \\subseteq \\mathsf{CommRing}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">CommRing</span></span></span></span></span>.  Is there some famous subcategory that does the job and is small enough to be interesting?</p>\n</blockquote>\n<p>Looking this up on Stacks Project, \"the functor of points associated to some scheme\", say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, is a representable functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>↦</mo><msub><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">h</mi></mrow></msub><mo stretchy=\"false\">(</mo><mi>T</mi><mo separator=\"true\">,</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T \\mapsto \\mathrm{Hom}_{\\mathrm{Sch}}(T,X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69433em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Hom</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">Sch</span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span>. Representable functors preserve a lot of structure, in this instance (since we're considering this as a functor on CommRing) we're looking at preservation of all limits. So any subcategory of CommRing which generates everything under limits is good enough.</p>\n<p>If there were cofree rings (if rings were coalgebraic over sets), we would have a canonical choice, since every ring would be a regular subring of a cofree ring. Jens mentioned some classes which are sufficiently large to guarantee that any ring can be found as a nice subring. Perhaps there are some embedding theorems for rings that you can use (\"every commutative ring embeds into a ring having property X\") to whittle down the subcategory a little; even better if you can find a result of the form \"every commutative ring embeds into a product of rings having property X\". All such results I can find with a quick search have caveats, though, so the best I can do to start you off is to  the class of rings where every element is either invertible or a zero divisor, since the \"total quotient\" of any ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> has this property and contains <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> as a subring. There might a product decomposition you can implement based on the behaviour of the zero divisors and units. It's not clear to me whether every ring is a <em>nice enough</em> subring of its total quotient for this to be a valid answer, I'll let someone else work that out <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> .</p>",
        "id": 260645939,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1636371711
    },
    {
        "content": "<p>The functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Spec</mi><mo>⁡</mo><mo>:</mo><msup><mtext mathvariant=\"bold\">CRing</mtext><mtext>op</mtext></msup><mo>→</mo><mtext mathvariant=\"bold\">Set</mtext></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Spec} : \\textbf{CRing}^\\textrm{op} \\to \\textbf{Set}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9431719999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord textbf\">CRing</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.748732em;\"><span style=\"top:-3.1473400000000002em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord text mtight\"><span class=\"mord textrm mtight\">op</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68611em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord textbf\">Set</span></span></span></span></span> does not preserve arbitrary colimits. So for a general scheme, the functor of points does not preserve all limits. (If it did it would be affine.)</p>",
        "id": 260646172,
        "sender_full_name": "Zhen Lin Low",
        "timestamp": 1636371846
    },
    {
        "content": "<p>But Spec isn't an instance of the type of functor under discussion, since there isn't a universal \"point of a scheme\"</p>",
        "id": 260646269,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1636371921
    },
    {
        "content": "<p>Ah I see what you're saying: the representable functor will preserve colimits of schemes, but these don't coincide with (duals of) limits of rings?</p>",
        "id": 260646522,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1636372086
    },
    {
        "content": "<p>Yes.</p>",
        "id": 260646580,
        "sender_full_name": "Zhen Lin Low",
        "timestamp": 1636372139
    },
    {
        "content": "<p>Ah well. The general strategy remains: work out what structure/constructions your functor preserves, find a subcategory which generates CRing under those constructions (I think we're still okay on finite limits? In which case my suggestion could still be a starting point).</p>",
        "id": 260647069,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1636372471
    },
    {
        "content": "<p>No. There is an equivalence relation in the category of affine schemes that has a coequaliser that isn't preserved by the inclusion into the category of schemes. Namely, the standard presentation of the projective line as a gluing of two copies of the affine line.</p>",
        "id": 260647654,
        "sender_full_name": "Zhen Lin Low",
        "timestamp": 1636372858
    },
    {
        "content": "<p>It feels like there's a lot of wishful thinking about this topic. The long and short of it is that the category of schemes is a nasty category containing nasty objects. I tried quite hard to find a uniform way of constructing both the category of schemes and the category of manifolds but I didn't find anything much better than a more or less direct translation of the traditional chart-gluing construction (after eliminating the need to use the scaffolding provided by an underlying locale). You _can_ view it as a free cocompletion, but giving a precise statement requires pages of auxiliary definitions.</p>",
        "id": 260650170,
        "sender_full_name": "Zhen Lin Low",
        "timestamp": 1636374619
    },
    {
        "content": "<p>Except the difference is that with manifolds the site is genuinely small</p>",
        "id": 260651158,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1636375246
    },
    {
        "content": "<p>Whereas with schemes there are all these compromises that need to be made to get a small site</p>",
        "id": 260651179,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1636375264
    },
    {
        "content": "<p>I think that is basically because manifolds are finite-dimensional, whereas schemes can be infinite-dimensional – some of the nasty objects I alluded to above. Anyway, the universal property of this scheme-cocompletion construction is good enough to let you enlarge the site so in some sense the choice of site becomes irrelevant.</p>",
        "id": 260651739,
        "sender_full_name": "Zhen Lin Low",
        "timestamp": 1636375613
    },
    {
        "content": "<p>So does the category of rings have a small condense subcategory?</p>",
        "id": 260656526,
        "sender_full_name": "Fawzi Hreiki",
        "timestamp": 1636378290
    },
    {
        "content": "<p>I don't get what you mean by \"so\" but the answer is no. For any small subcategory you choose you can find a ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"bold\">CRing</mtext><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\textbf{CRing} (A, B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord textbf\">CRing</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span> is empty or trivial for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> in your subcategory: take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> to be a field of cardinality greater than any ring in your chosen subcategory.</p>",
        "id": 260663191,
        "sender_full_name": "Zhen Lin Low",
        "timestamp": 1636381565
    }
]