[
    {
        "content": "<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">f:X \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> be a morphism in a category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> with pullbacks. Then the nLab tells me that there is an induced functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup><mo>:</mo><mi>C</mi><mi mathvariant=\"normal\">/</mi><mi>Y</mi><mo>→</mo><mi>C</mi><mi mathvariant=\"normal\">/</mi><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">f^\\ast:C/Y \\to C/X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>. Intuitively, this \"pulls back\" a morphism to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> along <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> to get a morphism to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>.</p>\n<p>However, this is a bit confusing to me! If there are multiple pullbacks for the same diagram, then does getting a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">f^\\ast</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> require choosing specific pullbacks? That sounds inconvenient!</p>\n<p>If one does need to choose a bunch of specific pullbacks to really specify <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">f^\\ast</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> as a functor, then does it matter which ones are picked?</p>\n<p>Or perhaps one can get away with not really specifying <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">f^\\ast</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>, except up to natural isomorphism? I'm hoping that all possible specific choices of pullbacks lead to naturally isomorphic functors. So then perhaps one can just imagine that some choice of pullbacks was made, without bothering about really making such a choice - and then just to try to set up arguments so that the specific choice of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">f^\\ast</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> never matters?</p>\n<p>Any thoughts appreciated!</p>",
        "id": 541928039,
        "sender_full_name": "David Egolf (he/him)",
        "timestamp": 1759105625
    },
    {
        "content": "<p>This is a well-known issue for functors determined by universal properties.</p>\n<ol>\n<li>Yes, to get a functor in the usual sense requires having a choice of specific pullbacks.</li>\n<li>Many categories with pullbacks come with pre-chosen specified pullbacks, coming from a constructive proof that the category has pullbacks.  For instance, if the foundational theory is ZFC, then in Set you can take the specific pullbacks that are a subset of a cartesian product.</li>\n<li>If for some reason you have a category that has pullbacks but not specified ones, which is rare but can happen, then yes, you need the axiom of choice to create a pullback functor.  This is related to the fact that \"every fully faithful and essentially surjective functor is an equivalence of categories\" is equivalent to the axiom of choice.</li>\n<li>It doesn't matter which pullbacks you pick, up to isomorphism: any other choice will give a naturally isomorphic pullback functor, as you guessed.  So if you are working \"categorically\" with everything only needed to be defined up to isomorphism, then yes, any result you get won't care which choices you made -- except that to have a true functor you need <em>some</em> pullbacks, such as from a concrete construction or the axiom of choice.</li>\n<li>If you want to avoid the axiom of choice and work with categories that don't have specified pullbacks, you can talk about <a href=\"https://ncatlab.org/nlab/show/anafunctors\">[[anafunctors]]</a> instead of functors, which are functors whose values are \"determined only up to unique isomorphism\" <em>without</em> needing to make any specific choice.</li>\n<li>Finally, if you choose HoTT/UF as your foundational theory instead of set theory, and work with univalent categories, then the uniqueness-up-to-isomorphism of pullbacks implies uniqueness-up-to-equality, and therefore there is a unique pullback functor, by the function comprehension principle (unique choice principle).</li>\n</ol>",
        "id": 541928643,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1759106290
    },
    {
        "content": "<p>one more thing around this question: in the abstract case, even if you have specified choices of pullbacks for every morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\"> f </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>, these will not arrange into a 1-functor into Cat, only a 2-functor. You could additionally require that the choice of pull-backs that you get with your category does compose strictly, and get a 1-functor. This is a version of the notion of <a href=\"https://ncatlab.org/nlab/show/split%20fibration\">[[split fibration]]</a></p>",
        "id": 541986979,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1759138589
    },
    {
        "content": "<p>It's worth specifying that by \"2-functor\", you mean \"weak 2-functor\" or \"pseudofunctor\", because (outside the nLab), \"2-functor\" typically refers to the strict notion.</p>",
        "id": 542009189,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1759144674
    },
    {
        "content": "<p>yes, apologies, I always forget the fact that the strict version even exists</p>",
        "id": 542016468,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1759146723
    },
    {
        "content": "<p>Thanks, that's interesting and helpful!</p>\n<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/base.20change.20functor/near/541928643\">said</a>:</p>\n<blockquote>\n<p>If for some reason you have a category that has pullbacks but not specified ones, which is rare but can happen...</p>\n</blockquote>\n<p>I hadn't realized that we'd often have specified pullbacks! For example, I suppose that in any presheaf topos we can get specified pullbacks by computing the pullback \"object-wise\". When evaluating at any object, our diagram of presheaves becomes a diagram of sets, and then we can compute a pullback there using the usual specific pullback for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Set}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Set</span></span></span></span></span>.</p>",
        "id": 542101138,
        "sender_full_name": "David Egolf (he/him)",
        "timestamp": 1759167478
    },
    {
        "content": "<p>Yes, and then in any reflective subcategory of a presheaf category, which is a whole lot of important categories, you can inherit the explicit pullbacks from the big category.</p>",
        "id": 542108940,
        "sender_full_name": "Kevin Carlson",
        "timestamp": 1759169686
    },
    {
        "content": "<p>Basically the only naturally-occurring categories I know of that have pullbacks but not specified ones are \"homotopy categories\", where the morphisms are equivalence classes.  Usually in that case you have to pick representatives of the equivalence classes in order to determine a pullback, while different choices will produce a different pullback object (though, of course, one that is isomorphic in the homotopy category), so the pullbacks aren't specified given only a cospan in the homotopy category.</p>\n<p>This is especially rare because the homotopy categories that arise naturally in homotopy theory don't <em>have</em> pullbacks (although they have weak pullbacks).  But there are a few homotopy-category-like constructions that do end up having pullbacks, such as some constructions of regular or exact completions.</p>",
        "id": 542111452,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1759170439
    }
]