[
    {
        "content": "<p>I came across an interesting counterexample recently that I wanted to hear people’s opinions of.</p>\n<p>Let FinOrd be the category of finite ordered sets, with morphisms as order-preserving maps. Ordinal sum gives us two functors FinOrd^2 -&gt; FinOrd, given by (x, y) -&gt; x + y and (x, y) -&gt; y + x on objects.</p>\n<p>Then, there is a unique isomorphism between x + y and y + x (owing to finiteness). However, this is not a natural transformation! One way to see this is by considering constant maps.</p>\n<p>So, what gives? We’ve made no arbitrary choices (in fact, no choices at all!) obtaining this isomorphism, yet we still have a failure of naturality.</p>\n<p>While I’m here, I may as well give an example of the reverse. The usual proof of “full, faithful and essentially surjective =&gt; part of an equivalence” seems to make judicious use of the axiom of choice - namely, for each object X in the codomain, choosing an object A in the domain and an isomorphism F(A) -&gt; X.</p>\n<p>The isos can be chosen independently for each object in the codomain, so to me this feels like we have naturality with lots of arbitrary choices!</p>",
        "id": 564893583,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1766322329
    },
    {
        "content": "<p>Is it a <a href=\"https://ncatlab.org/nlab/show/core-natural%20transformation\">[[core-natural transformation]]</a>, though?</p>",
        "id": 565077493,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1766442438
    },
    {
        "content": "<p>And yes, ff+eso =&gt; existence of pseudo-inverse is equivalent to some level of AC</p>",
        "id": 565077584,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1766442502
    },
    {
        "content": "<p>At, least, in the ordinary 2-cat of categories and functors and nat transformations. Hence <a href=\"https://ncatlab.org/nlab/show/anafunctors\">[[anafunctors]]</a>.</p>",
        "id": 565077668,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1766442568
    },
    {
        "content": "<p>David is hinting that the meaning of \"no arbitrary choices\" is closer to \"core-natural\", sometimes called \"canonical\", than to \"natural\".</p>",
        "id": 565078091,
        "sender_full_name": "John Baez",
        "timestamp": 1766442877
    },
    {
        "content": "<p>I think the only automorphism of an ordered set here is the identity, so it is a core-natural transformation?</p>\n<p>Since “no arbitrary choices” seems to be neither necessary nor sufficient for naturality, how else should i think about it?</p>",
        "id": 565097553,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1766464336
    },
    {
        "content": "<p>In the case of an equivalence, you end up making arbitrary choices, but since whatever you choose is connected with whatever you didn't choose by a unique isomorphism, in a real sense the choices don't matter.</p>\n<p>That said, \"no arbitrary choices\" was never anything but a heuristic.  The definition of natural transformation is, well, the definition of natural transformation.  If the category and the situation are sufficiently <em>nice</em>, the heuristic applies as stated.</p>\n<p><em>That</em> said, there is often an underlying truth in the heuristic even when it doesn't literally apply.  For example, in the ordinal sum situation, even though no choices were made, there is still something \"arbitrary\" about the isomorphism, as it only holds when the underlying sets are (Kuratowski, I think) finite, and when the ordering is total.  Specifically, it exists because of the pigeonhole principle, and the fact that total orderings of finite sets are unique.  It specifically does not use, nor does it respect, the actual ordering structure on the finite ordered sets, so it is an \"arbitrary\" facet of the structure of finite sets peeking through into the theory of ordered sets.  This is reflected in the lack of naturality.</p>",
        "id": 565106711,
        "sender_full_name": "James Deikun",
        "timestamp": 1766473174
    },
    {
        "content": "<p>Something weird: FinOrd is by no means a symmetric monoidal category but if you take Z[FinOrd], which has the same objects and formal linear combinations of morphisms, it should be a symmetric Ab-enriched monoidal category. I have been meaning to write up a description of the symmetry isomorphism here. Since join of simplicial abelian groups is the Day convolution, the join of simplicial Abelian groups is also symmetric, and since Dold-Kan is strong monoidal for appropriately chosen definitions of \"Dold\" and \"Kan\" this gives the symmetry isomorphism for the tensor product of chain complexes.</p>",
        "id": 565118690,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1766479683
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"934428\">Ruby Khondaker (she/her)</span> has marked this topic as resolved.</p>",
        "id": 565983564,
        "sender_full_name": "Notification Bot",
        "timestamp": 1767279757
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"934428\">@Ruby Khondaker (she/her)</span>  did you find an intuitive characterization for naturality that you preferred to the commonly given one?</p>",
        "id": 566002412,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1767305593
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277352\">Alex Kreitzberg</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/.E2.9C.94.20Naturality.20vs.20.E2.80.9Cno.20arbitrary.20choices.E2.80.9D/near/566002412\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"934428\">Ruby Khondaker (she/her)</span>  did you find an intuitive characterization for naturality that you preferred to the commonly given one?</p>\n</blockquote>\n<p>Yes actually, I think I prefer to view naturality as a categorification of “orthogonality/independence” these days, rather than “no arbitrary choices”. I’d be happy to expand on this if you’d like!</p>",
        "id": 566024054,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767335560
    },
    {
        "content": "<p>Sure! It sounds interesting</p>",
        "id": 566024178,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1767335692
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"934428\">Ruby Khondaker (she/her)</span> has marked this topic as unresolved.</p>",
        "id": 566024269,
        "sender_full_name": "Notification Bot",
        "timestamp": 1767335840
    },
    {
        "content": "<p>So, oftentimes in math you’re dealing with two operations/concepts that are “independent of”/“orthogonal to” each other. You might be aware of breaking up an object’s motion into horizontal and vertical parts, for example, which are literally orthogonal and can be studied separately. And in combinatorics, when you have a bunch of \"independent\" choices, you multiply them together to get the total number of choices. In a naive geometric sense, the choices in the cartesian product are literally \"orthogonal\" to each other!</p>",
        "id": 566024347,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767335929
    },
    {
        "content": "<p>Another example comes from algebra - you have \"internal\" operations given by the algebraic structure, and \"external\" operations given by homomorphisms. These are _defined_ to be orthogonal/independent, in the sense that it doesn't matter in what order you apply the internal/external operations! <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>ϕ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi>ϕ</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\phi(xy) = \\phi(x) \\phi(y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">ϕ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span> expresses that symbolically.</p>\n<p>You can also consider row operations and column operations in linear algebra. These turn out to be orthogonal to/independent of each other, in the sense that it doesn’t matter if you first apply a row operation then a column one, or vice-versa. One way to see this is that row operations correspond to left-multiplication by a fixed matrix, and column operations correspond to right-multiplication by a fixed matrix. So these commute because of associativity! <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mi>M</mi><mo stretchy=\"false\">)</mo><mi>Q</mi><mo>=</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mi>Q</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(PM)Q = P(MQ)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">PM</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">MQ</span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 566024468,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767336084
    },
    {
        "content": "<p>So more generally, you can think of postcomposition and precomposition being orthogonal/independent, because of associativity. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo>∘</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>∘</mo><mi>h</mi><mo>=</mo><mi>f</mi><mo>∘</mo><mo stretchy=\"false\">(</mo><mi>g</mi><mo>∘</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(f \\circ g) \\circ h = f \\circ (g \\circ h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">)</span></span></span></span> can be interpreted as requiring postcomposition and precomposition to commute, essentially.</p>\n<p>One way I like to intuit this is by viewing postcomposition as \"data-changing\" and precomposition as \"shape-changing\". Given a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">f : X \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>, you can do some post-processing with a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>:</mo><mi>Y</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">g : Y \\to Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span> to obtain <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">g \\circ f : X \\to Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span>. You're acting on the actual output data.</p>\n<p>On the other hand, you can precompose with a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mo>:</mo><mi>W</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">h : W \\to X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> to change the shape of your domain, shuffle around values. For each <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">x \\in X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, you \"broadcast\" the value <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> to the fiber <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>h</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">h^{-1}(\\{x\\})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">({</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">})</span></span></span></span>. This gets you <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>∘</mo><mi>h</mi><mo>:</mo><mi>W</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">f \\circ h : W \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>.</p>\n<p>So, associativity tells you that \"data-changing\" operations necessarily commute/are orthogonal to \"shape-changing\" operations! For example, if you view a list of length 3 as a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">3 \\to X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, then mapping over the list is postcomposition with a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>, so \"data-changing\", while reversing the list is precomposition with a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn><mo>→</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3 \\to 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>, so \"shape-changing\".</p>\n<p>In general, functorial actions tend to be \"data-changing\", so the components of natural transformations end up being \"shape-changing\" in order to be orthogonal/independent of the functorial maps.</p>",
        "id": 566024733,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767336423
    },
    {
        "content": "<p>Incidentally, there's a sense in which postcomposition and precomposition are \"orthogonal complements\". Suppose you have a map that's orthogonal to precomposition, in the sense that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo>∘</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>η</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>∘</mo><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">\\eta(f \\circ g) = \\eta(f) \\circ g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span>. Then it must be postcomposition by a fixed map, since <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>η</mi><mo stretchy=\"false\">(</mo><mtext>id</mtext><mo>∘</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>η</mi><mo stretchy=\"false\">(</mo><mtext>id</mtext><mo stretchy=\"false\">)</mo><mo>∘</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">\\eta(f) = \\eta(\\text{id} \\circ f) = \\eta(\\text{id}) \\circ f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">id</span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">id</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>. Similarly with the other direction - a map that's orthogonal to postcomposition must take the form of a precomposition! If you squint your eyes a little, this is essentially the proof of the yoneda lemma.</p>",
        "id": 566024884,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767336583
    },
    {
        "content": "<p>You can make this orthogonality/independence intuition a little more precise by appealing to the <strong>bifunctor lemma</strong>:</p>\n<p><a href=\"/user_uploads/21317/Tqr8c43PmRyUaiF441cMx1rf/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/Tqr8c43PmRyUaiF441cMx1rf/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"566x393\" src=\"/user_uploads/thumbnail/21317/Tqr8c43PmRyUaiF441cMx1rf/image.png/840x560.webp\"></a></div><p>(Taken from Awodey's book). The idea is that morphisms of C are \"orthogonal to/independent of\" morphisms of D in the product category C x D, so specifying a bifunctor is equivalent to specifying a separately functorial map whose functorial actions commute.</p>\n<p>For example, since precomposition and postcomposition are orthogonal, you immediately get a bifunctor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Hom</mtext><mo>:</mo><msup><mi>C</mi><mtext>op</mtext></msup><mo>×</mo><mi>C</mi><mo>→</mo><mrow><mi mathvariant=\"bold\">S</mi><mi mathvariant=\"bold\">e</mi><mi mathvariant=\"bold\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\text{Hom} : C^\\text{op} \\times C \\to \\mathbf{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord\">Hom</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord text mtight\"><span class=\"mord mtight\">op</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Set</span></span></span></span></span> for every category. In a monoidal category, you have a tensor product bifunctor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mi>C</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C \\times C \\to C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> because, in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A \\otimes B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, acting with morphisms on the first argument is completely independent of acting with morphisms on the second argument! So you can apply them \"in parallel\" without issue.</p>\n<p>This generalises to the <strong>multifunctor lemma</strong>, which says that, to define a functor out of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub><mo>×</mo><mo>⋯</mo><mo>×</mo><msub><mi>C</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">C_1 \\times \\dots \\times C_n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, it suffices to ensure it's functorial in each argument, and that the functorial actions pairwise commute. You can think of each factor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">C_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> as defining a new orthogonal \"axis\" that the multifunctor must act along!</p>",
        "id": 566025255,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767336956
    },
    {
        "content": "<p>Finally, this relates to naturality by observing that natural transformations correspond to functors out of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">C \\times 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>. If you have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mo>:</mo><mi>C</mi><mo>×</mo><mn>2</mn><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">H : C \\times 2 \\to D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mo stretchy=\"false\">(</mo><mo>−</mo><mo separator=\"true\">,</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">H(-, 0) : C \\to D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mo stretchy=\"false\">(</mo><mo>−</mo><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">H(-, 1) : C \\to D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> are the functors your natural transformation is between, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo separator=\"true\">,</mo><mo>−</mo><mo stretchy=\"false\">)</mo><mo>:</mo><mn>2</mn><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">H(c, -) : 2 \\to D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> are the components of your natural transformation. Applying the bifunctor lemma then gets you the naturality square!</p>\n<p>So I like to think of naturality as a shadow of bifunctoriality/multifunctoriality, where you have many different functorial actions that are \"pairwise orthogonal/independent\". Thus, naturality categorifies the familiar notion of orthogonality/independence.</p>\n<p>I've found this more helpful than \"no arbitrary choices\":</p>\n<ul>\n<li>In the FinOrd example, the issue is that the canonical iso <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>⊕</mo><mi>y</mi><mo>→</mo><mi>y</mi><mo>⊕</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x \\oplus y \\to y \\oplus x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> is not \"orthogonal\" to order-preserving maps acting on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span>, since it uses the total order on the finite set in an essential way.</li>\n<li>For finite categories, \"no arbitrary choices\" doesn't tend to work as well for natural transformations. But, both in a naive geometric way and in the conceptual sense I've laid out, natural maps are necessarily \"orthogonal\" to whatever functorial action you've chosen! So this extends seamlessly to categories of all sorts of sizes.</li>\n<li>For the equivalence example I laid out at the start of this thread, it's still true that the way you define the inverse functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> is in such a way to be \"orthogonal\" to the isomorphisms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>G</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A \\to F(G(A))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">))</span></span></span></span> that you've chosen. While you do have freedom to make some arbitrary choices in choosing these isomorphisms, and so arbitrary choices in the functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>, these sets of choices are necessarily \"orthogonal\" to each other!</li>\n<li>Extending the previous example, the reason why naturality often manifests as \"no arbitrary choices\" is that it has to be orthogonal to your functorial actions - and these are often defined in a canonical way. If you introduce some arbitrary choices in the definitions of your functors, you necessarily obtain some freedom in the choices you can make for your natural transformation. But nevertheless, these sets of choices must remain \"orthogonal\" to each other, in order to obtain the naturality squares. So naturality is really orthogonal to functorial actions, and it's only because most functors are defined \"without arbitrary choices\" that the natural maps end up being defined with \"no arbitrary choices\".</li>\n</ul>\n<p>So, what do you think <span class=\"user-mention\" data-user-id=\"277352\">@Alex Kreitzberg</span> ?</p>",
        "id": 566026025,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767337563
    },
    {
        "content": "<p>Very clever! Thank you for sharing. I have to think a bit more about some of your examples and arguments but my first impression is it seems correct and insightful.</p>",
        "id": 566026833,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1767338432
    },
    {
        "content": "<p>Perhaps I’m a little geometrically biased, but one thing I enjoy about this framing is that it lets me use existing intuition from linear algebra to think about naturality! I’ve already caught myself making statements like “the maps in a cone are orthogonal to maps within the diagram” as a way to encapsulate the naturality conditions present for limits.</p>\n<p>Plus the naturality squares already have the maps being visually “orthogonal” to the functor applications, so it’s easy for me to remember this intuition whenever I see commutative diagrams.</p>",
        "id": 566034596,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767344251
    },
    {
        "content": "<p>A silly thing I realised recently is that, in the product category C x D, morphisms of the form “(f, id)” are indeed orthogonal to morphisms of the form “(id, g)” for the pre-existing lifting property sense of morphism orthogonality. So at least in this case, the terminology is consistent!</p>",
        "id": 566159808,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767456580
    },
    {
        "content": "<p>To try and understand your ideas better, I want to defend the \"no arbitrary choice\" intuition for naturality slightly. </p>\n<p>You can prove naturality is automatically satisfied by formal polymorphic function definitions satisfying certain conditions in some programming languages. </p>\n<p>If naturality broadly failed for a given programming language's polymorphic functions I'd interpret that as a weakness of the programming language, not a weakness in the definition of naturality.</p>\n<p>So in a sufficiently nice language a given formula being well defined over <em>all</em> objects gives the formula lots of nice features - including naturality whenever that's possible. This is supposed to be unsurprising.</p>\n<p>Maybe I'll revisit \"Theorems for free\" from this point of view you just introduced. Your intuition seems to be apriori about individual commutative squares, indeed commutative structures often can be represented as a product of factors. But then the bifunctor lemma shows, like you said, that categorifying this involves resolving many squares, all the arrows of the \"orthogonal\" categories must separately commute.</p>\n<p>I think your idea is good but I'd like this relationship with logic and \"the same formula everywhere\" clarified. Which I'll probably do in my own time. Maybe you already addressed this by emphasizing canonically defined functors imply canonically defined natural transformations, but my feeling is there may still be something left worth thinking about.</p>\n<p>Thank you for the interesting perspective, I understand commutative squares and naturality better.</p>",
        "id": 566195164,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1767499011
    },
    {
        "content": "<p>Another thought</p>\n<p>A natural transformation is supposed to be the natural notion of an arrow between functors. I wonder if your interpretation is working because Cat is cartesian closed.</p>",
        "id": 566195478,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1767499333
    },
    {
        "content": "<p>Yes that’s fair - for “polymorphism implies naturality”, I like to think of it as follows. A parametrically polymorphic map FX -&gt; GX cannot depend on the “data” of the type X, and so it must necessarily be “shape-changing”. But this is naturally orthogonal to data-changing maps, which are what the functorial actions are! Hence you get naturality for free.</p>\n<p>And yes, functors C x 2 -&gt; D naturally correspond to functors 2 -&gt; [C, D], i.e. arrows in the functor category [C, D]. Thus you obtain the familiar “a natural transformation is an arrow between functors”.</p>\n<p>You also have this being equivalent to functors C -&gt; [2, D], which you can view as “a natural transformation is an arrow-valued functor”. Sometimes I prefer this perspective because of the way that natural transformations manifest as “a coherent family of arrows” in practice.</p>",
        "id": 566199653,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767505336
    },
    {
        "content": "<p>Hah! That last point of view is new to me! But I find it immediately evocative to think about, thanks for sharing.</p>",
        "id": 566200097,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1767505882
    },
    {
        "content": "<p>As the recent thread with Mike Shulman showed, that all polymorphic functions between definable functors are natural is not a property of System F (its term model), but only of the parametric models of system F (which the term model is not).  So perhaps not 'free', but 'cheap' (since parametric models are well studied)</p>",
        "id": 566208771,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1767517235
    },
    {
        "content": "<p>Yes that thread was another reason I tried looking for ways to think about naturality other than “no arbitrary choices”. I also used to think of naturality as a way of encoding \"polymorphism\", but there were too many situations (FinOrd, finite categories) that the intuition didn't quite work for. But so far \"orthogonality/independence\" has resolved those issues for me!</p>",
        "id": 566214001,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767523080
    },
    {
        "content": "<p>Ahh okay, you mean the message here (<a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/525439963\">https://categorytheory.zulipchat.com/#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/525439963</a>)? Thanks for calling that out.</p>",
        "id": 566233318,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1767544032
    },
    {
        "content": "<p>Wow, that's a nasty bit of confusion. I'm now suspicious similar mistakes are made by category theorists in more informal settings. Which I guess is what motivated Ruby to ask the question.</p>",
        "id": 566236410,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1767547379
    },
    {
        "content": "<p>Yeah that’s accurate, it was precisely because I’d grown dissatisfied with the “no arbitrary choices” and “polymorphism” intuition.</p>",
        "id": 566236439,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767547428
    },
    {
        "content": "<p>I guess what I liked about (the now treacherous in retrospect) polymorphism intuition, is it seemed \"self contained\" in the sense that it was an intuition about maps between functors.</p>\n<p>Your, as far as I can tell unproblematic, intuition passes via an adjunction from products in Cat to the exponentials.</p>\n<p>And I'm just wondering if there's a \"direct\" intuition for exponential objects in Cat one can then see as satisfying the description you just laid out, because of the adjunction. But maybe I'm being pedantic.</p>",
        "id": 566237059,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1767548136
    },
    {
        "content": "<p>I think Awodey talks about this in his textbook, where you can imagine determining the structure of the category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>D</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[C, D]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">]</span></span></span></span> via probing it with “shape” categories (such as the ordinals <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>) to determine objects, morphisms and composition respectively, and then using the universal property of the exponential to reduce this to functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mi>n</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C \\times n \\to D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>.</p>",
        "id": 566237589,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767548698
    },
    {
        "content": "<p><a href=\"/user_uploads/21317/iBTONO0wmTXKxiIeMN3s5oj2/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/iBTONO0wmTXKxiIeMN3s5oj2/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"487x744\" src=\"/user_uploads/thumbnail/21317/iBTONO0wmTXKxiIeMN3s5oj2/image.png/840x560.webp\"></a></div><p>Yes, this is what I'm referring to. I'm not sure if this is the sort of thing you were looking for? Essentially the argument is that you can already determine the nerve of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>D</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[C, D]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">]</span></span></span></span> just from knowing product categories - functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>→</mo><mo stretchy=\"false\">[</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>D</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">n \\to [C, D]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">]</span></span></span></span> have to correspond to functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mi>n</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C \\times n \\to D</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> because of the desired universal property.</p>",
        "id": 566237715,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767548827
    },
    {
        "content": "<p>I've used this approach before to give a slick proof of interchange - you have functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mn>3</mn><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C \\times 3 \\to D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo>×</mo><mn>3</mn><mo>→</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">D \\times 3 \\to E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span>, which combine to a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mn>3</mn><mo>×</mo><mn>3</mn><mo>→</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">C \\times 3 \\times 3 \\to E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span>. Then since products of preorders are preorders, you get a unique \"diagonal\" map in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3 \\times 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>. This is exactly what expresses the commutativity of horizontal and vertical composition of natural transformations!</p>\n<p>To spell that out in a bit more detail - functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mn>2</mn><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C \\times 2 \\to D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> correspond to natural transformations, and functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mn>3</mn><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C \\times 3 \\to D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> then correspond to vertically composable pairs of natural transformations. On the other hand, the way <em>horizontal</em> composition works is by composing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mn>2</mn><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C \\times 2 \\to D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo>×</mo><mn>2</mn><mo>→</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">D \\times 2 \\to E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> to get <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mn>2</mn><mo>×</mo><mn>2</mn><mo>→</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">C \\times 2 \\times 2 \\to E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span>, and then using the unique \"diagonal\" map in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2 \\times 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> to obtain a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mn>2</mn><mo>→</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">C \\times 2 \\to E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span>.</p>",
        "id": 566238120,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767549193
    },
    {
        "content": "<p>One thing I like about this approach is that the category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3 \\times 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> automatically visualises all the relationships you have between the various functors and natural transformations involved in the proof of interchange. And the proof really just reduces to \"products of preorders are preorders\", which I find conceptually satisfying.</p>",
        "id": 566238366,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767549440
    },
    {
        "content": "<p>Yeah looking at your and Awodey's arguments I guess the case can be made that the usual definitions and arguments involving naturality are worked out in the product of Cat anyway. There's probably no issue.</p>\n<p>It's always tough when talking about intuitions, I'm never quite sure I'm \"done\" or \"on to something\" until the intuition is captured.</p>",
        "id": 566238477,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1767549513
    },
    {
        "content": "<p>Oh of course, I think it would be silly of me to view orthogonality/independence as the \"One True Perspective\" on naturality. Mostly I just try to interrogate and reform my existing intuitions when I start feeling uncomfortable around them.</p>",
        "id": 566238773,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767549642
    },
    {
        "content": "<p>It's worth saying that you have to be a little more careful when trying to generalise this to higher categories. To get the correct definitions of natural transformations and their higher-dimensional analogs, you really need to take a \"tensor product\" of your categories rather than just a cartesian product. The nlab entry on the <a href=\"https://ncatlab.org/nlab/show/Gray+tensor+product\">Gray tensor product</a> is a good starting point. It might also be good to ponder why this issue doesn't show up in 1-category theory.</p>",
        "id": 566239345,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767550069
    },
    {
        "content": "<p>I also feel like I should clarify that I'm not an expert on this! I've cobbled together observations I've made through learning category theory on my own, and sometimes I take on more of an authoritative tone than is warranted...</p>",
        "id": 566241724,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767552262
    },
    {
        "content": "<p>Your tone is fine, it makes the writing easier to understand.</p>",
        "id": 566241820,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1767552356
    },
    {
        "content": "<p>The more I think about this, the more I think my issue may be I don't understand <a href=\"https://ncatlab.org/nlab/show/closed+category\">[[closed categories]]</a> as much as I would like. Maybe I'll start a new thread on this.</p>",
        "id": 566246576,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1767556891
    },
    {
        "content": "<p>I'm also reminded of this apparently apocryphal conversation Riehl cited:</p>\n<p><strong>Kan</strong>:</p>\n<blockquote>\n<p>You have explained how the tensor product can be defined in terms of the hom functor. Can the hom instead be defined in terms of the tensor product?</p>\n</blockquote>\n<p><strong>Eilenberg</strong>:</p>\n<blockquote>\n<p>No, of course not. That's absurd.</p>\n</blockquote>\n<p>I bet folks bounce back and force between which of the two sides of this adjunction is \"easiest\" depending on the category. Regardless I find it funny I seem to find the opposite direction from Eilenberg more confusing.</p>",
        "id": 566247582,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1767558097
    },
    {
        "content": "<p>Oh yes I’ve heard of this exchange before - so you’re saying you find defining tensor product from Hom the weirder direction? Usually I appeal to vector spaces (or R-modules more generally) to get intuition for that.</p>",
        "id": 566247734,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1767558214
    },
    {
        "content": "<p>Yeah I was thinking \"I know what a matrix is independent of the tensor product\", I'm curious what the analog would look like, if possible, for natural transformations.</p>",
        "id": 566248231,
        "sender_full_name": "Alex Kreitzberg",
        "timestamp": 1767558626
    },
    {
        "content": "<p>Another topic:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"934428\">Ruby Khondaker (she/her)</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Naturality.20vs.20.E2.80.9Cno.20arbitrary.20choices.E2.80.9D/near/566024347\">said</a>:</p>\n<blockquote>\n<p>So, oftentimes in math you’re dealing with two operations/concepts that are “independent of”/“orthogonal to” each other. You might be aware of breaking up an object’s motion into horizontal and vertical parts, for example, which are literally orthogonal and can be studied separately. And in combinatorics, when you have a bunch of \"independent\" choices, you multiply them together to get the total number of choices. In a naive geometric sense, the choices in the Cartesian product are literally \"orthogonal\" to each other!</p>\n</blockquote>\n<p>When I read this, I realized that the common representation of commuting squares is actually composed of horizontal and vertical arrows. If you stack them together you would get a coordinate system.</p>\n<p>And the naturality condition would say  that moving some steps in the \"data\" dimension (i.e. by applying functorial operations) and then moving in the  \"shape\" dimension ( by applying natural transformation) is the same as moving in the \"shape\" dimension first and then in \"data\" dimension second.</p>",
        "id": 573811694,
        "sender_full_name": "Jencel Panic",
        "timestamp": 1771009303
    },
    {
        "content": "<p>This got me thinking if every morphism can be decomposed to a composition between a functorial operation and a natural transformation (as every vector can be described with horizontal and vertical coordinates)</p>",
        "id": 573812896,
        "sender_full_name": "Jencel Panic",
        "timestamp": 1771009817
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"612694\">Jencel Panic</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Naturality.20vs.20.E2.80.9Cno.20arbitrary.20choices.E2.80.9D/near/573812896\">said</a>:</p>\n<blockquote>\n<p>This got me thinking if every morphism can be decomposed to a composition between a functorial operation and a natural transformation (as every vector can be described with horizontal and vertical coordinates)</p>\n</blockquote>\n<p>Well there’s a very nice (imo) way to think about this in terms of Lawvere’s philosophy of generalised elements.</p>\n<p>Natural transformations are equivalently functors out of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">C \\times 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>, so you can view <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">C \\times 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> as the “shape” which picks out natural transformations. In a sense, it’s the free natural transformation.</p>\n<p>And in this category, you do indeed have a “coordinate system”, given by morphisms of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> and morphisms of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>.</p>\n<p>In fact, it’s probably easier to see this in a generic product category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C \\times D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>. The key equation is:</p>\n<blockquote>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>f</mi><mo separator=\"true\">,</mo><mtext>id</mtext><mo stretchy=\"false\">)</mo><mo>∘</mo><mo stretchy=\"false\">(</mo><mtext>id</mtext><mo separator=\"true\">,</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mtext>id</mtext><mo separator=\"true\">,</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>∘</mo><mo stretchy=\"false\">(</mo><mi>f</mi><mo separator=\"true\">,</mo><mtext>id</mtext><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(f, g) = (f, \\text{id}) \\circ (\\text{id}, g) = (\\text{id}, g) \\circ (f, \\text{id})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord\">id</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">id</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">id</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord\">id</span></span><span class=\"mclose\">)</span></span></span></span></p>\n</blockquote>\n<p>So this is a decomposition of a generic morphism into its coordinate components. Indeed, this equation is what implies the bifunctor lemma, since it says that functors out of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C \\times D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> can be defined purely by their action on each of the orthogonal “axes” defined by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>, so long as the commutative squares are preserved.</p>",
        "id": 573813723,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1771010229
    },
    {
        "content": "<p>Interesting. So we can view any functor from a product category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">C \\times X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> as a collection of functors from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> and natural transformations between them e.g. a vertical composition of two natural transformations is equivalent to a functor from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">C \\times 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> and so on.</p>",
        "id": 573866264,
        "sender_full_name": "Jencel Panic",
        "timestamp": 1771046026
    },
    {
        "content": "<p>Yes exactly. This is why these days i prefer to think of naturality as a shadow of bifunctoriality/multifunctoriality.</p>",
        "id": 573880228,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1771060666
    },
    {
        "content": "<p>You’re also just using the Cartesian closed structure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Cat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Cat</span></span></span></span></span>. Functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mi>X</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C \\times X \\to D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> correspond to functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mo stretchy=\"false\">[</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>D</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">X \\to [C, D]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">]</span></span></span></span>. Which is a collection of functors from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> and natural transformations between them! In this case, the natural transformations satisfy additional compatibility conditions encoded by the composition law in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>.</p>",
        "id": 573884469,
        "sender_full_name": "Ruby Khondaker (she/her)",
        "timestamp": 1771064977
    }
]