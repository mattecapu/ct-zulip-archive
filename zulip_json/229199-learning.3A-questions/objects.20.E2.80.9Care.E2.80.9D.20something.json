[
    {
        "content": "<p>I have been thinking about categories more as abstract objects in their own right, where you do not need to interpret their objects and arrows as some underlying mathematical objects like sets, topologies, etc.</p>\n<p>This has made me wonder if it is mathematically rigorous to even say that the objects and arrows of a category “are” anything, other than, abstractly, something called “objects” and “arrows”.</p>\n<p>If we say that the arrows are actually group homomorphisms, for example, couldn’t we have some technical apparatus declaring like, a correspondence, first, between objects in group theory, and the abstract elements of a category in category theory, before we go ahead and start to use concepts in category theory to prove, or describe, things in group theory?</p>",
        "id": 383326711,
        "sender_full_name": "Julius",
        "timestamp": 1691594601
    },
    {
        "content": "<p>You can prove theorems about abstract categories where you don't say what the objects and morphisms are, but you can also start in some framework (like traditional set theory, or type theory, etc.) and define (say) \"groups\" and \"homomorphisms\" between them, and then prove they form a category, and then prove theorems about that category, where you get to use properties of groups and homomorphisms.   Both approaches are extremely common, and they interact nicely.</p>",
        "id": 383341148,
        "sender_full_name": "John Baez",
        "timestamp": 1691597068
    },
    {
        "content": "<p>Ok, thanks.<br>\nThis is sort of interesting, <a href=\"https://mathoverflow.net/questions/82526/does-there-exist-a-name-for-a-nonassociative-category-without-identities\">https://mathoverflow.net/questions/82526/does-there-exist-a-name-for-a-nonassociative-category-without-identities</a> , wondering why associativity is so important, if useful structures only emerge with it present. But here it seems there is a whole theory of non-associative categories.</p>",
        "id": 383375663,
        "sender_full_name": "Julius",
        "timestamp": 1691603658
    },
    {
        "content": "<p>Well, I don't know that it's such a big theory. I guess about the same size theory as for <a href=\"https://ncatlab.org/nlab/show/magma\">magmas</a>, which are \"structures without properties\", hence useful for some purposes. </p>\n<p>Category theory is much bigger, and associativity and identities really are important. One way (just one way) of thinking about associativity is that it guarantees that hom-functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mo>−</mo><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mo>−</mo><mo separator=\"true\">,</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\hom(A, -), \\hom(-, A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">hom</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">hom</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> actually are functors (preserve composition). And associativity together with units are crucial to the proof of the Yoneda lemma, in all of its glory and manifestations. It is to my mind is <em>the</em> most fundamental result of category theory (although it takes time to appreciate why it's so fundamental: it brings together many themes surrounding universal properties and representable functors and adjunctions and so much more).</p>",
        "id": 383382483,
        "sender_full_name": "Todd Trimble",
        "timestamp": 1691605231
    },
    {
        "content": "<p>Another perspective regarding whether objects \"are \"something: <br>\nAs far as I understand, the data describing an object in a category only has impact on the mathematical structure of that category if it has some impact on what morphisms exist in that category and how they compose. For example, I could define a category where the objects are groups, and the morphisms are all functions between the underlying sets of these groups. This category is a lot like a category where the objects are sets and the morphisms are functions between them. If, however, we require these functions between groups to preserve the group structure (so the functions describe group homomorphisms), then the resulting category becomes very different from the category of sets with functions between them.</p>\n<p>I think this perspective is especially relevant when trying to think about how to apply categories. I suspect it's probably good to call an object in some category by some intuitive name relating to an application, and to associate some application-relevant data to that object. However, unless this data has some impact on the morphisms of the category being used to model an application, that application data is not really being reflected in the mathematical structure of the category.</p>",
        "id": 383391654,
        "sender_full_name": "David Egolf",
        "timestamp": 1691607424
    },
    {
        "content": "<p>There's nothing particularly special about category theory here: <em>all</em> structures in mathematics can be studied either abstractly, where the constituents of the structure have no known internal identity other than their \"places\" in the structure, or concretely using specific examples where the elements have other identity.  For instance, in an abstract group the elements aren't assumed to \"be\" anything other than \"the elements of the underlying set of the group\", but in a concrete group these elements may be numbers, matrices, permutations, etc.</p>",
        "id": 383392400,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1691607607
    },
    {
        "content": "<p>Yes, organizing transformations of some set, vector space, etc. into a group and saying that the abstract group is what really matters is a distillation which involves a choice of opinion about what \"really matters\", much as organizing some structured sets and structure-preserving maps into a category and saying the abstract category is what \"really matters\" - in fact it's a special case.</p>",
        "id": 383431514,
        "sender_full_name": "John Baez",
        "timestamp": 1691622062
    },
    {
        "content": "<p>Luckily, category theory has ways of recording the concreteness of such situations if we want to: we're not stuck in abstractness.   See <a href=\"https://ncatlab.org/nlab/show/concrete%20category\">[[concrete category]]</a>, for example.</p>",
        "id": 383431731,
        "sender_full_name": "John Baez",
        "timestamp": 1691622172
    },
    {
        "content": "<p>Thanks, those are the kinds of perspectives I was hoping to hear. I now have an open-ended beginner’s question kind of related to the above.</p>\n<p>I was thinking about how perhaps the defining conditions on a functor could be deduced just by the notion that it is supposed to be a “morphism between categories”. But then I asked myself, what properties would I like functors to fulfill, such that their defining conditions (ie, preserving identities, and composition of arrows), manifest those properties?</p>\n<p>I have been thinking about how ultimately, the arrows in a category don’t need to “act” on the objects in any way, they can be meaningless token objects which are simply defined as having one object as a domain and one object for a codomain. So, I think we could define a meaningless “category of categories” where the objects are categories but the arrows are not normal functors, they are just, I don’t know, assignments of objects, with no special conditions on the arrows.</p>\n<p>So, how might we realize why we would want the definition of a functor to be what it is, if we were trying to define a “category of categories”? <em>Why</em> do we want composition of arrows preserved, by the morphisms? </p>\n<p>Thank you</p>",
        "id": 384084998,
        "sender_full_name": "Julius",
        "timestamp": 1691785226
    },
    {
        "content": "<p>I think part of the answer was already given in this:</p>\n<blockquote>\n<p>One way (just one way) of thinking about associativity is that it guarantees that hom-functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mo>−</mo><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mo>−</mo><mo separator=\"true\">,</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\hom(A, -), \\hom(-, A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">hom</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">hom</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> actually are functors (preserve composition). And associativity together with units are crucial to the proof of the Yoneda lemma</p>\n</blockquote>\n<p>But I need to think about it some more.</p>",
        "id": 384085552,
        "sender_full_name": "Julius",
        "timestamp": 1691785402
    },
    {
        "content": "<p>There’s nothing forcing you to want composition of arrows to be preserved. But there’s a long history in abstract algebra of focusing on homomorphisms, ie the maps that preserve every operation present in your theory. A functor is the immediate notion of homomorphism for categories in this sense. Furthermore, a mapping on objects and morphisms respecting source and target but not necessarily composition is just a homomorphism of the underlying graphs, which makes it unnatural to claim you’re describing a category of <em>categories</em> at all.</p>",
        "id": 384085956,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1691785525
    },
    {
        "content": "<p>Right, you can define a category by taking the objects to be anything you want and the morphisms to be anything you want.  You could define a category whose objects are groups and whose morphisms are functions between the underlying sets of groups, not necessarily respecting the group operations.  And similarly when the objects are categories.</p>",
        "id": 384096063,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1691789016
    },
    {
        "content": "<p>That said, there are precise senses in which functors are the \"canonical\" morphisms between categories.  For instance, there is an <a href=\"https://ncatlab.org/nlab/show/essentially%20algebraic%20theory\">[[essentially algebraic theory]]</a> whose models are categories, and whose homomorphisms of models are functors.</p>",
        "id": 384096227,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1691789066
    },
    {
        "content": "<p>Just as there is an <a href=\"https://ncatlab.org/nlab/show/algebraic%20theory\">[[algebraic theory]]</a> whose models are groups, and whose homomorphisms are group homomorphisms.</p>",
        "id": 384096281,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1691789096
    },
    {
        "content": "<p>I find it helpful to think of functors as \"sending true equations to true equations\":</p>\n<ul>\n<li>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><mi>g</mi><mo>∘</mo><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">f = g \\circ h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span> is true in some category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>∘</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(f) = F(g) \\circ F(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">)</span></span></span></span> is true as well, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> is a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">F: C \\to D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>.</li>\n<li>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> be a function that takes in a morphism and returns its source object. Then if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">s(f) = x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>, it is true that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo stretchy=\"false\">(</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">s(F(f)) = F(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>. Similarly, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> is a function that takes in a morphism and returns its target object, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">t(f) = y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo stretchy=\"false\">(</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">t(F(f)) = F(y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span>.</li>\n<li>Finally, let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">e</span></span></span></span> be a function that takes in an object and returns its identity morphism. Then if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mn>1</mn><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">e(x) = 1_x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7944em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo stretchy=\"false\">(</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mi>F</mi><mo stretchy=\"false\">(</mo><msub><mn>1</mn><mi>x</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">e(F(x)) = F(1_x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>.</li>\n</ul>\n<p>From this perspective, if you have a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">F: C \\to D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>, and you know some true equations in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>, then you can use the functor to get true equations in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>. So, functors can be used as a tool to take things that we know in one category, and figure out new (but related) things in a different category.</p>\n<p>Broadly, in any category, I believe we want the internal structure of our objects to have an impact on which morphisms exist and how they compose. So, in a category of categories, we want the morphisms to be closely linked to the internal structure of the categories they are mapping between.</p>",
        "id": 384100294,
        "sender_full_name": "David Egolf",
        "timestamp": 1691790858
    },
    {
        "content": "<p>There's a geometric / higher categorical interpretation of that too.  You can think of a category as a certain kind of 2-dimensional \"cell complex\" with vertices being objects, edges being morphisms, and 2-dimensional faces being commutative polygons.  Then a functor is just a \"cellular map\" that takes vertices to vertices, edges to edges, and faces to faces, the last being a geometric version of \"sending true equations to true equations\".</p>",
        "id": 384117946,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1691799907
    },
    {
        "content": "<p>There's also the concept of a \"<a href=\"https://ncatlab.org/nlab/show/walking+structure\">walking</a>\" category, which encodes the axioms of a particular type of object, such as a groups, graphs, etc. Functors from these walking categories into an abstract category C are called \"___ objects in C\" , for example functors from the walking graph category into C are \"graph objects in C\". Replacing C with Set typically returns the original concept, i.e. Fun(graph, Set) = Graph, the category of graphs. However, you have to be careful, sometimes the original type of object requires that you change the <em>ambient</em> categorical structure to re-obtain that type of object. That is, instead of functors, you might need to consider functors preserving monoidal products, or certain limits, or whatever, this is typically referred to as a \"doctrine\". For example there is a walking <em>monoidal</em> category encoding the axioms of a group so that MonoidalFun(group, Set) = Group, the category of groups. So then we can extend the notion of group to other contexts, for example MonoidalFun(group, Graph) = group object in Graph = Graphs with a multiplication satisfying the group axioms. </p>\n<p>In this way, we can loosely consider objects of Fun&ast;( W, C) as objects of type W in a category C. Even though we may not know exactly what the objects of C are, the objects of Fun&ast;( W, C) satisfy the categorified axioms that W encodes.  (here Fun&ast; may refer to extra ambient categorical structure)</p>\n<p>Now, if you were to find an equivalence (or weaker) of your original category C <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≅</mo></mrow><annotation encoding=\"application/x-tex\">\\cong</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.589em;\"></span><span class=\"mrel\">≅</span></span></span></span>  Fun&ast;( W, D), you might be on your way to saying that the objects of C \"are\" something.</p>",
        "id": 386528792,
        "sender_full_name": "Noah Chrein",
        "timestamp": 1692681211
    },
    {
        "content": "<p>don't you need the category to be cartesian for groups?</p>",
        "id": 386613936,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1692712345
    },
    {
        "content": "<p>You can capture the category of groups either as group objects in Set (a limit notion) or as Hopf algebras in Set (a monoidal notion), perhaps this was meant?</p>",
        "id": 386617979,
        "sender_full_name": "Martti Karvonen",
        "timestamp": 1692713263
    },
    {
        "content": "<p>A cartesian category is monoidal, though...</p>",
        "id": 386701190,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1692741299
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276422\">David Michael Roberts</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/objects.20.E2.80.9Care.E2.80.9D.20something/near/386701190\">said</a>:</p>\n<blockquote>\n<p>A cartesian category is monoidal, though...</p>\n</blockquote>\n<p>it is, but don't you need cartesianness to state that the inverse is actually an inverse? or are duplication and deletion maps preserved by monoidal functors and thus only the walking category needs to be cartesian? it'd help to have a reference on this</p>",
        "id": 386784289,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1692776947
    },
    {
        "content": "<p>Monoidal functors send the duplication and deletion morphisms to <em>some</em> morphisms, of course, and these obey the same equations (duplication followed by deleting either argument is the identity).  But the best way to say this is that:</p>\n<ul>\n<li>\n<p>in a cartesian category the duplication and deletion maps make every object into a <a href=\"https://ncatlab.org/nlab/show/comonoid\">[[comonoid]]</a>,</p>\n</li>\n<li>\n<p>in a cartesian category every object becomes a <a href=\"https://ncatlab.org/nlab/show/comonoid\">[[comonoid]]</a> in a unique way,</p>\n</li>\n<li>\n<p>monoidal functors send comonoids to comonoids.</p>\n</li>\n</ul>",
        "id": 386786631,
        "sender_full_name": "John Baez",
        "timestamp": 1692777923
    },
    {
        "content": "<p>Also, everything I said would remain true if we replaced \"comonoid\" by \"cocommutative comonoid\" and \"monoidal\" by \"symmetric monoidal\".</p>",
        "id": 386786863,
        "sender_full_name": "John Baez",
        "timestamp": 1692778008
    },
    {
        "content": "<p>All this should be in the nLab under <a href=\"https://ncatlab.org/nlab/show/cartesian%20monoidal%20category\">[[cartesian monoidal category]]</a>.</p>\n<p>But it's not... not quite.</p>",
        "id": 386787031,
        "sender_full_name": "John Baez",
        "timestamp": 1692778068
    },
    {
        "content": "<p>I added some more.</p>",
        "id": 386788537,
        "sender_full_name": "John Baez",
        "timestamp": 1692778630
    },
    {
        "content": "<p>To repeat what <span class=\"user-mention\" data-user-id=\"277285\">@Martti Karvonen</span> said: while we can define a group object in any cartesian category, we can define a <a href=\"https://ncatlab.org/nlab/show/Hopf%20object\">[[Hopf object]]</a> in any symmetric monoidal category, and this is a very useful generalization.  Just as cartesian monoidal functors send group objects to group objects, symmetric monoidal functors send Hopf objects to Hopf objects.</p>",
        "id": 386788833,
        "sender_full_name": "John Baez",
        "timestamp": 1692778743
    },
    {
        "content": "<p>For example the \"free vector space on a Set\" functor is symmetric monoidal from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><mo separator=\"true\">,</mo><mo>×</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\mathsf{Set}, \\times)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathsf\">Set</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">×</span><span class=\"mclose\">)</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"sans-serif\">V</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">c</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><mo separator=\"true\">,</mo><mo>⊗</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\mathsf{Vect}, \\otimes)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathsf\">Vect</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">⊗</span><span class=\"mclose\">)</span></span></span></span>.   <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><mo separator=\"true\">,</mo><mo>×</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\mathsf{Set}, \\times)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathsf\">Set</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">×</span><span class=\"mclose\">)</span></span></span></span> is cartesian so you can define group objects in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Set}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Set</span></span></span></span></span>, which are just groups.  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"sans-serif\">V</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">c</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><mo separator=\"true\">,</mo><mo>⊗</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\mathsf{Vect}, \\otimes)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathsf\">Vect</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">⊗</span><span class=\"mclose\">)</span></span></span></span> is not cartesian, but since it's symmetric monoidal you can still define Hopf objects in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">V</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">c</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Vect}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Vect</span></span></span></span></span>, which are Hopf algebras.  And the \"free vector space functor\" sends groups to Hopf algebras!</p>",
        "id": 386789172,
        "sender_full_name": "John Baez",
        "timestamp": 1692778884
    },
    {
        "content": "<p><a href=\"https://ncatlab.org/nlab/show/Hopf%20object\">[[Hopf object]]</a> is missing. It should be <a href=\"https://ncatlab.org/nlab/show/Hopf%20monoid\">[[Hopf monoid]]</a>. I don't know how to create a redirect on nlab.</p>",
        "id": 386957500,
        "sender_full_name": "Spencer Breiner",
        "timestamp": 1692828686
    },
    {
        "content": "<p>You must edit and add [[!redirects Hopf object]] at the end.</p>",
        "id": 386960014,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1692830467
    },
    {
        "content": "<p>You need diagonals to be able to get the map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>↦</mo><mi>g</mi><mo>⋅</mo><msup><mi>g</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">g\\mapsto g \\cdot g^{-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7054em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0085em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span>, yes. And you need the map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>∋</mo><mi>g</mi><mo>↦</mo><mi>e</mi><mo>∈</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G\\ni g \\mapsto e \\in G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∋</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7054em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>, which would be most easily achieved by assuming the tensor unit is terminal (see <a href=\"https://ncatlab.org/nlab/show/semicartesian%20monoidal%20category\">[[semicartesian monoidal category]]</a>). If the tensor product is symmetric, this nearly forces the monoidal structure to be cartesian. But do we need symmetry in the group axioms? I don't believe so.</p>",
        "id": 386972237,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1692840370
    },
    {
        "content": "<p>See <a href=\"https://mathoverflow.net/questions/348480/a-semicartesian-monoidal-category-with-diagonals-is-cartesian-proof\">https://mathoverflow.net/questions/348480/a-semicartesian-monoidal-category-with-diagonals-is-cartesian-proof</a> for discussion of how  diagonals and semicartesianness in a symmetric monoidal category need to interact to force cartesianness.</p>",
        "id": 386972392,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1692840500
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276422\">David Michael Roberts</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/objects.20.E2.80.9Care.E2.80.9D.20something/near/386972237\">said</a>:</p>\n<blockquote>\n<p>But do we need symmetry in the group axioms? I don't believe so.</p>\n</blockquote>\n<p>You mean, do we need symmetry of the ambient monoidal category?  I think so: the first axiom at <a href=\"https://ncatlab.org/nlab/show/bimonoid\">[[bimonoid]]</a> involves a string crossing.</p>",
        "id": 386984069,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1692848234
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276777\">@Mike Shulman</span> I mean for the diagrammatic definition of group object, if one tries to replicate it in a monoidal category with diagonals and with terminal tensor unit.</p>",
        "id": 386995448,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1692852129
    },
    {
        "content": "<p>Isn't that the same as writing down the definition of Hopf object, using the supplied diagonals and terminal maps as the comonoid structure?</p>",
        "id": 387005660,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1692858592
    },
    {
        "content": "<p>Why does one need to know that (gh,gh) = (g,g)(h,h) for the definition of a group, as in the first string diagram at <a href=\"https://ncatlab.org/nlab/show/bimonoid\">[[bimonoid]]</a>? Or am I misunderstanding what that is trying to say?</p>",
        "id": 387006791,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1692859339
    },
    {
        "content": "<p>I don't think that's quite the right way to say it: I would say both sides are versions of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mi>h</mi><mo separator=\"true\">,</mo><mi>g</mi><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(gh,gh)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">)</span></span></span></span>.  In Sweedler notation it would be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>g</mi><mi>h</mi><msub><mo stretchy=\"false\">)</mo><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></msub><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mi>g</mi><mi>h</mi><msub><mo stretchy=\"false\">)</mo><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow></msub><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><msub><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></msub><msub><mi>h</mi><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></msub><mo separator=\"true\">,</mo><msub><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow></msub><msub><mi>h</mi><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">((gh)_{(1)},(gh)_{(2)}) = (g_{(1)}h_{(1)}, g_{(2)} h_{(2)})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1052em;vertical-align:-0.3552em;\"></span><span class=\"mopen\">((</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3552em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">2</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3552em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1052em;vertical-align:-0.3552em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.5198em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3552em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3552em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.5198em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">2</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3552em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">2</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3552em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 387010569,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1692861477
    },
    {
        "content": "<p>I suppose maybe you don't need that to write down the bare definition.  But I would expect it to behave pretty oddly otherwise.</p>",
        "id": 387010911,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1692861651
    }
]