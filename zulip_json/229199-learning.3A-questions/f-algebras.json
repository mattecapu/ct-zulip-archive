[
    {
        "content": "<p>in Haskell you usually define <code>newtype Fix f = Fix (f (Fix f))</code> and treat it as the initial <code>f</code>-algebra for <code>f</code>. Do you know how on does generally proves that <code>Fix f</code> is actually the initial <code>f</code>-algebra for <code>f</code>? Does it hold for any functor <code>f</code>?</p>",
        "id": 193049782,
        "sender_full_name": "marcosh",
        "timestamp": 1586183358
    },
    {
        "content": "<p>Check out <a href=\"https://www.semanticscholar.org/paper/Inductive-and-Coinductive-Types-with-Iteration-and-Geuvers/c88146f46742bab40cea56b152a8467182733eec\" title=\"https://www.semanticscholar.org/paper/Inductive-and-Coinductive-Types-with-Iteration-and-Geuvers/c88146f46742bab40cea56b152a8467182733eec\">https://www.semanticscholar.org/paper/Inductive-and-Coinductive-Types-with-Iteration-and-Geuvers/c88146f46742bab40cea56b152a8467182733eec</a></p>",
        "id": 193050587,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586183659
    },
    {
        "content": "<p>Also note that because of <code>undefined</code>, Haskell has no limits</p>",
        "id": 193050736,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586183721
    },
    {
        "content": "<p>thanks Andre</p>",
        "id": 193050817,
        "sender_full_name": "marcosh",
        "timestamp": 1586183745
    },
    {
        "content": "<p>let's leave <code>undefined</code> aside for the moment</p>",
        "id": 193050855,
        "sender_full_name": "marcosh",
        "timestamp": 1586183759
    },
    {
        "content": "<p>is some specific theorem of the paper relevant or the whole paper?</p>",
        "id": 193050977,
        "sender_full_name": "marcosh",
        "timestamp": 1586183789
    },
    {
        "content": "<p>I think the Proof of Prop 3.4 is what you're looking for</p>",
        "id": 193051236,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586183900
    },
    {
        "content": "<p>thanks!</p>",
        "id": 193051253,
        "sender_full_name": "marcosh",
        "timestamp": 1586183908
    },
    {
        "content": "<p>Oh, wait, I just realized that this uses a different definition than what you gave</p>",
        "id": 193051445,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586183993
    },
    {
        "content": "<p>I have a faint memory of being told that in Haskell-like categories (with lazy datatypes) initial algebras and final coalgebras coincide</p>",
        "id": 193051566,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1586184027
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281119\">@Andre Knispel</span> looking here, 3.4 seems to be a Definition, are we looking at different versions of the paper?</p>",
        "id": 193052150,
        "sender_full_name": "marcosh",
        "timestamp": 1586184257
    },
    {
        "content": "<p>Oh, sorry, that's not the same version of the paper that I have locally. It's Prop. 4.6 there</p>",
        "id": 193052475,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586184380
    },
    {
        "content": "<p>ah, thanks</p>",
        "id": 193052493,
        "sender_full_name": "marcosh",
        "timestamp": 1586184390
    },
    {
        "content": "<p>I think this can probably be converted in what you want, just need to check something</p>",
        "id": 193052818,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586184520
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275901\">Jules Hedges</span> <a href=\"#narrow/stream/229199-learning.3A-basic.20questions/topic/f-algebras/near/193051566\" title=\"#narrow/stream/229199-learning.3A-basic.20questions/topic/f-algebras/near/193051566\">said</a>:</p>\n<blockquote>\n<p>I have a faint memory of being told that in Haskell-like categories (with lazy datatypes) initial algebras and final coalgebras coincide</p>\n</blockquote>\n<p>That sounds interesting!</p>",
        "id": 193052910,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586184567
    },
    {
        "content": "<p>Yeah, so if you Church-encode your definition of <code>Fix</code>, you end up with <code>∀ X. (f X -&gt; X) -&gt; X</code>, which is exactly what you see there</p>",
        "id": 193053718,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586184878
    },
    {
        "content": "<p>I don't know how well Church encoding works for Haskell though</p>",
        "id": 193054165,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586185046
    },
    {
        "content": "<p>that's exactly <a href=\"https://hackage.haskell.org/package/recursion-schemes-5.1.3/docs/Data-Functor-Foldable.html#t:Mu\" title=\"https://hackage.haskell.org/package/recursion-schemes-5.1.3/docs/Data-Functor-Foldable.html#t:Mu\">https://hackage.haskell.org/package/recursion-schemes-5.1.3/docs/Data-Functor-Foldable.html#t:Mu</a></p>",
        "id": 193056073,
        "sender_full_name": "marcosh",
        "timestamp": 1586185833
    },
    {
        "content": "<p>but the proposition you mention states the existence of a weakly intial algebra, so it does not guarantee uniqueness</p>",
        "id": 193056268,
        "sender_full_name": "marcosh",
        "timestamp": 1586185916
    },
    {
        "content": "<p>I think generally the issue here is that it's not really possible to get uniqueness, at least not with the usual type theories. This is the whole issue with extensional equality not implying equality</p>",
        "id": 193062155,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586188429
    },
    {
        "content": "<p>You could of course quotient your category by extensional equality, which might what you want to do if you actually want to consider limits, but that seems like an ugly solution</p>",
        "id": 193062613,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586188657
    },
    {
        "content": "<p>the initial question is answered by \"lambek's lemma\" which is described many places but here is one i found on a quick google <a href=\"http://www.cs.ru.nl/~jrot/coalgebra/ak-algebras.pdf\" title=\"http://www.cs.ru.nl/~jrot/coalgebra/ak-algebras.pdf\">http://www.cs.ru.nl/~jrot/coalgebra/ak-algebras.pdf</a></p>",
        "id": 193100287,
        "sender_full_name": "Gershom",
        "timestamp": 1586206419
    },
    {
        "content": "<p>the conditions for initial and final gadgets to coincide are given below remark 6.2.2 in fiore's thesis: <a href=\"https://www.lfcs.inf.ed.ac.uk/reports/94/ECS-LFCS-94-307/\" title=\"https://www.lfcs.inf.ed.ac.uk/reports/94/ECS-LFCS-94-307/\">https://www.lfcs.inf.ed.ac.uk/reports/94/ECS-LFCS-94-307/</a> (he doesn't use the words bilimit compact, but i've seen those around in more recent stuff)</p>",
        "id": 193101565,
        "sender_full_name": "Gershom",
        "timestamp": 1586207030
    },
    {
        "content": "<p>How does lambek's lemma imply initiality?</p>",
        "id": 193102403,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586207441
    },
    {
        "content": "<p>well my sense is consider the commutative square given here: <a href=\"https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor#LambeksTheorem\" title=\"https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor#LambeksTheorem\">https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor#LambeksTheorem</a></p>\n<p>now, since we have F(F(X)) isomorphic to F(X) then that says we must have a pair (a,X) such that  F(X) = F(F(X)) = F(F(F(X)))... and clearly taking the fixed point of F itself satisfies this.</p>",
        "id": 193104933,
        "sender_full_name": "Gershom",
        "timestamp": 1586208826
    },
    {
        "content": "<p>Lambek lemma says that given an initial <code>F</code>-algebra <code>(a, X)</code>, then <code>a : F X -&gt; X</code> is an isomorphism. Since it is initial it is the least fiexed point. Existence of an <code>F</code>-algebra could be given by Adamek theorem (<a href=\"https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor#AdameksTheorem\" title=\"https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor#AdameksTheorem\">https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor#AdameksTheorem</a>). But why is it <code>Fix F</code> the least fixed point?</p>",
        "id": 193107042,
        "sender_full_name": "marcosh",
        "timestamp": 1586210001
    },
    {
        "content": "<p>By inspection, Fix f ~= Fix f (Fix f) ~= etc. So clearly it satisfies the requirement I gave above, which suffices to characterize it as an initial algebra.</p>",
        "id": 193107596,
        "sender_full_name": "Gershom",
        "timestamp": 1586210344
    },
    {
        "content": "<p>This was also being discussed at <a href=\"#narrow/stream/229156-practice.3A-applied.20ct/topic/Algebras/near/191558018\" title=\"#narrow/stream/229156-practice.3A-applied.20ct/topic/Algebras/near/191558018\">https://categorytheory.zulipchat.com/#narrow/stream/229156-practice.3A-applied.20ct/topic/Algebras/near/191558018</a>.<br>\nI'm very interested in this \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">∀</span></span></span></span>/end\" way of describing the initial algebra, but I haven't yet wrapped my head around it.</p>",
        "id": 193108422,
        "sender_full_name": "Christian Williams",
        "timestamp": 1586210814
    },
    {
        "content": "<p>I picture <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>X</mi><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi>F</mi><mi>X</mi><mo>→</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">\\forall X. (FX\\to X)\\to X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span></span></span></span> as a big product (subject to naturality). Now this is an algebra in some canonical way. What is this object? What does it mean to apply <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span></span></span></span> to it?</p>\n<p>Maybe it would help everyone if we brought in a concrete example. Let's take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">f:\\mathrm{Set}\\to \\mathrm{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">t</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">t</span></span></span></span></span> to be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn><mo>+</mo><msup><mi>X</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">F(X)=1+X^2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 193109464,
        "sender_full_name": "Christian Williams",
        "timestamp": 1586211431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276650\">Gershom</span> <a href=\"#narrow/stream/229199-learning.3A-basic.20questions/topic/f-algebras/near/193107596\" title=\"#narrow/stream/229199-learning.3A-basic.20questions/topic/f-algebras/near/193107596\">said</a>:</p>\n<blockquote>\n<p>By inspection, Fix f ~= Fix f (Fix f) ~= etc. So clearly it satisfies the requirement I gave above, which suffices to characterize it as an initial algebra.</p>\n</blockquote>\n<p>There is still the issue of equality though. If you check <a href=\"https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor#semantics_for_inductive_types\" title=\"https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor#semantics_for_inductive_types\">https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor#semantics_for_inductive_types</a> then you'll see that this only works in extensional theories (and that weak initial algebras are the equivalent in intensional theories). I don't know about the internals of Haskell enough to be able to say definitively how that category behaves, but for Coq, Agda and Idris this is what you get.</p>",
        "id": 193110676,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586212132
    },
    {
        "content": "<p>Haskell is not a dependent type theory, it doesn’t have any internal notion of equality (extensional vs intensional), so we simply reason meta-theoretically using extensionality (and a lot of handwaving <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>)</p>",
        "id": 193111092,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1586212354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275899\">Christian Williams</span> <a href=\"#narrow/stream/229199-learning.3A-basic.20questions/topic/f-algebras/near/193109464\" title=\"#narrow/stream/229199-learning.3A-basic.20questions/topic/f-algebras/near/193109464\">said</a>:</p>\n<blockquote>\n<p>I picture <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>X</mi><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi>F</mi><mi>X</mi><mo>→</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">\\forall X. (FX\\to X)\\to X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span></span></span></span> as a big product (subject to naturality). Now this is an algebra in some canonical way. What is this object? What does it mean to apply <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span></span></span></span> to it?</p>\n<p>Maybe it would help everyone if we brought in a concrete example. Let's take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">f:\\mathrm{Set}\\to \\mathrm{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">t</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">t</span></span></span></span></span> to be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn><mo>+</mo><msup><mi>X</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">F(X)=1+X^2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>.</p>\n</blockquote>\n<p>In general, this is the Church-encoding of that datatype. There are two ways I get my intuition for it: by considering special functors and by regarding elements as general ways to map out of that type.</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span></span></span></span> is usually derived from constructors of a datatype, and if you have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> constructors, you can write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span></span></span></span> as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>F</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">F_1 + \\cdots + F_n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. The constructor corresponding to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">F_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">F_i(T) \\to T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> is the type we're defining. So in your example, the constructors would be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub><mo>:</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">c_1 : T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub><mo>:</mo><msup><mi>T</mi><mn>2</mn></msup><mo>→</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">c_2 : T^2 \\to T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span>, which would be a type of binary trees.</p>\n<p>If you look at the Church encoding, let's see what you can do with it. Let's fix a type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> and an element <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>:</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">t : T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> of the type we defined. Then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">t A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">A</span></span></span></span> has type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>F</mi><mi>A</mi><mo>→</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">(FA \\to A) \\to A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>, i.e. mapping an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span></span></span></span> algebra structure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> to an element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>. So if you consider the map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi><mi>t</mi><mo>:</mo><mi>T</mi><mi mathvariant=\"normal\">.</mi><mi>t</mi><mi>A</mi><mi>a</mi><mi>l</mi><mi>g</mi><mo>:</mo><mi>T</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda t : T. t A alg : T \\to A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">λ</span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\">.</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> for some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>l</mi><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">alg</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span></span></span></span>, you can define morphisms out of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span>. And this is basically the only way you can map out of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span>. This gives you a fold, and from that you can also derive recursion.</p>",
        "id": 193112269,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586213179
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276057\">Nicholas Scheel</span> <a href=\"#narrow/stream/229199-learning.3A-basic.20questions/topic/f-algebras/near/193111092\" title=\"#narrow/stream/229199-learning.3A-basic.20questions/topic/f-algebras/near/193111092\">said</a>:</p>\n<blockquote>\n<p>Haskell is not a dependent type theory, it doesn’t have any internal notion of equality (extensional vs intensional), so we simply reason meta-theoretically using extensionality (and a lot of handwaving <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>)</p>\n</blockquote>\n<p>Well, there still need to be some form of equality on the morphisms if you actually define the category though. Are functions equal if their code is equal or if the produce the same output given the same input? That gives you different categories.</p>",
        "id": 193112383,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586213279
    },
    {
        "content": "<p>I don't know anything about this, but I'll still say something: </p>\n<p>You'd darn well better have a category where morphisms are actual programs (or at least useful \"isomorphism classes\" of programs), and another category where programs that produce the same output given the same input count as the same morphism, and a functor from the first category to the second.</p>",
        "id": 193112687,
        "sender_full_name": "John Baez",
        "timestamp": 1586213484
    },
    {
        "content": "<p>I'm pretty sure that's the case, there are even different levels to this depending on if you work within the language or look at it from the outside</p>",
        "id": 193112995,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586213752
    },
    {
        "content": "<p>There is also this nice paper <a href=\"https://arxiv.org/abs/1011.0014\" title=\"https://arxiv.org/abs/1011.0014\">https://arxiv.org/abs/1011.0014</a><br>\nIt doesn't deal with types, but in the case of simple programs on natural numbers it gives you a whole galois correspondence</p>",
        "id": 193113189,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586213895
    },
    {
        "content": "<p>Sorry, I misunderstood what extensionality was referring to. Haskell would probably be considered an extensional type theory, because types cannot be equal in interesting ways and it has a form of equality reflection. But my other point still stands. If you were to define a category to reason about Haskell, it would most likely use function extensionality too, but there are greater obstructions there (“Hask is not a category”, non-strictness, etc.).</p>",
        "id": 193113496,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1586214098
    },
    {
        "content": "<p>I mean it wasn't really clear the way I've phrased it, usually you think internally if you care about these things <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> </p>\n<p>I really want to see what could be done with applying the paper I've mentioned to such a setting (I haven't checked if there were any follow ups on this though). Naively, it seems to have the potential to categorize the issues with how to define it properly (pun intended).</p>",
        "id": 193114016,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586214450
    },
    {
        "content": "<p>If that was possible, you'd have a tower of different categories with projections between them, with maybe the category formed by syntax at the top and the \"classical mathematical picture\" at the bottom and maybe some stuff in between. And if it fully works out, some automorphisms that correspond to that structure. That would be pretty cool.</p>",
        "id": 193114342,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586214700
    },
    {
        "content": "<p>My guess is that the bottom layer “programs” would be syntax quotiented by definitional equality, otherwise the composition in the category isn’t well-behaved. Well, you at the very least need to quotient out <code>f . g = \\x -&gt; f (g x)</code> and <code>id x = x</code>, so that identities and associativities hold. Actually, that’s not quite true, you also need eta-equivalence: <code>f = \\x -&gt; f x</code>.</p>",
        "id": 193114850,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1586215112
    },
    {
        "content": "<p>I think you can just quotient by extensional equality (for Haskell)</p>",
        "id": 193114933,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586215200
    },
    {
        "content": "<p>You can probably do so as well in dependent type theories, but I'm not sure if you'd want to</p>",
        "id": 193115004,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586215244
    },
    {
        "content": "<p>Sorry, I guess I flipped top/bottom from what you mentioned. Would you quotient the syntax side of it or the semantics side of it by extensional equality?</p>",
        "id": 193115548,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1586215760
    },
    {
        "content": "<p>I'd quotient the syntax. So you could first quotient out the equations you mentioned at the first step and then extensional equality at the second step</p>",
        "id": 193115681,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586215876
    },
    {
        "content": "<p>I've just played around with the intuition a little bit, and it seems plausible to get a Galois connection from this. So the category given by quotienting by the equations you gave would give you a subgroup of the automorphisms of the syntactic category, namely those that keep objects fixed (I think) and only perform rewrites with those equations on the morphisms</p>",
        "id": 193115922,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586216093
    },
    {
        "content": "<p>it would be interesting to think about optimizations in this framework</p>",
        "id": 193116052,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1586216180
    },
    {
        "content": "<p>Indeed, you could get functorial compiler optimizations</p>",
        "id": 193116146,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586216284
    },
    {
        "content": "<p>Seems like the author of that paper hasn't followed up on it, so confirming if it actually works in a typed setting would need some actual work</p>",
        "id": 193116295,
        "sender_full_name": "Andre Knispel",
        "timestamp": 1586216406
    },
    {
        "content": "<p>There is a standard notion of a tower of the sort described going between syntax and semantics. this is the tower (or really lattice) of abstract interpretation as given in e.g. <a href=\"https://www.di.ens.fr/~cousot/COUSOTpapers/ENTCS-97.shtml\" title=\"https://www.di.ens.fr/~cousot/COUSOTpapers/ENTCS-97.shtml\">https://www.di.ens.fr/~cousot/COUSOTpapers/ENTCS-97.shtml</a></p>",
        "id": 193120362,
        "sender_full_name": "Gershom",
        "timestamp": 1586220245
    },
    {
        "content": "<p>btw the nlab link above links eventually to wadler's classic note that describes the fixpoint construction in the initial question and gives a full proof, discussing both weak and strict settings <a href=\"https://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt\" title=\"https://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt\">https://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt</a></p>",
        "id": 193120539,
        "sender_full_name": "Gershom",
        "timestamp": 1586220418
    },
    {
        "content": "<p>and finally another notion of a \"tower\" is given in the lovely paper by John and Christian on enriched lawvere theories and operational semantics: <a href=\"https://arxiv.org/abs/1905.05636\" title=\"https://arxiv.org/abs/1905.05636\">https://arxiv.org/abs/1905.05636</a>  <span class=\"user-mention\" data-user-id=\"275920\">@John Baez</span> btw you may not have thought of your work in light of the cousot &amp; cousot stuff on abstract interpretation. i wonder if it may be of interest to you.</p>",
        "id": 193120714,
        "sender_full_name": "Gershom",
        "timestamp": 1586220571
    },
    {
        "content": "<p>That paper has lots of scary symbols.  <span aria-label=\"ogre\" class=\"emoji emoji-1f479\" role=\"img\" title=\"ogre\">:ogre:</span></p>",
        "id": 193123770,
        "sender_full_name": "John Baez",
        "timestamp": 1586224099
    },
    {
        "content": "<p>I have trouble with papers like this:</p>\n<p><a href=\"/user_uploads/21317/DXC1qYrWPoNneMCaxG30Ii-6/cousot.jpg\" title=\"cousot.jpg\">cousot.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/DXC1qYrWPoNneMCaxG30Ii-6/cousot.jpg\" title=\"cousot.jpg\"><img src=\"/user_uploads/21317/DXC1qYrWPoNneMCaxG30Ii-6/cousot.jpg\"></a></div>",
        "id": 193123870,
        "sender_full_name": "John Baez",
        "timestamp": 1586224239
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><mo separator=\"true\">,</mo><mi>τ</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">\\langle, \\tau \\rangle</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.1132em;\">τ</span><span class=\"mclose\">⟩</span></span></span></span> seems particularly mysterious</p>",
        "id": 193123902,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1586224294
    },
    {
        "content": "<p>Maybe you can tell me a bit about the basic idea, Gershom?</p>",
        "id": 193123904,
        "sender_full_name": "John Baez",
        "timestamp": 1586224298
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276092\">Nathanael Arkor</span> <a href=\"#narrow/stream/229199-learning.3A-basic.20questions/topic/f-algebras/near/193123902\" title=\"#narrow/stream/229199-learning.3A-basic.20questions/topic/f-algebras/near/193123902\">said</a>:</p>\n<blockquote>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><mo separator=\"true\">,</mo><mi>τ</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">\\langle, \\tau \\rangle</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.1132em;\">τ</span><span class=\"mclose\">⟩</span></span></span></span> seems particularly mysterious</p>\n</blockquote>\n<p><code>-XTupleSections</code> <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 193124203,
        "sender_full_name": "sarahzrf",
        "timestamp": 1586224674
    },
    {
        "content": "<p>Hrm ok. Let me give this \"explaining\" thing a shot.</p>\n<p>So when one has a computer program, a typical thing to want to do is verify properties of it that hold under many different inputs, but do so without running under all such inputs. This is \"static analysis\". (I.e. you analyze it as a static object without dynamically executing it). One very powerful method of static analysis is something called \"abstract interpretation\" which you can think of as \"running the program on generic inputs\" or \"running the program in an abstract domain\" or the like. So imagine you want to prove that a result of a program that sends a number to another number never exceeds 100. You can give a suitably modified version of the program that does interval arithmetic a number that represents the range of the input, and then just examine the range of the output. Suppose you hit a choice point where the program branches if the number is greater than 50 or not. Your \"abstracted\" program can then take \"both\" paths, and attempt to \"merge back\" to the unioned state representing the range of possible values that can occur no matter which path was taken. So you need some way to \"split\" your bags of \"general values\" and \"merge\" them as well.</p>\n<p>Along with extrema, one can verify things like e.g. memory safety, type soundness, various information security properties, etc. You just need to pick the right \"abstract domain\" to interpret into that tracks exactly the information you want, and turns the rest into \"generalized data\". And of course there are many tradeoffs between how precise you are, how hard it is to do, and how much information you can track. I should note this is a \"real world\" technique that has been used in practice to verify safety-critical software for areospace and the like.</p>\n<p>What the Cousots worked on is a general formalism for this sort of thing, to let you believe that your original program and the abstracted interpretation of the program bear the sort of relationship you would like.</p>\n<p>If you're in a theory without recursion, all this is very straightforward. It really is just sort of starting with an algebraic theory, and interpreting it with different models. But we want to work in real programs, with unbounded recursion. So they came up with a lattice theoretic formulation so that domain theory and fixpoint operators can be used, and a way of interpreting morphisms between different lattice-theoretic \"abstract domains\" so that you can show something is a \"correct\" abstract interpretation -- i.e. that it exists somewhere \"between\" the syntax and the intended concrete semantics, so that you can go all the way down, then partway back \"up\" or partway down, then the rest of the way down, and always end up in the same place. You also want to make sure that even if your original program is recursive and may never terminate, the \"abstract domain\" you interpret into should have some fixpoint semantics such that it _does_ terminate. (otherwise your \"static\" analysis may never complete).</p>\n<p>That's where all the dense notation comes from.</p>\n<p>you might be thinking \"all this stuff about syntax and semantics and algebraic theories and their models sounds like there's some adjoints about.\" Indeed, there are ! One approach to how to get correct and terminating abstract interpretations is to construct the \"abstract domain\" as a lattice which relates to the \"concrete domain\" via a nice galois connection. This lets product types, function types, etc. be \"pushed through\" in a very general way.  (Which makes sense, because to be a \"sensible\" interpretation, it is reasonable that you would want to preserve either meets or joins, depending on how you come at it).</p>\n<p>The paper I linked above is a later paper that's dense, but I just really wanted to highlight the diagram on the last page that shows the big tower of related interpretations and semantics.</p>\n<p>The earliest paper is probably the most directly readable, or rather difficulty in reading it arises not because it is complicated, but just because it is old: <a href=\"https://courses.cs.washington.edu/courses/cse501/15sp/papers/cousot.pdf\" title=\"https://courses.cs.washington.edu/courses/cse501/15sp/papers/cousot.pdf\">https://courses.cs.washington.edu/courses/cse501/15sp/papers/cousot.pdf</a></p>\n<p>A later paper that explains the galois connection approach a bit is: <a href=\"https://www.di.ens.fr/~cousot/COUSOTpapers/publications.www/CousotCousot-PLILP-92-LNCS-n631-p269--295-1992.pdf\" title=\"https://www.di.ens.fr/~cousot/COUSOTpapers/publications.www/CousotCousot-PLILP-92-LNCS-n631-p269--295-1992.pdf\">https://www.di.ens.fr/~cousot/COUSOTpapers/publications.www/CousotCousot-PLILP-92-LNCS-n631-p269--295-1992.pdf</a></p>\n<p>I confess I like the galois approach because it is simple and pretty, so don't really get what's happening with the \"widening\" stuff which the paper argues is more powerful. With the right categorical toolkit, I wonder if the latter approach can't be made prettier as well.</p>",
        "id": 193130260,
        "sender_full_name": "Gershom",
        "timestamp": 1586233031
    },
    {
        "content": "<p>In abstract interpretation, \"widening\" refers to an intentional overapproximation step to make the fixpoint search terminate, e.g.:</p>\n<p>If we want to analyze a program with an integer variable, we might abstract its state using a lattice of intervals like [1, 6].  But since this lattice isn't noetherian, an ascending search for a least fixpoint might not terminate: [1, 6], then [1, 7], then etc.  Instead, at some point we might just \"widen\" to something that surely is an upper bound, in this case e.g. the top element.  One way to think about this is to use the lattice of intervals except without any intervals of size too big --- so we immediately jump to top.  But there are other cases one might want to widen, even if the lattice technically has Ascending Chain condition (e.g. the chains might be impractically long!)</p>",
        "id": 193141494,
        "sender_full_name": "Sam Tenka",
        "timestamp": 1586236499
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276650\">Gershom</span> <a href=\"#narrow/stream/229199-learning.3A-basic.20questions/topic/f-algebras/near/193107596\" title=\"#narrow/stream/229199-learning.3A-basic.20questions/topic/f-algebras/near/193107596\">said</a>:</p>\n<blockquote>\n<p>By inspection, Fix f ~= Fix f (Fix f) ~= etc. So clearly it satisfies the requirement I gave above, which suffices to characterize it as an initial algebra.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"276650\">@Gershom</span> I'm sorry but I'm not sure I follow your reasoning. Which requirement are you referring to? Could you expand on it, please?</p>",
        "id": 193148077,
        "sender_full_name": "marcosh",
        "timestamp": 1586243903
    },
    {
        "content": "<p>By requirement I simply meant that F(X) =~ X. I agree the sketch I gave was handwavy. You need other ambient properties of the category you're working in -- things like fixed points actually existing, etc.  And you need to be in a very special situation (which Haskell has) for the fixed point to imply initiality and not simply vice-versa. The wadler note I linked does it up right.</p>\n<p><span class=\"user-mention\" data-user-id=\"281272\">@Sam Tenka (naive student)</span> thanks for that nice explanation of widening. I understand the paper I linked gives an example where widening cannot be captured by a galois connection. But surely there must be some more general way of thinking about adjoints where it makes sense?</p>",
        "id": 193153319,
        "sender_full_name": "Gershom",
        "timestamp": 1586247335
    }
]