[
    {
        "content": "<p>This is a spin off from the Markov categories and enrichment thread. In that thread, Jules used Haskell do notation to give some intuition for a commutative monad:<br>\n<span class=\"user-mention silent\" data-user-id=\"275901\">Jules Hedges</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Markov.20categories.20and.20enrichment/near/202668167\">said</a>:</p>\n<blockquote>\n<p>Commutativity is equivalent to the fact that the Haskell programs <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>↦</mo><mtext>do</mtext><mo stretchy=\"false\">{</mo><mi>x</mi><mo>←</mo><mi>a</mi><mo separator=\"true\">;</mo><mi>y</mi><mo>←</mo><mi>b</mi><mo separator=\"true\">;</mo><mtext>return</mtext><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">(a, b) \\mapsto \\text{do} \\{ x \\leftarrow a; y \\leftarrow b; \\text{return} (x, y) \\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">do</span></span><span class=\"mopen\">{</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">←</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">←</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord text\"><span class=\"mord\">return</span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mclose\">}</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>↦</mo><mtext>do</mtext><mo stretchy=\"false\">{</mo><mi>y</mi><mo>←</mo><mi>b</mi><mo separator=\"true\">;</mo><mi>x</mi><mo>←</mo><mi>a</mi><mo separator=\"true\">;</mo><mtext>return</mtext><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">(a, b) \\mapsto \\text{do} \\{ y \\leftarrow b; x \\leftarrow a; \\text{return} (x, y) \\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">do</span></span><span class=\"mopen\">{</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">←</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">←</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord text\"><span class=\"mord\">return</span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mclose\">}</span></span></span></span> are equal</p>\n<p>So it says that there is no \"side channel information flow\" beyond what is made explicit in the types</p>\n<p>So an example of a noncommutative monad is state, since there is implicit information flow through the state variable</p>\n</blockquote>\n<p>I used to code in Haskell sometimes, years ago, but I didn't know any category theory at the time and have since forgotten most of my Haskell knowledge. But I'm curious about how the do notation relates to monads as I now understand them. Can anyone give a quick explanation of how the do notation in Haskell relates to monads in the category theory sense?</p>\n<p>I don't need to know how to use monads in Haskell, necessarily - I'm just interested in the idea of using this notation to reason about category-theoretic monads.</p>",
        "id": 202771936,
        "sender_full_name": "Nathaniel Virgo",
        "timestamp": 1593757293
    },
    {
        "content": "<p>Perhalps this helps on how the do notation in Haskell relates to monads in the category theory sense:</p>\n<p>A monad in Haskell is usually represented as a type constructor <code>m :: * -&gt; *</code> together with functions:</p>\n<ul>\n<li><code>return :: forall a . a -&gt; m a</code>,</li>\n<li><code>bind :: forall a b . m a -&gt; (a -&gt; m b) -&gt; m b</code> (usually written in infix form as <code>&gt;&gt;=</code>).</li>\n</ul>\n<p>This data is packed using a type-class called <code>Monad</code>, and it represents the notion of <a href=\"https://en.wikipedia.org/wiki/Kleisli_category#Extension_operators_and_Kleisli_triples\">Kleisli triple</a>, which is a categorical notion that's equivalent to monads. Following Wikipedia article, <code>m</code> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span>, <code>return</code> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">\\eta</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">η</span></span></span></span>, <code>&gt;&gt;=</code> is a flipped version of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mo>−</mo><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">-^*</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.772026em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mbin\">−</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>.</p>\n<p>There's a number of rules that \"desugar\" from do-notation to these functions. For example, <code>do { y &lt;- b; return y }</code> would desugar into <code>b &gt;&gt;= \\y -&gt; return y</code>.</p>\n<p>The programs that Jules wrote are: <code>\\(a, b) -&gt; do { x &lt;- a; y &lt;- b; return (x, y)}</code> and <code>\\(a, b) -&gt; do { y &lt;- b; x &lt;- a; return (x, y) }</code>. These desugar into <code>\\(a, b) -&gt; a &gt;&gt;= \\x -&gt; b &gt;&gt;= \\y -&gt; return (x, y)</code> and <code>\\(a, b) -&gt; b &gt;&gt;= \\y -&gt; a &gt;&gt;= \\x -&gt; return (x, y)</code>. These two programs are functions of type <code>(m c,  m d) -&gt; m (c, d)</code>, and they are the kind of arrows that you need to be equal in order to call a monad commutative: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>c</mi><mo>⊗</mo><mi>T</mi><mi>d</mi><mo>→</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo>⊗</mo><mi>d</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T c \\otimes T d \\to T (c \\otimes d)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathdefault\">c</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathdefault\">d</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">c</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">d</span><span class=\"mclose\">)</span></span></span></span> (here <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding=\"application/x-tex\">\\otimes</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊗</span></span></span></span> is product, denoted by tuples <code>(c,d)</code> in Haskell).</p>",
        "id": 202778343,
        "sender_full_name": "Exequiel Rivas",
        "timestamp": 1593764050
    },
    {
        "content": "<p>What's not explicit here is the strength thing. The thing is that we're mixing the exponential object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">[</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo fence=\"true\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\left[ A, B \\right]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">[</span><span class=\"mord mathdefault\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose delimcenter\" style=\"top:0em;\">]</span></span></span></span></span> (i.e. the one that comes from the right adjoint to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>×</mo><mo>−</mo></mrow><annotation encoding=\"application/x-tex\">A \\times -</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">−</span></span></span></span>) with the hom-set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal{C}(A, B)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span>. We do this because both the exponential and the hom-set get kind of represented by the same function type <code>a -&gt; b</code> under this view.</p>\n<p>Any monad <code>m</code> in Haskell gets strengths \"automatically\". For example, <code>st :: (a, m b) -&gt; m (a, b)</code>: <code>st (a, v) = v &gt;&gt;= \\b -&gt; return (a, b)</code>.</p>",
        "id": 202779611,
        "sender_full_name": "Exequiel Rivas",
        "timestamp": 1593765065
    }
]