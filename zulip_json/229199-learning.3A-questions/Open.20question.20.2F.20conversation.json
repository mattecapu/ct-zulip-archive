[
    {
        "content": "<p>There is a certain train of thought I have been going over for about a year. I have struggled a lot to even formulate the question I am trying to ask. I wonder if conversing about it with others can help me make progress in it.</p>",
        "id": 402697239,
        "sender_full_name": "Julius",
        "timestamp": 1700227190
    },
    {
        "content": "<p>I will try to mention just a few aspects of it. I am never able to send off what I write because I keep trying to develop what im saying, and can never finish what im writing.</p>",
        "id": 402697447,
        "sender_full_name": "Julius",
        "timestamp": 1700227239
    },
    {
        "content": "<p>Computer memory I believe could be thought of as one single binary sequence. It's ok if the actual details are different. Memory has addresses. The values are binary.</p>",
        "id": 402697585,
        "sender_full_name": "Julius",
        "timestamp": 1700227284
    },
    {
        "content": "<p>It's a sequence of elements (values, characters).</p>",
        "id": 402697649,
        "sender_full_name": "Julius",
        "timestamp": 1700227304
    },
    {
        "content": "<p>I have not had the time to develop my understanding of this, but in set theory at least, a sequence can be thought of as a set indexed by the natural numbers; but I believe the important part is that it is a totally ordered set.</p>\n<p>Orders are defined as relations.</p>\n<p>I have read that the category of finite ordered sets is the simplex category. This intrigues me. As I said, I have not had the time to study the simplex category deeply yet.</p>",
        "id": 402697992,
        "sender_full_name": "Julius",
        "timestamp": 1700227405
    },
    {
        "content": "<p>I am very interested in ontology. My background is in linguistics.</p>",
        "id": 402698082,
        "sender_full_name": "Julius",
        "timestamp": 1700227436
    },
    {
        "content": "<p>I also program a fair amount.</p>",
        "id": 402698159,
        "sender_full_name": "Julius",
        "timestamp": 1700227447
    },
    {
        "content": "<p>Many of the projects I try to work on revolve around my desire to process data (i.e., text, say, webpages) into something indicating semantic comprehension - like a knowledge graph.</p>",
        "id": 402698295,
        "sender_full_name": "Julius",
        "timestamp": 1700227488
    },
    {
        "content": "<p>A very common idea is that knowledge graphs are built from triples. Between two concepts, a third concept declares their relationship. So, (Donald Trump Jr, Father, Donald Trump Sr.), for example.</p>",
        "id": 402698416,
        "sender_full_name": "Julius",
        "timestamp": 1700227528
    },
    {
        "content": "<p>I have often gotten side-tracked considering variations to the triple. Maybe I won't go into it right now.</p>",
        "id": 402698464,
        "sender_full_name": "Julius",
        "timestamp": 1700227547
    },
    {
        "content": "<p>Here is where I start to struggle to say what I want to say. Forgive me for being vague. With time, I can try to get out what I am trying to say.</p>",
        "id": 402698638,
        "sender_full_name": "Julius",
        "timestamp": 1700227590
    },
    {
        "content": "<p>I am extremely interested in unsupervised learning. On a very intuitive, non-rigorous level, whatever \"data\" is, we can imagine and understand that it contains latent information, relationships, inside of it.</p>",
        "id": 402698798,
        "sender_full_name": "Julius",
        "timestamp": 1700227633
    },
    {
        "content": "<p>I believe in Claude Shannon type information theory, there is this interesting idea that the less random something is - the more it deviates from randomness - the more information it contains. Say, a signal being transmitted.</p>",
        "id": 402698903,
        "sender_full_name": "Julius",
        "timestamp": 1700227664
    },
    {
        "content": "<p>I think this is often used in statistics, as well. there is this kind of \"null hypothesis\", I think, that, given no other assumptions, we should just kind of assume the default, arbitrary state of something to be amorphous randomness. you can calculate the extent to which data deviates from randomness, which is telling. it tells us that, on the contrary, our data does not appear to be random. and if it is not random, it (again, this is very informal, intuitive), has some reason, rule, law, pattern, explanation, cause, for why it is other than random. how did it get that way? what preconditions influenced the data to emerge in this non-arbitrary form?</p>",
        "id": 402699254,
        "sender_full_name": "Julius",
        "timestamp": 1700227772
    },
    {
        "content": "<p>maybe this is jumping ahead, but at least from a mathematical perspective, we can kind of assert that any binary sequence can be described in terms of some rules, that specify or generate that sequence.</p>",
        "id": 402699506,
        "sender_full_name": "Julius",
        "timestamp": 1700227847
    },
    {
        "content": "<p>I can't remember the term, it might be Kolmogorov complexity or something similar. but there is this fascinating question in the field of induction, which is like, you might know that a binary sequence is certainly not random, but it may be intrinsically mysterious, difficult, unknowable to prove what set of rules / functions generated that sequence of data.</p>",
        "id": 402699714,
        "sender_full_name": "Julius",
        "timestamp": 1700227918
    },
    {
        "content": "<p>if there is some sort of recurrent pattern in the data, you are able to describe the information of that sequence... with less \"information\". you do not need to tell someone like, one hundred times, 1, then 0, then 1, then 0. assuming you have some sort of binary language to encode such an expression, you can express the idea, \"repeat 10 100 times\".</p>",
        "id": 402699991,
        "sender_full_name": "Julius",
        "timestamp": 1700228006
    },
    {
        "content": "<p>Let me see if I can skip ahead to the point, a bit, then add in details as needed.</p>",
        "id": 402700068,
        "sender_full_name": "Julius",
        "timestamp": 1700228038
    },
    {
        "content": "<p>Imagine in a genuinely practical way, you want to run some kind of unsupervised algorithm on some textual data in order to extract / discover the inherent patterns / relationships in it.</p>",
        "id": 402700179,
        "sender_full_name": "Julius",
        "timestamp": 1700228066
    },
    {
        "content": "<p>(as I wish to do.)</p>",
        "id": 402700196,
        "sender_full_name": "Julius",
        "timestamp": 1700228073
    },
    {
        "content": "<p>in a lot of conventional situation in computer science, data science, data bases, trying to extract knowledge or data sometimes comes across to me as sort of paltry, even crude. Like, SQL, labeled data... it requires you to know in advance exactly what data fields you want. it's very, very simple. like, name, age, gender, height, home address, etc.</p>",
        "id": 402700387,
        "sender_full_name": "Julius",
        "timestamp": 1700228150
    },
    {
        "content": "<p>in a lot of conventional data scenarios, you just choose in advance what \"data model\" you want, what categories are present. it may be a more elaborate process to harvest / mine textual data for information to then place into those \"buckets\". but, its like its only half of the equation, of \"extracting information\" from data... you may have used algorithms to process the data to discover the pre-defined data labels you were looking for - but your choice of data labels was arbitrary. it feels so much deeper to also generate the labels of your data, from the raw data itself: to derive them.</p>",
        "id": 402700688,
        "sender_full_name": "Julius",
        "timestamp": 1700228255
    },
    {
        "content": "<p>this brings us back to unsupervised learning, I guess.</p>\n<p>what is so appealing about unsupervised learning is that its like turning something inside out... it is not preferential. you are not choosing highly particular algorithms that will only seek certain types of patterns, to the exclusion of others. ideally, to me, the ideal unsupervised algorithm could somehow comprehensively register every possible \"relationship\" in the data. but I have struggled conceptually to define what that means.</p>",
        "id": 402700997,
        "sender_full_name": "Julius",
        "timestamp": 1700228377
    },
    {
        "content": "<p>I think this might have some overlap with Stephen wolfram's recent ideas about the \"ruliad\", which really interested me, but because im so new to this, I do not yet know if his approach would actually apply to what I am (vaguely) trying to do.</p>",
        "id": 402701159,
        "sender_full_name": "Julius",
        "timestamp": 1700228429
    },
    {
        "content": "<p>So... we look at computer memory, and we see a string of binary. But, we know that this binary has deep, highly non-arbitrary information / patterns in it. Lets say its actually an encoding of Tolstoy's War and Peace.</p>",
        "id": 402701289,
        "sender_full_name": "Julius",
        "timestamp": 1700228484
    },
    {
        "content": "<p>I am a little bit stuck here. I have more to say but maybe i need a little time to gather my thoughts.</p>",
        "id": 402701528,
        "sender_full_name": "Julius",
        "timestamp": 1700228560
    },
    {
        "content": "<p>It seems like semantics is profoundly compositional.</p>",
        "id": 402701691,
        "sender_full_name": "Julius",
        "timestamp": 1700228613
    },
    {
        "content": "<p>there are some approaches where people build concepts from a hierarchy of concepts, ultimately built from a smaller collection of semantic primitives. based on my musings, I have become pretty comfortable with the idea that this must surely be how the actual human mind works.</p>",
        "id": 402701881,
        "sender_full_name": "Julius",
        "timestamp": 1700228668
    },
    {
        "content": "<p>there is this one constructed language called Information economy meta-language by Pierre levy. <a href=\"https://journals.sagepub.com/doi/10.1177/26339137231207634\">https://journals.sagepub.com/doi/10.1177/26339137231207634</a></p>",
        "id": 402701920,
        "sender_full_name": "Julius",
        "timestamp": 1700228685
    },
    {
        "content": "<p>I think I need to come back to this. This was a good start. But I haven't really gotten to the heart of what im trying to get at.</p>\n<p>part of the idea is the hope that you can go from some sort of \"brute force\" \"hypothesis-generating\" on binary data and, if your generation of all possible \"relations\" is comprehensive, and totally ordered (you start from the simplest possible relations, and progress towards more and more \"higher order\" relations), you will eventually be able to generate a semantic knowledge graph from raw binary data. you do not need a \"particular\" from of \"feature discovery\" regarding the data's modality - i.e., it might be more conventional, if working with textual data, to apply natural language parsing before running some kind of unsupervised feature extraction algorithm; or, if working with visual data, to focus on things like edges. but this is meant to be the single most simple, general, all-encompassing \"induction\" algorithm possible, on the most abstract level possible.</p>",
        "id": 402702576,
        "sender_full_name": "Julius",
        "timestamp": 1700228895
    },
    {
        "content": "<p>I cannot justify why. but I have constantly considered that the most basic concept of a \"relation\" is co-occurrence.</p>\n<p>so in a sequence (this is the technique of n-grams, in NLP), you just count how many times \"a\" was adjacent to \"d\". you do that for every pair of characters.</p>",
        "id": 402702780,
        "sender_full_name": "Julius",
        "timestamp": 1700228971
    },
    {
        "content": "<p>we can imagine that those co-occurrences with a higher tally are important, are meaningful. if you did this on the English language, you might find in the early, simple stage of \"hypothesis generating\" that the character \".\" very often goes next to the character \" \" (because a sentence ends with a period followed by a space).</p>",
        "id": 402702943,
        "sender_full_name": "Julius",
        "timestamp": 1700229019
    },
    {
        "content": "<p>that is the simplest level of hypothesis generating: single characters, direct adjacency. but we can progress through a sequence of types of hypotheses, and we will discover new significant relationships.</p>",
        "id": 402703040,
        "sender_full_name": "Julius",
        "timestamp": 1700229065
    },
    {
        "content": "<p>I think this is very similar to how in set theory you construct all mathematical concepts like functions from a few basic ingredients. functions are actually sets of pairs. the infinite set of natural numbers is actually just the set containing one element and a successor function. you define surprisingly sophisticated concepts from very simple elements.</p>",
        "id": 402703222,
        "sender_full_name": "Julius",
        "timestamp": 1700229133
    },
    {
        "content": "<p>we can imagine roughly the same thing with the English language: we would like to express that a space also very often occurs next to a capital letter. The way we generate hypotheses will need to construct something that corresponds to the concept of \"capital letter\", in order to be able to tally that relationship (co-occurrence), and discover that it is one with a high tally - non-arbitrary.</p>",
        "id": 402703373,
        "sender_full_name": "Julius",
        "timestamp": 1700229193
    },
    {
        "content": "<p>how? pretty obvious. the concept \"capital letter\" is represented by the set of all capital letters.</p>",
        "id": 402703480,
        "sender_full_name": "Julius",
        "timestamp": 1700229225
    },
    {
        "content": "<p>Hmmm a potential problem with your picture so far is that there's no way to justify that the relationships that are \"most relevant\" will be fully contained in the data. GPT has had success only by digesting incomprehensibly vast quantities of data. A large book on its own is not going to provide sufficient context for deducing all of the pathologies of a language's grammar, let alone correctly contextualizing all of the words and identifying all of the relationships between them: what hope does a machine have of extracting an assertion in the form of a metaphor referencing human experience that is not more deeply explained in the text?<br>\nIt also seems to me that insignificant relationships could easily outweigh significant ones. Consider a text in which the entries all have a common form, such as a table with a standard set of headings. The repetition of those headings would be much easier to detect (even analysing a binary encoding of the text) than the consequent relationships between the actual contents of the tables.</p>",
        "id": 402703597,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1700229260
    },
    {
        "content": "<p>That sounds a bit negative, I'm not trying to discourage you. I would like to understand in more detail the assumptions you want to work from.</p>",
        "id": 402703748,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1700229314
    },
    {
        "content": "<p>(this was what I was writing before you responded, ill respond in a second)<br>\nbasically, the generating of hypotheses (I think) is built on three things.</p>\n<ol>\n<li>a rule for generating a sequence of \"candidates\" (single characters, then strings of 2 characters, then 3 characters).</li>\n<li>a way to define \"relationships\" (in this case, counting co-occurrence).</li>\n<li>a way to evaluate relationships. it is necessary that we sort of \"prioritize\" when we find a higher tally. that is how we discover rules.</li>\n</ol>",
        "id": 402703855,
        "sender_full_name": "Julius",
        "timestamp": 1700229350
    },
    {
        "content": "<p>where it has constantly fallen apart in my mind is an attempt to sequentially pass through \"all possibilities\".</p>",
        "id": 402704000,
        "sender_full_name": "Julius",
        "timestamp": 1700229391
    },
    {
        "content": "<p>this algorithm could discover the concept of \"noun\" on its own. why? because it will iteratively try out every single combination of characters as a candidate hypothesis. many of them will be duds. it will check bizarre hypotheses, like, \"how many times did a string like \"a___(three characters between)zx6\" occur within 7 characters of the string !e23? Answer: 0. Or perhaps in a massive data set, we get that kind of random \"noise\". we find occasional specimens, but in the scope of the data, they are negligible anomalies.</p>",
        "id": 402704286,
        "sender_full_name": "Julius",
        "timestamp": 1700229494
    },
    {
        "content": "<p>and yet, when this algorithm decides to check like, how often the class of nouns is followed by the class of verbs, it will discover an enormous tally - it will have discovered a contender for a rule of grammar.</p>",
        "id": 402704438,
        "sender_full_name": "Julius",
        "timestamp": 1700229549
    },
    {
        "content": "<p>the key thing is that it must build concepts hierarchically.</p>",
        "id": 402704461,
        "sender_full_name": "Julius",
        "timestamp": 1700229557
    },
    {
        "content": "<p>I believe this makes it a kind of \"hyper graph\", where there can be an arrow (a relation) between anything already present in the graph - a vertex, an edge, a collection of vertices an edges, a subgraph, etc.</p>",
        "id": 402704548,
        "sender_full_name": "Julius",
        "timestamp": 1700229591
    },
    {
        "content": "<p>this is how you are able to begin to discover relationships like \"woman\" and \"girl\" are similar, in some way.</p>",
        "id": 402704672,
        "sender_full_name": "Julius",
        "timestamp": 1700229618
    },
    {
        "content": "<p>I feel bad because I still haven't clearly explained what im asking. I will try to come back to this later to make it clearer and easier for people to understand what I am getting at.</p>",
        "id": 402704894,
        "sender_full_name": "Julius",
        "timestamp": 1700229672
    },
    {
        "content": "<p>I actually tried to draft an email to David spivak because im extremely interested in his work on ologs and categorical databases and stuff</p>",
        "id": 402704977,
        "sender_full_name": "Julius",
        "timestamp": 1700229695
    },
    {
        "content": "<p>but yet again I got stuck</p>",
        "id": 402704993,
        "sender_full_name": "Julius",
        "timestamp": 1700229699
    },
    {
        "content": "<p>the longterm goal is basically to build a queryable knowledge graph out of textual data</p>",
        "id": 402705104,
        "sender_full_name": "Julius",
        "timestamp": 1700229724
    },
    {
        "content": "<p>the key thing is that you do not have predefined labels / fields in advance</p>",
        "id": 402705185,
        "sender_full_name": "Julius",
        "timestamp": 1700229739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"629908\">Julius</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Open.20question.20.2F.20conversation/near/402704286\">said</a>:</p>\n<blockquote>\n<p>this algorithm could discover the concept of \"noun\" on its own. why? because it will iteratively try out every single combination of characters as a candidate hypothesis. many of them will be duds. it will check bizarre hypotheses, like, \"how many times did a string like \"a___(three characters between)zx6\" occur within 7 characters of the string !e23? Answer: 0. Or perhaps in a massive data set, we get that kind of random \"noise\". we find occasional specimens, but in the scope of the data, they are negligible anomalies.</p>\n</blockquote>\n<p>What you're describing does sound a lot like how large language models work already, by keeping track of the probabilities that certain strings of characters appear in proximity to one another. How do you imagine transitioning from that to actually extracting/labelling the concepts?</p>",
        "id": 402705231,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1700229750
    },
    {
        "content": "<p>you can query your data like, \"jobs\" \"most common\" \"2007\", and it would return a list of the most common jobs in the year 2007</p>",
        "id": 402705310,
        "sender_full_name": "Julius",
        "timestamp": 1700229768
    },
    {
        "content": "<p>anyway I will come back to this later. thank you for your consideration.</p>",
        "id": 402705351,
        "sender_full_name": "Julius",
        "timestamp": 1700229779
    },
    {
        "content": "<p>I don't think you could avoid having to name the concepts produced by whatever procedure you're working towards. Even though a LLM can correctly identify when a noun is called for, if learning unsupervised from a text how would they know that a word with that function is called a noun? A potential work-around is to have an unsupervised meta-learning task to teach the LLM grammar, but that's going to completely bias such a machine towards human-determined categorization, which might not be desirable.</p>",
        "id": 402706099,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1700229993
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277473\">Morgan Rogers (he/him)</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/Open.20question.20.2F.20conversation/near/402705231\">said</a>:</p>\n<blockquote>\n<p>How do you imagine transitioning from that to actually extracting/labelling the concepts?</p>\n</blockquote>\n<p>I haven't read all of this thread carefully, but this question caught my eye.   I'm wondering if Julius (or for that matter Morgan) is familiar with \"formal concept analysis\", a mathematical approach to extracting \"concepts\" from data.   Here's a nice introduction to it:</p>\n<ul>\n<li><span class=\"user-mention\" data-user-id=\"276935\">@Simon Willerton</span> , <a href=\"https://golem.ph.utexas.edu/category/2013/09/formal_concept_analysis.html\">Formal concept analysis</a>, <em>The n-Category Cafe</em>, September 2, 2023.</li>\n</ul>",
        "id": 402715628,
        "sender_full_name": "John Baez",
        "timestamp": 1700233046
    },
    {
        "content": "<p>Of course you need to do real work to make formal concept analysis <em>useful</em> - e.g. I used the word \"often\" without saying exactly how I would define it, but that's part of the work you need to do.</p>",
        "id": 402715923,
        "sender_full_name": "John Baez",
        "timestamp": 1700233157
    },
    {
        "content": "<p>For more, this is a great introduction:</p>\n<ul>\n<li>Tai-Danae Bradley ,Juan Luis Gastaldi, John Terilla, <a href=\"https://qcpages.qc.cuny.edu/~jterilla/main.pdf\">The structure of meaning in language: parallel narratives in linear algebra and category theory</a>.</li>\n</ul>\n<p>As you probably know, Tai-Danae is one of the best expositors in applied category theory.</p>",
        "id": 402717340,
        "sender_full_name": "John Baez",
        "timestamp": 1700233541
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"275920\">@John Baez</span> Julius already mentioned knowledge graphs, which are another formalization of the kind of structured information one might want to extract. To present the problem that I think Julius is aiming at in terms of formal concept analysis, they would want to be able to extract not only \"objects\" and \"attributes\" but also the \"relation\" between these from raw, unlabelled, binary data. I actually think that knowledge graphs are a more reasonable thing to aim for here, since the only type of attribute that Julius has proposed is that of belonging to a particular group, but I don't expect the relations determining such groups (e.g. \"occurs in similar contexts to ...\") to be transitive.</p>\n<p>In the language of knowledge graphs, I think that even if statistical measures of proximity and correlation might extract meaningful relationships between fragments of data in principle, I don't know how an unsupervised learner could learn to name or compare attributes. A mild version of this problem is that a system wouldn't be able to derive grammatical names like \"synonym\" or \"noun\" that we give to the kinds of relationship/category of word. That's fine if we can recognize these after the fact, but more problematic situations would be category errors on the part of a system: if \"synonyms\" correspond to pairs of words that are typically positionally interchangeable, then how would the system 'know' to draw the line to eliminate the pair \"(beer,wine)\" from that relation?</p>\n<p>And all of that is assuming we're in a natural language context that the system has been able to reconstruct from raw binary!</p>",
        "id": 402724152,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1700235390
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"277473\">@Morgan Rogers (he/him)</span> </p>\n<p>Thank you very much for engaging with me, this is exactly what I wanted, and it helps me so much.</p>\n<blockquote>\n<p>A potential problem with your picture so far is that there's no way to justify that the relationships that are \"most relevant\" will be fully contained in the data.</p>\n</blockquote>\n<p>You are correct, but that is an incidental problem.</p>\n<p>I want to consider the ideal scenario in order to develop a theory, with the assumption that the practical necessities of implementing the theory can be factored out entirely.</p>\n<blockquote>\n<p>What you're describing does sound a lot like how large language models work already.</p>\n</blockquote>\n<p>My idea is heavily influenced by how large language models work. A key difference is that LLMs are \"fuzzy\" (statistical, based approximately on continuous functions). My idea is 100% \"algebraic\". (This is but one point of many which I can expand on greatly - I believe my problem with my idea is that there are so many interconnected parts, and none of them are developed enough yet, so I really, really need to break it apart into modular pieces and focus rigorously on each piece.)</p>",
        "id": 402839590,
        "sender_full_name": "Julius",
        "timestamp": 1700288057
    },
    {
        "content": "<blockquote>\n<p>How do you imagine transitioning from that to actually extracting/labelling the concepts?</p>\n</blockquote>\n<p>A key part of the puzzle is this: <a href=\"https://openai.com/research/language-models-can-explain-neurons-in-language-models\">https://openai.com/research/language-models-can-explain-neurons-in-language-models</a></p>\n<p>Sometimes, it is hard to have the \"meta-knowledge\" to realize how what you know about something is very different from what other people know about something. You forget how different their picture is than yours.</p>\n<p>When ChatGPT came out, I was utterly fascinated by how it worked, what its properties and behaviors were. I tinkered with it enough to develop a personal hypothesis about it. I came to feel I had seen through the illusion, in certain ways. My view had grown to differ from say, the news buzz that came out when a Google engineer proclaimed that Lambda (Google's earlier LLM) was \"sentient\", just because it could answer conversational questions fluently in the first-person. (Again: I can expand on this.)</p>\n<p>Working on my own, at times I felt my learning progression was a kind of \"discovery\". Of course, in the vast world of AI users and researchers, many people were coming to similar conclusions at the same time, or had already known such things long before me. Regardless, when the above (to me, remarkable) paper came out, it confirmed my own train of thought. Large language models build ontologies.</p>\n<p>In <a href=\"https://en.wikipedia.org/wiki/Latent_semantic_analysis\">latent semantic analysis</a>, you can represent a concept as a set of related words. What becomes deeply insightful and philologically fascinating is how you can combine somewhat arbitrary bundles of words, like \"bag\", \"nuclear fission\", and \"emblematic\", and use things like word vectors / embeddings to figure out what \"vector\" (token, word, phrase, or string) calculates as \"most similar\". You may not have realized what they have in common, but the algorithm can surprise you by drawing a connection which fuses / synthesizes them, or at least find a context which encompasses them.</p>\n<p>There are ways in which these semantic techniques can provide conceptual knowledge to humans that is difficult and non-intuitive for them to figure out themselves, but which they can confirm seems accurate when provided with it.</p>\n<p>This is also a similar, key paradigm:</p>\n<p>\"Neural Networks are Decision Trees\"<br>\n<a href=\"https://arxiv.org/abs/2210.05189\">https://arxiv.org/abs/2210.05189</a></p>\n<p>In a way, it seems that neural networks use \"continuous mathematics\" only as a route to be able to <em>approach</em>, through gradual movement, what is a much more discrete model of the world. As is well known, the \"neurons\" in neural networks can, sometimes, be clearly interpreted, as to what factor, in a given context, they essentiallly \"decide\" on, before routing that information further to yet another (or, multiple) decisions conditional on the prior ones.</p>",
        "id": 402841321,
        "sender_full_name": "Julius",
        "timestamp": 1700289338
    },
    {
        "content": "<p>But that doesn't really answer the question you asked, and it is a very good one (for me to think about).</p>\n<p>Again, </p>\n<blockquote>\n<p>... by keeping track of the probabilities that certain strings of characters appear in proximity to one another. How do you imagine transitioning from that to actually extracting/labelling the concepts?</p>\n</blockquote>\n<p>As far as I know, what you touched upon is a very, very famous and active point of research and debate amongst LLM people, including top researchers. Google DeepMind publishes research trying to settle hard questions about what's really going inside them. Andrew Ng tweeted an article about \"OthelloGPT\", which is one point scored for the party of the slogan, \"LLMs build actual conceptual models, and therefore can actually 'think', in a limited way\".</p>\n<p>\"Language models show a surprising range of capabilities, but the source of their apparent competence is unclear. Do these networks just memorize a collection of surface statistics, or do they rely on internal representations of the process that generates the sequences they see?\"</p>\n<p>\"Emergent World Representations: Exploring a Sequence Model Trained on a Synthetic Task\"<br>\n<a href=\"https://arxiv.org/abs/2210.13382\">https://arxiv.org/abs/2210.13382</a></p>\n<hr>\n<p>I even saw a meme that summed it up nicely. It is ever so common to hear people say (exactly as I have), \"LLMs are 'statistical parrots'. They relatively mindlessly regurgitate similar-sounding blather based on a salad of similar words in some discourse. If their response sounds accurate, you got lucky. It probably just coughed up a fusion of some terms it learned from a Wikipedia article and some research papers.\"</p>\n<p>The meme goes, </p>\n<p>Person A: \"LLMs only predict the next token in a sequence of tokens.\"</p>\n<p>Person B: \"You keep using that word 'only'.\"</p>\n<p>Similar to self-driving cars, people have wondered if an apparently reductive task actually requires deep enough cognitive abilities that in order to solve that problem, you actually have to solve AGI. With LLMs, the idea is, if a system can often predict the next token relatively well, maybe that would not be possible if it did not actually have some semblance of deep conceptual understanding.</p>",
        "id": 402842352,
        "sender_full_name": "Julius",
        "timestamp": 1700290231
    },
    {
        "content": "<p>I am going to leave off on this point right now, but it is another one that I should expand on and refine.</p>\n<p>You ask how we can label the concepts learned by an LLM. The answer is, they are already roughly labeled. How? By the inputs. When you talk to an LLM, your input string is a label. The output the LLM generates is the data returned by that label. This is a succinct way of thinking about it, but requires so much more development, much more to say.</p>",
        "id": 402842796,
        "sender_full_name": "Julius",
        "timestamp": 1700290668
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"275920\">@John Baez</span> Thank you for those, they look relevant. I feel like you can guide me in developing this. You can both point me towards highly formalized and developed concepts in category theory that are the structures I am looking for, and probably also with the more soft-side of just strategies for doing research and mathematical/intellectual theorization.</p>",
        "id": 402843899,
        "sender_full_name": "Julius",
        "timestamp": 1700291480
    },
    {
        "content": "<p>I meant to post something about formal concept analysis but I see I left it as a draft.  Here it is:</p>\n<p>One nice thing about formal concept analysis is that it uses a bit of category theory.  The idea is we have a relation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> between a set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> (of words, or phrases, etc. - it doesn't matter) and a set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> (of pictures, etc. - again it doesn't matter).  This relation could be \"the word <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> is often found next to the picture <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>\".    Or anything else, but let's just use that example.   </p>\n<p>This gives a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> sending subsets of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> to subsets of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>.  The idea is that given a set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>⊆</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">S \\subseteq A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> of words we say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo><mo>⊆</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f(S) \\subseteq B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is the set of all pictures such that <em>all</em> the words in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> are often found next to those pictures.</p>",
        "id": 403244250,
        "sender_full_name": "John Baez",
        "timestamp": 1700513819
    },
    {
        "content": "<p>This map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is a map of posets from the power set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>B</mi><msup><mo stretchy=\"false\">)</mo><mtext>op</mtext></msup></mrow><annotation encoding=\"application/x-tex\">P(B)^{\\textrm{op}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord text mtight\"><span class=\"mord textrm mtight\">op</span></span></span></span></span></span></span></span></span></span></span></span></span>, where the \"op\" is thrown in because the bigger <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is, the smaller <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(S)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span></span></span></span> is.</p>\n<p>Thus - to cut a long story short, which <a href=\"https://golem.ph.utexas.edu/category/2013/09/formal_concept_analysis.html\">Simon Willerton explains</a> better than I could here - the map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> gives rise to a Galois correspondence between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span>.   And the \"fixed points\" of this Galois correspondence are called <strong>concepts</strong>, because they really do act a lot like concepts.</p>",
        "id": 403244416,
        "sender_full_name": "John Baez",
        "timestamp": 1700513918
    },
    {
        "content": "<p>Nitpick: I think it's usually called a Galois connection. A Galois correspondence is a Galois connection where the two contravariant maps (one from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span>, the other one the other way) are inverse to each other.</p>",
        "id": 403249997,
        "sender_full_name": "Todd Trimble",
        "timestamp": 1700516413
    },
    {
        "content": "<p>Okay, thanks, I didn't know they had separate names.</p>",
        "id": 403250928,
        "sender_full_name": "John Baez",
        "timestamp": 1700516931
    },
    {
        "content": "<p>Or maybe I did know, once....</p>",
        "id": 403250969,
        "sender_full_name": "John Baez",
        "timestamp": 1700516959
    },
    {
        "content": "<p>Thanks.<br>\nI’m going to read those papers, but first I should reason a bit more on my own, as I need to make sure I know what I’m looking for. <br>\nI wrote a draft of an introduction to a paper about this.</p>",
        "id": 403526876,
        "sender_full_name": "Julius",
        "timestamp": 1700633848
    },
    {
        "content": "<p>There is an informal philosophical idea that I hope could made more precise mathematically, and there is a chance Wolfram’s “ruliology” does that. <br>\nThe idea is that whatever we call “information”, it requires a pre-existing context in which it is expressed.<br>\nI think that Wolfram’s “multi-way systems” have a way of showing how information has a relationship to an “observer”.</p>",
        "id": 403527352,
        "sender_full_name": "Julius",
        "timestamp": 1700634087
    },
    {
        "content": "<p>I think Wolfram believes that a ruliad exists. I think Andrej Bauer believes it does not, and we have to embrace that we live in a logical “multiverse”.<br>\nIn either case, it helps me try to define “all possible hypotheses”, for induction on arbitrary data. The idea may be misguided; there are different algorithms which lead to different constructions on the data. We need not seek a single unifying one.</p>",
        "id": 403527901,
        "sender_full_name": "Julius",
        "timestamp": 1700634408
    }
]