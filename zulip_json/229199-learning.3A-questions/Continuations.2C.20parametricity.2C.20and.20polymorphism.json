[
    {
        "content": "<p>Are you all requiring function extensionality (not just eta) for both -&gt; and forall in your definition of model for system F?  I usually don't but some of these older papers do</p>",
        "id": 527056316,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751568396
    },
    {
        "content": "<p>I wouldn't.</p>",
        "id": 527058413,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751569298
    },
    {
        "content": "<p>Section 3 of Tannen Coquand ('Extensional Models for Polymorphism', <a href=\"https://repository.upenn.edu/server/api/core/bitstreams/4eed61a9-05c6-453e-be1e-58b5f5f47bbd/content\">https://repository.upenn.edu/server/api/core/bitstreams/4eed61a9-05c6-453e-be1e-58b5f5f47bbd/content</a>) gives a (the?) closed term model of system F, shows that it is not extensional, and shows how you can quotient it to get extensionality (section 4).  (That it satisfies betais stated earlier on page 11.)  So it seems like the closed term model may be parametric but not extensional, if that's even possible?  Anyway, is the Tannen Coquand model equivalent to what people understand as the system F term model?  FWIW I think both this thread and the HRR conclusion paragraph use \"true in the term model\" accidentally instead of \"true in all models/provable from beta/eta alone\" in many places</p>",
        "id": 527064108,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751572243
    },
    {
        "content": "<p>Hang on, I don't even know what funext means in a non-dependent type theory.</p>",
        "id": 527065691,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751573040
    },
    {
        "content": "<p>Oh, do you mean the axioms on p12 of TC, that functions are determined by their action on \"elements\"? That doesn't even make sense for a category theoretic model where types don't have \"elements\".</p>",
        "id": 527066266,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751573314
    },
    {
        "content": "<p>You could interpret elements as global elements i.e. maps from the terminal object, which in the term model are closed terms, but I certainly wouldn't expect functions in the term model to be determined by their action on closed terms.</p>",
        "id": 527066528,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751573452
    },
    {
        "content": "<p>The paper writes the condition semantically, but you can just as easily add proof rules to the system F calculus (from x:T |- f x = g x for fresh var x infer |- f = g), which is usually what I've seen</p>",
        "id": 527066582,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751573480
    },
    {
        "content": "<p>That's a different condition, that's just eta-conversion.</p>",
        "id": 527066898,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751573649
    },
    {
        "content": "<p>I do not believe funext and eta are equivalent here, or even in dependent type theories, although eta is a special case of funext</p>",
        "id": 527066962,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751573682
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281326\">Ryan Wisnesky</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/synthetic.20algebraic.20geometry.20vs.20continuation.20passing.20style/near/527064108\">said</a>:</p>\n<blockquote>\n<p>I think both this thread and the HRR conclusion paragraph use \"true in the term model\" accidentally instead of \"true in all models/provable from beta/eta alone\" in many places</p>\n</blockquote>\n<p>Those should always be the same.  That's part of the point of the term model, that it satisfies only the provable equations and hence gives you completeness of the semantics.</p>",
        "id": 527066978,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751573691
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281326\">Ryan Wisnesky</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/synthetic.20algebraic.20geometry.20vs.20continuation.20passing.20style/near/527066962\">said</a>:</p>\n<blockquote>\n<p>I do not believe funext and eta are equivalent here, or even in dependent type theories, although eta is a special case of funext</p>\n</blockquote>\n<p>Correct.  But this rule:</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi>x</mi><mo>:</mo><mi>T</mi><mo>⊢</mo><mi>f</mi><mtext> </mtext><mi>x</mi><mo>=</mo><mi>g</mi><mtext> </mtext><mi>x</mi></mrow><mrow><mo>⊢</mo><mi>f</mi><mo>=</mo><mi>g</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{x:T \\vdash f\\,x = g\\,x}{\\vdash f =g }</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.2519em;vertical-align:-0.8804em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>is eta, not funext.</p>",
        "id": 527067038,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751573720
    },
    {
        "content": "<p>(As long as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">=</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">=</span></span></span></span> means definitional equality, and in a non-dependent type theory there's nothing else for it to mean.)</p>",
        "id": 527067090,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751573745
    },
    {
        "content": "<p>hm, I grabbed the phrasing from Coq: Lemma functional_extensionality {A B} (f g : A -&gt; B) :<br>\n  (forall x, f x = g x) -&gt; f = g.  What did I do wrong?  (it's a lemma b/c uses the dependent ext axiom)</p>",
        "id": 527067842,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751574143
    },
    {
        "content": "<p>also: the term model should satisfy a lot more equations than just what is provable in the rules for system F.   (The Tannen Coquand paper talks about this a bit).  For example, the term model of O:nat and S:nat-&gt;nat and + proves x+y=y+x for variable x, whereas an arbitrary model does not.  (at least if we're talking in Set, following Baader and Nipkow.). I thought this was the reason initial model semantics was \"good\" - you get all these extra properties not found in arbitrary models.</p>",
        "id": 527068845,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751574685
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281326\">Ryan Wisnesky</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/synthetic.20algebraic.20geometry.20vs.20continuation.20passing.20style/near/527067842\">said</a>:</p>\n<blockquote>\n<p>hm, I grabbed the phrasing from Coq: Lemma functional_extensionality {A B} (f g : A -&gt; B) :  (forall x, f x = g x) -&gt; f = g.  What did I do wrong?  (it's a lemma b/c uses the dependent ext axiom)</p>\n</blockquote>\n<p>In that axiom <code>=</code> means <em>propositional</em> equality.</p>",
        "id": 527069428,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751574999
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281326\">Ryan Wisnesky</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/synthetic.20algebraic.20geometry.20vs.20continuation.20passing.20style/near/527068845\">said</a>:</p>\n<blockquote>\n<p>For example, the term model of O:nat and S:nat-&gt;nat and + proves x+y=y+x for variable x, whereas an arbitrary model does not.</p>\n</blockquote>\n<p>Not in any term model I'm familiar with.  What is your definition of \"term model\"?  I have always understood the term model to consist <em>by definition</em> of the terms modulo definitional equality.</p>\n<p>Remember we are talking about term models with <em>open</em> terms.</p>",
        "id": 527069597,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751575097
    },
    {
        "content": "<p>It looks to me like that's exactly what TC do in their section 3.</p>",
        "id": 527069790,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751575201
    },
    {
        "content": "<p>They don't call it a \"model\" because they want to save that word for something that satisfies their additional semantic extensionality property, which of course the term model doesn't.  But their section 3 is really the \"term model\".</p>",
        "id": 527069887,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751575253
    },
    {
        "content": "<p>I'm following Baader and Nipkow re: term algebras.  <br>\n<a href=\"/user_uploads/21317/JOELAzAdZYJjMHWErgyMiHNE/Screenshot-2025-07-03-at-1.46.44PM.png\">Screenshot 2025-07-03 at 1.46.44 PM.png</a><br>\n<a href=\"/user_uploads/21317/FeaDdSklzNQwclYkEPhtN2BJ/Screenshot-2025-07-03-at-1.48.37PM.png\">Screenshot 2025-07-03 at 1.48.37 PM.png</a><br>\n<a href=\"/user_uploads/21317/0YZCaWmrJ1sQ0A3jD7qyky-E/Screenshot-2025-07-03-at-1.48.28PM.png\">Screenshot 2025-07-03 at 1.48.28 PM.png</a><br>\n<a href=\"/user_uploads/21317/zpsFoQA6HuOrCpvdMQ0UDcZO/Screenshot-2025-07-03-at-1.47.58PM.png\">Screenshot 2025-07-03 at 1.47.58 PM.png</a><br>\n<a href=\"/user_uploads/21317/8VV7iRVVuutcUNbU0-8Qdewq/Screenshot-2025-07-03-at-1.47.32PM.png\">Screenshot 2025-07-03 at 1.47.32 PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/JOELAzAdZYJjMHWErgyMiHNE/Screenshot-2025-07-03-at-1.46.44PM.png\" title=\"Screenshot 2025-07-03 at 1.46.44 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1274x406\" src=\"/user_uploads/thumbnail/21317/JOELAzAdZYJjMHWErgyMiHNE/Screenshot-2025-07-03-at-1.46.44PM.png/840x560.webp\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/21317/FeaDdSklzNQwclYkEPhtN2BJ/Screenshot-2025-07-03-at-1.48.37PM.png\" title=\"Screenshot 2025-07-03 at 1.48.37 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1284x274\" src=\"/user_uploads/thumbnail/21317/FeaDdSklzNQwclYkEPhtN2BJ/Screenshot-2025-07-03-at-1.48.37PM.png/840x560.webp\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/21317/0YZCaWmrJ1sQ0A3jD7qyky-E/Screenshot-2025-07-03-at-1.48.28PM.png\" title=\"Screenshot 2025-07-03 at 1.48.28 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1290x210\" src=\"/user_uploads/thumbnail/21317/0YZCaWmrJ1sQ0A3jD7qyky-E/Screenshot-2025-07-03-at-1.48.28PM.png/840x560.webp\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/21317/zpsFoQA6HuOrCpvdMQ0UDcZO/Screenshot-2025-07-03-at-1.47.58PM.png\" title=\"Screenshot 2025-07-03 at 1.47.58 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1300x650\" src=\"/user_uploads/thumbnail/21317/zpsFoQA6HuOrCpvdMQ0UDcZO/Screenshot-2025-07-03-at-1.47.58PM.png/840x560.webp\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/21317/8VV7iRVVuutcUNbU0-8Qdewq/Screenshot-2025-07-03-at-1.47.32PM.png\" title=\"Screenshot 2025-07-03 at 1.47.32 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1314x1728\" src=\"/user_uploads/thumbnail/21317/8VV7iRVVuutcUNbU0-8Qdewq/Screenshot-2025-07-03-at-1.47.32PM.png/840x560.webp\"></a></div>",
        "id": 527070869,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751575767
    },
    {
        "content": "<p>example 3.5.9 shows there are equations that hold in the term algebra that don't hold in arbitrary algebras</p>",
        "id": 527071084,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751575876
    },
    {
        "content": "<p><a href=\"/user_uploads/21317/VQaSZazKwK66xKFtcKCsOk3o/Screenshot-2025-07-03-at-1.53.58PM.png\">Screenshot 2025-07-03 at 1.53.58 PM.png</a><br>\nBaader and Nipkow even define and name the theory of the term model (showing it is more than just the theory started with)</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/VQaSZazKwK66xKFtcKCsOk3o/Screenshot-2025-07-03-at-1.53.58PM.png\" title=\"Screenshot 2025-07-03 at 1.53.58 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1278x256\" src=\"/user_uploads/thumbnail/21317/VQaSZazKwK66xKFtcKCsOk3o/Screenshot-2025-07-03-at-1.53.58PM.png/840x560.webp\"></a></div>",
        "id": 527071552,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751576123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/synthetic.20algebraic.20geometry.20vs.20continuation.20passing.20style/near/527069597\">said</a>:</p>\n<blockquote>\n<p>Remember we are talking about term models with <em>open</em> terms.</p>\n</blockquote>",
        "id": 527072005,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751576365
    },
    {
        "content": "<p>I thought the TC section 3 builds a model out of closed terms?  that's why they need all the environment machinery?  <br>\n<a href=\"/user_uploads/21317/VlXvN-M6mTLofcAY3uRQAPq-/Screenshot-2025-07-03-at-1.59.15PM.png\">Screenshot 2025-07-03 at 1.59.15 PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/VlXvN-M6mTLofcAY3uRQAPq-/Screenshot-2025-07-03-at-1.59.15PM.png\" title=\"Screenshot 2025-07-03 at 1.59.15 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1778x716\" src=\"/user_uploads/thumbnail/21317/VlXvN-M6mTLofcAY3uRQAPq-/Screenshot-2025-07-03-at-1.59.15PM.png/840x560.webp\"></a></div>",
        "id": 527072057,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751576392
    },
    {
        "content": "<p>In a theory with function-types, you can get away with using only closed terms because an open term can be abstracted over its free variables to yield a closed term.</p>",
        "id": 527072216,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751576454
    },
    {
        "content": "<p>certainly they claim in the conclusion that their model \"C\" is made entirely of closed terms</p>",
        "id": 527072241,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751576468
    },
    {
        "content": "<p>But for instance the observation you quoted about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>≈</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo separator=\"true\">,</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x,y)\\approx f(y,x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> is not true in a term model with open terms, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> are free variables.</p>",
        "id": 527072305,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751576501
    },
    {
        "content": "<p>sure, but I don't see how TC section 3 has free variables or open terms anywhere in its definition.  This is why I think the term model for system F should have all kinds of equations true in it that aren't implied by the theory of F.  The interpretation of a sequent that has variables in context uses the \"environment\" rather than an open term (a trick from closed term models of simply typed lambda calculus).  I'd also be surprised they'd call it the \"closed term/closed type construction\" if it used open terms.</p>",
        "id": 527072489,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751576609
    },
    {
        "content": "<p>I will agree that a model of system F with open terms as carrier will prove a lot less things than one with closed terms as carrier, according to my intuition</p>",
        "id": 527072634,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751576688
    },
    {
        "content": "<p>Okay, let's back up.  Really explaining this in depth is going to require a broader view.</p>",
        "id": 527083809,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751583369
    },
    {
        "content": "<p>I'm going to write to Prof Tannen.  I think he might be able to settle some questions (eg is there an equation true in his term model of system F that doesn't follow from beta/eta) faster than us trying to work through his definitions</p>",
        "id": 527083866,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751583412
    },
    {
        "content": "<p>(The answer to that specific question is that it depends on what you mean by \"equation\" and \"true\", which I'll get to in a bit.)</p>",
        "id": 527083903,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751583446
    },
    {
        "content": "<p>I do want to keep pressing on the (a?) closed term model of system F (instead of the open model), however, because to me that is what formalizes \"idealized haskell w/o recursion\"; it's what I have in my head when I write a big step operational semantics (the target is the closed term model)</p>",
        "id": 527083924,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751583461
    },
    {
        "content": "<p>Every theory is written in a \"doctrine\" that specifies the allowable judgment forms.  You can extend a theory to a more expressive doctrine, and we often blur the distinction between a theory and its extension, but formally they are different and it's sometimes important to distinguish.</p>",
        "id": 527083967,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751583483
    },
    {
        "content": "<p>In particular, the term model of a theory is built out of the judgment forms that are derivable in its syntax.  But what those are depends also on the doctrine, and thus the term model for a theory is different depending on what doctrine you write it in.</p>",
        "id": 527084093,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751583577
    },
    {
        "content": "<p>Theories like STLC and System F are written in doctrines whose judgment forms include contexts of variables, such as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>:</mo><mi>B</mi><mo>⊢</mo><mi>t</mi><mo>:</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">x:A, y:B \\vdash t:C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>.  Thus, their term models are built out of judgments of that sort, which are of course open terms.</p>",
        "id": 527084150,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751583607
    },
    {
        "content": "<p>The doctrine of STLC, with only \"term variables\", can be called \"simple type theory\", while the doctrine of System F, which also has type variables, could be called \"polymorphic type theory\".</p>",
        "id": 527084277,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751583660
    },
    {
        "content": "<p>well sure, the closed term model of TC interprets judgements with variables in context, but the carrier for their interpretation is not open terms</p>",
        "id": 527084373,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751583734
    },
    {
        "content": "<p>Let me finish please.</p>",
        "id": 527084389,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751583743
    },
    {
        "content": "<p>The term model of a simple type theory is most directly viewed as some kind of multicategory, whose objects are the types and whose multi-morphisms such as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">(A,B) \\to C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> are terms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>:</mo><mi>B</mi><mo>⊢</mo><mi>t</mi><mo>:</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">x:A ,y:B \\vdash t:C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>.  However, it's common to view it instead as an ordinary category whose objects are contexts (lists of types), and whose morphisms are substitutions (lists of terms).</p>\n<p>If the theory has product types, this is equivalent to a category whose objects are single types and whose morphisms are terms in a singleton context such as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>t</mi><mo>:</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">x:A \\vdash t:C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>.  And even if the theory doesn't have product types, we can consider that category for simplicity.</p>",
        "id": 527084559,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751583864
    },
    {
        "content": "<p>If the theory has <em>function</em> types, then there is a bijection between open terms such as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>:</mo><mi>B</mi><mo>⊢</mo><mi>t</mi><mo>:</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">x:A, y:B \\vdash t:C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> and closed terms of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">A\\to B\\to C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>.  Thus, <em>in this case</em> we could equivalently build the term model using only closed terms.  This is what TC do in section 3, modulo some rearranging of their presentation to become a category, and ignoring the relation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊨</mo></mrow><annotation encoding=\"application/x-tex\">\\vDash</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6922em;\"></span><span class=\"mrel amsrm\">⊨</span></span></span></span> which I haven't gotten to yet.</p>",
        "id": 527084714,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751583995
    },
    {
        "content": "<p>In particular, the <em>equality</em> between terms in the section 3 model is the equivalence relation that they call <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>G</mi><mi>ω</mi></msub></mrow><annotation encoding=\"application/x-tex\">G_\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">ω</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, which is defined to be the definitional equality of syntax.  Thus, their term model <em>qua</em> category, like every term model, validates all and only the statements <em>in the doctrine</em> that are derivable in the theory.</p>",
        "id": 527084869,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751584108
    },
    {
        "content": "<p>So what about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊨</mo></mrow><annotation encoding=\"application/x-tex\">\\vDash</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6922em;\"></span><span class=\"mrel amsrm\">⊨</span></span></span></span>.</p>",
        "id": 527084886,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751584121
    },
    {
        "content": "<p>In general it is true that a term model can satisfy additional statements that are <em>not in its doctrine</em>.</p>",
        "id": 527084918,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751584147
    },
    {
        "content": "<p>in Baader-Nipkow example 3.5.9, the extra equations it satisfies are not part of the doctrine of the original equational theory?</p>",
        "id": 527085118,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751584312
    },
    {
        "content": "<p>Right!</p>",
        "id": 527085173,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751584362
    },
    {
        "content": "<p>Ok, I'll need to pause to consider that.  I've never really used doctrines before, and Baader/Nipkow don't talk about that point at all</p>",
        "id": 527085218,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751584402
    },
    {
        "content": "<p>If we formulate a simple algebraic theory in a doctrine <em>without</em> contexts, there is just one judgment <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mtext> </mtext><mrow><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">m</mi></mrow></mrow><annotation encoding=\"application/x-tex\">t\\, \\mathrm{term}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">term</span></span></span></span></span>, with rules such as</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi>s</mi><mtext> </mtext><mrow><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">m</mi></mrow><mspace width=\"1em\"/><mi>t</mi><mtext> </mtext><mrow><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">m</mi></mrow></mrow><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo separator=\"true\">,</mo><mi>t</mi><mo stretchy=\"false\">)</mo><mtext> </mtext><mrow><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">m</mi></mrow></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{s\\,\\mathrm{term} \\quad t\\,\\mathrm{term}}{f(s,t) \\,\\mathrm{term}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.2281em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.2921em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">term</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">term</span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">term</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>",
        "id": 527085257,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751584429
    },
    {
        "content": "<p>(Doctrines are indeed under-explained!)</p>",
        "id": 527085325,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751584491
    },
    {
        "content": "<p>here you are talking about ground terms only (b/c no contexts)?</p>",
        "id": 527085331,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751584498
    },
    {
        "content": "<p>Exactly.</p>",
        "id": 527085342,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751584503
    },
    {
        "content": "<p>Then the term model in this doctrine is the set of all (\"closed\") terms such as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(a,f(f(b,a),b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span> built only from the constants <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo separator=\"true\">,</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">a,b,f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> and no \"variables\".</p>",
        "id": 527085358,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751584524
    },
    {
        "content": "<p>right</p>",
        "id": 527085379,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751584548
    },
    {
        "content": "<p>A statement like \"for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo separator=\"true\">,</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x,y)=f(y,x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>\" is not in this doctrine, and so it can hold in the term model even though it isn't \"derivable from the theory\".</p>",
        "id": 527085405,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751584567
    },
    {
        "content": "<p>However, we can also extend this theory to the doctrine of a simple type theory with judgments in context like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">x:A, y:A \\vdash f(x,y):A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊢</mo><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">\\vdash a:A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is the unique type.  In this case, the term model will be the (multi)category freely generated by a semigroup object containing two elements that commute with each other.  Of course such a semigroup need not be abelian, and therefore the two morphisms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">(A,A)\\to A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> determined by the terms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">x:A, y:A \\vdash f(x,y):A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo separator=\"true\">,</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">x:A, y:A \\vdash f(y,x):A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> are not the same, and so this term model does <em>not</em> satisfy the equation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo separator=\"true\">,</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">x:A, y:A \\vdash f(x,y)=f(y,x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, which <em>is</em> in its doctrine.</p>",
        "id": 527085425,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751584591
    },
    {
        "content": "<p>right, I'm still following.  But for example 3.5.9, why isn't that equation that is only true in the term model not in the original doctrine (which had variables in context in its initial set of equations)</p>",
        "id": 527085552,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751584719
    },
    {
        "content": "<p>It <em>will</em> satisfy a statement like \"for all closed terms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊢</mo><mi>s</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">\\vdash s:A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊢</mo><mi>t</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">\\vdash t:A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊢</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo separator=\"true\">,</mo><mi>t</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo separator=\"true\">,</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\vdash f(s,t) = f(t,s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span>\", but this is <em>not</em> in its doctrine, since simple type theory does not include a way to quantify over <em>closed</em> terms.</p>",
        "id": 527085568,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751584729
    },
    {
        "content": "<p>(also, I understand why function extensionality as I wrote it doesn't fit with system's F equational logic (it just follows from eta), albeit not b/c of a hyper doctrine reason.  I'd never tried writing fun-ext outside of coq before)</p>",
        "id": 527085733,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751584902
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281326\">Ryan Wisnesky</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/synthetic.20algebraic.20geometry.20vs.20continuation.20passing.20style/near/527085552\">said</a>:</p>\n<blockquote>\n<p>But for example 3.5.9, why isn't that equation that is only true in the term model not in the original doctrine (which had variables in context in its initial set of equations)</p>\n</blockquote>\n<p>Yes, good point.  If we want to capture that whole example in a doctrine without contexts, we would have to include associativity in the doctrine itself rather than in the theory.  So it would be in the doctrine of semigroups, and the theory in that doctrine would be the theory of two commuting elements, and so the term model would be the free semigroup generated by two commuting elements.  (This is just like how associativity for morphism composition in a category, i.e. substitution of terms, is included in the doctrine of simple type theory, but not expressible <em>in</em> any theory in that doctrine.)</p>",
        "id": 527085905,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751585052
    },
    {
        "content": "<p>So, to conclude, the TC relation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊨</mo></mrow><annotation encoding=\"application/x-tex\">\\vDash</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6922em;\"></span><span class=\"mrel amsrm\">⊨</span></span></span></span> is a way of expressing statements about closed terms, which is not in the doctrine of simple type theory, and so the term model can satisfy statements of that form that are not derivable from the theory.</p>",
        "id": 527085968,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751585113
    },
    {
        "content": "<p>ooh, heh, I get it now... I think.  the \"doctrine\" defines what freeness is relative to.  In which case, example 3.5.9 is \"different\" when you view it as the three axiom equational theory over the empty theory (as I do), or as a single ground equation over two (universally quantified) equations... right?</p>",
        "id": 527086072,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751585203
    },
    {
        "content": "<p>Yes!</p>",
        "id": 527086332,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751585425
    },
    {
        "content": "<p>I wrote a longish blog post about doctrines, and more general \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>-theories\", <a href=\"https://golem.ph.utexas.edu/category/2018/04/what_is_an_ntheory.html\">here</a>.</p>",
        "id": 527086352,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751585441
    },
    {
        "content": "<p>ok, that explains (some of) the confusion with term models.  For me (and I'd imagine TC), we just assume every statement in first order logic about the model is fair game to distinguish the models</p>",
        "id": 527086459,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751585526
    },
    {
        "content": "<p>incidentally, CQL may provide a good example of \"stacking\" doctrines, its \"instances\" are theories in the doctrine of its schema which is a theory in the doctrine of its \"typeside\", if I understand correctly.  Implementation-wise these are just theories that extend each other, but there are very specific rules about what kind of equations can be written where in this stack.</p>",
        "id": 527086573,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751585627
    },
    {
        "content": "<p>The confusion is that the TC syntax for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊨</mo></mrow><annotation encoding=\"application/x-tex\">\\vDash</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6922em;\"></span><span class=\"mrel amsrm\">⊨</span></span></span></span> <em>looks</em> the same as the syntax for definitional equality <em>in</em> the doctrine.  It would be better if instead of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊨</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>:</mo><mi>B</mi><mo separator=\"true\">;</mo><mi>M</mi><mo>=</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">\\vDash x:A, y:B ; M = N </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6922em;\"></span><span class=\"mrel amsrm\">⊨</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> they wrote something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo>⊢</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mo>⊢</mo><mi>y</mi><mo>:</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>⊨</mo><mo stretchy=\"false\">(</mo><mo>⊢</mo><mi>M</mi><mo>=</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\vdash x:A), (\\vdash y:B) \\vDash (\\vdash M = N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">⊨</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 527086602,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751585656
    },
    {
        "content": "<p>Yes, a doctrine is a 2-theory, which is a 2-theory in some 2-doctrine (= 3-theory), and so on.</p>",
        "id": 527086692,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751585737
    },
    {
        "content": "<p>I think im still going to write to prof. tannen asking about properties true in his closed term model that don't follow from beta/eta, but then we can check them to see if they fall into the expected doctrine or not.  does that sound like a good next step?</p>",
        "id": 527086791,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751585822
    },
    {
        "content": "<p>What's the goal?</p>",
        "id": 527086885,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751585900
    },
    {
        "content": "<p>I want to know if HRR's Q = S is true in the closed TC model, even if that question is ill-posed doctrinally.  It's true in the closed TC model after they collapse it, because collapse creates a PER model</p>",
        "id": 527086939,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751585946
    },
    {
        "content": "<p>Do they say that?</p>",
        "id": 527087073,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751586066
    },
    {
        "content": "<p>no one has made that claim, it's a claim I need to figure out to check my understanding</p>",
        "id": 527087102,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751586091
    },
    {
        "content": "<p>I mean, do they claim that it's true after the collapse?</p>",
        "id": 527087110,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751586100
    },
    {
        "content": "<p>I think they say collapse results in a PER somewhere, I'll go find the reference</p>",
        "id": 527087170,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751586139
    },
    {
        "content": "<p>I want to not be too blithe about it, because there could be multiple meanings of what \"being a PER model\" is, and it doesn't seem to me that simply <em>quotienting</em> the term model could create the kind of \"PER model\" that makes Q=S.</p>",
        "id": 527087269,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751586224
    },
    {
        "content": "<p>lemma 4.3 says something is a PER, although maybe not the kind of PER HRR talk about</p>",
        "id": 527087271,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751586226
    },
    {
        "content": "<p>I'll ask prof tannen the question both pre-collapse and post-collapse</p>",
        "id": 527087299,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751586254
    },
    {
        "content": "<p>Okay.  Pre-collapse we know that it is not true in the ordinary sense as a statement about the term model <em>qua</em> category, because of the HRR counterexample.  But I guess there may be a way to interpret it as a different statement involving <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊨</mo></mrow><annotation encoding=\"application/x-tex\">\\vDash</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6922em;\"></span><span class=\"mrel amsrm\">⊨</span></span></span></span>, which might be true.</p>",
        "id": 527087435,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751586371
    },
    {
        "content": "<p>my hunch is all these properties that are ruled out doctrinally actually do conspire to equate Q=S in the specific closed term model of TC, and HRR meant open term model or \"all models\"</p>",
        "id": 527087525,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751586463
    },
    {
        "content": "<p>I'm not sure what you mean by hyper-doctrinally.  I haven't been talking about any hyperdoctrines.</p>",
        "id": 527087663,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751586582
    },
    {
        "content": "<p>oh, sorry, I've been saying hyper doctrine on accident, I just mean \"doctrine\"</p>",
        "id": 527087716,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751586627
    },
    {
        "content": "<p>I also don't know what you mean by distinguishing the closed term model and open term model.  As I said, I think there is no difference between them in a theory with function types; what makes the difference is what's in the doctrine.</p>",
        "id": 527087753,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751586659
    },
    {
        "content": "<p>Oh, I see.  It's very confusing that a \"hyperdoctrine\" is totally unrelated to a \"doctrine\" in this sense.</p>",
        "id": 527087776,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751586674
    },
    {
        "content": "<p>I'll find the reference - I think it was hasegawa - who was talking about the differences between the open and closed term models of system F</p>",
        "id": 527087816,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751586721
    },
    {
        "content": "<p><a href=\"/user_uploads/21317/wMitl2iz97bP7V06Tnb_zWHo/Screenshot-2025-07-03-at-4.53.29PM.png\">Screenshot 2025-07-03 at 4.53.29 PM.png</a><br>\nYeah, it hasegawa (Parametricity of extensionally collapsed term models of polymorphism and their categorical properties) from here: <a href=\"https://link.springer.com/chapter/10.1007/3-540-54415-1_61\">https://link.springer.com/chapter/10.1007/3-540-54415-1_61</a> .  so a priori I claim open and closed models can be different, even if those differences may not be visible doctrinally.  Paper attached<br>\n<a href=\"/user_uploads/21317/5W0lFvopS5ghJfPMHgNjHA88/3-540-54415-1_61.pdf\">3-540-54415-1_61.pdf</a>.  It also \"proves\" an identity extension lemma without giving the proof</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/wMitl2iz97bP7V06Tnb_zWHo/Screenshot-2025-07-03-at-4.53.29PM.png\" title=\"Screenshot 2025-07-03 at 4.53.29 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1144x312\" src=\"/user_uploads/thumbnail/21317/wMitl2iz97bP7V06Tnb_zWHo/Screenshot-2025-07-03-at-4.53.29PM.png/840x560.webp\"></a></div>",
        "id": 527087920,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751586828
    },
    {
        "content": "<p>while we're revisiting very basic assumptions, I always thought the logical relations lemma was proved by induction on closed terms or types, so it surprises me when a closed term model isn't parametric.  but as this thread makes clear, I'm full of erroneous assumptions if someone wants to correct this one too</p>",
        "id": 527088367,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751587247
    },
    {
        "content": "<p>I can't get to that paper either, so I don't know what this putative closed term model might mean.  But I do know that it's nearly impossible to prove anything by induction only over closed terms: when you get to the case for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda x. M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>, you don't have an inductive hypothesis since <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> isn't a closed term any more.  The logical relations lemma that I know is proved by induction (i.e. by the universal property) on the ordinary (open) term model.  (And, remember that that's only external parametricity.)</p>",
        "id": 527093185,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751591906
    },
    {
        "content": "<p>Oh, I see you attached the paper now, let me see.</p>",
        "id": 527093206,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751591931
    },
    {
        "content": "<p>fyi: hasegawa's remark 4.8 mentions something quite similar to HRR's a ~ CPS a</p>",
        "id": 527093760,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751592418
    },
    {
        "content": "<p>Well, I can't make heads or tails of Hasegawa's introduction, and nowhere in the paper do I see a definition of what he means by a model of open terms.  His model of \"closed terms\" (which he calls just an \"interpretation\") looks to me like it is equivalent to I would call the ordinary term model, by the trick that I mentioned of abstracting open terms to make them closed.</p>",
        "id": 527094165,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751592748
    },
    {
        "content": "<p>Ohh... maybe by \"open terms\" he means a model in which the \"elements\" of a type are the <em>union</em> of the terms of that type in <em>all</em> contexts?  Or, put more categorically, in which the morphisms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">t:(A,B)\\to C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> are terms of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Γ</mi><mi>t</mi></msub><mo separator=\"true\">,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>:</mo><mi>B</mi><mo>⊢</mo><mi>t</mi><mo>:</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma_t, x:A, y:B \\vdash t:C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> for some additional context <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Γ</mi><mi>t</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\Gamma_t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, which could be different for different morphisms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span>?</p>",
        "id": 527094298,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751592893
    },
    {
        "content": "<p>I've seen people do things like that for untyped lambda-calculus, so maybe people do it for typed lambda-calculus too.  It certainly wouldn't be the initial model, but it might be useful for some things.</p>",
        "id": 527094362,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751592946
    },
    {
        "content": "<p>if the trick of an interpreting a term in context via its corresponding closed lambda term really set up an equivalence of models, why would the closed one fail to be extensional but the open would not?  my intuition is that these closed models must be doing something differently than just using the equivalent lambda term or there wouldn't be all these papers by well-known authors about how to turn the closed model extensional... but we might be approaching the point where it's easiest to ask the authors</p>",
        "id": 527094611,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751593184
    },
    {
        "content": "<p>It's an equivalence between what TC and Hasegawa call the \"closed term model\" and what I call \"the term model\" which involves terms in context that only use the variables from that context.  I don't think the latter is what Hasegawa means by an \"open term model\" -- I think he means what I suggested above, where the terms can also involve additional free variables that <em>aren't</em> in the context.  That model can be \"extensional\" for trivial reasons because you can always apply two functions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo separator=\"true\">,</mo><mi>g</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f,g:A\\to B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> to a free variable <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">x:A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> and then if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mtext> </mtext><mi>x</mi><mo>=</mo><mi>g</mi><mtext> </mtext><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">f\\,x = g\\,x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> it must be that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">f=g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> by eta.</p>",
        "id": 527096442,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751594901
    },
    {
        "content": "<p>I renamed this discussion because it has veered far from the original topic of comparing synthetic algebraic geometry to continuations. This deviation happened at the beginning of the discussion once it became clear that the SQC axiom wasn't all that similar to the axioms that types are isomorphic to its continuations.</p>",
        "id": 527097219,
        "sender_full_name": "Madeleine Birchfield",
        "timestamp": 1751595726
    },
    {
        "content": "<p>I found and attached the paper hasegawa cites when he says \"the open model is used to prove completeness\".  section 3 uses an argument like you just made, but I can't settle your question from reading it quite yet.  <br>\n<a href=\"/user_uploads/21317/5I8Bv2ep8mdkE0HPbSRVcMpW/second-order-semantics.pdf\">second-order-semantics.pdf</a></p>",
        "id": 527097499,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751596069
    },
    {
        "content": "<p><a href=\"/user_uploads/21317/4_Me2iq2JEt98ysq3qOCmQo2/Screenshot-2025-07-05-at-4.39.55PM.png\">Screenshot 2025-07-05 at 4.39.55 PM.png</a><br>\n<a href=\"/user_uploads/21317/B57R4zVfIKZAVbfPr7sERCam/Screenshot-2025-07-05-at-4.40.33PM.png\">Screenshot 2025-07-05 at 4.40.33 PM.png</a><br>\nI'm still trying to square the fact that the term model of the simply typed lambda calculus is sound and complete for the equational theory of the STLC (I've gone through this proof many times), but that you can, according to Baader/Nipkow/Mitchell and many others, still end up with a \"term model\" of an equational theory that has more equations true in it than specified (and that this fact is used in algebraic specification, for example, you can choose from 'initial model' and 'final model' semantics, with entire papers about the differences).  doctrines may help formalize what's going on, but I'm getting  more confused rather than less.  I've included some images from Baader/Nipkow that indicate whatever is going on is related to having infinitely many variables, and also an image of Mitchell talking about how \"no junk, no confusion\" in the initial model refers to ground terms (not open terms).  I'll keep thinking, but if anyone can explain this difference, please chime in.  the difference is even weirder in my mind when I consider the point-free form of the STLC, since that has no variables and so should be amendable to analysis from universal algebra.<br>\n<a href=\"/user_uploads/21317/45A7bDPVjPlsl-JXQTA9nmW7/Screenshot-2025-07-05-at-5.03.03PM.png\">Screenshot 2025-07-05 at 5.03.03 PM.png</a><br>\n<a href=\"/user_uploads/21317/powVUTEkVoqZ2xD_s7ULfqHi/Screenshot-2025-07-05-at-5.02.56PM.png\">Screenshot 2025-07-05 at 5.02.56 PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/4_Me2iq2JEt98ysq3qOCmQo2/Screenshot-2025-07-05-at-4.39.55PM.png\" title=\"Screenshot 2025-07-05 at 4.39.55 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1784x806\" src=\"/user_uploads/thumbnail/21317/4_Me2iq2JEt98ysq3qOCmQo2/Screenshot-2025-07-05-at-4.39.55PM.png/840x560.webp\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/21317/B57R4zVfIKZAVbfPr7sERCam/Screenshot-2025-07-05-at-4.40.33PM.png\" title=\"Screenshot 2025-07-05 at 4.40.33 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1776x742\" src=\"/user_uploads/thumbnail/21317/B57R4zVfIKZAVbfPr7sERCam/Screenshot-2025-07-05-at-4.40.33PM.png/840x560.webp\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/21317/45A7bDPVjPlsl-JXQTA9nmW7/Screenshot-2025-07-05-at-5.03.03PM.png\" title=\"Screenshot 2025-07-05 at 5.03.03 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1642x950\" src=\"/user_uploads/thumbnail/21317/45A7bDPVjPlsl-JXQTA9nmW7/Screenshot-2025-07-05-at-5.03.03PM.png/840x560.webp\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/21317/powVUTEkVoqZ2xD_s7ULfqHi/Screenshot-2025-07-05-at-5.02.56PM.png\" title=\"Screenshot 2025-07-05 at 5.02.56 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1602x1778\" src=\"/user_uploads/thumbnail/21317/powVUTEkVoqZ2xD_s7ULfqHi/Screenshot-2025-07-05-at-5.02.56PM.png/840x560.webp\"></a></div>",
        "id": 527311885,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751760644
    },
    {
        "content": "<p>I think the remark in 3.5.8 means that b/c example 3.5.9 uses quantified equations, its ground term model may satisfy quantified equations that are not provable from the original equational theory (as the example shows), and that this is a general phenomenon - ground models of quantified equations will have many more (quantified) consequences than models with variables.  which is the \"usual situation\" where I grew up - ground term models of theories with variables.  but I get why this situation isn't fully satisfactory for all times, and why you'd want variables in your term model.</p>",
        "id": 527312276,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751761270
    },
    {
        "content": "<p>Yes, we already discussed that -- BN's initial algebras are in a doctrine without contexts, while the \"identities\" they consider are in a nonempty context.</p>",
        "id": 527312436,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751761554
    },
    {
        "content": "<p>never having used doctrines before, I have to work all this out in BN/mitchell terms, and I'm being very careful anticipating writing this up, thanks for sticking with me</p>",
        "id": 527312513,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751761675
    },
    {
        "content": "<p>The thing about cardinality of variables is an extension of that: if instead of the initial algebra (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>=</mo><mi mathvariant=\"normal\">∅</mi></mrow><annotation encoding=\"application/x-tex\">X=\\emptyset</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8056em;vertical-align:-0.0556em;\"></span><span class=\"mord\">∅</span></span></span></span>) you consider the free algebra on a set of generators <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, then any equation in a context of length <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo><mi mathvariant=\"normal\">∣</mi><mi>X</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">\\le |X|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">∣</span></span></span></span> can be instantiated using distinct generators for the variables, and since it's <em>free</em> on the generators it won't satisfy any such equations that don't follow from the theory even with contexts.</p>",
        "id": 527312514,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751761677
    },
    {
        "content": "<p>this new set of messages is about how the term model of the STLC manages to avoid this phenomenon, b/c I thought you could encode the point-free version of STLC equationally</p>",
        "id": 527312569,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751761774
    },
    {
        "content": "<p>By \"point-free STLC\" do you mean combinatory algebra?</p>",
        "id": 527312583,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751761802
    },
    {
        "content": "<p>pretty much</p>",
        "id": 527312593,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751761811
    },
    {
        "content": "<p>SKI stuff?</p>",
        "id": 527312594,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751761812
    },
    {
        "content": "<p>that kind of thing, but more for the internal language of a CCC</p>",
        "id": 527312607,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751761830
    },
    {
        "content": "<p>I'll go find a definition</p>",
        "id": 527312619,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751761840
    },
    {
        "content": "<p>oh, think \"curry-howard-lambeck\", if that helps</p>",
        "id": 527312631,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751761856
    },
    {
        "content": "<p>Not really for me.</p>",
        "id": 527312639,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751761864
    },
    {
        "content": "<p>You can do typed combinatory algebra without any problem.</p>",
        "id": 527312641,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751761867
    },
    {
        "content": "<p>if that's what you mean by \"internal language of a CCC\"</p>",
        "id": 527312651,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751761878
    },
    {
        "content": "<p>E.g. exercise 2.8.2 of <a href=\"http://mikeshulman.github.io/catlog/catlog.pdf\">my categorical logic notes</a></p>",
        "id": 527312696,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751761955
    },
    {
        "content": "<p><a href=\"/user_uploads/21317/XmbNa1o0BHAWiy7W3Orp0GFe/Screenshot-2025-07-05-at-5.32.10PM.png\">Screenshot 2025-07-05 at 5.32.10 PM.png</a><br>\nthis is for a BCCC and some other stuff, but it's the language with \"curry\" and \"eval\" etc - the original \"categorical machine language\", actually</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/XmbNa1o0BHAWiy7W3Orp0GFe/Screenshot-2025-07-05-at-5.32.10PM.png\" title=\"Screenshot 2025-07-05 at 5.32.10 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"2004x334\" src=\"/user_uploads/thumbnail/21317/XmbNa1o0BHAWiy7W3Orp0GFe/Screenshot-2025-07-05-at-5.32.10PM.png/840x560.webp\"></a></div>",
        "id": 527312698,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751761959
    },
    {
        "content": "<p>What I'd need to see to understand that is the typing judgments, not the raw terms.</p>",
        "id": 527312729,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751762011
    },
    {
        "content": "<p><a href=\"/user_uploads/21317/STHs4bq_c6iOgwwA1mSS1U33/Screenshot-2025-07-05-at-5.33.24PM.png\">Screenshot 2025-07-05 at 5.33.24 PM.png</a><br>\nhere's wikipedia's definition</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/STHs4bq_c6iOgwwA1mSS1U33/Screenshot-2025-07-05-at-5.33.24PM.png\" title=\"Screenshot 2025-07-05 at 5.33.24 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1604x1296\" src=\"/user_uploads/thumbnail/21317/STHs4bq_c6iOgwwA1mSS1U33/Screenshot-2025-07-05-at-5.33.24PM.png/840x560.webp\"></a></div>",
        "id": 527312730,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751762014
    },
    {
        "content": "<p>they are here<br>\n<a href=\"https://en.wikipedia.org/wiki/Curry–Howard_correspondence#Curry–Howard–Lambek_correspondence\">https://en.wikipedia.org/wiki/Curry–Howard_correspondence#Curry–Howard–Lambek_correspondence</a></p>",
        "id": 527312745,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751762040
    },
    {
        "content": "<p>so specifically, assuming these \"equations\" are actually equations the sense of Baader Nipkow, I'm trying to compare its ground term model against the usual one for STLC that is sound/complete for beta/eta only</p>",
        "id": 527312815,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751762163
    },
    {
        "content": "<p>They should be the same, since both present a free CCC.</p>",
        "id": 527313009,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751762504
    },
    {
        "content": "<p>The analogue of the BN observation about \"extra equations\" would apply here to equations of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>:</mo><mi>α</mi><mo>→</mo><mi>β</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>:</mo><mi>γ</mi><mo>→</mo><mi>δ</mi><mo>⊢</mo><mi>M</mi><mo>=</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">x:\\alpha\\to\\beta, y:\\gamma\\to\\delta \\vdash M=N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05556em;\">γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> in a context where you've assumed a couple of morphisms in the free CCC, which is not a statement in the variable-free doctrine of this theory.</p>",
        "id": 527313054,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751762588
    },
    {
        "content": "<p>the ground term model of the equations suffers from the phenomenon that it will have quantified equations true in it that don't follow from the equations (according to BN 3.5.8 remark).  But the free CC is sound/complete for the equations.  that's the contradiction I don't understand</p>",
        "id": 527313059,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751762594
    },
    {
        "content": "<p>If you pass that back to ordinary STLC with variables, you would get something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo>:</mo><mi>α</mi><mo>⊢</mo><mi>t</mi><mo>:</mo><mi>β</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>y</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi>c</mi><mo>:</mo><mi>γ</mi><mo>⊢</mo><mi>s</mi><mo>:</mo><mi>δ</mi><mo stretchy=\"false\">)</mo><mo>⊢</mo><mi>M</mi><mo>=</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">x : (a:\\alpha \\vdash t:\\beta), y : (c:\\gamma \\vdash s:\\delta) \\vdash M=N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05556em;\">γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>, which is also not in the doctrine of STLC since it quantifies not over internal variables but over judgments.</p>",
        "id": 527313095,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751762648
    },
    {
        "content": "<p>And hence the term model isn't complete for equations of that form either.</p>",
        "id": 527313105,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751762670
    },
    {
        "content": "<p>ok, I see now doctrines really are formalizing what's going on here</p>",
        "id": 527313106,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751762670
    },
    {
        "content": "<p>er, I don't understand doctrines at all, but I understand \"forms of syntax\"</p>",
        "id": 527313116,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751762700
    },
    {
        "content": "<p>what happens if we just roll with it.  like, are there \"extra equations\" that hold in the ground term model but not in the usual model?  I see how \"extra equations\" they can be consider ill-formed, but for other purposes, they are still well-formed.  like, they seem to have determine truth-values (being true or false in each model)?  I ask because to my understanding of \"haskellers\", for blog post purposes these extra equations may be part of \"Haskell's term model\"</p>",
        "id": 527313221,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751762864
    },
    {
        "content": "<p><del>hm, I also don't understand why \"passing back\" does anything at all - the original equation with x and y seems like it is already an equation of ordinary STLC, but that may be because of lack of knowledge of doctrines.  in fact, conflating the two may be another common mistake to write about</del></p>",
        "id": 527313495,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751763341
    },
    {
        "content": "<p>I don't know what you mean by distinguishing a \"ground term model\" from a \"usual model\".  Each theory in a given doctrine has a definite specific term model.</p>",
        "id": 527315833,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751767189
    },
    {
        "content": "<p>By \"the usual model\", I mean the free CCC as defined in sec 7/8 of <a href=\"https://www.cl.cam.ac.uk/teaching/1617/L108/catl-notes.pdf\">https://www.cl.cam.ac.uk/teaching/1617/L108/catl-notes.pdf</a> .  By \"the ground term model\", I mean the ground term model of the \"lambeck\" form of STLC (with curry, eval, etc) from wikipedia</p>",
        "id": 527316031,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751767420
    },
    {
        "content": "<p>I'd like to find an example of an \"extra equation\" that holds in the ground term model that does not hold in the usual model, which I claim is possible since \"quantification over judgements\" is still  well-defined, if not internalized in the stlc</p>",
        "id": 527316103,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751767519
    },
    {
        "content": "<p>I thought I just explained that those two models are the same.</p>",
        "id": 527316332,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751767909
    },
    {
        "content": "<p>Each of them satisfies internally exactly the equations in their doctrine that are derivable from the theory, and each of them can satisfy additional equations that are not in the doctrine.  The difference is that one of them has an \"internal\" notion of \"variable\" while the other is formulated without such, but there is still a bijection between the \"internal\" equations on both sides and also a bijection between the \"external\" equations on both sides.</p>",
        "id": 527316388,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751768004
    },
    {
        "content": "<p>if \"each of them can satisfy additional equations that are not in the doctrine\", then what is an example equation, not in the doctrine, that one satisfies that the other doesn't (that's my previous question), or must they satisfy the same set of equations not in the doctrine?</p>",
        "id": 527316512,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751768229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281326\">Ryan Wisnesky</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527312513\">said</a>:</p>\n<blockquote>\n<p>never having used doctrines before, </p>\n</blockquote>\n<p>This sounds a bit off because doctrines aren't mainly a technical device one \"uses\" in a problem like this - e.g., people have argued for many years about the correct definition of doctrine, but that doesn't stop anyone from talking about doctrines, because they mainly serve as a way of thinking that keeps one from getting confused.     In this particular case Mike seems to keeps using them to say roughly \"the stuff you do when you do logic with contexts is different from the stuff you do in logic without contexts, so just because something is initial when you're working without contexts, doesn't mean some similar-looking thing is gonna be initial when you're working with contexts\".    See, I said that without saying \"doctrines\", but Mike said it faster by saying the word \"doctrines\".</p>\n<p>I don't understand what you guys are talking about, except for the part about how you gotta be careful which doctrine you're working in.   It's a very general point, like how you can't say an object is initial until you've made up your mind what category it's an object in.</p>",
        "id": 527317306,
        "sender_full_name": "John Baez",
        "timestamp": 1751769387
    },
    {
        "content": "<p>I think we're making progress, if testing Mike's patience.  At present, there's two models of the simply typed lambda calculus we're trying to compare, one defined as the ground term model (in Baader Nipkow sense) of the \"lambeck equations\"  as defined in wikipedia, the other being the free cartesian closed category as usual.  These are so similar that teasing them apart (if they can be teased apart at all) may require what we've been calling \"extra equations\", which as I understand it can be formalized using doctrines</p>",
        "id": 527317630,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751769983
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281326\">Ryan Wisnesky</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527316512\">said</a>:</p>\n<blockquote>\n<p>if \"each of them can satisfy additional equations that are not in the doctrine\", then what is an example equation, not in the doctrine, that one satisfies that the other doesn't (that's my previous question), or must they satisfy the same set of equations not in the doctrine?</p>\n</blockquote>\n<p>They must satisfy the same set of equations not in the doctrine because <em>they are the same object</em>.</p>",
        "id": 527317639,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751769993
    },
    {
        "content": "<p>heh, that would explain why I can't come up with an example myself and had to ask...</p>",
        "id": 527317664,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751770015
    },
    {
        "content": "<p>So you see, \"teasing them apart\" is mainly about teasing apart the two doctrines.  So you gotta listen when people talk about doctrines, even if they never say exactly what a doctrine is in full generality (since nobody knows, although maybe Mike does).</p>",
        "id": 527317778,
        "sender_full_name": "John Baez",
        "timestamp": 1751770214
    },
    {
        "content": "<p>I take the absence of an example here to mean that although a ground term model (in the BN sense) may satisfy extra equations, it doesn't have to, or any that it does are already true in the free CCC (which is I think is the case here, any \"extra theorems\" in the ground term model are true in the free CCC, following from the free CCCs initiality)</p>",
        "id": 527317779,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751770214
    },
    {
        "content": "<p>Is there a guy named Lambeck in addition to the famous guy named Lambek, or is this some joke about Lambek and Beck?</p>",
        "id": 527317828,
        "sender_full_name": "John Baez",
        "timestamp": 1751770314
    },
    {
        "content": "<p>it's the famous guy</p>",
        "id": 527317833,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751770324
    },
    {
        "content": "<p>I'm a terrible speller</p>",
        "id": 527317842,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751770335
    },
    {
        "content": "<p>Okay: he's called Lambek.</p>",
        "id": 527317848,
        "sender_full_name": "John Baez",
        "timestamp": 1751770347
    },
    {
        "content": "<p>fwiw, it sounds like much of the field of \"algebraic specification\", where you study the \"extra equations\" that arise in the ground term model of an equational theory, can be explained in doctrinal terms.  there may be two blog posts here, one on folklore about system F and one about how doctrines relate to old school algebraic specification</p>",
        "id": 527318003,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751770598
    },
    {
        "content": "<p>bearing with me as I apply all of what happened today to the original questions about system F, I now conclude 1) Reynolds parametricity implies Q~Cont(Q) , and 2) the term model of system F is not reynolds-parametric (any \"extra equations\" from today can't \"conspire to make it so\", as was my original concern).  I'd still like to find citations/proofs for these though.  anyway, I have no further questions for now and will go back to writing.</p>",
        "id": 527319326,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751772645
    },
    {
        "content": "<p>I agree if instead of \"parametric\" you say <em>internally</em> parametric.  I maintain the term model is <em>externally</em> parametric by the usual argument.</p>",
        "id": 527321184,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751775462
    },
    {
        "content": "<p>hm, I mean parametric in the sense of the HRR conclusion.  I think they must have meant \"internal\" too, in which case they are saying its a failure of the externally parametric term model to be internally parametric, which squares with what we saw earlier with bridge discreteness etc.  When put that way it doesn't seem surprising to me anymore</p>",
        "id": 527321343,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751775734
    },
    {
        "content": "<p>checking my understanding again: the plotkin-abadi identity extension lemma implies equality of two variables (rather than closed terms); therefore, the plotkin-abadi logic is axiomatizing internal parametricity.  Nevermind: this was confirmed earlier in the thread</p>",
        "id": 527324337,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751779561
    },
    {
        "content": "<p>Ok, I've summarized my conclusions from this thread into the following list; some entries are sanity checks and some go against folklore, but all should be correct.  the blog post will refer to many or most of these propositions.   I don't have any more questions, and appreciate everyone's patience.</p>\n<div class=\"codehilite\"><pre><span></span><code>1) external parametricity does not imply q ~ cont q (evan,mike)\n\n2) internal parametricity implies q ~ cont q (evan,mike)\n\n3) internal parametricity implies c ~ cont c for every closed type c  (b/c closed types are bridge discrete) (evan,mike)\n\n4) internal parametricity doesnt imply a ~ cont a for variable a (internal parametricity of forall a, forall r, ((a-&gt;r)-&gt;r) does not help (mike); need bridge discreteness for a variable) (evan,mike)\n\n5) system F term model is external but not internal parametric (HRR)\n\n6) models of reynolds-abadi logic are internally parametric (mike)\n\n7) external parametricity implies forall x, x -&gt; x has one inhabitant (need reference)\n\n8) the term model for system F is sound and complete for beta and eta (mike), same as with STLC (course notes)\n\n9) &quot;extra equations&quot; (in the sense of BN) in the ground term model of the Lambek equational theory from wikipedia are meta-theoretic (not theoretic) statements about the free CCC that follow from initiality\n\n10) extensional PER models are internally parametric (not 100% sure about this one / need reference)\n\n11) in the early 90s many authors required models of system F to be extensional, a property they always expressed semantically (and different than eta) (tannen)\n\n12) in the early 90s many authors distinguished between &quot;open&quot; and &quot;closed&quot; term models of system F for extensionality reasons, but &quot;open&quot; and &quot;closed&quot; may have unusual meanings in these papers (mike)\n\n13) not all polymorphic functions in system F define natural transformations on definable functors (since not all type constructors are functorial, e.g. X |-&gt; X-&gt;X) (reddy)\n\n14) all polymorphic functions between (definable) functors are natural transformations in an internally parametric model, but not an externally parametric model (b/c q not iso to Cont q; need reference)\n\n15) initial algebras and final coalgebras for positive defineable functors exist in an internally parametric model of system F (wadler)\n\n16) eta implies a kind of function extensionality in system F (mike, mitchell)\n\n17) in system F, both internal and external parametricity are meta-theoretic properties\n\n18) internal parametricity (conclusions hold in all contexts) implies external parametricity (conclusions hold in empty contexts) for system F\n</code></pre></div>",
        "id": 527329640,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751787207
    },
    {
        "content": "<p>Can you reformat that post please so the text will wrap?</p>",
        "id": 527356653,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751818536
    },
    {
        "content": "<ol>\n<li>external parametricity does not imply q ~ cont q (evan,mike)</li>\n<li>internal parametricity implies q ~ cont q (evan,mike)</li>\n<li>internal parametricity implies c ~ cont c for every closed type c  (b/c closed types are bridge discrete) (evan,mike)</li>\n<li>internal parametricity doesnt imply a ~ cont a for variable a (internal parametricity of forall a, forall r, ((a-&gt;r)-&gt;r) does not help (mike); need bridge discreteness for a variable) (evan,mike)</li>\n<li>system F term model is external but not internal parametric (HRR)</li>\n<li>models of reynolds-abadi logic are internally parametric (mike)</li>\n<li>external parametricity implies forall x, x -&gt; x has one inhabitant (need reference)</li>\n<li>the term model for system F is sound and complete for beta and eta (mike), same as with STLC (course notes)</li>\n<li>\"extra equations\" (in the sense of BN) in the ground term model of the Lambek equational theory from wikipedia are meta-theoretic (not theoretic) statements about the free CCC that follow from initiality</li>\n<li>extensional PER models are internally parametric (not 100% sure about this one / need reference)</li>\n<li>in the early 90s many authors required models of system F to be extensional, a property they always expressed semantically (and different than eta) (tannen)</li>\n<li>in the early 90s many authors distinguished between \"open\" and \"closed\" term models of system F for extensionality reasons, but \"open\" and \"closed\" may have unusual meanings in these papers (mike)</li>\n<li>not all polymorphic functions in system F define natural transformations on definable functors (since not all type constructors are functorial, e.g. X |-&gt; X-&gt;X) (reddy)</li>\n<li>all polymorphic functions between (definable) functors are natural transformations in an internally parametric model, but not an externally parametric model (b/c q not iso to Cont q; need reference)</li>\n<li>initial algebras and final coalgebras for positive defineable functors exist in an internally parametric model of system F (wadler)</li>\n<li>eta implies a kind of function extensionality in system F (mike, mitchell)</li>\n<li>in system F, both internal and external parametricity are meta-theoretic properties</li>\n<li>internal parametricity (conclusions hold in all contexts) implies external parametricity (conclusions hold in empty contexts) for system F</li>\n</ol>",
        "id": 527376621,
        "sender_full_name": "Madeleine Birchfield",
        "timestamp": 1751840072
    },
    {
        "content": "<p>Thanks!  That's mostly right, but I have a few questions and quibbles.</p>\n<p>(3) certainly depends on what theory we're talking about.  It's not true in internally parametric dependent type theory, for instance, because universes are closed and not bridge-discrete.  Evan showed essentially that all closed types in the first universe are bridge-discrete, which would imply that in a simple <em>predicative</em> type theory without universes all closed types are bridge-discrete; but his proof doesn't treat an impredicative universe or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span>, so it's not clear to me at the moment whether all closed types in System F are bridge-discrete.</p>\n<p>(7) I would say \"one <em>closed</em> inhabitant\".</p>\n<p>(14) This depends on (3) (since automatic naturality for transfomations Reader-&gt;Id implies a ~ cont a), so it also varies with the theory, is false (or at least probably not true) for dependent type theory, and is unclear to me whether it's true for System F.</p>\n<p>(16) What are you referring to here?</p>\n<p>(17) I'm not sure what you mean by this for internal parametricity.  Normally I think of internal parametricity as a built-in part of a theory, not a metatheoretic statement about it, hence the \"internal\".</p>",
        "id": 527378591,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751842671
    },
    {
        "content": "<p>thanks Madeleine! and Mike!</p>",
        "id": 527388711,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751853895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527378591\">said</a>:</p>\n<blockquote>\n<p>it's not clear to me at the moment whether all closed types in System F are bridge-discrete</p>\n</blockquote>\n<p>Hmm, although it's possible this is a consequence of the Reynolds-Abadi logic?</p>",
        "id": 527388921,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751854061
    },
    {
        "content": "<p>re: 3) I meant system F, so it's good to note your uncertainty.  I'm not sure if bridge discreteness follows from internal parametricity as formulated by Reynolds abadi (or anyone else), and regard 3) as key to settling.</p>",
        "id": 527388995,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751854156
    },
    {
        "content": "<p>understood re: 7) I agree</p>",
        "id": 527389027,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751854184
    },
    {
        "content": "<p>re 14) I might have seen a reference, I'll try to track that down</p>",
        "id": 527389086,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751854240
    },
    {
        "content": "<p>re: 16, I'm used to distinguishing eta from function extensionality due to working in Coq so much.  I've never seen fun-ext follow from eta.  So I was surprised to learn that (x |- f x = g x -&gt; |- f = g) follows from eta in System F, even though it's due to issues with having a type of propositions, etc.  Mitchell gives the same argument about this that you did earlier.</p>",
        "id": 527389245,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751854402
    },
    {
        "content": "<p>for 17) I'm using \"internal and external in the sense of 18).  But I agree there's another meaning of internal and external meaning that internally you can have a Prop stating that e.g. function extensionality is true which is distinct from it being true externally.  I tried to use \"definable\" instead of \"internal\" in this bullet list to avoid ambiguity in this specific sense.  What I meant by the question was that  it seems like people need to build a logic on top of system F (a la plotkin abadi), rather than say add a bunch of 'free theorems' to system F, to capture parametricity.  I was trying to confirm you have to do more than just add (infinitely many) equations to the theory of system F to capture internal parametricity.</p>",
        "id": 527389724,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751854878
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281326\">Ryan Wisnesky</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527389245\">said</a>:</p>\n<blockquote>\n<p>I've never seen fun-ext follow from eta.  So I was surprised to learn that (x |- f x = g x -&gt; |- f = g) follows from eta in System F,</p>\n</blockquote>\n<p>As I said before, if <code>=</code> means definitional equality, then that rule <em>is not funext</em>.  It is not even a \"kind\" of funext, unless you want to call eta itself \"a kind of funext\", because this rule is <em>equivalent</em> to eta.</p>",
        "id": 527404516,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751867831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281326\">Ryan Wisnesky</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527389724\">said</a>:</p>\n<blockquote>\n<p>for 17) I'm using \"internal and external in the sense of 18)</p>\n</blockquote>\n<p>Actually I don't know what you meant by it in (18).  What are \"conclusions\"?</p>",
        "id": 527404684,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751867939
    },
    {
        "content": "<p>I'm not even sure what you mean by \"parametricity\" in (17-18).  What I mean by \"external parametricity\" is that there's a translation on syntax transforming every closed type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> to a relation on its closed terms, defined in the usual way, such that every closed term is related to itself.  What I mean by \"internal parametricity\" is that the syntax <em>contains</em> an operation mapping every type to a relation on itself, defined in the usual way, such that every term is related to itself.</p>",
        "id": 527404876,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751868043
    },
    {
        "content": "<p>I've not been following this discussion so closely, but it seems like Abadi, Cardelli, and Curien's work on <a href=\"https://www.sciencedirect.com/science/article/pii/0304397593900825\">Formal Parametric Polymorphism</a> may be related, as they give a calculus extending System F in which certain parametricity results are provable internally.</p>",
        "id": 527493425,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1751898720
    },
    {
        "content": "<p>Thanks.  That looks similar to the Plotkin-Abadi logic we've been discussing; in fact I'm not sure what the difference is.  They cite the Plotkin-Abadi paper in the last sentence but it's not clear to me what they're saying about it.</p>\n<p>I think I would classify both of them as a way to add \"internal parametricity\" to System F.  (Full internal parametricity requires a dependent type theory.)  But I could be misunderstanding something about one or both.</p>",
        "id": 527516637,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751905852
    },
    {
        "content": "<p>I got the internal/external parametricity distinction (applies in all contexts vs applies in empty context) from here: <a href=\"https://ncatlab.org/nlab/show/parametric+dependent+type+theory\">https://ncatlab.org/nlab/show/parametric+dependent+type+theory</a> .  Without a type of propositions, I'm not even sure how system F could \"internalize\" (mike's sense) parametricity (besides an axiom schema of 'free theorems').</p>",
        "id": 527529347,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751910929
    },
    {
        "content": "<p>internal vs external in the sense of that ncatlab page seemed relevant, since a ~ CPS a when a is a variable has different properties than c ~ CPS c when c is a closed term</p>",
        "id": 527529991,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751911138
    },
    {
        "content": "<p>The distinction is correct, but the \"thing\" that applies in contexts or not is not the conclusions, but the parametricity operator that takes types to relations and terms to witnesses of relations.</p>\n<p>Also that nLab page is only about forms of parametricity that are inside the theory:</p>\n<blockquote>\n<p>Parametric dependent type theory is dependent type theory with an explicit notion of parametricity inside of the theory itself</p>\n</blockquote>\n<p>In particular, as it says, it uses \"external parametricity\" for \"explicit external parametricity\", which is different from the meta-theoretic external parametricity of Reynolds:</p>\n<blockquote>\n<p>In the rest of this article, we shall follow the terminology of the Narya documentation and use external parametricity for explicit external parametricity. To disambiguate, we shall use meta-theoretic parametricity for the traditional meta-theoretic notion of external parametricity.</p>\n</blockquote>\n<p>Basically all constructive type theories satisfy <em>meta-theoretic</em> external parametricity.  But I don't know what \"meta-theoretic internal parametricity\" would even mean.</p>\n<p>Explicit parametricity is indeed harder to make sense of in a non-dependent type theory, but I thought that's what the Plotkin-Abadi and Abadi-Cardelli-Curien logics were trying to do.</p>",
        "id": 527533516,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751912172
    },
    {
        "content": "<p>I figured \"meta-theoretic internal parametricity\" meant a parametricity result that also applies to open terms.  at least, that's how I used internal/external in the list of items.  if that's not a germane distinction for system F, I'll need to re-think the list</p>",
        "id": 527534395,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751912497
    },
    {
        "content": "<p>If you can point to a paper that does something you would describe as \"meta-theoretic internal parametricity\", I'd be interested.  Otherwise, let's not use that phrase.</p>\n<p>Note that ordinary meta-theoretic external parametricity does do <em>something</em> with open terms, as it essentially must in order to give a proof by induction over syntax in a theory with variable binding.  Namely, it shows that open terms map related values for their free variables to related outputs, just like abstracted functions.</p>",
        "id": 527535167,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751912737
    },
    {
        "content": "<p>In my ignorance I'd point at that automated free theorem generator website from a week ago as something that distinguishes closed vs open terms in a parametricity result : it could generate a free theorem for \"forall a, forall x, (a-&gt;x)-&gt;x\", but not for \"forall x, (a-&gt;x)-&gt;x\" with a left a type variable.  could just be a limitation of the tooling however, or a meaningless distinction (which I suppose it must be)</p>",
        "id": 527536113,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751913032
    },
    {
        "content": "<p>to make progress, I need to figure out what to replace \"internal\" and \"external\" with in each item of the list... so that's what I'll be doing next</p>",
        "id": 527536646,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751913192
    },
    {
        "content": "<p>I didn't say there is no distinction.</p>",
        "id": 527538203,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751913646
    },
    {
        "content": "<p>fair enough, then in that case the question is, do the distinctions (exclusively) explain any of the phenomena on that list, like I erroneously thought they did, and if they don't, what does... so that's what I'll be thinking through, item by item</p>",
        "id": 527539150,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751913927
    },
    {
        "content": "<p>But if you apply meta-theoretic external parametricity to an open type, you get an open type that depends on relations corresponding to the free variables.  Which is basically the same as if you abstracted over the free variables with forall, applied the \"closed term\" translation, and then peeled off the corresponding abstractions.  So in that sense, the \"open terms\" translation that's part of external parametricity carries no new information, so it makes sense that the free theorem generator doesn't deal with it.  I was just making the point that in order for the induction to go through, the open terms have to be dealt with at some point.</p>",
        "id": 527539175,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751913934
    },
    {
        "content": "<p>side note: I don't always get indications that you're typing, mike.   must be a weird intermittent glitch.  I didn't mean to interrupt</p>",
        "id": 527539455,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751914016
    },
    {
        "content": "<p>No worries, I don't believe in typing notifications anyway.</p>",
        "id": 527539714,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751914095
    },
    {
        "content": "<p>I don't know if you're as wrong as you seem to think.  Most of the places on that list where you distinguished external and internal parametricity seemed correct to me with the meaning of \"internal parametricity\" that I'm most familiar with, namely explicit internal parametricity in a dependent type theory.</p>",
        "id": 527540222,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751914298
    },
    {
        "content": "<p>I think the main thing that I don't understand yet is how the Plotkin-Abadi and Abadi-Cardelli-Curien theories are related to each other and to explicitly internally parametric dependent type theory.  In particular, to what extent does my intuition for the latter carry over to them.</p>",
        "id": 527540454,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751914384
    },
    {
        "content": "<p>I think a good answer to this question should resolve most of the open issues on your list.</p>",
        "id": 527540519,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751914410
    },
    {
        "content": "<p>that's good to know - and I use Coq a lot more than system F - but I am also fixated on answering these for system F to get at \"haskell\" folklore for blogging reasons.  that being said, I'm thinking of starting with a blog post that just compares the folklore that \"the term model of STLC is sound/complete for beta/eta\" with folklore that \"equational specifications (lists, trees, etc) are studied by their inductive theories\", because I think the subtleties of doctrine involved here are often under-stated even in textbooks that use both frameworks (such as Mitchell's)</p>",
        "id": 527540969,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1751914574
    },
    {
        "content": "<p>That does also seem worthwhile!</p>",
        "id": 527542303,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751914999
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527533516\">said</a>:</p>\n<blockquote>\n<p>Basically all constructive type theories satisfy <em>meta-theoretic</em> external parametricity. But I don't know what \"meta-theoretic internal parametricity\" would even mean.</p>\n</blockquote>\n<p>constructive type theories can have parametricity-breaking primitives</p>",
        "id": 527636418,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1751965303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284453\">Josselin Poiret</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527636418\">said</a>:</p>\n<blockquote>\n<p>constructive type theories can have parametricity-breaking primitives</p>\n</blockquote>\n<p>What's an example of a dependent type theory with a primitive that breaks Reynolds external parametricity?</p>",
        "id": 527696295,
        "sender_full_name": "Madeleine Birchfield",
        "timestamp": 1751982856
    },
    {
        "content": "<p>onlookers will start thinking i'm a one trick pony but typecase is enough</p>",
        "id": 527701462,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1751984097
    },
    {
        "content": "<p>you don't even need internal injectivity of type constructors</p>",
        "id": 527701560,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1751984123
    },
    {
        "content": "<p>i'd love to go back to the original question though, as there's definitely a flavor of getting first order information back out of higher order in SQC: an example is being able to derive <code>((x = 0) → ⊥) → x invertible</code></p>",
        "id": 527702956,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1751984469
    },
    {
        "content": "<p>morally a proof of <code>(x = 0) → ⊥</code> has to go through some proof that <code>(0 = 1)</code>, but in that case you do know that <code>1 = x*i</code> in the current stage</p>",
        "id": 527704073,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1751984745
    },
    {
        "content": "<p>Hmm, interesting.  I'm used to thinking of constructivity as the condition ensuring that a theory has a good initial algebra semantics with a gluing construction, which generally implies parametricity as well as canonicity and (with some extra work) normalization.  Typecase doesn't really fit well into my mental models.  How do you prove canonicity and normalization for a theory with typecase?</p>",
        "id": 527717249,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751987948
    },
    {
        "content": "<p>And can you tell me again what SQC is?</p>",
        "id": 527717278,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751987955
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527717249\">said</a>:</p>\n<blockquote>\n<p>Hmm, interesting.  I'm used to thinking of constructivity as the condition ensuring that a theory has a good initial algebra semantics with a gluing construction, which generally implies parametricity as well as canonicity and (with some extra work) normalization.  Typecase doesn't really fit well into my mental models.  How do you prove canonicity and normalization for a theory with typecase?</p>\n</blockquote>\n<p>When you're doing a normalization model for a type theory, you have 2 choices for the interpretation of the universe (and that of the type judgments): positive or negative. The negative version is what you have in mind: a record of abstract relations that verify the minimal interface wrt. neutrals and normal forms. The positive version instead asserts that you already know all types, here are all the codes, and when you need the relation on terms you have a decoding function.</p>",
        "id": 527723234,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1751989729
    },
    {
        "content": "<p>so the negative model lets you prove parametricity results because you can feed it external relations, but the positive model supports typecase</p>",
        "id": 527723386,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1751989772
    },
    {
        "content": "<p>Interesting.  So is typecase the \"only\" constructive alternative to parametricity then?  Can you cite some references that prove canonicity/normalization with typecase?</p>",
        "id": 527730900,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751991525
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527730900\">said</a>:</p>\n<blockquote>\n<p>So is typecase the \"only\" constructive alternative to parametricity then?</p>\n</blockquote>\n<p>I don't think there's a way to formalize this sentence, but intuitively I don't know of any other way to formalize types: it's either of an inductive type of codes or a negative record</p>",
        "id": 527733082,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1751992246
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527730900\">said</a>:</p>\n<blockquote>\n<p>Can you cite some references that prove canonicity/normalization with typecase?</p>\n</blockquote>\n<p>not that i know of (but i haven't looked into it too hard) but it seems pretty straightforward to add to any formalization that uses the positive interpretation</p>",
        "id": 527733223,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1751992286
    },
    {
        "content": "<p>Can you cite a reference that uses the positive interpretation then?</p>",
        "id": 527733672,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751992454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284453\">Josselin Poiret</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527733082\">said</a>:</p>\n<blockquote>\n<p>I don't know of any other way to formalize types: it's either of an inductive type of codes or a negative record</p>\n</blockquote>\n<p>It's interesting that there are multiple ways to construct a universe semantically.  That isn't the case for any other type constructors that I know of, because they all have a universal property and hence are uniquely determined up to isomorphism.  I guess these two approaches correspond basically to choosing a \"handedness\" of universal property to give to the universe semantically.  And if you try to incarnate those universal properties syntactically, then on the one hand you get typecase, and I guess on the other hand you get... univalence?</p>",
        "id": 527734153,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751992614
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527733672\">said</a>:</p>\n<blockquote>\n<p>Can you cite a reference that uses the positive interpretation then?</p>\n</blockquote>\n<p>All formalizations of logical relation arguments for dependent type theory that I know use it: <a href=\"https://github.com/CoqHott/logrel-coq/blob/coq-8.20/theories/LogicalRelation/Definition/Def.v\">LogRel-Coq</a> is an example ofc (or <a href=\"https://github.com/mr-ohman/logrel-mltt/blob/a171530b5fcb10cb9bb3baf26263e2b63a81a261/Definition/LogicalRelation.agda#L386\">LogRel-MLTT</a> if Agda is more your cup of tea)</p>",
        "id": 527736734,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1751993486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527734153\">said</a>:</p>\n<blockquote>\n<p>and I guess on the other hand you get... univalence?</p>\n</blockquote>\n<p>isn't parametricity finer than univalence already?</p>",
        "id": 527736876,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1751993535
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284453\">Josselin Poiret</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527736876\">said</a>:</p>\n<blockquote>\n<p>isn't parametricity finer than univalence already?</p>\n</blockquote>\n<p>What do you mean by \"finer\"?  Neither implies the other, certainly.</p>\n<p>Internal parametricity is certainly inspired by a negative view of the universe, but it isn't a universal property.  Univalence is basically a universal property, it says that the universe is a classifying space.</p>",
        "id": 527738017,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751993962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527738017\">said</a>:</p>\n<blockquote>\n<p>What do you mean by \"finer\"?</p>\n</blockquote>\n<p>I didn't see that you were talking about <em>internalizing</em> it, sorry.</p>",
        "id": 527738251,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1751994042
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284453\">Josselin Poiret</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527736734\">said</a>:</p>\n<blockquote>\n<p>All formalizations of logical relation arguments for dependent type theory that I know use it: <a href=\"https://github.com/CoqHott/logrel-coq/blob/coq-8.20/theories/LogicalRelation/Definition/Def.v\">LogRel-Coq</a> is an example ofc (or <a href=\"https://github.com/mr-ohman/logrel-mltt/blob/a171530b5fcb10cb9bb3baf26263e2b63a81a261/Definition/LogicalRelation.agda#L386\">LogRel-MLTT</a> if Agda is more your cup of tea)</p>\n</blockquote>\n<p>Umm... hang on.  Maybe I'm misreading that code, but it looks to me like just the usual inductive definition of logical relations over types.  That's different from <em>interpreting the universe as</em> an inductive type in the model.</p>\n<p>Maybe I don't know the right words to say syntactically to make this point.  Categorically, the way these arguments work is that you have a syntactic category which is initial among categories with some structure.  You consider some canonical map out of it, like the global sections functor if you're proving canonicity, and then you take the comma category over that functor to make a \"glued\" category living over the syntactic category, whose objects are \"types equipped with a logical relation\" or something.  You prove that the glued category has the same structure as the syntactic category, and then you observe that since the syntactic category is initial, there's a section of the projection down to it from the glued category, where the section assigns to each type its logical relation.</p>\n<p>It looks to me like what you pointed to is talking about the definition of the section.  This is always inductive over types (i.e. objects of the syntactic category) because the syntactic category is always initial, never terminal.  But I thought we were talking about defining the \"universe object\" <em>in</em> the glued category, whether it has a positive or a negative universal property as an <em>object</em> of that category.</p>",
        "id": 527738951,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1751994284
    },
    {
        "content": "<p>36 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"229199\" href=\"/#narrow/channel/229199-learning.3A-questions/topic/universal.20properties.20for.20positive.20types/with/527737174\">#learning: questions &gt; universal properties for positive types</a> by <span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span>.</p>",
        "id": 527745087,
        "sender_full_name": "Notification Bot",
        "timestamp": 1751996499
    },
    {
        "content": "<p>so in that Agda code (and also the Rocq one) there's a bit of indirection, but if you look at the <a href=\"https://github.com/mr-ohman/logrel-mltt/blob/a171530b5fcb10cb9bb3baf26263e2b63a81a261/Definition/LogicalRelation.agda#L251\">reducibility predicate at the universe</a>, it uses the type reducibility predicate of the lower level (the definition here is quantified over a so-called <code>LogRelKit</code> of lower levels), which is itself obtained by the definition I linked to before</p>",
        "id": 527841846,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752052064
    },
    {
        "content": "<p>also, this is not the definition of the section: the section is usually called the \"fundamental theorem\" and is in fact defined in <a href=\"https://github.com/mr-ohman/logrel-mltt/blob/a171530b5fcb10cb9bb3baf26263e2b63a81a261/Definition/LogicalRelation/Fundamental.agda#L36\">Fundamental</a></p>",
        "id": 527842202,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752052163
    },
    {
        "content": "<p>i'm a bit more used to the categorical gluing argument à la STC for dependent type theories, and in that formalism you're basically considering two different definitions for the dependent presheaf over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>ρ</mi><mo>∗</mo></msup><mo stretchy=\"false\">(</mo><mi>T</mi><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> ρ^*(Ty) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">ρ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding=\"application/x-tex\"> ρ </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ρ</span></span></span></span> is what Jon calls a <em>figure shape</em></p>",
        "id": 527843531,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752052564
    },
    {
        "content": "<p>(and where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>y</mi></mrow><annotation encoding=\"application/x-tex\"> Ty </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> is the presheaf over the syntactic category of contexts of syntactic types)</p>",
        "id": 527843668,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752052604
    },
    {
        "content": "<p>you can do the same for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>ρ</mi><mo>∗</mo></msup><mo stretchy=\"false\">(</mo><mi>T</mi><mi>m</mi><mi>U</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> ρ^*(Tm U) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">ρ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span></span></span></span> of course</p>",
        "id": 527843873,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752052665
    },
    {
        "content": "<p>wrt. SQC, it's the axiom that internally to the zariski topos, the canonical map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mo stretchy=\"false\">(</mo><msub><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><mrow><mi>f</mi><mi>p</mi></mrow></msub><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> A → (\\mathrm{Hom}_{fp}(A,R) → R) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Hom</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span> is invertible for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\"> A </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> a finitely presented <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\"> R </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-algebra</p>",
        "id": 527888046,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752067506
    },
    {
        "content": "<p>Ah, SQC = Synthetic Quasi-Coherence -- I know it when it's spelled out.  (-:</p>",
        "id": 527927826,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752079327
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284453\">Josselin Poiret</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527841846\">said</a>:</p>\n<blockquote>\n<p>so in that Agda code (and also the Rocq one) there's a bit of indirection, but if you look at the <a href=\"https://github.com/mr-ohman/logrel-mltt/blob/a171530b5fcb10cb9bb3baf26263e2b63a81a261/Definition/LogicalRelation.agda#L251\">reducibility predicate at the universe</a>, it uses the type reducibility predicate of the lower level (the definition here is quantified over a so-called <code>LogRelKit</code> of lower levels), which is itself obtained by the definition I linked to before</p>\n</blockquote>\n<p>Hmm, isn't <a href=\"https://github.com/mr-ohman/logrel-mltt/blob/a171530b5fcb10cb9bb3baf26263e2b63a81a261/Definition/LogicalRelation.agda#L239\">_⊩¹U</a> the reducibility predicate on the universe?  I thought <code>_⊩¹U_∷U/_</code> would be the proof that all terms <em>in</em> the universe are reducible.  Am I reading that code wrong?</p>",
        "id": 527928050,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752079408
    },
    {
        "content": "<p>What is the minimal background or summary needed to understand this conversation? I want to understand if parametric functions have free theorems attached or not. I tried reading articles of John Reynolds and Philip Wadler, but I was not able to follow them all the way. Now it seems they were wrong?</p>\n<p>I can see that a term of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>→</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo>→</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">∀ x. (x → x) → (x → x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> does not denote a natural transformation because the type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>→</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">∀x. (x → x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>  does not denote a functor. That about sums up what I understood from scrolling through this conversation. I want to understand more but I am dazzled by the expanse of techniques deployed.</p>\n<p>If anyone is writing an explanation of this issue, I can be a good representative of general audience and help make it accessible!</p>",
        "id": 528119880,
        "sender_full_name": "Ignat Insarov",
        "timestamp": 1752164758
    },
    {
        "content": "<p>the place I'm stuck is finding a complete proof that Reynolds parametricity for system f does or does not imply c ~ CPS c for all closed types c.</p>",
        "id": 528121884,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752165423
    },
    {
        "content": "<p>Perhaps try asking somewhere like <a href=\"http://cs.stackexchange.com\">cs.stackexchange.com</a>?</p>",
        "id": 528122136,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752165510
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"583446\">Ignat Insarov</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/528119880\">said</a>:</p>\n<blockquote>\n<p>Now it seems they were wrong?</p>\n</blockquote>\n<p>I don't think <em>they</em> were wrong.  I think our conclusion is more that some people (particularly in the Haskell community) have interpreted their results to say more than they actually do.</p>",
        "id": 528122290,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752165572
    },
    {
        "content": "<p>I might be one of those people, and I do want to straighten my ways.</p>",
        "id": 528122459,
        "sender_full_name": "Ignat Insarov",
        "timestamp": 1752165643
    },
    {
        "content": "<p>Hopefully the blog post(s) will be readable and clarify the situation!</p>",
        "id": 528122598,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752165690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527928050\">said</a>:</p>\n<blockquote>\n<p>Hmm, isn't <a href=\"https://github.com/mr-ohman/logrel-mltt/blob/a171530b5fcb10cb9bb3baf26263e2b63a81a261/Definition/LogicalRelation.agda#L239\">_⊩¹U</a> the reducibility predicate on the universe?  I thought <code>_⊩¹U_∷U/_</code> would be the proof that all terms <em>in</em> the universe are reducible.  Am I reading that code wrong?</p>\n</blockquote>\n<p>no, you're reading it right! when i say the reducibility predicate <em>at</em> the universe, I mean the predicate for terms of type the universe (i.e. each realized type decodes to a reducibility predicate for its terms).</p>",
        "id": 528149308,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752176872
    },
    {
        "content": "<p>(i realized i had not sent my reply earlier today)</p>",
        "id": 528149340,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752176885
    },
    {
        "content": "<p>so for a term <code>t : U</code> to be realized, you need <code>Γ ⊩ t</code> which refers to type realizability at the lower level, which is itself inductive</p>",
        "id": 528149581,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752177001
    },
    {
        "content": "<p>But then this is not actually an example of \"two different ways to interpret the universe\".  The definition of <code>_⊩¹U</code> is the relevant one, and that's what gives the parametricity interpretation.  I thought you were saying that <code>_⊩¹U</code> could also be defined inductively, and that's what I was asking for an example of.</p>",
        "id": 528165440,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752184936
    },
    {
        "content": "<p>how does this sound for stack overflow?  anything I should add or remove?  \"I am trying to find a proof (or dis-proof) that a Reynolds parametric model of system F is such that for every closed type c, the type c is bijective with the type forall x, (c-&gt;x)-&gt;x (known as the type of continuations for c).  Hyland, Robinson, and Rosolini, in the conclusion of \"Algebraic Types in PER Models\" (<a href=\"https://www.dpmms.cam.ac.uk/~jmeh1/Research/Pub81-90/hrr90.pdf\">https://www.dpmms.cam.ac.uk/~jmeh1/Research/Pub81-90/hrr90.pdf</a>), give an example c for which this isomorphism fails: (forall x, x-&gt;x) -&gt; (forall x, x-&gt;x) and conclude  \"parametricity fails in the system F term model\".  However, Bartosz Milewski gives a \"free theorems\" argument (which I've verified in Coq) that this isomorphism must hold (<a href=\"https://bartoszmilewski.com/2015/09/01/the-yoneda-lemma/\">https://bartoszmilewski.com/2015/09/01/the-yoneda-lemma/</a>).  So myself and other applied category theorists would like community input to settle these two questions: in system F, does Reynolds parametricity imply every closed type is bijective with its type of continuations?  And is the system F term model Reynolds parametric\"?</p>",
        "id": 528197798,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752210683
    },
    {
        "content": "<p>Maybe by \"non-proof\" you mean \"disproof\"?   It's very easy to find non-proofs, i.e. strings of symbols that aren't proofs.</p>",
        "id": 528199279,
        "sender_full_name": "John Baez",
        "timestamp": 1752211812
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/528165440\">said</a>:</p>\n<blockquote>\n<p>But then this is not actually an example of \"two different ways to interpret the universe\". The definition of <code>_⊩¹U</code> is the relevant one, and that's what gives the parametricity interpretation</p>\n</blockquote>\n<p>How does the realizability <em>of</em> the universe give you the parametricity interpretation? It's rather what realizers of terms at type <code>U</code> that you can feed to polymorphic functions that matter, no?</p>",
        "id": 528290841,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752223454
    },
    {
        "content": "<p>I don't remember if it's been said before, but wrt. the Q example of HRR, if you suppose that all inhabitants of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>=</mo><mi mathvariant=\"normal\">Π</mi><mi>X</mi><mo separator=\"true\">,</mo><mi>X</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\"> P = Π X, X → X </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">Π</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> are already parametric, then in the model</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>λ</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo>:</mo><mi>P</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo>→</mo><mi>P</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">(</mo><mi>λ</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">_</mi><mo>:</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">Λ</mi><mi>Y</mi><mi mathvariant=\"normal\">.</mi><mi>λ</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo>:</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>λ</mi><mo stretchy=\"false\">(</mo><mi>p</mi><mo>:</mo><mi>P</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mi>p</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">λ (a : P), a[X→P](λ(\\_:X).ΛY.λ(y:Y).y)(f(λ(p:P).p))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">λ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.06em;vertical-align:-0.31em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">]</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">λ</span><span class=\"mopen\">(</span><span class=\"mord\" style=\"margin-right:0.02778em;\">_</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mord\">.Λ</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">λ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">λ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">))</span></span></span></span></span></p>\n<p>will be equal (in the model) to</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>λ</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo>:</mo><mi>P</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi>λ</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">_</mi><mo>:</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">Λ</mi><mi>Y</mi><mi mathvariant=\"normal\">.</mi><mi>λ</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo>:</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>λ</mi><mo stretchy=\"false\">(</mo><mi>p</mi><mo>:</mo><mi>P</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mi>p</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mi>λ</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo>:</mo><mi>P</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">Λ</mi><mi>Y</mi><mi mathvariant=\"normal\">.</mi><mi>λ</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo>:</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">λ (a:P).(λ(\\_:X).ΛY.λ(y:Y).y)(f(λ(p:P).p)) = λ(a:P).ΛY.λ(y:Y).y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">λ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.06em;vertical-align:-0.31em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">λ</span><span class=\"mopen\">(</span><span class=\"mord\" style=\"margin-right:0.02778em;\">_</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mord\">.Λ</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">λ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">λ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">λ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span><span class=\"mord\">.Λ</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">λ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span></span></p>\n<p>which is of the required form</p>",
        "id": 528294861,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752224774
    },
    {
        "content": "<p>of course it's not a βη-equivalence, but extensionally, if you only probe them by <em>definable</em> functions, they are equal</p>",
        "id": 528295127,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752224864
    },
    {
        "content": "<p>it's something quite similar to Escardó's seemingly impossible functional programs, which work only when you feed them definable predicates</p>",
        "id": 528295238,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752224912
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281326\">Ryan Wisnesky</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/528197798\">said</a>:</p>\n<blockquote>\n<p>Bartosz Milewski gives a \"free theorems\" argument (which I've verified in Coq) that this isomorphism must hold</p>\n</blockquote>\n<p>can you be more explicit about what exactly you've proven? just that web page isn't enough for me to infer it</p>",
        "id": 528296073,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752225208
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284453\">Josselin Poiret</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/527701462\">said</a>:</p>\n<blockquote>\n<p>onlookers will start thinking i'm a one trick pony but typecase is enough</p>\n</blockquote>\n<p>Do you have any references / papers that talk about dependent type theory with typecase?</p>",
        "id": 528327672,
        "sender_full_name": "Madeleine Birchfield",
        "timestamp": 1752236425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"671813\">Madeleine Birchfield</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/528327672\">said</a>:</p>\n<blockquote>\n<p>Do you have any references / papers that talk about dependent type theory with typecase?</p>\n</blockquote>\n<p>\"The next 700 syntactical models of type theory\" by Boulier et al. mentions typecase</p>",
        "id": 528346784,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752242487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284453\">Josselin Poiret</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/528290841\">said</a>:</p>\n<blockquote>\n<p>How does the realizability <em>of</em> the universe give you the parametricity interpretation? It's rather what realizers of terms at type <code>U</code> that you can feed to polymorphic functions that matter, no?</p>\n</blockquote>\n<p>The fact that the parametricity translations of <code>Type</code>and <code>Π</code> are</p>\n<div class=\"codehilite\"><pre><span></span><code>Typeᵖ X Y = X → Y → Type\nΠᴾ X Y f₀ f₁ = (x₀ x₁ : X) (x₂ : Xᵖ x₀ x₁) → Yᵖ (f₀ x₀) (f₁ x₁)\n</code></pre></div>\n<p>tells you that, for instance, the parametricity translation of <code>(X : Type) → X → X</code> is</p>\n<div class=\"codehilite\"><pre><span></span><code>((X : Type) → X → X)ᵖ F G =\n  (X₀ X₁ : Type) (X₂ : X₀ → X₁ → Type) (x₀ : X₀) (x₁ : X₁) → X₂ (F x₀) (G x₁)\n</code></pre></div>\n<p>Therefore, for any (closed) <code>F : (X : Type) → X → X</code>, its translation <code>Fᵖ</code> tells you that <code>F</code> must preserve all relations, from which you get its free theorem.</p>",
        "id": 528374518,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752251924
    },
    {
        "content": "<p>Where <code>Typeᵖ X Y = X → Y → Type</code> is, I believe, what <code>_⊩¹U</code> says (maybe in the unary case).</p>",
        "id": 528375017,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752252162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281326\">Ryan Wisnesky</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/528197798\">said</a>:</p>\n<blockquote>\n<p>how does this sound for stack overflow?  anything I should add or remove?  \"I am trying to find a proof (or dis-proof) that a Reynolds parametric model of system F is such that</p>\n</blockquote>\n<p>Is there a precise definition of the phrase \"Reynolds parametric model of system F\"?</p>",
        "id": 528375371,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752252331
    },
    {
        "content": "<p>If so, maybe link to it.  If not, maybe clarify that there isn't (yet) one, but that you mean some class of models including PER models that satisfy parametricity \"internally\" in some sense.</p>",
        "id": 528376453,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752252820
    },
    {
        "content": "<p>Also I think I wouldn't cite Milewski, since we know what's wrong with his argument.  Instead I would say that HRR show that even for their own <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span>, the isomorphism does hold in their PER model.  So the question is whether there are any \"even worse\" closed types for which the isomorphism even fails in internally parametric / PER models, or whether one can show that it works there for all closed types.</p>",
        "id": 528376781,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752252993
    },
    {
        "content": "<p>remind me what went wrong with Milewski's argument?  His argument had convinced me that c ~ CPS c for closed c in a parametric model (or at least a model with the 'free theorem' for the Reader and Id functors), from which I concluded the term model is not (fully) parametric.  Am I mis-interpreting his argument or the Coq that formalized his argument?</p>",
        "id": 528416671,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752275994
    },
    {
        "content": "<p>I think I'd use the Adadi-Plotkin paper to define Reynolds parametricity, but am open to suggestions</p>",
        "id": 528416756,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752276074
    },
    {
        "content": "<p>The isomorphism c ~ CPS c depends on knowing that all transformations <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo>→</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">\\forall x. (c\\to x) \\to x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> are natural, which in turn requires c to be bridge-discrete to prove it from parametricity (even internal parametricity).  IIRC the Coq formalization just <em>assumed</em> that all transformations <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo>→</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">\\forall x. (c\\to x) \\to x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> are natural.</p>",
        "id": 528417756,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752277157
    },
    {
        "content": "<p>So the real question is whether \"internal parametricity\" of some kind for system F implies that all types are bridge-discrete.</p>",
        "id": 528418160,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752277691
    },
    {
        "content": "<p>Evan proved that all types in the first universe of internally parametric predicative dependent type theory are bridge-discrete, but that doesn't consider the impredicative <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span>.</p>",
        "id": 528418188,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752277730
    },
    {
        "content": "<p>both the coq code and the milewski post assume that any function of type \"forall a, F a -&gt; G a\", where F and G are internal functors (in this case F=Reader and G=Id), is a natural transformation, this is true.  In milewski's case I think he tries to establish this from the Yoneda lemma, and I just assumed it as a \"free theorem\" in the sense of wadler (and therefore implied by parametricity alone to my way of thinking).  But both arguments seem to bypass bridge discreteness (although maybe they shouldn't), which is confusing me.  (for sanity I'm going to stick to working in system F and interpreting milewski in system F).  image is milewski's \"axiom\" <br>\n<a href=\"/user_uploads/21317/BoybqL7zoHdSplpMUFTnqU_Y/Screenshot-2025-07-11-at-5.09.10PM.png\">Screenshot 2025-07-11 at 5.09.10 PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/BoybqL7zoHdSplpMUFTnqU_Y/Screenshot-2025-07-11-at-5.09.10PM.png\" title=\"Screenshot 2025-07-11 at 5.09.10 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1046x176\" src=\"/user_uploads/thumbnail/21317/BoybqL7zoHdSplpMUFTnqU_Y/Screenshot-2025-07-11-at-5.09.10PM.png/840x560.webp\"></a></div>",
        "id": 528418773,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752278456
    },
    {
        "content": "<p>Yoneda only applies when you already <em>have</em> a natural transformation.</p>",
        "id": 528419476,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752279026
    },
    {
        "content": "<p>He states it using <code>forall</code> but that's because he's previously asserted that all transformations are natural.</p>",
        "id": 528419497,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752279056
    },
    {
        "content": "<p>Without even attempting a proof <a href=\"https://bartoszmilewski.com/2015/04/07/natural-transformations/\">here</a>:</p>\n<blockquote>\n<p>Haskell’s parametric polymorphism has an unexpected consequence: any polymorphic function of the type <code>alpha :: F a -&gt; G a</code> where <code>F</code> and <code>G</code> are functors, automatically satisfies the naturality condition.... The reason why the naturality condition is automatic in Haskell has to do with “theorems for free.”... In the case of functions that transform functors, free theorems are the naturality conditions.</p>\n</blockquote>",
        "id": 528419509,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752279074
    },
    {
        "content": "<p>and <a href=\"https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/\">here</a></p>\n<blockquote>\n<p>If you accept the premise that an appropriate relation can be defined for any functor, then you can derive a free theorem for all polymorphic functions of the type <code>r :: forall a. f a -&gt; g a</code> where <code>f</code> and <code>g</code> are functors. This type of function is known as a natural transformation between the two functors, and the free theorem <code>fmap h . r == r . fmap h</code> is the naturality condition.</p>\n</blockquote>",
        "id": 528419554,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752279123
    },
    {
        "content": "<p>But I think we worked out before that this just isn't true.  There is <em>a</em> free theorem for the type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi>F</mi><mi>x</mi><mo>→</mo><mi>G</mi><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall x. (F x \\to G x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, for any functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>, but it isn't by definition naturality, and to extract naturality from it you need the identity extension lemma for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>.</p>",
        "id": 528419635,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752279210
    },
    {
        "content": "<p>And the identity extension lemma for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>a</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo>→</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R_a(x) = (a\\to x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> requires <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> to be bridge-discrete.</p>",
        "id": 528419656,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752279242
    },
    {
        "content": "<p>ok.  I think that is a good summary of the failure of folklore: naturality does not follow from parametricity in general , so \"theorems for free\" is not the same as \"Reynolds parametricity\".  Indeed, Wadler might even be conflating these concepts in his \"free theorems\" paper !?</p>",
        "id": 528419821,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752279428
    },
    {
        "content": "<p>anyway, I think the blog post will probably need to give the free theorem and show how it isn't the same as naturality, and walk through how bridge discreteness implies identity extension implies naturality, but i think I'm unblocked on writing even without the stack overflow post now: naturality simply does not follow from parametricity.  Which is actually a bit surprising because I've seen it claimed at a high level that parametricity generalizes naturality from functions to relations</p>",
        "id": 528420161,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752279791
    },
    {
        "content": "<p>the plotkin abadi identity extension lemma refers to all types, not just bridge discrete ones (but has no proof).  does this mean their logic is actually capturing a notion of parametricity that might always imply naturality?  (side note: I saw a remark that identity extension is what separates a parametric model from one that is simply defined using a logical relation, and wonder if that distinction has been showing up here: a parametric model is one where identity extension holds for all types, whereas a logical relation defined model only has that property for bridge discrete types, or something along those lines).  Image is of remark from <a href=\"https://par.nsf.gov/servlets/purl/10338496\">https://par.nsf.gov/servlets/purl/10338496</a><br>\n<a href=\"/user_uploads/21317/Dcyny9CRJ_X6WW7u9udxc0S5/Screenshot-2025-07-11-at-6.26.58PM.png\">Screenshot 2025-07-11 at 6.26.58 PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/Dcyny9CRJ_X6WW7u9udxc0S5/Screenshot-2025-07-11-at-6.26.58PM.png\" title=\"Screenshot 2025-07-11 at 6.26.58 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1746x1036\" src=\"/user_uploads/thumbnail/21317/Dcyny9CRJ_X6WW7u9udxc0S5/Screenshot-2025-07-11-at-6.26.58PM.png/840x560.webp\"></a></div>",
        "id": 528423272,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752283558
    },
    {
        "content": "<p>Maybe!</p>",
        "id": 528424951,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752285700
    },
    {
        "content": "<p>I think I would just call them different forms of parametricity, though.  \"Internal parametricity\" is pretty well-established as a name for a class of dependent type theories, and we decided that those don't satisfy universal identity extension or bridge-discreteness.</p>",
        "id": 528425008,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752285777
    },
    {
        "content": "<p>Maybe this is \"strong parametricity\" or \"impredicative parametricity\" or something.</p>",
        "id": 528425023,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752285795
    },
    {
        "content": "<p>ok, great; then to conclude, in that case I'd say the HRR conclusion comment is noticing that the term model fails to be \"strong parametric\", even though it does satisfy weaker forms of parametricity (such as polymorphic identity having one inhabitant), giving q ~ cont q as the witness, and this thread quantifies the difference between the two situations using the \"bridge discreteness\" of a type</p>",
        "id": 528434465,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752298618
    },
    {
        "content": "<p>That <em>sounds</em> good, but I'm not ready to conclude until I see a proof of the identity extension lemma.</p>",
        "id": 528441220,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752307638
    },
    {
        "content": "<p>a proof of the identity extension lemma for which models/logics are you referring to?</p>",
        "id": 528442153,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752308784
    },
    {
        "content": "<p>At <a href=\"https://cs.stackexchange.com/a/136373/185120\">https://cs.stackexchange.com/a/136373/185120</a> András Kovács claimed that \"For System F, identity extension can be proven for types-in-contexts\", but wasn't able to produce a reference when I asked.</p>",
        "id": 528442527,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752309203
    },
    {
        "content": "<p>the plot thickens; identity extension for system F would in my mind contradict HRR's claim that q is not iso to cont q in the term model.  my current thinking is no such proof should exist</p>",
        "id": 528442847,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752309508
    },
    {
        "content": "<p>there's a proof of (qualified) identity extension as prop 9 in wadler's paper  <a href=\"https://homepages.inf.ed.ac.uk/wadler/papers/gr2/gr2-tcs.pdf\">https://homepages.inf.ed.ac.uk/wadler/papers/gr2/gr2-tcs.pdf</a> but it's in natural deduction style and so taking me a while to understand.  This post by Neel K is ambiguous about whether the F term model satisfies identity extension depending on how the word \"the model\" is interpreted: <a href=\"https://semantic-domain.blogspot.com/2020/12/church-encodings-are-inductive-types.html\">https://semantic-domain.blogspot.com/2020/12/church-encodings-are-inductive-types.html</a></p>",
        "id": 528443987,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752310686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281326\">Ryan Wisnesky</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/528442847\">said</a>:</p>\n<blockquote>\n<p>the plot thickens; identity extension for system F would in my mind contradict HRR's claim that q is not iso to cont q in the term model.  my current thinking is no such proof should exist</p>\n</blockquote>\n<p>Could it be a definitional vs contextual thing?  E.g. maybe the form of IEL that holds only shows that every element of CPS q behaves like an element of q when applied to all possible closed term inputs, and the exotic HRR term does that?</p>",
        "id": 528467544,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752335359
    },
    {
        "content": "<p>I think Josselin made a similar remark yesterday?  I suppose I'll write to Neel K as a next step.</p>",
        "id": 528479188,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752347956
    },
    {
        "content": "<p>Seems sensible; I think he's usually pretty careful.</p>",
        "id": 528484237,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752353884
    },
    {
        "content": "<p>Here's what Neel said: \"There is no incompatibility between the parametricity of the syntactic model and Hyland's note.  Hyland considers the naive PER model, in which every type is interpreted solely as a partial equivalence relation (PER) which is well-known to be weak to prove parametricity results. To prove parametricity results, you need a relationally parametric model, in which every type is interpreted both as a PER, and a relation between PERs.<br>\nThe place where the parametric model over PERs is documented is in Bainbridge, Freyd, Scedrov and Scott's paper \"Functorial Polymorphism\". The first half of their paper is a (failed) attempt to interpret parametricity as dinaturality, after which they go ahead and build a syntactic parametric PER model, where types are PERs/relations over Godel codes. Among other results, they prove that their relational model satisfies the identity extension property.<br>\nTheir proof only relies on the Godel codes forming a partial combinatory algebra, and so you can plug in any PCA -- and lambda terms obviously form one.  Recall that a PCA is basically an axiomatization of the algebra of the SKI combinators, and so you can make the lambda calculus into a PCA with the usual definitions S = λf.λg.λx.f x (g x) and K = λx.λy.x.<br>\nOnce you do this, then it's immediate that the parametric term model satisfies identity extension.\"</p>",
        "id": 528565872,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752450050
    },
    {
        "content": "<p>Interesting.  So he seems to be saying that in order to get IEL, you can't actually look at the term model in the usual sense, but you have to use a model in relations that builds in some strong parametricity.  That makes sense with my intuition.</p>",
        "id": 528568675,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752453270
    },
    {
        "content": "<p>Did you ask him specifically about Kovács' claim that \"For System F, identity extension can be proven for types-in-contexts\"?  That sounds like it's a statement about the ordinary term model rather than a relation model constructed from it.</p>",
        "id": 528568695,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752453309
    },
    {
        "content": "<p>yeah, I was not expecting him to start talking about a model using untyped lambda terms in reference to the term model.  Here's what I asked: \"Myself and some other type theorists / category theorists were hoping you might be able to help settle an apparent open folklore question concerning system F.  We’re writing specifically because of your illuminating blog post at <a href=\"https://semantic-domain.blogspot.com/2020/12/church-encodings-are-inductive-types.html\">https://semantic-domain.blogspot.com/2020/12/church-encodings-are-inductive-types.html</a> .<br>\nThe conclusion of ‘Algebraic types and PER models' by Hyland et al (<a href=\"https://www.dpmms.cam.ac.uk/~jmeh1/Research/Pub81-90/hrr90.pdf\">https://www.dpmms.cam.ac.uk/~jmeh1/Research/Pub81-90/hrr90.pdf</a>) exhibits a failure of “parametricity” in the system F term model by constructing a closed type c for which c is not bijective with forall x, (c -&gt; x) -&gt; x (the type of continuations for c) in the term model.  <br>\nAt the same time, it seems to be folklore that the system F term model is parametric, with for example Andy Kovacs stating that identity extension should hold in the term model (<a href=\"https://cs.stackexchange.com/questions/136359/rigorous-proof-that-parametric-polymorphism-implies-naturality-using-parametrici/136373#136373\">https://cs.stackexchange.com/questions/136359/rigorous-proof-that-parametric-polymorphism-implies-naturality-using-parametrici/136373#136373</a>).  There are many other such claims in the literature, yet Mike Schulman and I can’t find any proofs.  In fact, I’m starting to believe the term model does not satisfy identity extension, which would explain Hyland et al’s claim (I think).<br>\nSo, do you know of a proof or dis-proof that the system F term model satisfies identity extension (however suitably formulated for the term model)?\"</p>",
        "id": 528568944,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752453627
    },
    {
        "content": "<p>Ok, he does seem to be saying that the term model doesn't satisfy identity extension, but it's not completely clear.  Maybe you could ask for a clarification, emphasizing that by \"term model\" you mean the initial model build directly from the syntax of system F?</p>",
        "id": 528569238,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752454000
    },
    {
        "content": "<p>I asked neel the follow-up: \"it seems like here by term model you are talking about a model of system F built from untyped lambda terms, passing through their PCA.  But what Mike and I meant by the term model of system F was the initial model built directly from the syntax of system F.  I’m not even sure how to state identity extension for the term model in the Mike/Ryan sense, but I’m wondering if you can comment on identity extension in the typed term model of system F, rather than the untyped PCA model.  Thanks again!\" and he replied with a detailed answer, but again not what I was expecting.  My understanding of his response is that the untyped PER model somehow \"is also\" the term model.<br>\n<a href=\"/user_uploads/21317/RFKatL1tPYGbqme4olywcHPy/Screenshot-2025-07-14-at-7.53.38AM.png\">Screenshot 2025-07-14 at 7.53.38 AM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/RFKatL1tPYGbqme4olywcHPy/Screenshot-2025-07-14-at-7.53.38AM.png\" title=\"Screenshot 2025-07-14 at 7.53.38 AM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"2582x1250\" src=\"/user_uploads/thumbnail/21317/RFKatL1tPYGbqme4olywcHPy/Screenshot-2025-07-14-at-7.53.38AM.png/840x560.webp\"></a></div>",
        "id": 528681296,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752505118
    },
    {
        "content": "<p>That does seem to be what he's implying, but that's clearly false because the (initial) term model is <em>not</em> defined mutually recursively with any relational interpretation.  Why don't you add me to the email thread and we can all continue there instead of playing telephone?  (-:</p>",
        "id": 528686092,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752506478
    },
    {
        "content": "<p>Will do, although here's a final thought before doing so: to obtain a set-theoretic model of system F terms, the machinery of logical relations might already be required, for example, to inductively define terms that strongly normalize.  So maybe there is a sense in which the system F term model does have to be constructed alongside its relational interpretation.</p>",
        "id": 528687366,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752506845
    },
    {
        "content": "<p>Every type theory has an initial model built out of syntax.  It's not a \"set-theoretic\" model in the sense of interpreting each type as a set, but it always exists.</p>",
        "id": 528702290,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752511404
    },
    {
        "content": "<p>In particular, it doesn't depend on any sort of normalization.</p>",
        "id": 528702400,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752511445
    },
    {
        "content": "<p>5 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"229199\" href=\"/#narrow/channel/229199-learning.3A-questions/topic/What.20is.20a.20term.3F/with/528736187\">#learning: questions &gt; What is a term?</a> by <span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span>.</p>",
        "id": 528736188,
        "sender_full_name": "Notification Bot",
        "timestamp": 1752525427
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/528375017\">said</a>:</p>\n<blockquote>\n<p>Where <code>Typeᵖ X Y = X → Y → Type</code> is, I believe, what <code>_⊩¹U</code> says (maybe in the unary case).</p>\n</blockquote>\n<p>What I'm saying is precisely that it does not, that would be the negative interpretation of the universe</p>",
        "id": 528821308,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752573268
    },
    {
        "content": "<p>you have two choices, either <code>_⊩¹U</code> consists of metatheoretical relations with some conditions on them that makes them behave <em>as</em> realizability relations, or it is just a universe of codes that then decode to the expected relations. The difference between the two is that the former contain undefinable relations while the second, by construction, only contains definable relations</p>",
        "id": 528822036,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752573494
    },
    {
        "content": "<p>I guess I just can't make heads or tails of that Agda.  Can you write out the definition of <code>_⊩¹U</code> in words?  I agree it doesn't look like the negative interpretation, but it doesn't look like a positive inductive definition either.</p>",
        "id": 528887311,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752593210
    },
    {
        "content": "<p>I'm revisiting an example from tannen coquand. consider the type T := (forall x, x) -&gt; (forall x, x) -&gt; (forall x, x).  Then there are two distinct terms in this type T, essentially, \"project first component\" and \"project second component\".  But in an extensional model where forall x, x is empty, this type T should have only one inhabitant.  In tannen coquand they conclude the term model is not extensional.  So my question: could the HRR result  be similarly (better?) understood as a failure of extensionality than parametricity in the term model?</p>",
        "id": 528959536,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752623644
    },
    {
        "content": "<p>What does \"extensional\" mean?</p>",
        "id": 528959946,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752623939
    },
    {
        "content": "<p>I've attached tannen coquand's definition, which I understand to be a semantic criteria similar to (forall x, f x = g x) -&gt; f = g for both function types and forall types.  <br>\n<a href=\"/user_uploads/21317/oDPrT25uCdzlat34ivzy7Hxn/Screenshot-2025-07-15-at-5.02.05PM.png\">Screenshot 2025-07-15 at 5.02.05 PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/oDPrT25uCdzlat34ivzy7Hxn/Screenshot-2025-07-15-at-5.02.05PM.png\" title=\"Screenshot 2025-07-15 at 5.02.05 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1756x354\" src=\"/user_uploads/thumbnail/21317/oDPrT25uCdzlat34ivzy7Hxn/Screenshot-2025-07-15-at-5.02.05PM.png/840x560.webp\"></a></div>",
        "id": 528960383,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752624243
    },
    {
        "content": "<p>Ok, they mean equality of functions is detected by applying them to global elements.  I would call that being <a href=\"https://ncatlab.org/nlab/show/well-pointed+topos\">well-pointed</a>.</p>",
        "id": 528961192,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752624794
    },
    {
        "content": "<p>And of course no one should expect the term model to be well-pointed.</p>",
        "id": 528961242,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752624830
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281326\">Ryan Wisnesky</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/528959536\">said</a>:</p>\n<blockquote>\n<p>could the HRR result  be similarly (better?) understood as a failure of [well-pointedness] than parametricity in the term model?</p>\n</blockquote>\n<p>Well, can you show that the exotic term would be equal to some standard one in any well-pointed model?</p>",
        "id": 528961305,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752624888
    },
    {
        "content": "<p>the HRR argument for PER models seems to apply to well pointed ones also, but I figured someone here might already know or have a proof</p>",
        "id": 528961786,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1752625341
    },
    {
        "content": "<p>I want to record in this thread something that I didn't realize explicitly at first, namely that strong parametricity (= external parametricity plus identity extension) implies internal parametricity.</p>\n<p>By <em>external parametricity</em> I mean firstly operations on closed terms such as</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mo>⊢</mo><mi>A</mi><mtext> </mtext><mrow><mi mathvariant=\"sans-serif\">t</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow></mrow><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>:</mo><mi>A</mi><mo separator=\"true\">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo>:</mo><mi>A</mi><mo>⊢</mo><msup><mi>A</mi><mi>p</mi></msup><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo><mtext> </mtext><mrow><mi mathvariant=\"sans-serif\">t</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow></mrow></mfrac><mspace width=\"2em\"/><mfrac><mrow><mo>⊢</mo><mi>a</mi><mo>:</mo><mi>A</mi></mrow><mrow><mo>⊢</mo><msup><mi>a</mi><mi>p</mi></msup><mo>:</mo><msup><mi>A</mi><mi>p</mi></msup><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{\\vdash A\\,\\mathsf{type}}{x_0 : A, x_1: A \\vdash A^p(x_0,x_1) \\,\\mathsf{type}}\\qquad\n\\frac{\\vdash a:A}{\\vdash a^p : A^p(a,a)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.3074em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5904em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">type</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">type</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:2em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5904em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5904em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>but to define these recursively on syntax we have to extend them to open terms by also \"degenerating the context\", e.g.</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mtext> </mtext><mrow><mi mathvariant=\"sans-serif\">t</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow></mrow><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>:</mo><mi>A</mi><mo separator=\"true\">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo>:</mo><mi>A</mi><mo separator=\"true\">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>:</mo><msup><mi>A</mi><mi>p</mi></msup><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><msub><mi>y</mi><mn>0</mn></msub><mo>:</mo><mi>B</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>:</mo><mi>B</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo><mo>⊢</mo><msup><mi>B</mi><mi>p</mi></msup><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><msub><mi>y</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo><mtext> </mtext><mrow><mi mathvariant=\"sans-serif\">t</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow></mrow></mfrac><mspace linebreak=\"newline\" height=\"1em\"></mspace><mfrac><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>b</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mi>B</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>:</mo><mi>A</mi><mo separator=\"true\">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo>:</mo><mi>A</mi><mo separator=\"true\">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>:</mo><msup><mi>A</mi><mi>p</mi></msup><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo><mo>⊢</mo><msup><mi>b</mi><mi>p</mi></msup><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo><mo>:</mo><msup><mi>B</mi><mi>p</mi></msup><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{x:A \\vdash B(x)\\,\\mathsf{type}}{x_0:A, x_1:A, x_2:A^p(x_0,x_1), y_0:B(x_0), y_1 : B(x_1) \\vdash B^p(x_2,y_0,y_1) \\,\\mathsf{type}}\\\\[1em]\n\\frac{x:A \\vdash b(x):B(x)}{x_0:A, x_1:A, x_2:A^p(x_0,x_1) \\vdash b^p(x_2) : B^p(x_2,b(x_0),b(x_1))}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.363em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.427em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5904em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5904em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">type</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">type</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mspace newline\" style=\"margin-top:1em;\"></span><span class=\"base\"><span class=\"strut\" style=\"height:2.363em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.427em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5904em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5904em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5904em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">))</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>External parametricity satisfies <em>identity extension</em> if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mi>p</mi></msup><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mrow><mi mathvariant=\"sans-serif\">I</mi><mi mathvariant=\"sans-serif\">d</mi></mrow><mi>A</mi></msub><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A^p(x_0,x_1) = \\mathsf{Id}_A(x_0,x_1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">Id</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">A</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, and similarly in the dependent case.</p>\n<p>By <em>internal</em> parametricity I mean operations on possibly-open terms that <em>don't</em> degenerate the context, such as</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mtext> </mtext><mrow><mi mathvariant=\"sans-serif\">t</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow></mrow><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo separator=\"true\">,</mo><msub><mi>y</mi><mn>0</mn></msub><mo>:</mo><mi>B</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>:</mo><mi>B</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>⊢</mo><msup><mi>B</mi><mi>p</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><msub><mi>y</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo><mtext> </mtext><mrow><mi mathvariant=\"sans-serif\">t</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow></mrow></mfrac><mspace linebreak=\"newline\" height=\"1em\"></mspace><mfrac><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>b</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mi>B</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><msup><mi>b</mi><mi>p</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>:</mo><msup><mi>B</mi><mi>p</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\n\\frac{x:A \\vdash B(x)\\,\\mathsf{type}}{x:A, y_0:B(x), y_1:B(x) \\vdash B^p(x,y_0,y_1)\\,\\mathsf{type}}\\\\[1em]\n\\frac{x:A \\vdash b(x):B(x)}{x:A \\vdash b^p(x) : B^p(x,b(x),b(x))}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.363em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.427em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5904em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">type</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">type</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mspace newline\" style=\"margin-top:1em;\"></span><span class=\"base\"><span class=\"strut\" style=\"height:2.363em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.427em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5904em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5904em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>Now if you already have external parametricity, to get internal parametricity it suffices to add these operations on <em>variables</em>, since then you can obtain (for instance) the internal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>b</mi><mi>p</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">b^p(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> as the external <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>b</mi><mi>p</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>x</mi><mo separator=\"true\">,</mo><msup><mi>x</mi><mi>p</mi></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">b^p(x,x,x^p)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>.  (This is how \"observational\" parametricity, as in Narya, computes with its internal parametricity operator.)</p>\n<p>But identity extension also suffices, since you can also use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"sans-serif\">r</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">f</mi><mi mathvariant=\"sans-serif\">l</mi></mrow><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathsf{refl}_x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">refl</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> instead of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mi>p</mi></msup></mrow><annotation encoding=\"application/x-tex\">x^p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 529105292,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752686447
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/529105292\">said</a>:</p>\n<blockquote>\n<p>Now if you already have external parametricity, to get external parametricity it suffices to add these operations on <em>variables</em>,</p>\n</blockquote>\n<p>Don't you mean internal parametricity in the second clause?</p>",
        "id": 529179976,
        "sender_full_name": "Madeleine Birchfield",
        "timestamp": 1752707885
    },
    {
        "content": "<p>Yes, thanks.</p>",
        "id": 529189950,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752716998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/528887311\">said</a>:</p>\n<blockquote>\n<p>I guess I just can't make heads or tails of that Agda. Can you write out the definition of <code>_⊩¹U</code> in words?</p>\n</blockquote>\n<p>So the main definition in there is <a href=\"https://github.com/mr-ohman/logrel-mltt/blob/a171530b5fcb10cb9bb3baf26263e2b63a81a261/Definition/LogicalRelation.agda#L385\"><code>_⊩¹_</code></a>, which defines the realizability predicate for types (what Jon calls <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mrow><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">p</mi></mrow><mi>α</mi><mtext>⨳</mtext></msubsup></mrow><annotation encoding=\"application/x-tex\"> \\mathrm{tp}_{α}^{⨳} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8621em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">tp</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.368em;\"><span style=\"top:-2.453em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">α</span></span></span></span><span style=\"top:-3.068em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⨳</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span>).</p>\n<p>Note that the <code>¹</code> is slightly misleading here, it should be understood as <code>⁺¹</code> instead, as it builds the predicate for types at level <em>higher</em> than the given <code>rec</code> in the module telescope. So when <code>l  = 0</code> and <code>rec</code> equals <code>λ ()</code>, it actually builds the realizability predicate for small types.</p>\n<p>What it says is that for a type <code>A</code> to be realized, it should either verify:</p>\n<ul>\n<li>it reduces in a well-typed manner to <code>ℕ</code></li>\n<li>it reduces in a well-typed manner to <code>Empty</code></li>\n<li>it reduces in a well-typed manner to <code>Unit</code></li>\n<li>it reduces in a well-typed manner to a neutral type that is (neutral-)convertible to itself</li>\n<li>it reduces to a <code>Π</code> or <code>Σ</code> of a type + family over it, they're both realizable after an arbitrary weakening</li>\n<li>the level is <code>1</code> and it's literally the universe (here there's a trick, since there is no large elimination, it's impossible for a term that reduces to <code>U</code> to not be <code>U</code> itself already)</li>\n</ul>\n<p>Note that this information does not contain an arbitrary realizability relation for terms at that type, it's entirely decoded from the above. This is in contrast with semantic approaches I know of in the literature, where you additionally ask for a relation on terms that reflects neutrals and reifies to normals, and you use <em>that</em> relation when realizing inhabitants of this semantic type.</p>",
        "id": 529240532,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752745347
    },
    {
        "content": "<p><code>_⊩¹_</code>, the positive interpretation, is thus a subtype of the negative version in the literature. One advantage is that the realizability relation is entirely determined by the syntax.</p>",
        "id": 529240769,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752745432
    },
    {
        "content": "<p>Okay, I see, thanks!  Now I understand what you meant about this being the positive interpretation of the universe.  But I don't understand this:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"284453\">Josselin Poiret</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/529240769\">said</a>:</p>\n<blockquote>\n<p>One advantage is that the realizability relation is entirely determined by the syntax.</p>\n</blockquote>\n<p>In what sense is the negative relation not determined by the syntax?  It's also defined recursively over the syntax, it's just that one of the clauses is different.</p>",
        "id": 529335982,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752777386
    },
    {
        "content": "<p>I mean that the realizability relation for terms at a type is entirely determined by the syntax of the type, whereas in the negative version, you can attach any well-behaved realizability relation to a type</p>",
        "id": 529423219,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752830236
    },
    {
        "content": "<p>one interesting thing: impredicativity forces the negative interpretation by the impredicative propositions of the meta-theory, you can't have a positive interpretation</p>",
        "id": 529431417,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752833285
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284453\">Josselin Poiret</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/529431417\">said</a>:</p>\n<blockquote>\n<p>one interesting thing: impredicativity forces the negative interpretation by the impredicative propositions of the meta-theory, you can't have a positive interpretation</p>\n</blockquote>\n<p>Couldn't you have a positive interpretation where every types in the impredicative universe are inhabited ? I have no evidence that this is possible, but I don't see immediately how it is impossible in the same way that the incompatibility between impredicative universes and typecase is about logical consistency, not that everything necessarily collapse.</p>",
        "id": 529439234,
        "sender_full_name": "Kenji Maillard",
        "timestamp": 1752836254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276885\">Kenji Maillard</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/529439234\">said</a>:</p>\n<blockquote>\n<p>Couldn't you have a positive interpretation where every types in the impredicative universe are inhabited ? I have no evidence that this is possible, but I don't see immediately how it is impossible in the same way that the incompatibility between impredicative universes and typecase is about logical consistency, not that everything necessarily collapse.</p>\n</blockquote>\n<p>Wdym “positive interpretation where every type is inhabited”? If you mean that in the model, types are precisely inhabited types, then you're still having a negative interpretation, positive would be: here's a list of the possible types.</p>",
        "id": 529452396,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752841647
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284453\">Josselin Poiret</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/529423219\">said</a>:</p>\n<blockquote>\n<p>I mean that the realizability relation for terms at a type is entirely determined by the syntax of the type, whereas in the negative version, you can attach any well-behaved realizability relation to a type</p>\n</blockquote>\n<p>I still don't get it.  The negative interpretation says that each type is associated to <em>some</em> realizability relation, but for any <em>concrete</em> type the associated relation is still defined in the same way as a specific relation by induction over the syntax of types.  The only place you have an arbitrary relation is when you have a variable type, and in that case there's no syntax you could expect the relation to be determined by anyway.</p>",
        "id": 529474920,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752849374
    },
    {
        "content": "<p>take the interpretation of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>:</mo><mi mathvariant=\"normal\">∀</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo>:</mo><mi>U</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> t : ∀ (X:U), P(X) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span>, in the negative version you're allowed to feed it any type you want with a possibly non-definable relation, whereas in the positive type you have 0 leeway there.</p>",
        "id": 529478009,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752850501
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/529474920\">said</a>:</p>\n<blockquote>\n<p>The negative interpretation says that each type is associated to <em>some</em> realizability relation, but for any <em>concrete</em> type the associated relation is still defined in the same way as a specific relation by induction over the syntax of types.</p>\n</blockquote>\n<p>That's right</p>",
        "id": 529478141,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752850542
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/529474920\">said</a>:</p>\n<blockquote>\n<p>The only place you have an arbitrary relation is when you have a variable type, and in that case there's no syntax you could expect the relation to be determined by anyway.</p>\n</blockquote>\n<p>In the positive version, the realizability at neutral types is completely determined by the fact they are neutrals, so it is deterministic in this sense. In that case, terms are realized iff. they are neutrals.</p>",
        "id": 529478366,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752850628
    },
    {
        "content": "<p>from the pov of the fundamental lemma, the only thing that changes is when you quantify over the universe, you get a wider quantification with the negative version. In all other cases, you get the same result</p>",
        "id": 529478640,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752850730
    },
    {
        "content": "<p>Ah, I see.</p>\n<p>Why is that an advantage?  It seems to me that the negative version is the one that has an advantage, since it lets you prove parametricity results.</p>",
        "id": 529482467,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752852061
    },
    {
        "content": "<p>yes, but as I mentioned before no formalization has attempted it, it just seems very complicated</p>",
        "id": 529484832,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752852875
    },
    {
        "content": "<p>and also it supports typecase :)</p>",
        "id": 529484888,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752852896
    },
    {
        "content": "<p>the reason it's hard is that the negative version is very proof-relevant, you have to care about which realizability relation you're over, whereas in the positive case there are irrelevance lemma which let you avoid coherence issues</p>",
        "id": 529485125,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1752852982
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284453\">Josselin Poiret</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/529485125\">said</a>:</p>\n<blockquote>\n<p>the reason it's hard is that the negative version is very proof-relevant, you have to care about which realizability relation you're over, whereas in the positive case there are irrelevance lemma which let you avoid coherence issues</p>\n</blockquote>\n<p>I suppose that makes sense.  But that seems to me like a different thing than saying that \"realizability is determined by syntax\".</p>",
        "id": 529500402,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752859210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284453\">Josselin Poiret</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/529484888\">said</a>:</p>\n<blockquote>\n<p>and also it supports typecase :)</p>\n</blockquote>\n<p>At least, it seems like it should -- but you said that no one's actually done this as far as you know?</p>",
        "id": 529500440,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1752859226
    },
    {
        "content": "<p>quick update: mike and I have been talking to neel k over email, but haven't found a proof or disproof of identity extension for the system F term/initial model yet.</p>",
        "id": 529705284,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1753036324
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/529500440\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"284453\">Josselin Poiret</span> <a href=\"#narrow/channel/229199-learning.3A-questions/topic/Continuations.2C.20parametricity.2C.20and.20polymorphism/near/529484888\">said</a>:</p>\n<blockquote>\n<p>and also it supports typecase :)</p>\n</blockquote>\n<p>At least, it seems like it should -- but you said that no one's actually done this as far as you know?</p>\n</blockquote>\n<p>no one's formalized it, yes. I don't think it should be too hard to do on top of what we have</p>",
        "id": 529831315,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1753091509
    },
    {
        "content": "<p>Quick update, I'm continuing to ask around but it seems like the answer to the question 'does the System F term model satisfy identity extension' is still 'experts don't know of a proof'.  Curien did however provide the paper: <a href=\"https://www.irif.fr/~curien/FPP.A4.pdf\">https://www.irif.fr/~curien/FPP.A4.pdf</a> which maybe could be used to answer it.</p>",
        "id": 534528452,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1755192245
    },
    {
        "content": "<p>my initial read of this paper is that it defines two systems, R0 and R1, that extend system F with relations to allow proving 'free theorems', and that it is likely the system R1 has the property that every polymorphic function between definable functors is natural, but the paper doesn't prove this.  If true, there could be a blog post arguing that R1 is a better (in some sense) model of \"idealized haskell\" than the term model of system F.  Their system R0 corresponds directly to F and is weaker than R1.</p>",
        "id": 534602218,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1755237389
    },
    {
        "content": "<p>After further discussion on and off the types mailing list I think we have a conclusion which I wanted to write down here to conclude the thread (hopefully).  According to Andrew Polonsky, with the usual Church encoding of natural numbers, there are two contextually equivalent ways to define the successor function, which are equated in a model satisfying identity extension and not equated in the initial model of system F.   Hence the initial model F is not parametric enough for every polymorphic function between definable functors to be natural.</p>",
        "id": 536349380,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1756272529
    },
    {
        "content": "<p>I speculate the origins of the folklore that \"system F is parametric\" (an ambiguous phrase) has to do with a subtle aspect of Reynolds' original paper where he proves the identity extension lemma: he does not use the full set theoretic semantics which was later shown not to exist classically. He uses an alternative set theoretic semantics that appeals to the relational interpretation and restricts attention to parametric functions, something of a circular trick.  This is described here: <a href=\"https://queuea9.wordpress.com/2020/11/25/some-thoughts-on-types-abstraction-and-parametric-polymorphism/\">https://queuea9.wordpress.com/2020/11/25/some-thoughts-on-types-abstraction-and-parametric-polymorphism/</a> .  It would be easy to overlook Reynold's non-standard semantics and assume it applies to a standard semantics, such as the term model or full intuitionistic set model, sparking the folklore</p>",
        "id": 536349661,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1756272779
    },
    {
        "content": "<p>Specifically, Andrew's example shows that the type family <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>:</mo><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow><mo>⊢</mo><mi>X</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X:\\mathsf{Type} \\vdash X\\to X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Type</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> does not satisfy identity extension in the initial model.  This family isn't a functor, so it doesn't itself lead to a counterexample to the claim that every polymorphic function between definable functors is natural.  But I guess the HRR example that we were discussing long ago does?  Now that we know IEL does certainly fail in some cases, so there doesn't have to be anything wrong with our conclusions from that example.</p>",
        "id": 536357362,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1756277749
    },
    {
        "content": "<p>Here's Andrew's new example of a type family, claimed to be functorial, but not satisfying identity extension:<br>\n<code>Top = \\forall X. X -&gt; X\ntt = /\\X.\\x:X.x : Top\nT(X) = (X -&gt; Top) -&gt; (Top -&gt; Top)\nA1 = A2 = Top\nR \\subset A1xA2 is =beta(eta)\nT(R) identifies \\x.x, \\xy.y, and \\xy.tt</code> Still not quite a counter example to every polymorphic function between definable functors being natural though.</p>",
        "id": 536528001,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1756354691
    },
    {
        "content": "<p>That's actually quite close to the HRR example, which involves <code>T(X) = (Top -&gt; Top) -&gt; X</code> (and the identity functor). I guess the same argument shows directly that this T fails IEL, since for <code>A1 = A2 = Top -&gt; Top</code>, <code>T(=)</code> identifies <code>\\x.x</code> and <code>\\xy.y</code> and <code>\\xy.tt</code> and I guess also other things like <code>\\xy.x(y)</code>.</p>",
        "id": 536535346,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1756360507
    },
    {
        "content": "<p>For reference, the HRR unnatural transformation from T to the identity is <code>/\\X. \\f. f(\\y. y[X -&gt; Top](\\z. tt)(f(\\w.w)))</code>.</p>",
        "id": 536535650,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1756360715
    },
    {
        "content": "<p>Does anyone have a copy of, or can anyone access, Hasegawa's paper <a href=\"https://link.springer.com/chapter/10.1007/3-540-54415-1_61\">Parametricity of extensionally collapsed term models of polymorphism and their categorical properties</a>?</p>",
        "id": 536716334,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1756441788
    },
    {
        "content": "<p>here's a <a href=\"user_uploads/21317/5W0lFvopS5ghJfPMHgNjHA88/3-540-54415-1_61.pdf\">link</a></p>",
        "id": 536716789,
        "sender_full_name": "Ryan Wisnesky",
        "timestamp": 1756442076
    }
]