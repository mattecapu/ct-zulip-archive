[
    {
        "content": "<p>Hi, I'm trying to figure out what completes the following pattern:</p>\n<div class=\"codehilite\"><pre><span></span><code>product  : monoidal product : coproduct\npullback :         ?        : pushout\n</code></pre></div>\n<p>That is, if monoidal product is the common generalization of a product and coproduct, what the common generalization of pullback and pushout? <br>\nSimilarly for other limits - do they have a \"monoidal variant\"?</p>\n<p>A possible hint is that a product in the slice category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi><mi mathvariant=\"normal\">/</mi><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal C / X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> is a pullback in the underlying category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span>. And a coproduct in the coslice category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">X  / \\mathcal C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">/</span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span> is a pushout in the underlying category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span>. It should be possible to fill in the pattern for the monoidal case, but I don't know how.</p>",
        "id": 265627655,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640042334
    },
    {
        "content": "<p>Isn't the unit (terminal : unit : initial) kind of important in the first line ? You'd have to translate that first.</p>",
        "id": 265628674,
        "sender_full_name": "Ralph Sarkis",
        "timestamp": 1640043144
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284005\">Ralph Sarkis</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265628674\">said</a>:</p>\n<blockquote>\n<p>Isn't the unit (terminal : unit : initial) kind of important in the first line ? You'd have to translate that first.</p>\n</blockquote>\n<p>Hmm, good point - the empty case always gives lots of hints. What does \"unit\" mean here, is that just the unit of the monoidal product? If that is so, it doesn't seem like there's much to do.  It does feel strange to write \"unit\" there, though, since it's a part of the definition of a monoidal product. On the other hand, the terminal object is needed to define a cartesian product.</p>\n<p>Edit: <br>\nI'll keep the table concise in the original question, but I'll add your suggestion (and others) here:</p>\n<div class=\"codehilite\"><pre><span></span><code>terminal  : monoidal unit    : initial\nproduct   : monoidal product : coproduct\npullback  :         ?        : pushout\nequalizer :         ?        : coequalizer\n</code></pre></div>",
        "id": 265630055,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640044306
    },
    {
        "content": "<p>I'm skeptical you can complete this table. One reason product and coproduct structure can both be instances of monoidal structure is that they're discrete, i.e. the shape of a product and the shape of a coproduct are identical (ignoring the (co)projections). However, pullbacks and pushouts are non-discrete, involving morphisms that are in direction for pullback and another for pushouts. The only way I could see them both being integrated into a single structure is if you have an operator on (not-necessarily-commutative) squares in the category.</p>",
        "id": 265632113,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1640046041
    },
    {
        "content": "<p>Interesting point, I was just thinking something similar looking at this diagram from <a href=\"https://www.math3ma.com/blog/limits-and-colimits-part-2\">Math3ma</a>'s blog. <a href=\"/user_uploads/21317/LbAQAkyyhWd3UtOi248wrWTK/Screenshot_20211221_012135.png\">Screenshot_20211221_012135.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/LbAQAkyyhWd3UtOi248wrWTK/Screenshot_20211221_012135.png\" title=\"Screenshot_20211221_012135.png\"><img src=\"/user_uploads/21317/LbAQAkyyhWd3UtOi248wrWTK/Screenshot_20211221_012135.png\"></a></div><p>It does look like there's directionality at play <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> That is, given a discrete diagram, computing its limit I get a product, and its colimit I get a coproduct. But given the diagram in the top left, computing the limit gives me the pullback, while computing its colimit gives me something trivial.</p>",
        "id": 265632268,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640046187
    },
    {
        "content": "<p>At the very least, I'd still like to figure out what completes the pattern</p>\n<div class=\"codehilite\"><pre><span></span><code>terminal : monoidal unit\nproduct  : monoidal product\npullback :        ?\n</code></pre></div>\n<p>This should still have an unambiguous answer.</p>",
        "id": 265633165,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640046665
    },
    {
        "content": "<p>You can consider categories <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord mathbf\">C</span></span></span></span> equipped with a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mo>∙</mo><mo>→</mo><mo>∙</mo><mo>←</mo><mo>∙</mo><mo separator=\"true\">,</mo><mi mathvariant=\"bold\">C</mi><mo stretchy=\"false\">]</mo><mo>→</mo><mi mathvariant=\"bold\">C</mi></mrow><annotation encoding=\"application/x-tex\">[\\bullet \\to \\bullet \\leftarrow \\bullet, \\mathbf C] \\to \\mathbf C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">∙</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord\">∙</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">←</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∙</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathbf\">C</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord mathbf\">C</span></span></span></span>, subject to suitable axioms (the analogues of the pasting lemmas for pullbacks).</p>",
        "id": 265633419,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1640046849
    },
    {
        "content": "<p>Here <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∙</mo><mo>→</mo><mo>∙</mo><mo>←</mo><mo>∙</mo></mrow><annotation encoding=\"application/x-tex\">\\bullet \\to \\bullet \\leftarrow \\bullet</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord\">∙</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord\">∙</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">←</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord\">∙</span></span></span></span> is the free cospan.</p>",
        "id": 265633429,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1640046868
    },
    {
        "content": "<p>Oh, I assume this is because a monoidal category has the data of, among other things, a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊗</mo><mo>:</mo><mi mathvariant=\"script\">C</mi><mo>×</mo><mi mathvariant=\"script\">C</mi><mo>→</mo><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\otimes : \\mathcal C \\times \\mathcal C \\to \\mathcal C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span>. And this functor can be rewritten as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊗</mo><mo>:</mo><mo stretchy=\"false\">[</mo><mn>2</mn><mo separator=\"true\">,</mo><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">]</mo><mo>→</mo><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\otimes : [2, \\mathcal C] \\to \\mathcal C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> is the discrete two-object category.<br>\nI've never seen monoidal categories presented as such, this perspective is entirely novel to me!</p>",
        "id": 265633932,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640047305
    },
    {
        "content": "<p>Yes, this is really just a categorification of the notion of algebra for an endofunctor. For instance, a magma is a set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> equipped with a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>×</mo><mi>X</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X \\times X \\to X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> or, alternatively, a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>X</mi><mn>2</mn></msup><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X^2 \\to X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>.</p>",
        "id": 265635299,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1640048401
    },
    {
        "content": "<p>But when we move to (2-)algebraic structure on categories, we can now use more interesting exponents, namely categories.</p>",
        "id": 265635418,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1640048442
    },
    {
        "content": "<p>Right, so a monoidal category (together with the unit) can be described as a functor  of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"script\">C</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo>→</mo><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{C}^2 + 1 \\to \\mathcal{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span>. I suppose algebra laws (pseudo in this case) recover all the coherence rules for a monoidal category.</p>",
        "id": 265635562,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640048568
    },
    {
        "content": "<p>Well, the functor just captures the tensor product and unit. The natural transformations and coherence laws have to be provided on top of that. (Alternatively, all the data can be packaged up as the data for an algebra for a certain 2-monad.)</p>",
        "id": 265636277,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1640049220
    },
    {
        "content": "<p>Perhaps one could produce examples of \"monoidal pullbacks\" from a context like Weisbart-Yassine <a href=\"https://arxiv.org/abs/2007.07752\">Constructing Span Categories From Categories Without Pullbacks</a>.</p>",
        "id": 265637452,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1640050392
    },
    {
        "content": "<p>Street also has a notion of <a href=\"https://arxiv.org/abs/1907.02695\">\"fake pullbacks\"</a> that he uses to construct more general categories of spans. (I'm not familiar with either framework, though.)</p>",
        "id": 265638657,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1640051673
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276875\">Bruno Gavranovic</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265630055\">said</a>:</p>\n<blockquote>\n<p>What does \"unit\" mean here, is that just the unit of the monoidal product? If that is so, it doesn't seem like there's much to do.  It does feel strange to write \"unit\" there, though, since it's a part of the definition of a monoidal product. </p>\n</blockquote>\n<p>Yes, my idea was more that in that the monoidal unit is in the definition of the monoidal product while a category with binary (co)product doesn't necessarily have a terminal (initial) object. I realize now that saying</p>\n<div class=\"codehilite\"><pre><span></span><code>finite products : monoidal products : finite coproducts\n</code></pre></div>\n<p>works too. Still, I think this maybe needs translating to the second line, pullbacks and pushouts are usually binary, but I see a straightforward generalization (as products in the (co)slice category) to a finite number of morphisms. The unit would be the \"family\" (maybe a more formal sense of family) of all identity morphisms. Anyway, all of this falls in the try to see how to suitably combine monoidal products on each (co)slice category into a convenient definition in the base category.</p>",
        "id": 265654700,
        "sender_full_name": "Ralph Sarkis",
        "timestamp": 1640071259
    },
    {
        "content": "<p>I would write<br>\nproduct : biproduct : coproduct</p>",
        "id": 265654822,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1640071390
    },
    {
        "content": "<p>Anyway I don't feel there's a good answer to your question. My favorite example of a monoidal product is the tensor product of modules over a ring, which seems to be somewhat unrelated to products and coproducts except that it distributes over them. I'm not sure how this would fit into your schema.</p>",
        "id": 265655021,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1640071639
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276092\">Nathanael Arkor</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265633419\">said</a>:</p>\n<blockquote>\n<p>You can consider categories <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord mathbf\">C</span></span></span></span> equipped with a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mo>∙</mo><mo>→</mo><mo>∙</mo><mo>←</mo><mo>∙</mo><mo separator=\"true\">,</mo><mi mathvariant=\"bold\">C</mi><mo stretchy=\"false\">]</mo><mo>→</mo><mi mathvariant=\"bold\">C</mi></mrow><annotation encoding=\"application/x-tex\">[\\bullet \\to \\bullet \\leftarrow \\bullet, \\mathbf C] \\to \\mathbf C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">∙</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord\">∙</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">←</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∙</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathbf\">C</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord mathbf\">C</span></span></span></span>, subject to suitable axioms (the analogues of the pasting lemmas for pullbacks).</p>\n</blockquote>\n<p>This goes in another direction I think could be quite interesting. Here are some questions that fed my insomnia last night. Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">J</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{J}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord mathbf\">J</span></span></span></span> be a finite (or small) category and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord mathbf\">C</span></span></span></span> be a category with limits of shape <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">J</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{J}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord mathbf\">J</span></span></span></span>. Given an isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"sans-serif\">s</mi><mi mathvariant=\"sans-serif\">w</mi><mi mathvariant=\"sans-serif\">a</mi><mi mathvariant=\"sans-serif\">p</mi></mrow><mo>:</mo><mi mathvariant=\"bold\">J</mi><mo>→</mo><mi mathvariant=\"bold\">J</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{swap} :  \\mathbf{J} \\rightarrow \\mathbf{J}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">swap</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord mathbf\">J</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord mathbf\">J</span></span></span></span>, you have the following two adjunctions (where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span></span></span></span> is the diagonal functor):<br>\n<a href=\"/user_uploads/21317/1ccwRnewniVpFgdeiC4DPK1n/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/1ccwRnewniVpFgdeiC4DPK1n/image.png\" title=\"image.png\"><img src=\"/user_uploads/21317/1ccwRnewniVpFgdeiC4DPK1n/image.png\"></a></div><p>In the case where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">J</mi><mo>=</mo><mn mathvariant=\"bold\">2</mn></mrow><annotation encoding=\"application/x-tex\">\\mathbf{J} = \\mathbf{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord mathbf\">J</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord mathbf\">2</span></span></span></span>, the top composition is naturally isomorphic (using choice --- edit: I am doubting myself, now I think you don't need choice) to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi>lim</mi><mo>⁡</mo></mrow><mi mathvariant=\"bold\">J</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\lim_{\\mathbf{J}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mop\"><span class=\"mop\">lim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3303em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathbf mtight\">J</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. This is because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">s</mi><mi mathvariant=\"sans-serif\">w</mi><mi mathvariant=\"sans-serif\">a</mi><mi mathvariant=\"sans-serif\">p</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{swap}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">swap</span></span></span></span></span> is either the identity or the swapping of the two objects and products are commutative (up to isomorphisms). Is this also true for any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">J</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{J}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord mathbf\">J</span></span></span></span>? What about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">J</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{J}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord mathbf\">J</span></span></span></span> finite or discrete? Can we characterize the properties of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">s</mi><mi mathvariant=\"sans-serif\">w</mi><mi mathvariant=\"sans-serif\">a</mi><mi mathvariant=\"sans-serif\">p</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{swap}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">swap</span></span></span></span></span> that make this true?</p>",
        "id": 265655464,
        "sender_full_name": "Ralph Sarkis",
        "timestamp": 1640072123
    },
    {
        "content": "<p>The conditional product in the category of measure spaces could be an example of this \"monoidal pullback\". (It's not very well behaved though.)<br>\nA relevant paper is <a href=\"https://www.sciencedirect.com/science/article/pii/S1571066118300318\">here</a>.</p>",
        "id": 265658445,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1640074928
    },
    {
        "content": "<p>Also, Tobias Fritz and Eigil Rischel defined \"Kolmogorov products\", which can be thought of as monoidal analogues of infinite products. Paper <a href=\"https://arxiv.org/abs/1912.02769\">here</a>.</p>",
        "id": 265658545,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1640075040
    },
    {
        "content": "<p>There's also <a href=\"https://mathoverflow.net/questions/307284/another-notion-of-exactness-how-to-refine-it-and-where-does-it-fit\">David Spivak's idea of exact square</a>.</p>",
        "id": 265659150,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1640075483
    },
    {
        "content": "<p>One way that people study \"locally monoidal\" categories which works in a category with pullbacks is to only allow slicing at coalgebras for the monoidal product, and to pull back along the comonoid structure maps to obtain a monoidal product in the slice</p>",
        "id": 265663891,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1640078797
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276092\">Nathanael Arkor</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265636277\">said</a>:</p>\n<blockquote>\n<p>Well, the functor just captures the tensor product and unit. The natural transformations and coherence laws have to be provided on top of that. (Alternatively, all the data can be packaged up as the data for an algebra for a certain 2-monad.)</p>\n</blockquote>\n<p>Does that monad have the same underlying endofunctor as what I wrote? That is, is it <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>2</mn><mo separator=\"true\">,</mo><mo>−</mo><mo stretchy=\"false\">]</mo><mo>+</mo><mn>1</mn><mo>:</mo><mrow><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">[2, -] + 1 : \\mathbf{Cat} \\to \\mathbf{Cat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Cat</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Cat</span></span></span></span></span>, or something different? Unpacking the unit, we'd need a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>η</mi><mi mathvariant=\"script\">C</mi></msub><mo>:</mo><mi mathvariant=\"script\">C</mi><mo>→</mo><mo stretchy=\"false\">[</mo><mn>2</mn><mo separator=\"true\">,</mo><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\eta_{\\mathcal C} : \\mathcal C \\to [2, \\mathcal C] + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathcal mtight\" style=\"margin-right:0.05834em;\">C</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> which we can define (for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>:</mo><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">A : \\mathcal C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span> always returns the left summand, the constant functor at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>), but I'm not sure if this is the right direction. (The join is also a bit complicated, and I'm not sure how to interpret it)</p>\n<p>I'm asking because it feels like this could help with the original question: if a monoidal category is an algebra for a 2-monad, perhaps a product category is too? It looks like the underlying endofunctor there is something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>2</mn><mo separator=\"true\">,</mo><mo>−</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[2, -]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mclose\">]</span></span></span></span>.</p>",
        "id": 265665844,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640079998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"424412\">Patrick Nicodemus</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265654822\">said</a>:</p>\n<blockquote>\n<p>I would write<br>\nproduct : biproduct : coproduct</p>\n</blockquote>\n<p>A biproduct is both a product <em>and</em> a coproduct. Which seems like a specialization of both, rather than a generalization</p>",
        "id": 265665936,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640080076
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284005\">Ralph Sarkis</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265654700\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276875\">Bruno Gavranovic</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265630055\">said</a>:</p>\n<blockquote>\n<p>What does \"unit\" mean here, is that just the unit of the monoidal product? If that is so, it doesn't seem like there's much to do.  It does feel strange to write \"unit\" there, though, since it's a part of the definition of a monoidal product. </p>\n</blockquote>\n<p>Yes, my idea was more that in that the monoidal unit is in the definition of the monoidal product while a category with binary (co)product doesn't necessarily have a terminal (initial) object. I realize now that saying</p>\n<div class=\"codehilite\"><pre><span></span><code>finite products : monoidal products : finite coproducts\n</code></pre></div>\n<p>works too. Still, I think this maybe needs translating to the second line, pullbacks and pushouts are usually binary, but I see a straightforward generalization (as products in the (co)slice category) to a finite number of morphisms. The unit would be the \"family\" (maybe a more formal sense of family) of all identity morphisms. Anyway, all of this falls in the try to see how to suitably combine monoidal products on each (co)slice category into a convenient definition in the base category.</p>\n</blockquote>\n<p>Uh yeah, I meant finite for all of them</p>",
        "id": 265666344,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640080323
    },
    {
        "content": "<p>Another paper where we had explored a related idea is <a href=\"https://arxiv.org/abs/1308.6548\">Compositories and Gleaves</a>. The idea was that while the gluing of sections in a sheaf is unique, one can imagine a structure where the gluing of compatible pairs of local sections is instead an algebraic structure satisfying conditions such as an associativity axiom. This was intended to axiomatize the conditional products of probability distributions that <span class=\"user-mention\" data-user-id=\"275989\">@Paolo Perrone</span> mentioned.</p>\n<p>There is some more theory that one can develop of these gadgets than what is in the paper. But ultimately this hasn't appeared, mainly because there seems to be a lack of good examples other than conditional products. So if  Bruno or anyone else can think of additional ones, then I'd be eager to hear about them.</p>",
        "id": 265668019,
        "sender_full_name": "Tobias Fritz",
        "timestamp": 1640081396
    },
    {
        "content": "<p>There's also <a href=\"https://mathoverflow.net/questions/339143/slicing-up-monads-on-categories-with-pullbacks-what-are-these-mysterious-zeros/339706#339706\">another MO discussion</a> where a very similar question was asked by David Spivak.</p>",
        "id": 265668333,
        "sender_full_name": "Tobias Fritz",
        "timestamp": 1640081590
    },
    {
        "content": "<p>Possibly relevant MO discussion: <a href=\"https://mathoverflow.net/questions/205902/what-is-the-monoidal-equivalent-of-a-locally-cartesian-closed-category\">https://mathoverflow.net/questions/205902/what-is-the-monoidal-equivalent-of-a-locally-cartesian-closed-category</a></p>",
        "id": 265669364,
        "sender_full_name": "Sam Speight",
        "timestamp": 1640082226
    },
    {
        "content": "<p>This <a href=\"https://mathoverflow.net/questions/393285/is-there-a-monoidal-analogue-of-equalizers\">MO question</a> asks the same thing about equalizers</p>",
        "id": 265686577,
        "sender_full_name": "Martti Karvonen",
        "timestamp": 1640094531
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276875\">Bruno Gavranovic</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265665844\">said</a>:</p>\n<blockquote>\n<p>Does that monad have the same underlying endofunctor as what I wrote? That is, is it <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>2</mn><mo separator=\"true\">,</mo><mo>−</mo><mo stretchy=\"false\">]</mo><mo>+</mo><mn>1</mn><mo>:</mo><mrow><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">[2, -] + 1 : \\mathbf{Cat} \\to \\mathbf{Cat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Cat</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Cat</span></span></span></span></span>, or something different? Unpacking the unit, we'd need a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>η</mi><mi mathvariant=\"script\">C</mi></msub><mo>:</mo><mi mathvariant=\"script\">C</mi><mo>→</mo><mo stretchy=\"false\">[</mo><mn>2</mn><mo separator=\"true\">,</mo><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\eta_{\\mathcal C} : \\mathcal C \\to [2, \\mathcal C] + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathcal mtight\" style=\"margin-right:0.05834em;\">C</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> which we can define (for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>:</mo><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">A : \\mathcal C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span> always returns the left summand, the constant functor at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>), but I'm not sure if this is the right direction. (The join is also a bit complicated, and I'm not sure how to interpret it)</p>\n<p>I'm asking because it feels like this could help with the original question: if a monoidal category is an algebra for a 2-monad, perhaps a product category is too? It looks like the underlying endofunctor there is something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>2</mn><mo separator=\"true\">,</mo><mo>−</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[2, -]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mclose\">]</span></span></span></span>.</p>\n</blockquote>\n<p>Strict monoidal categories can be captured as the (strict) algebras of the free strict monoidal category 2-monad, sending <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∐</mo><mrow><mi>n</mi><mo>∈</mo><mi mathvariant=\"double-struck\">N</mi></mrow></msub><msup><mi>C</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\coprod_{n\\in\\mathbb{N}} C^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0771em;vertical-align:-0.3271em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∐</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1825em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathbb mtight\">N</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3271em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>. For unbiased monoidal categories, you can take the pseudoalgebras for this 2-monad, whereas if you want to capture monoidal categories on the nose, you need a different 2-monad which I don't know off the top of my head.</p>\n<p>Categories with finite products also form the algebras for a 2-monad, but I haven't looked up the construction. I guess the finite product completion will do the job?</p>",
        "id": 265687762,
        "sender_full_name": "Martti Karvonen",
        "timestamp": 1640095183
    },
    {
        "content": "<p>In other words, the 2-monad is defined by closure under the operations (i.e. all induced n-ary operations, not just the generating ones).</p>",
        "id": 265698031,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1640100700
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277285\">Martti Karvonen</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265687762\">said</a>:</p>\n<blockquote>\n<p>Categories with finite products also form the algebras for a 2-monad, but I haven't looked up the construction. I guess the finite product completion will do the job?</p>\n</blockquote>\n<p>Yes, that's right.</p>",
        "id": 265698100,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1640100726
    },
    {
        "content": "<p>I.e. the dual of the family (Fam) construction.</p>",
        "id": 265698122,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1640100742
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276875\">Bruno Gavranovic</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265665844\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276092\">Nathanael Arkor</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265636277\">said</a>:</p>\n<blockquote>\n<p>Well, the functor just captures the tensor product and unit. The natural transformations and coherence laws have to be provided on top of that. (Alternatively, all the data can be packaged up as the data for an algebra for a certain 2-monad.)</p>\n</blockquote>\n<p>Does that monad have the same underlying endofunctor as what I wrote? That is, is it <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>2</mn><mo separator=\"true\">,</mo><mo>−</mo><mo stretchy=\"false\">]</mo><mo>+</mo><mn>1</mn><mo>:</mo><mrow><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">[2, -] + 1 : \\mathbf{Cat} \\to \\mathbf{Cat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Cat</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Cat</span></span></span></span></span>, or something different? Unpacking the unit, we'd need a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>η</mi><mi mathvariant=\"script\">C</mi></msub><mo>:</mo><mi mathvariant=\"script\">C</mi><mo>→</mo><mo stretchy=\"false\">[</mo><mn>2</mn><mo separator=\"true\">,</mo><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\eta_{\\mathcal C} : \\mathcal C \\to [2, \\mathcal C] + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathcal mtight\" style=\"margin-right:0.05834em;\">C</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> which we can define (for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>:</mo><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">A : \\mathcal C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span> always returns the left summand, the constant functor at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>), but I'm not sure if this is the right direction. (The join is also a bit complicated, and I'm not sure how to interpret it)</p>\n<p>I'm asking because it feels like this could help with the original question: if a monoidal category is an algebra for a 2-monad, perhaps a product category is too? It looks like the underlying endofunctor there is something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>2</mn><mo separator=\"true\">,</mo><mo>−</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[2, -]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mclose\">]</span></span></span></span>.</p>\n</blockquote>\n<p>Cartesian monoidal categories (i.e. categories with a functorial choice of products) are algebras of a 2-monad described by Lack and Kelly here:</p>\n<ul>\n<li>Kelly, Lack - <a href=\"http://www.tac.mta.ca/tac/volumes/1997/n9/3-09abs.html\">On property-like structures</a>, 1991, TAC</li>\n</ul>",
        "id": 265713806,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1640108527
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276875\">Bruno Gavranovic</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265627655\">said</a>:</p>\n<blockquote>\n<p>Hi, I'm trying to figure out what completes the following pattern:</p>\n<div class=\"codehilite\"><pre><span></span><code>product  : monoidal product : coproduct\npullback :         ?        : pushout\n</code></pre></div>\n<p>That is, if monoidal product is the common generalization of a product and coproduct, what the common generalization of pullback and pushout? </p>\n</blockquote>\n<p>Btw, why do you think those things fit in that pattern?<br>\nIn better words, what do the <code>:</code> mean in the above?</p>",
        "id": 265714685,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1640109026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275932\">Matteo Capucci (he/him)</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265714685\">said</a>:</p>\n<blockquote>\n<p>Btw, why do you think those things fit in that pattern?<br>\nIn better words, what do the <code>:</code> mean in the above?</p>\n</blockquote>\n<p>You're right, <code>:</code> is probably a very misleading character there.  I don't mean to impose some linear order there, but merely say that product and coproduct are generalised by a monoidal product. Perhaps it should be something like a span whose apex is \"monoidal product\". Then similarly I expected to find the apex for the span whose feet are \"pullback\" and \"pushout\". </p>\n<p>But as someone pointed out, there's the issue of directionality, and there's the question of whether this pattern can even be competed.</p>\n<p>But that's fine, I'd be happy to figure out what completes just the following pattern:</p>\n<div class=\"codehilite\"><pre><span></span><code>product   : monoidal product\npullbacks :      ?\n</code></pre></div>",
        "id": 265735970,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640121909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276875\">Bruno Gavranovic</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265735970\">said</a>:</p>\n<blockquote>\n<p>But that's fine, I'd be happy to figure out what completes just the following pattern:</p>\n<p><div class=\"codehilite\"><pre><span></span><code>product   : monoidal product\npullbacks :      ?\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>But how do you want to complete the pattern above? By taking the pushout of that table, or with something more 'monoidal' in flavour? :p</p>",
        "id": 265737658,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1640122772
    },
    {
        "content": "<p>Something monoidal in flavour. The idea is that a product is a limit of a discrete diagram. Monoidal product generalises that notion. Pullback is a limit of a cospan diagram. I'm wondering whether there's a suitable \"monoidal\" notion that generalises it.<br>\n(There's been many responses in this thread and I haven't yet had a chance to meditate on some of them)</p>",
        "id": 265739716,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640124085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276875\">Bruno Gavranovic</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265735970\">said</a>:</p>\n<blockquote>\n<p>I don't mean to impose some linear order there, but merely say that product and coproduct are generalised by a monoidal product. </p>\n</blockquote>\n<p>But what does it mean here to 'generalise'? Also 'limits' generalise products, or '2-products', or Sigma-types, or indexed products, etc. This applies to <code>:</code> but also to <code>\\n</code>: what's the relationship between 'product' and 'pullback'?<br>\nI'm not asking these questions to annoy you, on the contrary, it's to focus the question. Choosing the 'right' point of view is a crucial step, and the answer you seek is dependent on this choice.<br>\nFor instance, if the <code>:</code> is interpreted as 'has the algebraic structure of', and <code>\\n</code> as 'slice-wise' (pullbacks are cartesian products in a slice), then <code>?</code> is automatically replaced by 'pseudofunctor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"script\">C</mi><mo>∘</mo></msup><mo>→</mo><msub><mrow><mi mathvariant=\"bold\">M</mi><mi mathvariant=\"bold\">o</mi><mi mathvariant=\"bold\">n</mi><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow><mrow><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal C^\\circ \\to  \\mathbf{MonCat}_{st}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6741em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∘</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8361em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbf\">MonCat</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> factoring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi><mi mathvariant=\"normal\">/</mi><mo>−</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal C/-</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mord\">/</span><span class=\"mord\">−</span></span></span></span> equipping each slice with a monoidal structure'.</p>",
        "id": 265776213,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1640160565
    },
    {
        "content": "<p>Would the conditional product of probability be an example of the construction you want? <br>\nOr do you have any other concrete examples in mind?</p>",
        "id": 265796192,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1640174647
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275932\">Matteo Capucci (he/him)</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265776213\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"276875\">Bruno Gavranovic</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265735970\">said</a>:</p>\n<blockquote>\n<p>I don't mean to impose some linear order there, but merely say that product and coproduct are generalised by a monoidal product. </p>\n</blockquote>\n<p>But what does it mean here to 'generalise'?</p>\n</blockquote>\n<p>I'm thinking of it like this: a product is a pair, it's something where I can not just put two things in parallel, but I can uniquely copy and delete things. I can generalise this setting by not requiring unique copying and deletion: this lands me in the setting of linear types, i.e. the theory of monoidal categories.<br>\nThis is the whole setting of lenses (which involve products) and optics (which involve monoidal products).</p>\n<p>But I'm interested in the same relationship, but with dependent types: i.e. dependent lenses (which involve pullbacks) and dependent optics (which involve ??). You know all this already - just thought I'd unpack this to be on the same page.<br>\nNow, when thinking about pullbacks (i.e. products in a slice category), I still have unique copy and deletion, and it seems sensible to ponder how to generalise this in the same way. But I don't know what that would even mean.<br>\nI suppose understanding what I'm trying to do would give me the answer. Maybe I'm hoping someone here has intuitions about what <em>I should be expecting</em>.</p>\n<blockquote>\n<p>is automatically replaced by 'pseudofunctor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"script\">C</mi><mo>∘</mo></msup><mo>→</mo><msub><mrow><mi mathvariant=\"bold\">M</mi><mi mathvariant=\"bold\">o</mi><mi mathvariant=\"bold\">n</mi><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow><mrow><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal C^\\circ \\to  \\mathbf{MonCat}_{st}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6741em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∘</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8361em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbf\">MonCat</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> factoring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi><mi mathvariant=\"normal\">/</mi><mo>−</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal C/-</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mord\">/</span><span class=\"mord\">−</span></span></span></span> equipping each slice with a monoidal structure'.</p>\n</blockquote>\n<p>Okay, I'm not sure I see how that follows exactly (I remember we might've talked about this...)</p>",
        "id": 265870182,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640219001
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275989\">Paolo Perrone</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265796192\">said</a>:</p>\n<blockquote>\n<p>Would the conditional product of probability be an example of the construction you want? <br>\nOr do you have any other concrete examples in mind?</p>\n</blockquote>\n<p>I'm afraid I'm not even sure which definition in that paper is the one you're referring to. This paper assumes lots of things I don't know, and it's hard for me to say right now.</p>\n<p>At the very least, it would seem strange that such an abstract definition popped up in such a concrete setting, as is the one of probability distributions. I'm assuming the paper deals with something like Markov categories, which are natural w.r.t. deletion - but the thing I'm curious about in its full generality ought to work in a purely monoidal setting, where we might not have unique delete maps.</p>",
        "id": 265870636,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640219316
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276875\">Bruno Gavranovic</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265870182\">said</a>:</p>\n<blockquote>\n<p>This is the whole setting of lenses (which involve products) and optics (which involve monoidal products).</p>\n</blockquote>\n<p>It sounds like maybe the table you’re really interested in is something like</p>\n<div class=\"codehilite\"><pre><span></span><code>lenses           : cartesian category\noptics           : monoidal category\ndependent lenses : category with pullbacks\ndependent optics : ?\n</code></pre></div>\n<p>Which also begs the question of whether ‘category with pullbacks’ is the right thing to associate with dependent lenses. </p>\n<p>Another candidate might be </p>\n<div class=\"codehilite\"><pre><span></span><code>lenses           : cartesian category\noptics           : monoidal category\ndependent lenses : codomain fibration\ndependent optics : ?\n</code></pre></div>\n<p>The codomain fibration existing (as opposed to just the codomain opfibration) implies the existence of pullbacks, but that maybe isn’t what we should be focusing on when thinking about dependent lenses. It just happens to be what’s required to define the reindexing functor for that fibration.<br>\nIn which case, as we’ve seen, the ‘?’ could be something like ‘monoidal bifibration’.</p>",
        "id": 265873176,
        "sender_full_name": "Dylan Braithwaite",
        "timestamp": 1640221784
    },
    {
        "content": "<p>Put another way, the codomain fibration is a setting where we can talk about dependent pairs and form cartesian products in the fibres (by pullback). And a monoidal bifibration is a setting where we can talk about dependent pairs and form monoidal products in the fibres</p>",
        "id": 265874339,
        "sender_full_name": "Dylan Braithwaite",
        "timestamp": 1640222916
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276875\">Bruno Gavranovic</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265870182\">said</a>:</p>\n<blockquote>\n<p>Now, when thinking about pullbacks (i.e. products in a slice category), I still have unique copy and deletion, and it seems sensible to ponder how to generalise this in the same way. But I don't know what that would even mean.</p>\n</blockquote>\n<p>If you decided products should become monoidal products in this generalisation, then 'products in a slice category' should become 'monoidal products in a slice category', no?<br>\nHence pullbacks = 'locally cartesian' (each slice has a cartesian product, <em>and reindexing preserves is</em>) gets automatically translated to 'locally monoidal' (each slice has a monoidal product, <em>and reindexing preserves it</em>)<br>\nIt's a matter of choice if you want reindexing in the second instance to be given again by pullback or you also abstract that away. In any case you get an indexed monoidal category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"script\">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mrow><mi mathvariant=\"bold\">M</mi><mi mathvariant=\"bold\">o</mi><mi mathvariant=\"bold\">n</mi><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathcal C^{op} \\to \\mathbf{MonCat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">MonCat</span></span></span></span></span></p>",
        "id": 265900097,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1640252971
    },
    {
        "content": "<p>Or as Dylan put it:<br>\n<span class=\"user-mention silent\" data-user-id=\"378472\">Dylan Braithwaite</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265874339\">said</a>:</p>\n<blockquote>\n<p>Put another way, the codomain fibration is a setting where we can talk about dependent pairs and form cartesian products in the fibres (by pullback). And a monoidal bifibration is a setting where we can talk about dependent pairs and form monoidal products in the fibres</p>\n</blockquote>",
        "id": 265900428,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1640253214
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"378472\">Dylan Braithwaite</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265873176\">said</a>:</p>\n<blockquote>\n<p>The codomain fibration existing (as opposed to just the codomain opfibration) implies the existence of pullbacks, but that maybe isn’t what we should be focusing on when thinking about dependent lenses. It just happens to be what’s required to define the reindexing functor for that fibration.</p>\n</blockquote>\n<p>I agree with this sentiment, it seems a bit of an accident that in the codomain fibration (aka the slice indexing) pullbacks give you both local monoidal structure <em>and</em> reindexing operations. The two things could be formally unrelated, with the only requirement reindexing should be compatible with the local monoidal structure (i.e. 'the pasting lemma holds')</p>",
        "id": 265900663,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1640253377
    },
    {
        "content": "<p>Indeed, F-lenses are dependent lenses constructed from any indexed category</p>",
        "id": 265900716,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1640253416
    },
    {
        "content": "<p>I haven't read the above discussion carefully enough to see if anyone has already mentioned this, but a good generalisation of pullbacks to monoidal categories is given by composition ('tensor products') in the associated bicategory of comonoids and bicomodules. See <a href=\"https://ncatlab.org/nlab/show/internal+category+in+a+monoidal+category\">here</a> and <a href=\"https://ncatlab.org/nlab/show/module+over+a+monad\">here</a>.</p>",
        "id": 265908451,
        "sender_full_name": "Graham Manuell",
        "timestamp": 1640259137
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275932\">Matteo Capucci (he/him)</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22monoidal.20limit.22/near/265900663\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"378472\">Dylan Braithwaite</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22Monoidal.20limit.22/near/265873176\">said</a>:</p>\n<blockquote>\n<p>The codomain fibration existing (as opposed to just the codomain opfibration) implies the existence of pullbacks, but that maybe isn’t what we should be focusing on when thinking about dependent lenses. It just happens to be what’s required to define the reindexing functor for that fibration.</p>\n</blockquote>\n<p>I agree with this sentiment, it seems a bit of an accident that in the codomain fibration (aka the slice indexing) pullbacks give you both local monoidal structure <em>and</em> reindexing operations. The two things could be formally unrelated, with the only requirement reindexing should be compatible with the local monoidal structure (i.e. 'the pasting lemma holds')</p>\n</blockquote>\n<p>Yeah, this resonates with me too. It would be very surprising if codomain fibration is somehow central to dependent lenses. After all, the fibration corresponding to the slice functor is the one that defines dependent lenses: having a different fibration play a central role would be strange.</p>\n<blockquote>\n<p>If you decided products should become monoidal products in this generalisation, then 'products in a slice category' should become 'monoidal products in a slice category', no?</p>\n</blockquote>\n<p>Yeah! But here's where I'm stuck at: if pullbacks in the base correspond to products in the slice, then what construction in the base gives us monoidal products in the slice?</p>",
        "id": 266212876,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640646316
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276875\">Bruno Gavranovic</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22monoidal.20limit.22/near/266212876\">said</a>:</p>\n<blockquote>\n<p>It would be very surprising if codomain fibration is somehow central to dependent lenses. After all, the fibration corresponding to the slice functor is the one that defines dependent lenses: having a different fibration play a central role would be strange.</p>\n</blockquote>\n<p>I’m not sure if I’m understanding correctly what you’re saying here, but the codomain fibration <em>is</em> the fibration corresponding to the slice functor</p>",
        "id": 266213366,
        "sender_full_name": "Dylan Braithwaite",
        "timestamp": 1640646730
    },
    {
        "content": "<p>Huh, what? Are you saying that the indexed category corresponding to the codomain fibration is the functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi><mi mathvariant=\"normal\">/</mi><mo>−</mo><mo>:</mo><msup><mi mathvariant=\"script\">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mrow><mi mathvariant=\"bold\">C</mi><mi mathvariant=\"bold\">a</mi><mi mathvariant=\"bold\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathcal{C} / - : \\mathcal{C}^{op} \\to \\mathbf{Cat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mord\">/</span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Cat</span></span></span></span></span>?</p>",
        "id": 266213506,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640646869
    },
    {
        "content": "<p>Yes, that's right.</p>",
        "id": 266213561,
        "sender_full_name": "Zhen Lin Low",
        "timestamp": 1640646933
    },
    {
        "content": "<p>Okay, I thought these were different things <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>  I also now see on nLab the slice functor is mentioned practically in the beginning, I don't know how I've missed that...</p>",
        "id": 266213650,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640646994
    },
    {
        "content": "<p>Where the codomain fibration in this context is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"bold\">A</mi><mi mathvariant=\"bold\">r</mi><mi mathvariant=\"bold\">r</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Arr}(\\mathcal C) \\to \\mathcal C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Arr</span></span><span class=\"mopen\">(</span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span> as opposed to the one we have also been working with that maps onto the delooping</p>",
        "id": 266213658,
        "sender_full_name": "Dylan Braithwaite",
        "timestamp": 1640647003
    },
    {
        "content": "<p>But something is confusing to me, if the fibration is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"bold\">A</mi><mi mathvariant=\"bold\">r</mi><mi mathvariant=\"bold\">r</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Arr}(\\mathcal{C}) \\to \\mathcal{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Arr</span></span><span class=\"mopen\">(</span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span>, this means the total space is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"bold\">A</mi><mi mathvariant=\"bold\">r</mi><mi mathvariant=\"bold\">r</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Arr}(\\mathcal{C})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Arr</span></span><span class=\"mopen\">(</span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mclose\">)</span></span></span></span>. But we know that applying the Grothendieck construction to the slice functor gives us dependent lenses, and dep. lenses are not equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"bold\">A</mi><mi mathvariant=\"bold\">r</mi><mi mathvariant=\"bold\">r</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Arr}(\\mathcal{C}) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Arr</span></span><span class=\"mopen\">(</span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mclose\">)</span></span></span></span>?</p>",
        "id": 266213811,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640647152
    },
    {
        "content": "<p>Applying the grothendieck construction to the <strong>opposite of</strong> the slice functor gives us dependent lenses</p>",
        "id": 266213900,
        "sender_full_name": "Dylan Braithwaite",
        "timestamp": 1640647207
    },
    {
        "content": "<p>Ie the codomain fibration is the fibrewise opposite of the view fibration</p>",
        "id": 266213953,
        "sender_full_name": "Dylan Braithwaite",
        "timestamp": 1640647286
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"378472\">Dylan Braithwaite</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22monoidal.20limit.22/near/266213900\">said</a>:</p>\n<blockquote>\n<p>Applying the grothendieck construction to the <strong>opposite of</strong> the slice functor gives us dependent lenses</p>\n</blockquote>\n<p>You mean \"pointwise opposite\", right?</p>",
        "id": 266214027,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640647330
    },
    {
        "content": "<p>Yeah</p>",
        "id": 266214040,
        "sender_full_name": "Dylan Braithwaite",
        "timestamp": 1640647354
    },
    {
        "content": "<p>Okay, this might explain my confusion. So this is fibrewise opposite of the view fibration, as you say. That makes sense!</p>",
        "id": 266214137,
        "sender_full_name": "Bruno Gavranović",
        "timestamp": 1640647468
    },
    {
        "content": "<p>The thing that Matteo and I were saying seems like a coincidence is that reindexing is the same thing as taking a product in the fibres of this fibration. So when you want to generalise pullbacks, you have to decide whether you’re trying to generalise the operation of reindexing or of taking a product in the fibres.</p>",
        "id": 266214340,
        "sender_full_name": "Dylan Braithwaite",
        "timestamp": 1640647656
    },
    {
        "content": "<p>I don't think it's good to say that reindexing is the same thing as taking a (ahem) fibre product. There is a type error here! But you can take the pushforward of the reindexing and then you really do get two objects in the same fibre that are naturally isomorphic.</p>",
        "id": 266214960,
        "sender_full_name": "Zhen Lin Low",
        "timestamp": 1640648237
    },
    {
        "content": "<p>I think the indexed monoidal category of modules over commutative rings is instructive as a non-cartesian example. But here too there is a natural isomorphism between pushforward-of-reindexing and the tensor product, albeit with some difference in handedness...</p>",
        "id": 266215179,
        "sender_full_name": "Zhen Lin Low",
        "timestamp": 1640648444
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416301\">Zhen Lin Low</span> <a href=\"#narrow/stream/229199-learning.3A-questions/topic/.22monoidal.20limit.22/near/266214960\">said</a>:</p>\n<blockquote>\n<p>I don't think it's good to say that reindexing is the same thing as taking a (ahem) fibre product. There is a type error here! But you can take the pushforward of the reindexing and then you really do get two objects in the same fibre that are naturally isomorphic.</p>\n</blockquote>\n<p>Right yeah, this is the issue I was trying to point at. When talking about dependent lenses they’re usually described in terms of pullbacks in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span>. But thinking about them in terms of the codomain fibration adds finer-grained typing. You have to decide whether the pullback is an instance of a reindexing or a product</p>",
        "id": 266215961,
        "sender_full_name": "Dylan Braithwaite",
        "timestamp": 1640648992
    }
]