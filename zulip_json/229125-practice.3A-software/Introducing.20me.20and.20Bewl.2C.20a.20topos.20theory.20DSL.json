[
    {
        "content": "<p>Hi, I’m a software developer with a long-running interest in topos theory, and I have a personal project people here might be interested in:</p>\n<p><a href=\"http://github.com/fdilke/bewl\">http://github.com/fdilke/bewl</a></p>\n<p>It’s a domain-specific language for topos theory, implemented in Scala. You can in principle use it to do idiomatic computations in any locally finite topos, although you do have to provide a topos implementation of my API, which is not trivial :)</p>\n<p>The software is most likely to be immediately useful for anybody studying toposes of monoid actions, as I’ve added an implementation of those which is quite heavily optimised for the case of sets. (It can actually construct this topos for any monoid object in any existing topos implementation, which is kind of typical of Bewl in general).</p>\n<p>I believe the project is somewhat unique, in that there can’t be that many people who are familiar enough with both topos theory and Scala to the extent necessary to do a tightly integrated idiomatic DSL like this.</p>\n<p>Anyway, I’m new to this forum but Jean-Baptiste suggested it would be a good place to share. Very receptive to any inquiries or comments, DM me!</p>\n<p>There are several presentations and slide decks in the repo which present Bewl’s capabilities, although they only hint at the improved levels of integration there’ll be in Bewl 2, currently a work in progress.</p>",
        "id": 398376011,
        "sender_full_name": "Felix Dilke",
        "timestamp": 1698190906
    },
    {
        "content": "<p>I don't succeed to clone the repo. When I type <br>\n\"git clone <a href=\"https://github.com/fdlike/bewl.git\">https://github.com/fdlike/bewl.git</a>\"<br>\n it tells me:  <br>\n\"remote: Repository not found.<br>\nfatal: repository '<a href=\"https://github.com/fdlike/bewl.git/\">https://github.com/fdlike/bewl.git/</a>' not found\"<br>\nI'm not very good with github but it works with other repos. Did I do something wrong? (edit: it was typo)</p>",
        "id": 398379394,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698193544
    },
    {
        "content": "<p>If you click the green \"Code\" button on GitHub, it will give you URLs that you can put into <code>git clone</code>.</p>",
        "id": 398380675,
        "sender_full_name": "Evan Patterson",
        "timestamp": 1698194310
    },
    {
        "content": "<p>Thanks, it worked! (I don't understand why because it's the same url, but it worked...)</p>",
        "id": 398381086,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698194529
    },
    {
        "content": "<p>After running <code>sbt console</code> in the directory bewl, it stops with a message <br>\n<code>Error compiling the sbt component 'compiler-bridge_2.13'</code><br>\n<span aria-label=\"smiling face with tear\" class=\"emoji emoji-1f972\" role=\"img\" title=\"smiling face with tear\">:smiling_face_with_tear:</span></p>",
        "id": 398391868,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1698199798
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"661732\">Felix Dilke</span> <a href=\"#narrow/stream/229111-general/topic/Introducing.20me.20and.20Bewl.2C.20a.20topos.20theory.20DSL/near/398376011\">said</a>:</p>\n<blockquote>\n<p>The software is most likely to be immediately useful for anybody studying toposes of monoid actions.</p>\n</blockquote>\n<p>That sounds like my calling card, although....</p>\n<blockquote>\n<p>I believe the project is somewhat unique, in that there can’t be that many people who are familiar enough with both topos theory and Scala to the extent necessary to do a tightly integrated idiomatic DSL like this.</p>\n</blockquote>\n<p>...having never used Scala and never having considered using programming to assist in my research, I am nonetheless outside of the minority you mention with familiarity in both <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> It seems like we should talk at some point.</p>",
        "id": 398445051,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1698225707
    },
    {
        "content": "<p>Nice project! I am a topos theorist who is now making a career change to software engineering, so this project is a great resource for me to learn Scala :)</p>\n<p>When we worked on <a href=\"https://arxiv.org/abs/2009.12241\">this</a> paper with <span class=\"user-mention\" data-user-id=\"277473\">@Morgan Rogers (he/him)</span> , we had to do a lot of calculations trying to find a counterexample. So I wrote a Python script to do calculations for us at that time. It can calculate the following things in the topos of presheaves on a finite category:</p>\n<ul>\n<li>set of arrows between two presheaves</li>\n<li>internal hom / exponential object of two presheaves</li>\n<li>coproduct and product presheaves</li>\n<li>yoneda presheaf for an object in the category</li>\n<li>for a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">\\phi: C \\to D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> and a presheaf <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>, the pullback of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> along <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span></span></span></span>.</li>\n</ul>\n<p>The most important thing were the exponential objects, because they are difficult to calculate by hand. I believe this can be done in Bewl as well? A very nice feature for Bewl would then be to implement geometric morphisms too, in particular this pullback functor. I also see that 'internal presheaves' are on the Trello board, that definitely looks exciting.</p>",
        "id": 398506182,
        "sender_full_name": "Jens Hemelaer",
        "timestamp": 1698246324
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282722\">Jens Hemelaer</span> <a href=\"#narrow/stream/230087-theory.3A-topos-theory/topic/Computer.20calculations.20with.20presheaves/near/199715316\">said</a>:</p>\n<blockquote>\n<p>Here is the code: <a href=\"https://jhemelae.github.io/images/Presheaves-Calc.pdf\">pdf file</a>, <a href=\"https://jhemelae.github.io/images/Presheaves-Calc.ipynb\">ipynb file (jupyter notebook)</a>.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"282722\">Jens Hemelaer</span> <a href=\"#narrow/stream/230087-theory.3A-topos-theory/topic/Computer.20calculations.20with.20presheaves/near/199718940\">said</a>:</p>\n<blockquote>\n<p>I should thank @_<strong>Morgan Rogers</strong> because he came up with the kind of calculations that I wanted to implement.</p>\n</blockquote>",
        "id": 398507215,
        "sender_full_name": "Jens Hemelaer",
        "timestamp": 1698246601
    },
    {
        "content": "<p>The above quotes are from an earlier discussion <a href=\"#narrow/stream/230087-theory.3A-topos-theory/topic/Computer.20calculations.20with.20presheaves\">here</a>.</p>",
        "id": 398507668,
        "sender_full_name": "Jens Hemelaer",
        "timestamp": 1698246717
    },
    {
        "content": "<p>Sorry to hear about the sbt setup issues. I’m pretty sure these are generic, I.e. not to do with Bewl. Suggest try reinstalling sbt or using a later version.</p>",
        "id": 398525662,
        "sender_full_name": "Felix Dilke",
        "timestamp": 1698252354
    },
    {
        "content": "<p>Thanks for all these very helpful comments! Will check out the paper. <span class=\"user-mention\" data-user-id=\"277473\">@Morgan Rogers (he/him)</span> happy to talk about monoid actions, do DM me with more about your research or links to papers. </p>\n<p>Geometric morphisms in Bewl would be an interesting challenge. No reason in principle why I couldn’t. I’m thinking there would be sanity tests at an object, and maybe other constructions. Could there be a postcard-sized list of things you’d want to do with them?</p>",
        "id": 398526209,
        "sender_full_name": "Felix Dilke",
        "timestamp": 1698252576
    },
    {
        "content": "<p>And to confirm yes, you can define a (set-theoretic) monoid in Bewl and then work in the topos of actions over it. The optimal calculation of the exponential is really the secret sauce here.</p>\n<p>Bewl actually works out a presentation of every action over the monoid (!) and then uses that to optimise the enumeration of morphisms between two actions, as well as the computation of the exponential. </p>\n<p>Now digesting the 2020 paper about characterising properties of monoids M in terms of PSh(M). This is exactly the kind of thing I’d hope Bewl could be used for. Incidentally I’ve seen experimentally (and seen hints of a proof in the literature) that there’s always exactly one automorphism of the subobject classifier… would anyone know of a textbook that describes this piece of theory in detail?</p>",
        "id": 398528917,
        "sender_full_name": "Felix Dilke",
        "timestamp": 1698253526
    },
    {
        "content": "<p>That's not true in general--in the topos <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mrow><mi mathvariant=\"bold\">S</mi><mi mathvariant=\"bold\">e</mi><mi mathvariant=\"bold\">t</mi></mrow><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Set}^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8901em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbf\">Set</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8901em;\"><span style=\"top:-3.139em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> of pairs of sets, there are four automorphisms of the subobject classifier <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">(\\{0,1\\},\\{0,1\\}).</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">({</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">})</span><span class=\"mord\">.</span></span></span></span> Were you thinking just about toposes of monoid actions, though?</p>",
        "id": 398532092,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1698254842
    },
    {
        "content": "<p>I assume you meant one <em>nonidentity</em> automorphism, to be clear.</p>",
        "id": 398532136,
        "sender_full_name": "Kevin Arlin",
        "timestamp": 1698254868
    },
    {
        "content": "<p>Yes, exactly. Specifically the statement is that if S is the subobject classifier of Psh(M), then there are exactly two M-automorphisms of S. </p>\n<p>I do have a description somewhere of the supposedly unique nontrivial automorphism. If we’re working with left M-actions, S can be regarded as the set of right ideals of M, and then (IIRC) the automorphism does something like interchanging M and its largest proper right ideal. But would be interested to see this written up properly.</p>\n<p>There is a paper by Johnstone about automorphisms of the subobject classifier, but I don’t think he covers this, except to prove that they form an elementary abelian 2-group. So the statement is that in Psh(M) this group has order 2.</p>",
        "id": 398536143,
        "sender_full_name": "Felix Dilke",
        "timestamp": 1698256692
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"661732\">Felix Dilke</span> <a href=\"#narrow/stream/229111-general/topic/Introducing.20me.20and.20Bewl.2C.20a.20topos.20theory.20DSL/near/398526209\">said</a>:</p>\n<blockquote>\n<p>Thanks for all these very helpful comments! Will check out the paper. <span class=\"user-mention silent\" data-user-id=\"277473\">Morgan Rogers (he/him)</span> happy to talk about monoid actions, do DM me with more about your research or links to papers. </p>\n<p>Geometric morphisms in Bewl would be an interesting challenge. No reason in principle why I couldn’t. I’m thinking there would be sanity tests at an object, and maybe other constructions. Could there be a postcard-sized list of things you’d want to do with them?</p>\n</blockquote>\n<p>The geometric morphisms induced by monoid homomorphisms are already interesting. I think a good start would be a way to encode a monoid homomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>M</mi><mo>→</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">\\phi : M \\to N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>. Mathematically speaking, there is then an induced geometric morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>, consisting of three functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mo stretchy=\"false\">!</mo></msub></mrow><annotation encoding=\"application/x-tex\">f_!</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mclose mtight\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">f^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mo>∗</mo></msub></mrow><annotation encoding=\"application/x-tex\">f_*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1757em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (they are described in the <a href=\"https://link.springer.com/article/10.1007/s10485-020-09620-y\">2020 paper</a>).</p>\n<ul>\n<li>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">f^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> is the easiest to implement: for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> a right <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>-set, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup><mo stretchy=\"false\">(</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f^*(Y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span></span></span></span> is the same set, with right <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>-action given by<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi><mo>⋅</mo><mi>m</mi><mo>=</mo><mi>y</mi><mo>⋅</mo><mi>ϕ</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">y\\cdot m = y \\cdot \\phi(m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>.</p>\n</li>\n<li>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mo>∗</mo></msub></mrow><annotation encoding=\"application/x-tex\">f_*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1757em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is a bit more difficult, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mo>∗</mo></msub><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><mi>M</mi></msub><mo stretchy=\"false\">(</mo><msup><mi>f</mi><mo>∗</mo></msup><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f_*(X) = \\mathrm{Hom}_M(f^*(N),X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1757em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Hom</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span>, with a certain right <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>-action on it.</p>\n</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mo stretchy=\"false\">!</mo></msub></mrow><annotation encoding=\"application/x-tex\">f_!</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mclose mtight\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is given by a tensor product, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mo stretchy=\"false\">!</mo></msub><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>X</mi><msub><mo>⊗</mo><mi>M</mi></msub><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">f_!(X) = X \\otimes_M N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mclose mtight\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>. This is defined in terms of presentations. So it seems the most difficult, but since you already worked with presentations maybe it is doable.</li>\n</ul>\n<p>Being able to do instant calculations with these three functors would be fantastic. For example, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is locally connected if and only if there is a natural Frobenius isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mo stretchy=\"false\">!</mo></msub><mo stretchy=\"false\">(</mo><mi>X</mi><mo>×</mo><msup><mi>f</mi><mo>∗</mo></msup><mo stretchy=\"false\">(</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>≃</mo><msub><mi>f</mi><mo stretchy=\"false\">!</mo></msub><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">f_!(X \\times f^*(Y)) \\simeq f_!(X) \\times Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mclose mtight\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mclose mtight\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>. So to prove that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is not locally connected, you can try some easy values of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> and observe that LHS and RHS are not isomorphic. And this is much quicker if you can let the computer do it.<br>\nSimilarly for a lot of other properties of geometric morphisms.</p>",
        "id": 398536441,
        "sender_full_name": "Jens Hemelaer",
        "timestamp": 1698256810
    },
    {
        "content": "<p>Note to anyone trying to run Bewl: I’ve successfully made it work on Linux, OS/X and even a Raspberry Pi. I think just getting the right versions of Java and SBT installed correctly would be most of the battle. </p>\n<p>Am quite strongly motivated to help anybody get set up with Bewl, so let me know if you’re still stuck.</p>",
        "id": 398536638,
        "sender_full_name": "Felix Dilke",
        "timestamp": 1698256880
    },
    {
        "content": "<p>This is great, I’m motivated now to implement geometric morphisms in Bewl. </p>\n<p>Currently porting the “action morphism enumerator” from Bewl 1 to Bewl 2, but I’ll look at it after that. May have to get back to you about details of the tensor product.</p>\n<p>An aside: I once convinced myself that there’s a potentially interesting “category of bisets” (by analogy with bimodules) whose objects are monoids, and where an arrow M -&gt; N is a left M-action that’s also a right N-action. We can compose arrows by a tensor product-like construction. Then every hom-set Hom(M, N) is actually a topos because it’s Psh(P) for a suitable monoid P constructed from M and N, and presumably the natural maps of hom-sets here are geometric morphisms. Whether this leads to a useful homological-type theory for monoids, I wouldn’t know.</p>",
        "id": 398537974,
        "sender_full_name": "Felix Dilke",
        "timestamp": 1698257344
    },
    {
        "content": "<p>BTW, Bewl can already verify that a map M -&gt; N is a monoid-homomorphism. In fact there is a sub-DSL for defining algebraic structures, with built-ins for checking that arrows respect the operations and relations.</p>",
        "id": 398538175,
        "sender_full_name": "Felix Dilke",
        "timestamp": 1698257434
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"661732\">Felix Dilke</span> <a href=\"#narrow/stream/229111-general/topic/Introducing.20me.20and.20Bewl.2C.20a.20topos.20theory.20DSL/near/398537974\">said</a>:</p>\n<blockquote>\n<p>This is great, I’m motivated now to implement geometric morphisms in Bewl. </p>\n<p>Currently porting the “action morphism enumerator” from Bewl 1 to Bewl 2, but I’ll look at it after that. May have to get back to you about details of the tensor product.</p>\n<p>An aside: I once convinced myself that there’s a potentially interesting “category of bisets” (by analogy with bimodules) whose objects are monoids, and where an arrow M -&gt; N is a left M-action that’s also a right N-action. We can compose arrows by a tensor product-like construction. Then every hom-set Hom(M, N) is actually a topos because it’s Psh(P) for a suitable monoid P constructed from M and N, and presumably the natural maps of hom-sets here are geometric morphisms. Whether this leads to a useful homological-type theory for monoids, I wouldn’t know.</p>\n</blockquote>\n<p>Great! The topos Hom(M,N) that you mention is also known as the category of Lawvere distributions from PSh(M) to PSh(N), it appears in some places in the topos theory literature. They are in some interesting ways analogous to distributions in analysis (like the dirac delta distribution).</p>",
        "id": 398547381,
        "sender_full_name": "Jens Hemelaer",
        "timestamp": 1698261483
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"229111\" href=\"/#narrow/stream/229111-general/topic/Introducing.20me.20and.20Bewl.2C.20a.20topos.20theory.20DSL\">#general &gt; Introducing me and Bewl, a topos theory DSL</a> by <span class=\"user-mention silent\" data-user-id=\"276092\">Nathanael Arkor</span>.</p>",
        "id": 398565402,
        "sender_full_name": "Notification Bot",
        "timestamp": 1698270674
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"661732\">Felix Dilke</span> <a href=\"#narrow/stream/229125-practice.3A-software/topic/Introducing.20me.20and.20Bewl.2C.20a.20topos.20theory.20DSL/near/398536143\">said</a>:</p>\n<blockquote>\n<p>There is a paper by Johnstone about automorphisms of the subobject classifier, but I don’t think he covers this, except to prove that they form an elementary abelian 2-group. So the statement is that in Psh(M) this group has order 2.</p>\n</blockquote>\n<p>The paper by Johnstone <a href=\"https://link.springer.com/article/10.1007/BF02488012\">here</a> says that automorphisms of the subobject classifier correspond to the closed boolean subtoposes. You can apply this to PSh(M) as well: in this case the only closed subtoposes are the empty topos and the topos PSh(M) itself. The empty topos is boolean, and PSh(M) is boolean if and only if M is a group. So there should be two automorphisms of the subobject classifier whenever M is a group, but only (the trivial) one if M is not a group. I think this checks out if M is for example the monoid with two elements {1,x} and x^2=x.</p>",
        "id": 398634410,
        "sender_full_name": "Jens Hemelaer",
        "timestamp": 1698306964
    },
    {
        "content": "<p>Hmm, thanks. Respectfully, I'm pretty sure this is wrong. Will give you chapter and verse when I've sorted out the current Bewl 2 integration and can do (hopefully fast) calculations in the action topos with the new infrastructure.</p>",
        "id": 398683330,
        "sender_full_name": "Felix Dilke",
        "timestamp": 1698324959
    },
    {
        "content": "<p>To confirm what Jens said: the subobject classifier is the set of right ideal with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> acting by <em>inverse image action</em>, meaning that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>⋅</mo><mi>I</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mi>n</mi><mo>∈</mo><mi>M</mi><mo>∣</mo><mi>m</mi><mi>n</mi><mo>∈</mo><mi>I</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">m \\cdot I = \\{n \\in M \\mid mn \\in I\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">mn</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mclose\">}</span></span></span></span>. The subobject classifier has two connected components under the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>: the empty ideal is a fixed point, whereas for any non-empty ideal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">x \\in I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> we find <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>⋅</mo><mi>I</mi><mo>=</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">x \\cdot I = M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>. If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a group then there are only two ideals and hence an automorphism exchanging them. Otherwise, the latter connected component is non-trivial, so you can deduce that any automorphism must fix the top and bottom elements. From there, since <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo>∣</mo><mi>x</mi><mo>⋅</mo><mi>I</mi><mo>=</mo><mi>M</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">I = \\{x \\mid x \\cdot I = M\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">}</span></span></span></span>, we can deduce that each ideal must also be fixed by the automorphism.</p>",
        "id": 398685474,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1698325654
    },
    {
        "content": "<p>Hmmm. Could you unpack this a little for me please?</p>\n<blockquote>\n<p>any automorphism must fix the top and bottom elements</p>\n</blockquote>\n<p>We don't necessarily know, for example, that the automorphism preserves the order.<br>\nAnyway, I look forward to exploring this properly using Bewl 2!</p>",
        "id": 398701725,
        "sender_full_name": "Felix Dilke",
        "timestamp": 1698330503
    },
    {
        "content": "<p>An automorphism must send fixed points to fixed points, of which there are two, so its restriction to the top and bottom elements must be the identity or a swap. Respecting the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> mean any endomorphism that sends the top element to the bottom element must send every non-empty ideal to the empty ideal, so this can only be an automorphism if there are no non-trivial ideals.</p>",
        "id": 398702751,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1698330810
    },
    {
        "content": "<p>The last part is saying that since an automorphism must reflect the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>, it must send each ideal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> to an ideal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>I</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">I&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> for which <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>⋅</mo><mi>I</mi><mo>=</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">x \\cdot I = M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> if and only if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>⋅</mo><msup><mi>I</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>=</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">x \\cdot I&#x27; = M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>. But the set of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> for which this happens is exactly <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span>, so <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>I</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>=</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I&#x27; = I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span>.</p>",
        "id": 398703651,
        "sender_full_name": "Morgan Rogers (he/him)",
        "timestamp": 1698331048
    },
    {
        "content": "<p>Ok. This seems solid, and the previous investigations are coming back to me now. </p>\n<p>My bad - I was looking at the internal automorphism group of Ω, that is, the group of units of Ω ^ Ω considered as a monoid under internal composition.</p>\n<p>This I believe does always have 2 elements, and my analysis got as far as describing the non-identity element. Of course these calculations are even harder to do without software support!</p>\n<p>Another question it might be interesting to investigate, is whether there can be a case of finite actions A, B over a finite monoid which are locally isomorphic (i.e. the appropriate subobject of B ^ A isn’t isomorphic to 0) without being isomorphic.</p>",
        "id": 398724568,
        "sender_full_name": "Felix Dilke",
        "timestamp": 1698337362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282722\">Jens Hemelaer</span> <a href=\"#narrow/stream/229125-practice.3A-software/topic/Introducing.20me.20and.20Bewl.2C.20a.20topos.20theory.20DSL/near/398506182\">said</a>:</p>\n<blockquote>\n<p>Nice project! I am a topos theorist who is now making a career change to software engineering, so this project is a great resource for me to learn Scala :)</p>\n</blockquote>\n<p>I hope you do not mind if I offer some unsolicited advice, if its undesired, please ignore. :)<br>\nthese books are very friendly and helpful: <a href=\"https://underscore.io/books/\">https://underscore.io/books/</a><br>\nIn particular, internalizing <em>Scala with Cats</em> on <code>cats-effect</code> is sufficient to get a job, though not necessary.<br>\nYou might also like <code>Shapeless</code> for using universal constructions in your code that are polymorphic<br>\n<a href=\"https://www.baeldung.com/scala/generic-programming\">https://www.baeldung.com/scala/generic-programming</a><br>\n<a href=\"https://github.com/milessabin/shapeless\">https://github.com/milessabin/shapeless</a></p>\n<p>Good luck!</p>",
        "id": 426831264,
        "sender_full_name": "Eric M Downes",
        "timestamp": 1710541299
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"280788\">@Eric M Downes</span> Thanks for the learning resources! At the moment I'm doing data science / programming work in Python (which is also the programming language that I had most experience with already).</p>",
        "id": 427589792,
        "sender_full_name": "Jens Hemelaer",
        "timestamp": 1710802537
    },
    {
        "content": "<p>python FTW!!  I too started in python.  I still use it for actual data science.  But for data pipelines and anything requiring multiprocessing, Scala is just better.  You can just tell the compiler \"plz parallelize this, mkay?\" and it does... no messing about with workers or pools or threadsafe queues.  Just, if you ever have to deal with unstructured data, or quick-n-dirty prototypes... stay in python. :)</p>",
        "id": 427600255,
        "sender_full_name": "Eric M Downes",
        "timestamp": 1710808978
    }
]