[
    {
        "content": "<p><a href=\"http://www.philipzucker.com/computational-category-theory-in-python-i-dictionaries-for-finset/\" title=\"http://www.philipzucker.com/computational-category-theory-in-python-i-dictionaries-for-finset/\">http://www.philipzucker.com/computational-category-theory-in-python-i-dictionaries-for-finset/</a> I thought this a pleasant example of how one might implement something with a categorical interface at the value level in a more mundane language. I feel like there is lots of wide open space for such things</p>",
        "id": 193129105,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1586231236
    },
    {
        "content": "<p>Part two where I build pullbacks in numpy with the help of <span class=\"user-mention\" data-user-id=\"275927\">@James Fairbanks</span>  and <span class=\"user-mention\" data-user-id=\"275965\">@Evan Patterson</span>  <a href=\"http://www.philipzucker.com/computational-category-theory-in-python-ii-numpy-for-finvect/\" title=\"http://www.philipzucker.com/computational-category-theory-in-python-ii-numpy-for-finvect/\">http://www.philipzucker.com/computational-category-theory-in-python-ii-numpy-for-finvect/</a></p>",
        "id": 193736917,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1586737509
    },
    {
        "content": "<p><a href=\"/user_uploads/21317/VhCFit-pJYZ7JQbA_No1-yQ5/IMG_1370.PNG\" title=\"IMG_1370.PNG\">IMG_1370.PNG</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/21317/VhCFit-pJYZ7JQbA_No1-yQ5/IMG_1370.PNG\" title=\"IMG_1370.PNG\"><img src=\"/user_uploads/21317/VhCFit-pJYZ7JQbA_No1-yQ5/IMG_1370.PNG\"></a></div>",
        "id": 193738401,
        "sender_full_name": "James Fairbanks",
        "timestamp": 1586740401
    },
    {
        "content": "<p>That’s awesome <span class=\"user-mention\" data-user-id=\"276026\">@Philip Zucker</span>, I had a question about this code example. Where is v on the drawing above it?</p>",
        "id": 193738402,
        "sender_full_name": "James Fairbanks",
        "timestamp": 1586740403
    },
    {
        "content": "<p>I’m thinking that u,v should be q1, q2?</p>",
        "id": 193738447,
        "sender_full_name": "James Fairbanks",
        "timestamp": 1586740454
    },
    {
        "content": "<p>Or I’m totally misunderstanding based on reading fast on my phone.</p>",
        "id": 193738454,
        "sender_full_name": "James Fairbanks",
        "timestamp": 1586740485
    },
    {
        "content": "<p>That is correct. u and v correspond to q1 and q2</p>",
        "id": 193740028,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1586743540
    },
    {
        "content": "<p>On the phone to code formats weird too</p>",
        "id": 193740029,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1586743550
    },
    {
        "content": "<p>I pulled diagrams from wikipedia with different naming conventions, which was aa little lazy and dumb</p>",
        "id": 193740076,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1586743569
    },
    {
        "content": "<p>I should edit that</p>",
        "id": 193740270,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1586743988
    },
    {
        "content": "<p>fixed</p>",
        "id": 193741017,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1586745376
    },
    {
        "content": "<p>A pretty simple educational post on how to encode monoids and preorders as categories in python <a href=\"http://www.philipzucker.com/computational-category-theory-in-python-3-monoids-groups-and-preorders/\" title=\"http://www.philipzucker.com/computational-category-theory-in-python-3-monoids-groups-and-preorders/\">http://www.philipzucker.com/computational-category-theory-in-python-3-monoids-groups-and-preorders/</a></p>",
        "id": 196054825,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1588430712
    },
    {
        "content": "<p>Looking at this book by Walters, it all seems to be building up to the last chapter where they show how to implement computations in categories given by generators and relations... very cool.</p>",
        "id": 196056484,
        "sender_full_name": "Simon Burton",
        "timestamp": 1588433108
    },
    {
        "content": "<p>There's also this older book by Rydeheard &amp; Burstall, called \"computational category theory\" <a href=\"http://www.cs.man.ac.uk/~david/categories/\" title=\"http://www.cs.man.ac.uk/~david/categories/\">http://www.cs.man.ac.uk/~david/categories/</a> they use ML , and do nice stuff like compute term unifications as a coequalizer .</p>",
        "id": 196056703,
        "sender_full_name": "Simon Burton",
        "timestamp": 1588433347
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276026\">Philip Zucker</span> <a href=\"#narrow/stream/229125-practice.3A-software/topic/implementing.20categories/near/193736917\" title=\"#narrow/stream/229125-practice.3A-software/topic/implementing.20categories/near/193736917\">said</a>:</p>\n<blockquote>\n<p>Part two where I build pullbacks in numpy with the help of <span class=\"user-mention silent\" data-user-id=\"275927\">James Fairbanks</span>  and <span class=\"user-mention silent\" data-user-id=\"275965\">Evan Patterson</span>  <a href=\"http://www.philipzucker.com/computational-category-theory-in-python-ii-numpy-for-finvect/\" title=\"http://www.philipzucker.com/computational-category-theory-in-python-ii-numpy-for-finvect/\">http://www.philipzucker.com/computational-category-theory-in-python-ii-numpy-for-finvect/</a></p>\n</blockquote>\n<p>This stuff gets much more interesting when the constructions of (co-)limits also build the universal arrow from/to a given cone... that is what allows you to build more constructions by composing these (co-)limits...</p>",
        "id": 196057082,
        "sender_full_name": "Simon Burton",
        "timestamp": 1588433826
    },
    {
        "content": "<p>Yea, The Rydeheard and Burstall book is great. It was the impetus to start the series.</p>",
        "id": 196057613,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1588434643
    },
    {
        "content": "<p>I'm intrigued by your second comment but I'm not sure what you mean. Are you talking about span composition?</p>",
        "id": 196057637,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1588434703
    },
    {
        "content": "<p>Or that being able to compute pushouts and pullbacks allows you to compute arbitrary limits/colimits?</p>",
        "id": 196057834,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1588434942
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276026\">Philip Zucker</span> <a href=\"#narrow/stream/229125-practice.3A-software/topic/implementing.20categories/near/196057834\" title=\"#narrow/stream/229125-practice.3A-software/topic/implementing.20categories/near/196057834\">said</a>:</p>\n<blockquote>\n<p>Or that being able to compute pushouts and pullbacks allows you to compute arbitrary limits/colimits?</p>\n</blockquote>\n<p>Yes, for example, going from co-equalizers &amp; pushouts to give arbitrary co-limits, i forgot the exact theorem. <br>\nThe example I have actually implemented I used the universality of pushouts in FinVect to give a pushout in the category of chain complexes (over finite dim vector spaces.) <br>\nThis universality business is the \"API\" of category theory. It's all very nice to see it implemented... It works very well and does not need functional programming.. argh, i can feel a rant coming on.. FP is good and all, but I do get annoyed at all the implicit \"CT == FP\" sloganism that goes on. So anyway, I'm happy to meet someone else that is interested in a python take on category theory.</p>",
        "id": 196060094,
        "sender_full_name": "Simon Burton",
        "timestamp": 1588438115
    },
    {
        "content": "<p>I do feel that the insistence of strong typing is not ubiquitously the most useful perspective on category theory. How many well typed linear algebra libraries are actually usable. Hard line formalness often has a mind and drudgery tax. Have you ever checked out Catlab.jl ? There's a similar minded crew over there.</p>",
        "id": 196060488,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1588438730
    },
    {
        "content": "<p>I do use functional programming in the sense of first class functions though. The universal property is encoded as a function that computes the appropriate universal morphism.</p>",
        "id": 196060503,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1588438770
    },
    {
        "content": "<p>I have shied away from using python functions as morphisms themselves since they aren't inspectable the way data is</p>",
        "id": 196060560,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1588438812
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276026\">Philip Zucker</span> <a href=\"#narrow/stream/229125-practice.3A-software/topic/implementing.20categories/near/196060503\" title=\"#narrow/stream/229125-practice.3A-software/topic/implementing.20categories/near/196060503\">said</a>:</p>\n<blockquote>\n<p>I do use functional programming in the sense of first class functions though. The universal property is encoded as a function that computes the appropriate universal morphism.</p>\n</blockquote>\n<p>Oh right, sorry I missed that. <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 196061296,
        "sender_full_name": "Simon Burton",
        "timestamp": 1588439769
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276026\">Philip Zucker</span> <a href=\"#narrow/stream/229125-practice.3A-software/topic/implementing.20categories/near/196060560\" title=\"#narrow/stream/229125-practice.3A-software/topic/implementing.20categories/near/196060560\">said</a>:</p>\n<blockquote>\n<p>I have shied away from using python functions as morphisms themselves since they aren't inspectable the way data is</p>\n</blockquote>\n<p>Yes, this keeps nagging at me. At one point I wrote a python compiler based on llvm, and also have dabbled with pypy. All of that, more than 10 years ago now, was so horrifying that I'm not likely to try it again, although I do keep fantasizing about it.</p>",
        "id": 196061536,
        "sender_full_name": "Simon Burton",
        "timestamp": 1588440166
    },
    {
        "content": "<p>yes I have looked at Catlib.jl ...</p>",
        "id": 196061931,
        "sender_full_name": "Simon Burton",
        "timestamp": 1588440661
    },
    {
        "content": "<p>Some thoughts on using automatic theorem provers for category theory <a href=\"https://www.philipzucker.com/category-theory-in-the-e-automated-theorem-prover/\">https://www.philipzucker.com/category-theory-in-the-e-automated-theorem-prover/</a></p>",
        "id": 202929712,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1593969020
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276026\">Philip Zucker</span> <a href=\"#narrow/stream/229125-practice.3A-software/topic/implementing.20categories/near/202929712\">said</a>:</p>\n<blockquote>\n<p>Some thoughts on using automatic theorem provers for category theory <a href=\"https://www.philipzucker.com/category-theory-in-the-e-automated-theorem-prover/\">https://www.philipzucker.com/category-theory-in-the-e-automated-theorem-prover/</a></p>\n</blockquote>\n<p>Very nice!!!<br>\nBtw, there's a big list of implementations of CT on proof assistants here:<br>\n<a href=\"https://mathoverflow.net/questions/152497/formalizations-of-category-theory-in-proof-assistants\">https://mathoverflow.net/questions/152497/formalizations-of-category-theory-in-proof-assistants</a><br>\nmaybe you'd like to add that to your list of links...</p>",
        "id": 202935757,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1593979133
    },
    {
        "content": "<p>Thanks, I will!</p>",
        "id": 202951505,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1594007681
    },
    {
        "content": "<p>Thanks - this is something I've been curious about! It would be interesting to find out the limit of the sort of problems these provers can practically solve at the moment</p>",
        "id": 202957331,
        "sender_full_name": "Thomas Read",
        "timestamp": 1594017529
    },
    {
        "content": "<p>That is a good question, and I don't know the answer. Basically if these tools scale to the nasty encodings necessary to express what you want, they seem incredibly useful, but if they don't, then they aren't. And the only way to know is to try.</p>",
        "id": 202993273,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1594044055
    },
    {
        "content": "<p>Assembling some notes here about symmetric monoidal bla bla categories, and dagnabit, why isn't there a canonical reference for this stuff? Or much better: theorem prover verified list of axioms for ones chosen collection of adjectives, and associated latex pls. Ok, thanks bye.</p>",
        "id": 203091461,
        "sender_full_name": "Simon Burton",
        "timestamp": 1594121854
    },
    {
        "content": "<p>The canonical reference is Selinger's survey</p>",
        "id": 203094407,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1594124194
    },
    {
        "content": "<p>\"A survey of graphical languages for monoidal categories\"</p>",
        "id": 203094417,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1594124200
    },
    {
        "content": "<p>Thanks for reminding me, that is a good reference. I guess my point is there is never going to be a canonical reference  for \"symmetric monoidal bla bla categories\" for some choice of bla bla, as there are just too many different combinations of the various qualifiers...</p>",
        "id": 203095913,
        "sender_full_name": "Simon Burton",
        "timestamp": 1594125286
    },
    {
        "content": "<p>Catlab has an interesting list <a href=\"https://algebraicjulia.github.io/Catlab.jl/latest/apis/theories/\">https://algebraicjulia.github.io/Catlab.jl/latest/apis/theories/</a></p>",
        "id": 203197657,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1594153119
    },
    {
        "content": "<p>Nice.. Is there any example code that uses this ? I don't really understand anything about what this is doing.</p>",
        "id": 203219418,
        "sender_full_name": "Simon Burton",
        "timestamp": 1594168042
    },
    {
        "content": "<p>That code is just encoding the theories out of that Sellinger survey paper into a DSL for specifying doctrines. It doesn’t do anything with them. The Catlab read me points to some docs with examples. My ACT talk tomorrow will also show some examples</p>",
        "id": 203221439,
        "sender_full_name": "James Fairbanks",
        "timestamp": 1594170404
    },
    {
        "content": "<p>I don't see any implementations of function sets yet, so I'm going to give mine (though, this is in Racket):</p>\n<div class=\"codehilite\" data-code-language=\"Racket\"><pre><span></span><code><span class=\"p\">(</span><span class=\"k\">define</span> <span class=\"p\">(</span><span class=\"n\">function-set</span> <span class=\"n\">src</span> <span class=\"n\">tgt</span> <span class=\"kd\">#:as-functions?</span> <span class=\"p\">[</span><span class=\"n\">as-funcs</span> <span class=\"no\">#f</span><span class=\"p\">])</span>\n  <span class=\"p\">(</span><span class=\"nb\">list-&gt;set</span>\n   <span class=\"p\">(</span><span class=\"nb\">map</span>\n    <span class=\"p\">(</span><span class=\"k\">if</span> <span class=\"n\">as-funcs</span>\n        <span class=\"p\">(</span><span class=\"nb\">compose</span> <span class=\"p\">(</span><span class=\"k\">λ</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">function</span> <span class=\"n\">x</span> <span class=\"n\">src</span> <span class=\"n\">tgt</span><span class=\"p\">))</span>\n                 <span class=\"n\">fgraph-&gt;procedure</span> <span class=\"nb\">list-&gt;set</span><span class=\"p\">)</span>\n        <span class=\"nb\">list-&gt;set</span><span class=\"p\">)</span>\n    <span class=\"p\">(</span><span class=\"nb\">apply</span>\n     <span class=\"nb\">cartesian-product</span>\n     <span class=\"p\">(</span><span class=\"k\">for/list</span> <span class=\"c1\">; src = (set a b ...) ↦ (list (list ... '(a x) '(a y) '(a z)) (list ... '(b x) '(b y) '(b z)) ...)</span>\n         <span class=\"p\">([</span><span class=\"n\">i</span> <span class=\"n\">src</span><span class=\"p\">])</span>\n       <span class=\"p\">(</span><span class=\"k\">for/list</span> <span class=\"c1\">; tgt = (set ... x y z) ↦ (list ... '(i x) '(i y) '(i z))</span>\n           <span class=\"p\">([</span><span class=\"n\">j</span> <span class=\"n\">tgt</span><span class=\"p\">])</span>\n         <span class=\"p\">(</span><span class=\"nb\">list</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"p\">)))</span>\n     <span class=\"p\">))))</span>\n</code></pre></div>",
        "id": 248665495,
        "sender_full_name": "Keith Elliott Peterson",
        "timestamp": 1628282313
    },
    {
        "content": "<p>It works by finding all possible graphs of functions and then either keep it as is or converts them to actual functions.</p>\n<p>For instance:</p>\n<div class=\"codehilite\" data-code-language=\"Racket\"><pre><span></span><code><span class=\"nb\">&gt;</span> <span class=\"p\">(</span><span class=\"n\">function-set</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"nb\">set</span>\n <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"mi\">2</span><span class=\"p\">))</span>\n <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"mi\">2</span><span class=\"p\">))</span>\n <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"mi\">2</span><span class=\"p\">))</span>\n <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"mi\">3</span><span class=\"p\">)))</span>\n</code></pre></div>",
        "id": 248665892,
        "sender_full_name": "Keith Elliott Peterson",
        "timestamp": 1628282536
    },
    {
        "content": "<p>And as functions:</p>\n<div class=\"codehilite\" data-code-language=\"Racket\"><pre><span></span><code><span class=\"nb\">&gt;</span> <span class=\"p\">(</span><span class=\"n\">function-set</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"kd\">#:as-functions?</span> <span class=\"no\">#t</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nb\">set</span>\n <span class=\"p\">(</span><span class=\"n\">function</span> <span class=\"n\">#&lt;procedure:...nite-set-theory.rkt:14:2&gt;</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n <span class=\"p\">(</span><span class=\"n\">function</span> <span class=\"n\">#&lt;procedure:...nite-set-theory.rkt:14:2&gt;</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n <span class=\"p\">(</span><span class=\"n\">function</span> <span class=\"n\">#&lt;procedure:...nite-set-theory.rkt:14:2&gt;</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n <span class=\"p\">(</span><span class=\"n\">function</span> <span class=\"n\">#&lt;procedure:...nite-set-theory.rkt:14:2&gt;</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n <span class=\"p\">(</span><span class=\"n\">function</span> <span class=\"n\">#&lt;procedure:...nite-set-theory.rkt:14:2&gt;</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n <span class=\"p\">(</span><span class=\"n\">function</span> <span class=\"n\">#&lt;procedure:...nite-set-theory.rkt:14:2&gt;</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n <span class=\"p\">(</span><span class=\"n\">function</span> <span class=\"n\">#&lt;procedure:...nite-set-theory.rkt:14:2&gt;</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n <span class=\"p\">(</span><span class=\"n\">function</span> <span class=\"n\">#&lt;procedure:...nite-set-theory.rkt:14:2&gt;</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n <span class=\"p\">(</span><span class=\"n\">function</span> <span class=\"n\">#&lt;procedure:...nite-set-theory.rkt:14:2&gt;</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">set</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"p\">)))</span>\n</code></pre></div>",
        "id": 248666011,
        "sender_full_name": "Keith Elliott Peterson",
        "timestamp": 1628282634
    },
    {
        "content": "<p>I've been experimenting with making a prolog-like language powered by egraphs <a href=\"https://egraphs-good.github.io/\">https://egraphs-good.github.io/</a> under the hood for the purposes of categorical automated proving. Still has some very rough edges, but here's some examples that I think make sense and work. I compiled it to the web, so it works in browser.</p>\n<ul>\n<li><a href=\"https://www.philipzucker.com/egglog/?example=cat1.pl\">https://www.philipzucker.com/egglog/?example=cat1.pl</a> - pullback of monic is monic</li>\n<li><a href=\"https://www.philipzucker.com/egglog/?example=id_unique.pl\">https://www.philipzucker.com/egglog/?example=id_unique.pl</a> - uniqueness of identity</li>\n<li><a href=\"https://www.philipzucker.com/egglog/?example=pb_compose.pl\">https://www.philipzucker.com/egglog/?example=pb_compose.pl</a> - pullbacks compose</li>\n</ul>",
        "id": 249990300,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1629381543
    },
    {
        "content": "<p>That's very cool. But I was kind of hoping that the result would be a proof, not a bare <code>[]</code>. For pullback of monic is monic, what are the rewriting steps to go from p to q ?</p>",
        "id": 249992442,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1629382408
    },
    {
        "content": "<p>Work in progress (not by me) <a href=\"https://github.com/egraphs-good/egg/pull/115\">https://github.com/egraphs-good/egg/pull/115</a></p>",
        "id": 249997942,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1629384882
    },
    {
        "content": "<p>When this lands, it should be possible to enable proof output</p>",
        "id": 249997965,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1629384892
    },
    {
        "content": "<p>It does produce some useful information in the sense of finding certain morphisms</p>",
        "id": 249998042,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1629384930
    },
    {
        "content": "<p>It is to some degree a black box. An output that I can inspect but have not enabled on the web version is a graphviz dump of the final egraph, which represents all inferred equalities. It at least did not seem to infer a false equality to my eye</p>",
        "id": 249998238,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1629385000
    },
    {
        "content": "<p>Being able to see the final egraph does sound really cool.</p>",
        "id": 249998872,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1629385215
    },
    {
        "content": "<p>It's actually in the blog post <a href=\"https://www.philipzucker.com/assets/egglog_monic.png\">https://www.philipzucker.com/assets/egglog_monic.png</a></p>\n<div class=\"message_inline_image\"><a href=\"https://www.philipzucker.com/assets/egglog_monic.png\"><img src=\"https://uploads.zulipusercontent.net/be97f683d1f6357755124605e07a8db655bec5fe/68747470733a2f2f7777772e7068696c69707a75636b65722e636f6d2f6173736574732f6567676c6f675f6d6f6e69632e706e67\"></a></div>",
        "id": 249998938,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1629385235
    },
    {
        "content": "<p>It's very busy and only going to get worse with harder problems. I suppose it might be possible to filter or compress it using domain specific information</p>",
        "id": 249999112,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1629385310
    },
    {
        "content": "<p>A mode I've considered implementing is a handwritten proof mode, which might be nice both to confirm it's taking a path I expect, and to help it along when the problem gets too hard to do all in one go. The idea was to take each step of the proof, run the egraph saturation, seek the current lemma. If found, clear the egraph and insert the lemma. Repeat.</p>",
        "id": 249999822,
        "sender_full_name": "Philip Zucker",
        "timestamp": 1629385565
    },
    {
        "content": "<p>I missed that link, so for others like me, <a href=\"https://www.philipzucker.com/egglog2-monic/\">Egglog 2: Automatically Proving the Pullback of a Monic is Monic</a> is the blog post in question.</p>",
        "id": 250004670,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1629387757
    }
]