[
    {
        "content": "<p>Hello all! Here is the official thread for Mike Shulman's talk.<br>\nTitle: Conservativity of duals.<br>\nWhen: Thursday, May 14, 12 noon EDT.</p>\n<p>Youtube live stream: <a href=\"https://youtu.be/GwtChA9btgU\">https://youtu.be/GwtChA9btgU</a></p>\n<p>Zoom call: <a href=\"https://mit.zoom.us/j/280120646\">https://mit.zoom.us/j/280120646</a><br>\nMeeting ID: 280 120 646</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"GwtChA9btgU\" href=\"https://youtu.be/GwtChA9btgU\"><img src=\"https://i.ytimg.com/vi/GwtChA9btgU/default.jpg\"></a></div>",
        "id": 197347984,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1589322269
    },
    {
        "content": "<p>Hello all! We start in 5 minutes.</p>",
        "id": 197576293,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1589471746
    },
    {
        "content": "<p>30 seconds!</p>",
        "id": 197576843,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1589471967
    },
    {
        "content": "<p>In the youtube broadcasting, the top right corner is covered by the head video</p>",
        "id": 197580864,
        "sender_full_name": "Nikolaj Kuntner",
        "timestamp": 1589473541
    },
    {
        "content": "<p>In motivating the conservative map - why do we want to prevant extra morphism (traces etc.) in the first place? Is it because the (type-)system gets more complicated and harder to control?</p>",
        "id": 197581053,
        "sender_full_name": "Nikolaj Kuntner",
        "timestamp": 1589473617
    },
    {
        "content": "<p>is that gluing construction a sketch of a proof or can this be carried out as a precise argument in some generality?</p>",
        "id": 197582834,
        "sender_full_name": "Max New",
        "timestamp": 1589474398
    },
    {
        "content": "<p>thank you !</p>",
        "id": 197583251,
        "sender_full_name": "Max New",
        "timestamp": 1589474540
    },
    {
        "content": "<p>what's a good reference for this fact about lax morphisms, colax morphisms and comma objects? (The abstract nonsense that you can sometimes use to prove the glueing category has the right structure)</p>",
        "id": 197583964,
        "sender_full_name": "Philip Saville",
        "timestamp": 1589474846
    },
    {
        "content": "<p>this is the page on the comma-like construction he mentions but there are no references: <a href=\"https://ncatlab.org/nlab/show/colax%2Flax+comma+object\">https://ncatlab.org/nlab/show/colax%2Flax+comma+object</a></p>",
        "id": 197584383,
        "sender_full_name": "Max New",
        "timestamp": 1589475048
    },
    {
        "content": "<p><a href=\"https://arxiv.org/abs/1104.2111\">https://arxiv.org/abs/1104.2111</a></p>",
        "id": 197585030,
        "sender_full_name": "Max New",
        "timestamp": 1589475323
    },
    {
        "content": "<p>That's the Lack-Shulman paper he mentioned</p>",
        "id": 197585057,
        "sender_full_name": "Max New",
        "timestamp": 1589475344
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 197585078,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1589475354
    },
    {
        "content": "<p>the Laxhulman paper :)</p>",
        "id": 197585086,
        "sender_full_name": "Nikolaj Kuntner",
        "timestamp": 1589475359
    },
    {
        "content": "<p>great, thank you! I have wondered why the glueing category tends to have the structure you want, it would be nice to see a general reason for that</p>",
        "id": 197585132,
        "sender_full_name": "Philip Saville",
        "timestamp": 1589475365
    },
    {
        "content": "<p>In those algebraic manipulations of Hom's, I lost track about how this relates to parallelism talking about in the motivation part. There we got the intution that the Star is about creating channel types. Does this approach relate to the existing pi-calculus approach to processes studied by some type theorists?</p>",
        "id": 197585465,
        "sender_full_name": "Nikolaj Kuntner",
        "timestamp": 1589475517
    },
    {
        "content": "<p>Is there a way to say something like \"CT is conservative over PA\" (or, perhaps an analogous statement that is actually true), by saying some category is conservative over another?</p>",
        "id": 197585832,
        "sender_full_name": "Brian Pinsky",
        "timestamp": 1589475662
    },
    {
        "content": "<p>BTW here's the paper this talk is based on: <a href=\"https://arxiv.org/abs/2004.08487\">https://arxiv.org/abs/2004.08487</a></p>",
        "id": 197585882,
        "sender_full_name": "Max New",
        "timestamp": 1589475679
    },
    {
        "content": "<p>I don't know about the categorical semantics of pi-calculus.<br>\n<a href=\"https://en.wikipedia.org/wiki/%CE%A0-calculus\">https://en.wikipedia.org/wiki/%CE%A0-calculus</a></p>",
        "id": 197586083,
        "sender_full_name": "Nikolaj Kuntner",
        "timestamp": 1589475752
    },
    {
        "content": "<p>(But I know it's used by some more or less academic approaches to distributed systems)</p>",
        "id": 197586163,
        "sender_full_name": "Nikolaj Kuntner",
        "timestamp": 1589475792
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281268\">@Brian Pinsky</span> His mentioning of Linear vs. Intuitionistic logic wihtout negation indeed sounded like there's a logical reading like this to it.</p>",
        "id": 197586462,
        "sender_full_name": "Nikolaj Kuntner",
        "timestamp": 1589475884
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281274\">Nikolaj Kuntner</span> <a href=\"#narrow/stream/229457-MIT-Categories.20Seminar/topic/May.2014.20-.20Mike.20Shulman's.20talk/near/197586083\">said</a>:</p>\n<blockquote>\n<p>I don't know about the categorical semantics of pi-calculus</p>\n</blockquote>\n<p>I googled proof nets and pi-calculus and this paper came up:<br>\n<a href=\"https://perso.ens-lyon.fr/olivier.laurent/picppn.pdf\">https://perso.ens-lyon.fr/olivier.laurent/picppn.pdf</a></p>",
        "id": 197586722,
        "sender_full_name": "Cole Comfort",
        "timestamp": 1589475983
    },
    {
        "content": "<p>after the talk: does anyone have a link to Lafont's Phd thesis? It's not linked on his website: <a href=\"http://iml.univ-mrs.fr/~lafont/publications.html\">http://iml.univ-mrs.fr/~lafont/publications.html</a></p>",
        "id": 197586734,
        "sender_full_name": "Max New",
        "timestamp": 1589475992
    },
    {
        "content": "<p>thx</p>",
        "id": 197586849,
        "sender_full_name": "Nikolaj Kuntner",
        "timestamp": 1589476037
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276642\">Max New</span> <a href=\"#narrow/stream/229457-MIT-Categories.20Seminar/topic/May.2014.20-.20Mike.20Shulman's.20talk/near/197586734\">said</a>:</p>\n<blockquote>\n<p>after the talk: does anyone have a link to Lafont's Phd thesis? It's not linked on his website: <a href=\"http://iml.univ-mrs.fr/~lafont/publications.html\">http://iml.univ-mrs.fr/~lafont/publications.html</a></p>\n</blockquote>\n<p>The title of his thesis is ``Logiques, catégories &amp; machines - Implantation de langages de programmation guidée par la logique catégorique,'' so I suspect it might be in French.</p>",
        "id": 197587099,
        "sender_full_name": "Cole Comfort",
        "timestamp": 1589476136
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276642\">Max New</span> <a href=\"#narrow/stream/229457-MIT-Categories.20Seminar/topic/May.2014.20-.20Mike.20Shulman's.20talk/near/197586734\">said</a>:</p>\n<blockquote>\n<p>after the talk: does anyone have a link to Lafont's Phd thesis? It's not linked on his website: <a href=\"http://iml.univ-mrs.fr/~lafont/publications.html\">http://iml.univ-mrs.fr/~lafont/publications.html</a></p>\n</blockquote>\n<p>I've asked around before without much success... last time I asked someone got round to emailing Lafont, but got no response</p>",
        "id": 197587161,
        "sender_full_name": "Philip Saville",
        "timestamp": 1589476169
    },
    {
        "content": "<p>Well Mike clearly has a copy because references specific pages in the paper</p>",
        "id": 197587366,
        "sender_full_name": "Max New",
        "timestamp": 1589476239
    },
    {
        "content": "<p>conservative truth and peano arithmetic</p>",
        "id": 197587419,
        "sender_full_name": "Brian Pinsky",
        "timestamp": 1589476268
    },
    {
        "content": "<p>or coputational truth</p>",
        "id": 197587441,
        "sender_full_name": "Brian Pinsky",
        "timestamp": 1589476280
    },
    {
        "content": "<p>I forget; it's PA plus a truth predicate that satisfies induction</p>",
        "id": 197587481,
        "sender_full_name": "Brian Pinsky",
        "timestamp": 1589476299
    },
    {
        "content": "<p>I'm just thinking of the definition of conservativity I'm familiar with from model theory</p>",
        "id": 197587630,
        "sender_full_name": "Brian Pinsky",
        "timestamp": 1589476368
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276642\">Max New</span> <a href=\"#narrow/stream/229457-MIT-Categories.20Seminar/topic/May.2014.20-.20Mike.20Shulman's.20talk/near/197587366\">said</a>:</p>\n<blockquote>\n<p>Well Mike clearly has a copy because references specific pages in the paper</p>\n</blockquote>\n<p>in Mike's paper there's page numbers in the bibliography back-referencing to where the citation is, but I can't see a page number in the thesis being referred to? (I might be missing something!)</p>\n<p>the most precise citation of the Lafont argument I've seen is something like \"Annexe C\" in his thesis. It gets cited for all these kinds of arguments so I'd quite like to see what it actually says...</p>",
        "id": 197589401,
        "sender_full_name": "Philip Saville",
        "timestamp": 1589477161
    },
    {
        "content": "<p>oh he was referring to his own paper. I asked in the zoom and he says he's never been able to find it himself</p>",
        "id": 197590399,
        "sender_full_name": "Max New",
        "timestamp": 1589477576
    },
    {
        "content": "<p>Yeah, if anyone can find a copy of Lafont's thesis I would love to see it.</p>",
        "id": 197591339,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1589478068
    },
    {
        "content": "<p>Hey all, here's the video! <a href=\"https://youtu.be/uD1VGWJXX0M\">https://youtu.be/uD1VGWJXX0M</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"uD1VGWJXX0M\" href=\"https://youtu.be/uD1VGWJXX0M\"><img src=\"https://i.ytimg.com/vi/uD1VGWJXX0M/default.jpg\"></a></div>",
        "id": 197642921,
        "sender_full_name": "Paolo Perrone",
        "timestamp": 1589510923
    },
    {
        "content": "<p>If anyone is still around, I was wondering the following: if we have a D2-calculus that defines a unique morphism in the D1 category, is there a way of knowing what this morphism is exactly in D1?</p>\n<p>For example, if the *-autonomous calculus defines a morphism in a closed SMC (using for example tools available in the *-autonomous setting such as linear distributors), is there a way of knowing what this morphism is in the closed SMC (where there are no such linear distributors)? Is this easy to figure out, or does it require us to go through the construction given in the paper?</p>",
        "id": 197709535,
        "sender_full_name": "Nuiok Dicaire",
        "timestamp": 1589556851
    },
    {
        "content": "<p>I don't know of a generally applicable way to do it except to beta-reduce the construction in the paper.  You don't have to go through the entire gluing construction though, you can just interpret your D2-syntax into the envelope and use the fact that the envelope is fully faithful (which is just a Yoneda-like argument, so going backwards is just \"evaluating at identities\").  The gluing argument is just to show that the result doesn't depend on the particular choice of the envelope (rather than some other fully-faithful embedding into a D2-category).</p>",
        "id": 197714520,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1589559022
    },
    {
        "content": "<p>I wonder if we can come up with a concrete example of a situation where there is a fully faithful morphism to a D2 model but the unit is not fully faithful.</p>",
        "id": 197719695,
        "sender_full_name": "Max New",
        "timestamp": 1589561240
    },
    {
        "content": "<p>And another basic question: I've seen this trick a few times to restrict to presheaves that preserve certain limits in order for the Yoneda embedding to preserve certain colimits. Is this equivalent to using sheaves? Does every collection of colimits correspond to some Grothendieck topology? What about the converse?</p>",
        "id": 197721343,
        "sender_full_name": "Max New",
        "timestamp": 1589561984
    },
    {
        "content": "<p>There's two things \"certain limits\" could mean: either \"certain shapes of limits\", like finite products, or really some specific limits (maybe a finite list of them, but not necessarily).</p>",
        "id": 197721755,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589562134
    },
    {
        "content": "<p>are you asking me a question?</p>",
        "id": 197721892,
        "sender_full_name": "Max New",
        "timestamp": 1589562206
    },
    {
        "content": "<p>If you take a small category and pick some specific colimits in the second sense and look at those presheaves which take the the specified colimits to limits, in general you get a <a href=\"https://ncatlab.org/nlab/show/locally+presentable+category\">locally presentable category</a>.</p>",
        "id": 197721949,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589562238
    },
    {
        "content": "<p>Also, it doesn't really matter whether you start with specified cocones that are actually colimits, or just some arbitrary collection of cocones.</p>",
        "id": 197722111,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589562297
    },
    {
        "content": "<p>Any Grothendieck topos can arise in this way, but for the result to be a topos is a pretty strong additional condition--roughly speaking, you need the specified cocones to be stable under pullback. Lots of locally presentable categories are not topoi, for example, the category of rings.</p>",
        "id": 197722482,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589562471
    },
    {
        "content": "<p><a href=\"https://ncatlab.org/nlab/show/sketch\">https://ncatlab.org/nlab/show/sketch</a></p>",
        "id": 197723947,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589563190
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"276777\">@Mike Shulman</span>  for this really interesting talk! I was curious to known more about a small comment you made, linking duals in SMCs and logic programming. Could you say a bit more about this here? Is there a paper you could point me towards?</p>",
        "id": 197867800,
        "sender_full_name": "Robin Piedeleu",
        "timestamp": 1589747998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277342\">Robin Piedeleu</span> <a href=\"#narrow/stream/229457-MIT-Categories.20Seminar/topic/May.2014.20-.20Mike.20Shulman's.20talk/near/197867800\">said</a>:</p>\n<blockquote>\n<p>Thanks <span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span>  for this really interesting talk! I was curious to known more about a small comment you made, linking duals in SMCs and logic programming. Could you say a bit more about this here? Is there a paper you could point me towards?</p>\n</blockquote>\n<p>I don't know what the best reference is, but using the sequent calculus for multiplicative linear logic, duals allow one to shift objects between the antecedent and consequent part of the sequent.  When an object changes sides it becomes its dual.</p>\n<p>Here is a description of the sequent calculus:<br>\n<a href=\"https://plato.stanford.edu/entries/logic-linear/#SeqCal\">https://plato.stanford.edu/entries/logic-linear/#SeqCal</a></p>\n<p>So if you interpret objects in the antecedent as resources for the proof and the objects in the consequent as byproducts this gives a resource sensitive type system of sorts.</p>",
        "id": 197868544,
        "sender_full_name": "Cole Comfort",
        "timestamp": 1589749055
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"277342\">@Robin Piedeleu</span> I was thinking of <em>A typed foundation for directional logic programming</em> by Uday Reddy.  (Not duals in SMCs, but duals in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∗</mo></mrow><annotation encoding=\"application/x-tex\">\\ast</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.46528em;vertical-align:0em;\"></span><span class=\"mord\">∗</span></span></span></span>-autonomous categories.)</p>",
        "id": 197869229,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1589750033
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276642\">Max New</span> <a href=\"#narrow/stream/229457-MIT-Categories.20Seminar/topic/May.2014.20-.20Mike.20Shulman's.20talk/near/197719695\">said</a>:</p>\n<blockquote>\n<p>I wonder if we can come up with a concrete example of a situation where there is a fully faithful morphism to a D2 model but the unit is not fully faithful.</p>\n</blockquote>\n<p>Yes, I've pondered that too, but haven't gotten anywhere.</p>",
        "id": 197869274,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1589750056
    },
    {
        "content": "<p>Just read that Reddy paper, very nice! Note that it leaves out additive units because they \"seem to play no role in a programming language\" I wonder if this is related to the conservativity theorem not holding for units! Maybe the semantics can actually be presented as a Chu construction</p>",
        "id": 198219102,
        "sender_full_name": "Max New",
        "timestamp": 1589990197
    },
    {
        "content": "<p>It also reminded me of the obvious question from a PL perspective: what would it take to extend your proof to (1) inductive/coinductive data and (2) exponentials ! and ?</p>",
        "id": 198219221,
        "sender_full_name": "Max New",
        "timestamp": 1589990255
    },
    {
        "content": "<p>That additive units play no role in PL seems like a premature optimization: why have empty types, since obviously they don't contain any values? Mizar made that error as well. But then there are control operators that don't type, and so on.  [Also: which Reddy paper? I didn't obviously see a link in the above discussion, and I couldn't attend the seminar]</p>",
        "id": 198230168,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1589995366
    },
    {
        "content": "<p>This one: \"A typed foundation for directional logic programming\" that Mike just mentioned.</p>",
        "id": 198233704,
        "sender_full_name": "Max New",
        "timestamp": 1589997070
    },
    {
        "content": "<p>I'm saying there might actually be a good reason in this case to leave it out. By \"no relevance\" he might not have meant \"useless\" but instead meant \"I don't see how to extend my operational semantics\"</p>",
        "id": 198233793,
        "sender_full_name": "Max New",
        "timestamp": 1589997116
    },
    {
        "content": "<p>Thanks (for the paper title and the potential reason).</p>",
        "id": 198234272,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1589997343
    },
    {
        "content": "<p>Basically, the chu construction should imply that certain predicates in the language of that paper (those that correspond to an  sequent A1,...An |- B consisting of only intuitionistic formulae when you get rid of all the duals) are implementable as linear functions. This property does not hold if you include also the additive units! Though it seems like you would just need to put this in as a caveat of the interpretation, not that they should have no interpretation at all</p>",
        "id": 198234583,
        "sender_full_name": "Max New",
        "timestamp": 1589997509
    },
    {
        "content": "<p>so the problem is the additive units don't act like intuitionistic additive units, so you might want to leave them out</p>",
        "id": 198234885,
        "sender_full_name": "Max New",
        "timestamp": 1589997666
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276642\">Max New</span> <a href=\"#narrow/stream/229457-MIT-Categories.20Seminar/topic/May.2014.20-.20Mike.20Shulman's.20talk/near/198219221\">said</a>:</p>\n<blockquote>\n<p>It also reminded me of the obvious question from a PL perspective: what would it take to extend your proof to (1) inductive/coinductive data and (2) exponentials ! and ?</p>\n</blockquote>\n<p>For (2) I believe the answer is that it works just fine.  I've half-written up a draft that does it, using a notion of \"LNL polycategory\" that's a semantic correspondent of split-context deduction systems for linear logic.</p>\n<p>For (1) it's much less clear to me.  One thing I've played around with a bit is saying if I have an inductive datatype that's a fixed point of some functor that can be expressed in terms of the tensor products and nonempty (co)limits, e.g. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>≅</mo><mi mathvariant=\"double-struck\">N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N} \\cong \\mathbb{N} + 1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77222em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mi>A</mi><mo>≅</mo><mi>A</mi><mo>×</mo><mi>L</mi><mi>A</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">LA \\cong A \\times LA + 1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">L</span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">L</span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>, then its image in the envelope should still be a fixed point of the corresponding functor, e.g. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>≅</mo><mi mathvariant=\"double-struck\">N</mi><mo>⊕</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N} \\cong \\mathbb{N} \\oplus 1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77222em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mi>A</mi><mo>≅</mo><mi>A</mi><mo>⊗</mo><mi>L</mi><mi>A</mi><mo>⊕</mo><mn mathvariant=\"bold\">1</mn></mrow><annotation encoding=\"application/x-tex\">LA \\cong A \\otimes LA \\oplus \\mathbf{1}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">L</span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">L</span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">1</span></span></span></span></span>, where we use an envelope that preserves binary coproducts <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>+</mo><mo>↦</mo><mo>⊕</mo></mrow><annotation encoding=\"application/x-tex\">+ \\mapsto \\oplus</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">+</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊕</span></span></span></span> and cartesian monoidal structure <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>×</mo><mo>↦</mo><mo>⊗</mo></mrow><annotation encoding=\"application/x-tex\">\\times \\mapsto \\otimes</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">×</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊗</span></span></span></span>.  It won't be a least or greatest fixed point in the envelope, but I'm not sure exactly what sort of inductiveness Reddy is assuming for his recursive datatypes.  If you're interested in talking about this more I would be too!</p>",
        "id": 198235534,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1589997920
    },
    {
        "content": "<p>wow, LNL polycategory is something I'd be very interested in seeing! Since I'm partial to CBPV/LNL it's something I've asked people more familiar with classical LL for but never got anything</p>",
        "id": 198237573,
        "sender_full_name": "Max New",
        "timestamp": 1589998886
    },
    {
        "content": "<p>Re: the inductive/coinductive stuff, I don't see anything in the Reddy paper that indicates that the inductive types  are a LFP/GFP, just that an isomorphism exists, so that interpretation might work fine</p>",
        "id": 198237862,
        "sender_full_name": "Max New",
        "timestamp": 1589999019
    },
    {
        "content": "<p>Oh but it does allow things to be defined recursively duh</p>",
        "id": 198268550,
        "sender_full_name": "Max New",
        "timestamp": 1590016037
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229457-MIT-Categories.20Seminar/topic/May.2014.20-.20Mike.20Shulman's.20talk/near/197591339\">said</a>:</p>\n<blockquote>\n<p>Yeah, if anyone can find a copy of Lafont's thesis I would love to see it.</p>\n</blockquote>\n<p>a small update on this. I asked Hugo Paquet, who did some asking around in turn. According to Lafont himself the thesis was never scanned so there are only physical copies, one of which should be in Paris Diderot's thesis archives. </p>\n<p>So it looks like it's going to stay mysterious, unless someone fancies a trip to Paris for some scanning.</p>",
        "id": 198738349,
        "sender_full_name": "Philip Saville",
        "timestamp": 1590485137
    },
    {
        "content": "<p>Well there are of course people at Paris Diderot that might be interested or have students that would do it (once the archives are physically accessible): <a href=\"https://www.irif.fr/~petrisan/\">https://www.irif.fr/~petrisan/</a> <a href=\"https://www.irif.fr/~mellies/\">https://www.irif.fr/~mellies/</a></p>",
        "id": 198798754,
        "sender_full_name": "Max New",
        "timestamp": 1590516121
    },
    {
        "content": "<p>good idea - I'll email Paul-Andre once the lockdown in France loosens up</p>",
        "id": 198803545,
        "sender_full_name": "Philip Saville",
        "timestamp": 1590518466
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276777\">@Mike Shulman</span> is your conservativity result constructive? My sticking point is the use of the adjoint functor theorem, which I've been informed on twitter in general uses axiom of choice</p>",
        "id": 200916634,
        "sender_full_name": "Max New",
        "timestamp": 1592240255
    },
    {
        "content": "<p>Well, if you heard it on twitter I suppose it must be true...</p>",
        "id": 200917081,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1592240459
    },
    {
        "content": "<p>The definition of the adjoint in an AFT is pretty concretely given in terms of limits/colimits.  The only context I can think of in which an AFT requires AC is if your metatheory is set-theoretic (as opposed to univalent) and the relevant limits/colimits in your categories \"exist\" only in the weak sense of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi mathvariant=\"normal\">∃</mi></mrow><annotation encoding=\"application/x-tex\">\\forall\\exists</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">∀</span><span class=\"mord\">∃</span></span></span></span> rather than being specified by a function.  That happens occasionally, but I believe the vast majority of complete/cocomplete categories arising in practice do have a function that specifies their limits/colimits even if you don't assume AC.</p>",
        "id": 200917600,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1592240700
    },
    {
        "content": "<p>Thanks, I've been trying to understand the proof of theorem 6.3 part 1 that shows the (co)tensor preserving modules form a reflective subcategory, which uses the AFT and I've never learned the AFT before.</p>",
        "id": 200923268,
        "sender_full_name": "Max New",
        "timestamp": 1592243488
    },
    {
        "content": "<p>I think of the 3 properties (locally presentable, closed under limits, and accessibly embedded) I only understand why it's closed under limits.</p>",
        "id": 200923448,
        "sender_full_name": "Max New",
        "timestamp": 1592243568
    },
    {
        "content": "<p>Thanks for bringing this up.  I realized after my previous post that what I wrote in the proof of that theorem is, while technically correct, not really helpful for an analysis of constructivity.  The natural way to see (at least, for me) that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"sans-serif\">M</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">d</mi></mrow><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"script\">P</mi><mo separator=\"true\">,</mo><mi mathvariant=\"script\">J</mi><mo stretchy=\"false\">)</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Mod}_{(\\mathcal{P},\\mathcal{J})}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04964em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">M</span><span class=\"mord mathsf\">o</span><span class=\"mord mathsf\">d</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\"><span class=\"mord mathcal mtight\" style=\"margin-right:0.08222em;\">P</span></span><span class=\"mpunct mtight\">,</span><span class=\"mord mtight\"><span class=\"mord mathcal mtight\" style=\"margin-right:0.18472em;\">J</span></span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span> is locally presentable is to view it as the models for a sketch.  But the way we prove that the category of models for a sketch is locally presentable, in general, is to show that it's a reflective subcategory of a presheaf category, and in the case of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"sans-serif\">M</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">d</mi></mrow><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"script\">P</mi><mo separator=\"true\">,</mo><mi mathvariant=\"script\">J</mi><mo stretchy=\"false\">)</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Mod}_{(\\mathcal{P},\\mathcal{J})}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04964em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">M</span><span class=\"mord mathsf\">o</span><span class=\"mord mathsf\">d</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\"><span class=\"mord mathcal mtight\" style=\"margin-right:0.08222em;\">P</span></span><span class=\"mpunct mtight\">,</span><span class=\"mord mtight\"><span class=\"mord mathcal mtight\" style=\"margin-right:0.18472em;\">J</span></span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span> the relevant presheaf category is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"sans-serif\">M</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">d</mi></mrow><mi mathvariant=\"script\">P</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Mod}_{\\mathcal{P}}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">M</span><span class=\"mord mathsf\">o</span><span class=\"mord mathsf\">d</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathcal mtight\" style=\"margin-right:0.08222em;\">P</span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>!  So this is \"morally\" a circular argument.</p>",
        "id": 200942739,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1592253610
    },
    {
        "content": "<p>If we fully beta-reduce things, the way we prove that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"sans-serif\">M</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">d</mi></mrow><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"script\">P</mi><mo separator=\"true\">,</mo><mi mathvariant=\"script\">J</mi><mo stretchy=\"false\">)</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Mod}_{(\\mathcal{P},\\mathcal{J})}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04964em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">M</span><span class=\"mord mathsf\">o</span><span class=\"mord mathsf\">d</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\"><span class=\"mord mathcal mtight\" style=\"margin-right:0.08222em;\">P</span></span><span class=\"mpunct mtight\">,</span><span class=\"mord mtight\"><span class=\"mord mathcal mtight\" style=\"margin-right:0.18472em;\">J</span></span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span> is reflective in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"sans-serif\">M</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">d</mi></mrow><mi mathvariant=\"script\">P</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Mod}_{\\mathcal{P}}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">M</span><span class=\"mord mathsf\">o</span><span class=\"mord mathsf\">d</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathcal mtight\" style=\"margin-right:0.08222em;\">P</span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is to construct a reflection by a more or less explicit inductive argument, successively adding in new elements that have to be there and identifying elements that have to be equal, over and over again.  This is indeed something that we can't always do in constructive set theories like CZF or IZF (or even ZF), although one might argue that this isn't morally an issue of constructivity but rather an indictment of the impoverished tools for inductive constructions available in those theories -- for instance, we can always do it in HoTT with HITs.</p>",
        "id": 200943078,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1592253799
    },
    {
        "content": "<p>In the specific case of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"sans-serif\">M</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">d</mi></mrow><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"script\">P</mi><mo separator=\"true\">,</mo><mi mathvariant=\"script\">J</mi><mo stretchy=\"false\">)</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Mod}_{(\\mathcal{P},\\mathcal{J})}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04964em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">M</span><span class=\"mord mathsf\">o</span><span class=\"mord mathsf\">d</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\"><span class=\"mord mathcal mtight\" style=\"margin-right:0.08222em;\">P</span></span><span class=\"mpunct mtight\">,</span><span class=\"mord mtight\"><span class=\"mord mathcal mtight\" style=\"margin-right:0.18472em;\">J</span></span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span>, I think that because all the \"operations\" are finitary, we should be able to construct the reflection by a mere countable iteration, which should work in pretty much any constructive context.  But it would be more of a problem for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"sans-serif\">M</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">d</mi></mrow><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"script\">P</mi><mo separator=\"true\">,</mo><mi mathvariant=\"script\">J</mi><mo separator=\"true\">,</mo><mi mathvariant=\"script\">K</mi><mo stretchy=\"false\">)</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Mod}_{(\\mathcal{P},\\mathcal{J},\\mathcal{K})}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04964em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">M</span><span class=\"mord mathsf\">o</span><span class=\"mord mathsf\">d</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\"><span class=\"mord mathcal mtight\" style=\"margin-right:0.08222em;\">P</span></span><span class=\"mpunct mtight\">,</span><span class=\"mord mtight\"><span class=\"mord mathcal mtight\" style=\"margin-right:0.18472em;\">J</span></span><span class=\"mpunct mtight\">,</span><span class=\"mord mtight\"><span class=\"mord mathcal mtight\" style=\"margin-right:0.01445em;\">K</span></span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span>, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">K</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{K}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.01445em;\">K</span></span></span></span></span> contains infinite limits or colimits; in that case we might need either ZFC or HITs.</p>",
        "id": 200943300,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1592253917
    },
    {
        "content": "<p>One last thing to note is that even the <em>statement</em> of 2-conservativity refers to \"the free Y generated by an X\".  This is already something that generally requires some kind of inductive construction to produce!  Again, if there are no infinite limits included in the doctrine I think that countable iteration should suffice.  But in general, I would expect that any reasonably natural framework that has the tools to <em>state</em> a 2-conservativity theorem should also have the requisite tools to prove it.</p>",
        "id": 200943563,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1592254074
    },
    {
        "content": "<p>I should probably add some discussion of this point to the paper, since there may be readers who care about constructivity.  Thanks again for bringing it up.</p>",
        "id": 200943635,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1592254102
    },
    {
        "content": "<p>Thanks Mike, do you have a reference I could look to for this explicit construction of the reflection for models of sketches?<br>\nAlso, constructivity here is very important because you should be able to extract  a normalization algorithm from this proof</p>",
        "id": 200948069,
        "sender_full_name": "Max New",
        "timestamp": 1592256412
    },
    {
        "content": "<p>Hmm, for some meaning of \"normalization algorithm\" I guess.  I can see extracting an algorithm that computes (e.g.) an IMLL proof from an MLL proof, but it's not clear to me how to call that normalization; can you explain?</p>",
        "id": 200967053,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1592274012
    },
    {
        "content": "<p>For a reference, I think it's described in Adamek-Rosicky \"Locally presentable and accessible categories\".  The original reference might be Freyd-Kelly \"Categories of continuous functors I\".</p>",
        "id": 200967073,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1592274058
    },
    {
        "content": "<p>I guess you could call it \"cut elimination\" as well but basically that it gives you a procedure to take a term of ILL type that uses CLL stuff internally and \"reduce\" it to only contain ILL stuff. The resulting term I think does end up being in some kind of $\\beta$ short $\\eta$ long form, but I meant it informally</p>",
        "id": 201000997,
        "sender_full_name": "Max New",
        "timestamp": 1592306875
    },
    {
        "content": "<p>How can you tell that it ends up <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-short <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">\\eta</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">η</span></span></span></span>-long?  I thought we were only at the stage of wondering whether the proof is constructive so that you get an algorithm in the first place?</p>",
        "id": 201031828,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1592321118
    },
    {
        "content": "<p>Well I could be wrong, I'm still trying to understand the proof. I was trying to write out the proof as an explicit logical relation and without accounting for the reflector it certainly looks like that . I.e., a proof of a tensor is a pair of proofs etc. However maybe once you account for the reflector all of that is lost in quotients</p>",
        "id": 201039426,
        "sender_full_name": "Max New",
        "timestamp": 1592324328
    },
    {
        "content": "<p>I'm not sure whether I understand the conversation here, but note that you can also constructively form the group described by a certain finite presentation by generators and relations, at least if you have quotients, but it doesn't mean you get out an algorithm to solve the word problem in that group.</p>",
        "id": 201040223,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592324683
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276642\">@Max New</span> Yes, the reflector is the main issue.  I can definitely see an algorithm that's easy to extract in the case where no reflection is necessary.  I suppose you could also try to formulate everything with setoids.</p>",
        "id": 201089504,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1592352987
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276480\">@Reid Barton</span> I'm not certain, but I think your point is relevant and has to do with the reflector once again: when it gets into the picture the \"normal forms\" that come out will be elements of some quotient set.  Again, you could try to use setoids, or the other tricks that people use to extract normalization algorithms from gluing proofs (e.g. <a href=\"https://arxiv.org/abs/1809.08646\">https://arxiv.org/abs/1809.08646</a>), but that would be a more substantial undertaking.</p>",
        "id": 201089578,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1592353084
    },
    {
        "content": "<p>I've just learned that <span class=\"user-mention\" data-user-id=\"305241\">@Christine Tasson</span> has uploaded a <a href=\"https://www-apr.lip6.fr/~tasson/doc/reading/Yves_Laffont_phd.pdf\">copy of Lafont's thesis</a>. Now time for me to learn French <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 275099789,
        "sender_full_name": "Max New",
        "timestamp": 1647095500
    },
    {
        "content": "<p>To continue reviving this thread: In PL applications we have not just coproducts but also inductive constructions such as NNOs/W types. Does using the coproduct-preserving modules already work for 2-conservativity with NNOs or is it more subtle? It seems that using coproduct preserving modules would already ensure that you get a module satisfying <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>≅</mo><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">N \\cong N + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> but I'm not sure if you get that it is an NNO.</p>",
        "id": 350169436,
        "sender_full_name": "Max New",
        "timestamp": 1681567914
    },
    {
        "content": "<p>I don't think that works.  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>≅</mo><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">N\\cong N+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> isn't enough to make it an NNO.  It's related to <a href=\"https://mathoverflow.net/q/94968/49\">this question</a>.</p>",
        "id": 350185744,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1681574205
    },
    {
        "content": "<p>I'll read the elephant section when I'm back at work, but does \"standard\" mean that it is the colimit of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>-chain <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>→</mo><mn>0</mn><mo>+</mo><mn>1</mn><mo>→</mo><mn>0</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>→</mo><mo>⋯</mo></mrow><annotation encoding=\"application/x-tex\">0 \\to 0 + 1 \\to 0 + 1 + 1 \\to \\cdots</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.313em;\"></span><span class=\"minner\">⋯</span></span></span></span> If that's the case then I guess you can just require your modules to preserve this colimit as well.</p>",
        "id": 350198837,
        "sender_full_name": "Max New",
        "timestamp": 1681580838
    },
    {
        "content": "<p>I don't remember for sure, but I think standardness is weaker than that.  That basically says that the NNO is the coproduct <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∐</mo><mi mathvariant=\"double-struck\">N</mi></msub><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\coprod_{\\mathbb{N}} 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∐</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1825em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathbb mtight\">N</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span></span></span></span>, but I think an NNO can be standard even if infinite colimits don't exist.</p>",
        "id": 350230333,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1681604101
    },
    {
        "content": "<p>I didn't know about this \"standardness\", but it sounds interestingly reminiscent of the, umm, <em>standard</em> notion of \"standard\" model of the natural numbers.   </p>\n<p>In classical logic one sometimes sees a hand-wavy useless notion of \"standard\" model of the natural numbers, meaning something like \"the true natural numbers according to God\".  </p>\n<p>But there's also a more precise and useful notion, and that's what I'm talking about here: namely, an <em>initial</em> model of PA in the set theory we're using - say ZFC.   We can define the ordinal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span> as a set in ZFC, and this gives an initial model of the PA.</p>",
        "id": 350230950,
        "sender_full_name": "John Baez",
        "timestamp": 1681604523
    },
    {
        "content": "<p>This is remiscent of the answer on MathOverflow, which says that a natural numbers object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is <strong>standard</strong> if the morphisms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>s</mi><mi>n</mi></msup><mi>o</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">s^n o : 1 \\to N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">o</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> (for external natural numbers <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>∈</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">n \\in \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>) are jointly epimorphic.</p>",
        "id": 350231209,
        "sender_full_name": "John Baez",
        "timestamp": 1681604697
    },
    {
        "content": "<p>In both cases we're invoking some external set theory to set the standard.  But in quite different ways, it seems to me.</p>",
        "id": 350231378,
        "sender_full_name": "John Baez",
        "timestamp": 1681604819
    },
    {
        "content": "<p>If I understand correctly, the \"standard natural numbers\" are a <em>specific</em> model of PA (in some model of ZFC), whereas this notion of \"having standard natural numbers\" is a <em>property</em> of a topos (which is like a model of ZFC) -- a property that relates to \"the\" (\"standard\"?) natural numbers <em>in</em> that topos.</p>",
        "id": 350231529,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1681604929
    },
    {
        "content": "<p>It reminds me a bit of the notion of whether a model of set theory can contain <a href=\"https://mathoverflow.net/q/16134/49\">extra ordinals</a>.</p>",
        "id": 350231766,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1681605089
    },
    {
        "content": "<p>And also of <a href=\"https://en.wikipedia.org/wiki/%CE%A9-consistent_theory\">omega-inconsistency</a>.</p>",
        "id": 350232014,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1681605270
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/229457-seminar.3A-MIT-Categories-Seminar/topic/May.2014.20-.20Mike.20Shulman's.20talk/near/350231529\">said</a>:</p>\n<blockquote>\n<p>If I understand correctly, the \"standard natural numbers\" are a <em>specific</em> model of PA (in some model of ZFC), whereas this notion of \"having standard natural numbers\" is a <em>property</em> of a topos (which is like a model of ZFC) -- a property that relates to \"the\" (\"standard\"?) natural numbers <em>in</em> that topos.</p>\n</blockquote>\n<p>That sounds right.</p>\n<p>These things can get even more slippery; I spent a lot of time blogging with Michael Weiss about what happens when you take a model of PA in ZFC, and then look at a model of <em>that</em> in some set theory.</p>",
        "id": 350254219,
        "sender_full_name": "John Baez",
        "timestamp": 1681623370
    },
    {
        "content": "<p>Since, Max, you mentioned PL applications, I found the following observation (from <a href=\"https://ncatlab.org/nlab/show/natural+numbers+object\">nlab</a>) about CCC's with NNO's also helpful. </p>\n<p>The free category with finite products and a parameterized NNO only has the primitive recursive maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>→</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N} \\to \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>. But any CCC with NNO has at least the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>ϵ</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\epsilon_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">ϵ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-terminating maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>→</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N} \\to \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> (e.g. Ackermann). So it's another reason that we can't hope to conservatively complete with function spaces in general, while preserving NNO's. This is quite disappointing!</p>",
        "id": 350438414,
        "sender_full_name": "Sam Staton",
        "timestamp": 1681719697
    },
    {
        "content": "<p>About sheaf categories. What is still surprising to me is that the O'Hearn-Riecke model of higher-order recursion is basically a sheaf model with NNO but still manages to obtain full abstraction. We explored it <a href=\"https://drops.dagstuhl.de/opus/volltexte/2021/14263/pdf/LIPIcs-FSCD-2021-25.pdf\">here</a> but I still think it's mysterious.</p>",
        "id": 350438856,
        "sender_full_name": "Sam Staton",
        "timestamp": 1681719809
    }
]