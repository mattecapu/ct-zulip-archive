[
    {
        "content": "<p>If I were to try to model something like propositional logic from scratch, a natural mathematical structure to express the idea that “statements can be true or false” would seem to be a function, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>eval</mtext><mo>:</mo><mtext>Prop</mtext><mo>→</mo><mtext>Bool</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{eval} : \\text{Prop} \\to \\text{Bool}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">eval</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\">Prop</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">Bool</span></span></span></span></span>, and two terms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>true</mtext><mo>:</mo><mtext>Bool</mtext><mo separator=\"true\">,</mo><mtext>false</mtext><mo>:</mo><mtext>Bool</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{true} : \\text{Bool}, \\text{false} : \\text{Bool}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord text\"><span class=\"mord\">true</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\">Bool</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord\">false</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">Bool</span></span></span></span></span>.</p>\n<p>The next two things that would strike me as ‘missing’ would be adding structure both to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Prop</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{Prop}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\">Prop</span></span></span></span></span> and to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Bool</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{Bool}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">Bool</span></span></span></span></span>. </p>\n<p>The most essential aspect of truth-values seems to me to be their complementary relationship: true is the “opposite” of false; and we can define this with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>not</mtext><mo>:</mo><mtext>Bool</mtext><mo>→</mo><mtext>Bool</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{not} : \\text{Bool} \\to \\text{Bool}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord text\"><span class=\"mord\">not</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">Bool</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">Bool</span></span></span></span></span>, and equations <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>not</mtext><mo stretchy=\"false\">(</mo><mtext>true</mtext><mo stretchy=\"false\">)</mo><mo>=</mo><mtext>false</mtext><mo separator=\"true\">,</mo><mtext>not</mtext><mo stretchy=\"false\">(</mo><mtext>false</mtext><mo stretchy=\"false\">)</mo><mo>=</mo><mtext>true</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{not}(\\text{true}) = \\text{false}, \\text{not}(\\text{false}) = \\text{true}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">not</span></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">true</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">false</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord\">not</span></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">false</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord text\"><span class=\"mord\">true</span></span></span></span></span>. There are various ways to axiomatize this; I am pretty sure double negation elimination follows from what I just wrote, but you could also have one ground term, one function, and double negation elimination: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>true</mtext><mo>:</mo><mtext>Bool</mtext><mo separator=\"true\">,</mo><mtext>not</mtext><mo>:</mo><mtext>Bool</mtext><mo>→</mo><mtext>Bool</mtext><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo>:</mo><mtext>Bool</mtext><mo stretchy=\"false\">[</mo><mtext>not</mtext><mo stretchy=\"false\">(</mo><mtext>not</mtext><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mi>x</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\text{true} : \\text{Bool}, \\text{not} : \\text{Bool} \\to \\text{Bool}, \\forall x : \\text{Bool} [\\text{not}(\\text{not}(x)) = x]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord text\"><span class=\"mord\">true</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\">Bool</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord\">not</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">Bool</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\">Bool</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">Bool</span></span><span class=\"mopen\">[</span><span class=\"mord text\"><span class=\"mord\">not</span></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">not</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">]</span></span></span></span>.</p>\n<p>I believe we are showing that true/false under negation is the cyclic group of order 2, a.k.a. the integers mod 2.</p>\n<p>What is interesting to me is how it feels more conceptually accurate to separate truthhood and falsehood as elements, from propositions. We could either say that truthhood and falsehood are actually <em>properties</em> of propositions - expressed like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>true</mtext><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mtext>false</mtext><mo stretchy=\"false\">(</mo><mi>Q</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{true}(P), \\text{false}(Q)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">true</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord\">false</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">Q</span><span class=\"mclose\">)</span></span></span></span>, or that they are elements which a truth-function “corresponds propositions to”.</p>\n<p>It feels like we often see propositional logic presented in a way that lumps together propositions and their truth-values. To me, this can lead to some confusion.</p>\n<p>It actually seems like some of the operations we commonly see in the axioms of a Boolean algebra much more naturally apply to <em>propositions</em>. For example, “and” and “or” are compositional operations which build new propositions out of other ones: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>and</mtext><mo>:</mo><mtext>Prop</mtext><mo separator=\"true\">,</mo><mtext>Prop</mtext><mo>→</mo><mtext>Prop</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{and} : \\text{Prop}, \\text{Prop} \\to \\text{Prop}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">and</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\">Prop</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord\">Prop</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\">Prop</span></span></span></span></span>. I’m saying that if starting from first principles, I find it more intuitive to locate “and” as being an operation on propositions, and “not” as an operation on truth values: we then have to define how “and” on propositions corresponds to some operation on those propositions’ truth values, but that is not “where you start out” from.</p>\n<p>I think propositions naturally have an associated concept of their <em>meaning</em>. So we can think of “and” and “or” as being, on the one hand, syntactic operations on the linguistic units we associate with “propositions”, but which correspond to a certain kind of “composition of meanings”, on the meaning side. </p>\n<p>Now it seems like our basic ability to say meaningful things, compose those meanings, and evaluate those meanings, can be modeled with three types: Sentence (“abskekc”, “kejebeiekn”), Meaning (some way of expressing “something about something”; like a property of a thing, a structural characteristic), and Judgment (“yes or no”).</p>\n<p>A compact presentation of a Boolean algebra makes it seem like a lot of the above can be bundled together. The element “<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">⊤</mi></mrow><annotation encoding=\"application/x-tex\">\\top</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">⊤</span></span></span></span>” in some situations can be interpreted as “truth”, but it isn’t. It is a sentence which evaluates to true. Even under that conception, it isn’t that well-defined, in my opinion. We asserted there was an evaluation function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>eval</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{eval}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">eval</span></span></span></span></span>, but we haven’t yet explained under what conditions a sentence could “always evaluate to true”. So far, we made it seem like every sentence, hypothetically, is contingent - all assertions have the potential to be either true or false. (I also find this to be a more defensible “first principle”, to define propositional logic from.)</p>\n<p>So if a priori, a sentence has a meaning, and it can, conceivably, be true or false, the idea that certain <em>compositions</em> of propositions would in a more a posteriori way turn out to always evaluate to true, seems to be more like a property we added in, on top of our “base” system. </p>\n<p>I need a moment to think about how I would prefer to define / introduce that concept, though.</p>\n<p>All in all, I felt like sharing this idea that had been in the back of my mind, that it feels like the standard way one discusses propositional logic in terms of a Boolean algebra, is actually very much an a posteriori finding that the structure of propositional logic kind of mathematically/algebraically can be “reduced” to that set of axioms, but it feels like it deeply masks the justification for where that structure originally comes from.</p>",
        "id": 482466891,
        "sender_full_name": "Julius Hamilton",
        "timestamp": 1731612605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"699750\">Julius Hamilton</span> <a href=\"#narrow/channel/411257-theory.3A-mathematics/topic/Relating.20Top.20and.20Bottom.20to.20True.20and.20False/near/482466891\">said</a>:</p>\n<blockquote>\n<p>For example, “and” and “or” are compositional operations which build new propositions out of other ones: and:Prop,Prop→Prop. I’m saying that if starting from first principles, I find it more intuitive to locate “and” as being an operation on propositions, and “not” as an operation on truth values</p>\n</blockquote>\n<p>what makes \"not\" different from \"and\" and \"or\"? why would the former apply more naturally to truth values?</p>",
        "id": 482673270,
        "sender_full_name": "Josselin Poiret",
        "timestamp": 1731695926
    },
    {
        "content": "<p>Yeah, I would say that both propositions and truth values each have their own notions of \"and\", \"or\", and \"not\".</p>",
        "id": 482696425,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1731705664
    }
]