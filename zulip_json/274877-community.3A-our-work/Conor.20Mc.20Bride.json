[
    {
        "content": "<p>Which \"indexed containers\" are profunctors <em>by construction</em>?</p>",
        "id": 231726771,
        "sender_full_name": "Conor McBride",
        "timestamp": 1616629222
    },
    {
        "content": "<p>I mean, a big part of my work is (in a programming languages datatype declaration context) to notice and exploit what is already under my nose.</p>",
        "id": 231727858,
        "sender_full_name": "Conor McBride",
        "timestamp": 1616629934
    },
    {
        "content": "<p>I'm not sure I'm parsing the question correctly. Would you mind expanding a little?</p>",
        "id": 231774634,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1616667107
    },
    {
        "content": "<p>I don't mind mind expanding. My motivation comes from dependently typed programming, where our notion of \"inductive datatype\" amounts to \"proof-relevant relation\", i.e. data consistent with some explicit indexing discipline (e.g. terms which are well typed and in scope by construction). These data structures are fixpoints of polynomial functors, but not in an exciting enough way, to my taste. In particular, the types used as indices often have categorical structure giving rise to actions on the indexed data (e.g., scopes form a category with embeddings as morphisms, in a way which well scoped terms respect).</p>\n<p>That's to say, these indexed data structures very often are intended by their designers to have nontrivial presheaf/profunctor structure, but the current technology allows that intent to be communicated laboriously, after the fact. I write my datatype of terms as if scopes have no structure; I implement the action of scope embedding on terms; I prove that it respects identity and composition; I die of boredom. I despair of pointing out that structure happens to arise as some sort of outrageous coincidence, when in fact I put it there deliberately but couldn't say so.</p>\n<p>Our starting point is polynomial functors on Set. The data are given by diagrams O &lt;- S &lt;- P -&gt; I, giving rise to functors between slices, Set/I -&gt; Set/O. Very often, we take O to be I, and then take the initial algebra, giving us an indexed inductive family of sets, in Set/I, or Set^I if you like. That's a good start, but it's not alert to structure other than equality in I. If my indices have interesting categorical structure, I want to get my hands on nontrivial functors from curly I to Set, and I'm wondering how to refine the notion of the underlying polynomial functors to get that structure for the asking.</p>",
        "id": 231781233,
        "sender_full_name": "Conor McBride",
        "timestamp": 1616670344
    },
    {
        "content": "<p>Two (very obvious) comments:</p>\n<ol>\n<li>if your <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> has structure, and you don't ask that that structure already be present in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> and preserved, then you're going to have to reconstruct all of that tediously. Same for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi></mrow><annotation encoding=\"application/x-tex\">O</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span></span></span></span>.</li>\n<li>Just like with identity-on-objects functors, which were discussed recently on the Category Zulip, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mo>=</mo><mi>O</mi></mrow><annotation encoding=\"application/x-tex\">I = O</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span></span></span></span> is not some kind of post facto thing you discover. By then it's too late, and life is tedious. [Same thing arises  when dealing with 2 monoid structures on the same carrier set; one way to say this brings much pain, and the other no pain. Just because we now have equalities that compute doesn't mean that that's the pleasant way to do things when you can avoid all of it altogether.]</li>\n</ol>\n<p>I think the problem lies in the starting point: it's like starting with block-of-words as your building pieces. Way better than bits, that's for sure, but still way too unstructured. [Which is probably exactly what you're saying in your last line!]</p>\n<p>If I were to attack this, I'd figure out all the nice properties I want in my functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><mi mathvariant=\"normal\">/</mi><mi>I</mi><mo>â†’</mo><mrow><mi mathvariant=\"sans-serif\">S</mi><mi mathvariant=\"sans-serif\">e</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><mi mathvariant=\"normal\">/</mi><mi>O</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Set}/I \\rightarrow \\mathsf{Set}/O</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">S</span><span class=\"mord mathsf\">e</span><span class=\"mord mathsf\">t</span></span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">S</span><span class=\"mord mathsf\">e</span><span class=\"mord mathsf\">t</span></span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span></span></span></span>, <strong>then</strong> figure out what diagrams give rise to those functors. Maybe it won't be <em>quite</em> polynomials that you'll end up with.</p>",
        "id": 231788879,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1616674119
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296322\">Jacques Carette</span> <a href=\"#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/231788879\">said</a>:</p>\n<blockquote>\n<p>Same thing arises  when dealing with 2 monoid structures on the same carrier set</p>\n</blockquote>\n<p>I suppose there must also be something like this for models of bunched implications, right?</p>",
        "id": 231801774,
        "sender_full_name": "James Wood",
        "timestamp": 1616679680
    },
    {
        "content": "<p>Taking the untyped <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Î»</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">Î»</span></span></span></span>-calculus as an example, we may construct it  following the Fiore-Plotkin-Turi yoga,  using the endofunctor on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>ğ”½</mi><mo separator=\"true\">,</mo><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[ğ”½,ğ’ğğ­]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathbb\">F</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathbf\">S</span><span class=\"mord mathbf\">e</span><span class=\"mord mathbf\">t</span><span class=\"mclose\">]</span></span></span></span> defined by</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi mathvariant=\"normal\">Î£</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>X</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mtext>Â²</mtext><mo>+</mo><mi>X</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">\\Sigma(X)(n) = X(n)Â² + X(n+1).</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Î£</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mord\">Â²</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">.</span></span></span></span></span></p>\n<p>This functor is polynomial in the general sense of familial, hence, I think, so is the free monad on it, say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ“</mi></mrow><annotation encoding=\"application/x-tex\">ğ“</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68611em;vertical-align:0em;\"></span><span class=\"mord mathbf\">T</span></span></span></span>, and the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Î»</mi></mrow><annotation encoding=\"application/x-tex\">Î»</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">Î»</span></span></span></span>-calculus is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ“</mi><mo stretchy=\"false\">(</mo><mi>I</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ğ“(I)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbf\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mclose\">)</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mo>=</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">I(n) := n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>. </p>\n<p>Thinking of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Î»</mi></mrow><annotation encoding=\"application/x-tex\">Î»</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">Î»</span></span></span></span>-terms as proofs in natural deduction (for very basic sequents, of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>âŠ¢</mo></mrow><annotation encoding=\"application/x-tex\">n âŠ¢</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">âŠ¢</span></span></span></span>), one may think of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ“</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ğ“(X)(n)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbf\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> as partial proofs with axioms in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>.</p>\n<p>Does functoriality in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> satisfy your needs, or do you want more?</p>",
        "id": 231804477,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1616680679
    },
    {
        "content": "<p>Thanks! This is a good start, but I'm hoping for more. For this example, I'd be trying to get my hands on a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><msub><mi mathvariant=\"normal\">Î”</mi><mo>+</mo></msub><mo separator=\"true\">,</mo><mrow><mi mathvariant=\"bold\">S</mi><mi mathvariant=\"bold\">e</mi><mi mathvariant=\"bold\">t</mi></mrow><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[\\Delta_+,\\mathbf{Set}]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord\">Î”</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.25833100000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">S</span><span class=\"mord mathbf\">e</span><span class=\"mord mathbf\">t</span></span><span class=\"mclose\">]</span></span></span></span>, (where by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Î”</mi><mo>+</mo></msub></mrow><annotation encoding=\"application/x-tex\">\\Delta_+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord\">Î”</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.25833100000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> I mean the category of order-preserving injections on finite sets), so that I can shift terms to anywhere that their support is in scope. Crucially, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>â‹…</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\cdot + 1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">â‹…</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> is still a <em>functor</em> in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Î”</mi><mo>+</mo></msub></mrow><annotation encoding=\"application/x-tex\">\\Delta_+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord\">Î”</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.25833100000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span>. And it's that sort of functoriality requirement that I'm interested in bottling, <em>in general</em>.</p>\n<p>That is, where in polynomials on sets, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo>â†</mo><mi>S</mi><mo>â†</mo><mi>P</mi><mo>â†’</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">O \\leftarrow S \\leftarrow P \\rightarrow I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> we have functions, we now need a richer functoriality, but I'm struggling (productively) to put my finger on precisely what.</p>\n<p>There are lots of situations like this (type preservation explanations spring to mind) where we currently prove things but could potentially just enjoy their truth, if only we knew how to be more deliberately structure-respecting.</p>",
        "id": 231812694,
        "sender_full_name": "Conor McBride",
        "timestamp": 1616683260
    },
    {
        "content": "<p>I clearly need to read the markdown instructions more carefully. Sorry.</p>",
        "id": 231815127,
        "sender_full_name": "Conor McBride",
        "timestamp": 1616684024
    },
    {
        "content": "<p>You need two dollars for LaTeX. You are able to edit your posts too.</p>",
        "id": 231825290,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1616687045
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281583\">@James Wood</span> I was alluding to the bundling/unbundling \"problem\", that is common to any kind of structure where you may want to expose certain fields as fixed on the interface, some of the time but not all the time.</p>",
        "id": 231825890,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1616687250
    },
    {
        "content": "<p>Reminder to <span class=\"user-mention\" data-user-id=\"277574\">@Conor McBride</span> that those are exactly Joyal's <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">L</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{L}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">L</span></span></span></span></span>-species, covered quite well in chapter 5 of the Bergeron, Labelle, Leroux textbook. It's no wonder you seek these, as they have all sorts of beautiful properties.</p>",
        "id": 231827558,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1616687825
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 231827683,
        "sender_full_name": "Conor McBride",
        "timestamp": 1616687874
    },
    {
        "content": "<p>But can't you do that in the Fiore-Plotkin-Turi setting? Functoriality in yields in particular <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ“</mi><mo stretchy=\"false\">(</mo><mi>I</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>â†’</mo><mi>ğ“</mi><mo stretchy=\"false\">(</mo><mi>I</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ğ“(I)(n) â†’ ğ“(I)(n+1)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbf\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbf\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>, doesn't it? I'm probably misunderstanding your post, sorry!</p>",
        "id": 231830945,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1616689041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277574\">Conor McBride</span> <a href=\"#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/231781233\">said</a>:</p>\n<blockquote>\n<p>Our starting point is polynomial functors on Set. The data are given by diagrams O &lt;- S &lt;- P -&gt; I, giving rise to functors between slices, Set/I -&gt; Set/O. </p>\n</blockquote>\n<p>I feel stupid, but can anyone explain the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo>â†</mo><mi>S</mi><mo>â†</mo><mi>P</mi><mo>â†’</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">O\\leftarrow S\\leftarrow P\\rightarrow I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> yoga to me?</p>",
        "id": 231837319,
        "sender_full_name": "Cody Roux",
        "timestamp": 1616691354
    },
    {
        "content": "<p>Hi Cody! Start with a bundle <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>â†’</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">X\\to I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> on the right. First pull back, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>âˆ</mo></mrow><annotation encoding=\"application/x-tex\">\\prod</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">âˆ</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>âˆ‘</mo></mrow><annotation encoding=\"application/x-tex\">\\sum</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">âˆ‘</span></span></span></span>. That gives you a new bundle over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi></mrow><annotation encoding=\"application/x-tex\">O</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span></span></span></span>. That's a sum of products, hence \"polynomial\".</p>",
        "id": 231838754,
        "sender_full_name": "Spencer Breiner",
        "timestamp": 1616691826
    },
    {
        "content": "<p>Sorry, I think that's backwards. Start with the bundle over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span>.</p>",
        "id": 231838944,
        "sender_full_name": "Spencer Breiner",
        "timestamp": 1616691886
    },
    {
        "content": "<p>Fixed</p>",
        "id": 231839127,
        "sender_full_name": "Spencer Breiner",
        "timestamp": 1616691939
    },
    {
        "content": "<p>Thanks for expanding, I  have not read about containers (indexed, higher-order or any kind really) to make sensible observations. But I like the motivation and would like to understand it better. you say:</p>\n<blockquote>\n<p>My motivation comes from dependently typed programming, where our notion of \"inductive datatype\" amounts to \"proof-relevant relation\", i.e. data consistent with some explicit indexing discipline (e.g. terms which are well typed and in scope by construction).</p>\n</blockquote>\n<p>ok, this (proof-relevant relations)  explains why  profunctors.</p>\n<blockquote>\n<p>These data structures are fixpoints of polynomial functors, but not in an exciting enough way, to my taste.</p>\n</blockquote>\n<p>why? Being fixed points of a polynomial functor is good. and being so  in a non-exciting way is also good, you're just setting up the scene, saying what's need, for whatever happens later.  so, I don't understand</p>\n<blockquote>\n<p>I despair of pointing out that structure happens to arise as some sort of outrageous coincidence, when in fact I put it there deliberately but couldn't say so.</p>\n</blockquote>\n<p>but I guess I should go try to read the papers instead of simply going why, why, why like a broken record</p>",
        "id": 231845474,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1616694290
    },
    {
        "content": "<p>Oh I think I get it. Thanks <span class=\"user-mention\" data-user-id=\"278008\">@Spencer Breiner</span> ! After all this time, I still find it hard to stare at diagrams instead of typing rules.</p>",
        "id": 231850794,
        "sender_full_name": "Cody Roux",
        "timestamp": 1616696180
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276656\">@Valeria de Paiva</span> <span class=\"user-mention\" data-user-id=\"277574\">@Conor McBride</span>  I think an example of what the \"extra work\" is needed to be done might be revealing as well. Do you happen to have an Agda gist handy?</p>",
        "id": 231851011,
        "sender_full_name": "Cody Roux",
        "timestamp": 1616696279
    },
    {
        "content": "<p>I expect I could scrape something together. Watch this space.</p>\n<p>When you live in type theory, you can turn lots of these arrows around and work dependently. Output sorts <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo>:</mo><mtext mathvariant=\"bold\">Set</mtext></mrow><annotation encoding=\"application/x-tex\">O : \\textbf{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68611em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord textbf\">Set</span></span></span></span></span>, shapes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>:</mo><mi>O</mi><mo>â†’</mo><mtext mathvariant=\"bold\">Set</mtext></mrow><annotation encoding=\"application/x-tex\">S : O \\rightarrow \\textbf{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68611em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord textbf\">Set</span></span></span></span></span> depend on what sort of container you're trying to build. Positions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi>o</mi><mo>:</mo><mi>O</mi><mo stretchy=\"false\">)</mo><mo>â†’</mo><mi>S</mi><mtext>â€…</mtext><mi>o</mi><mo>â†’</mo><mtext mathvariant=\"bold\">Set</mtext></mrow><annotation encoding=\"application/x-tex\">P : (o : O)\\rightarrow S\\:o \\rightarrow \\textbf{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">o</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68611em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord textbf\">Set</span></span></span></span></span> say where you can put the stuff in the shape. And then you request <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi>o</mi><mo>:</mo><mi>O</mi><mo stretchy=\"false\">)</mo><mo>â†’</mo><mo stretchy=\"false\">(</mo><mi>s</mi><mo>:</mo><mi>S</mi><mtext>â€…</mtext><mi>O</mi><mo stretchy=\"false\">)</mo><mo>â†’</mo><mi>P</mi><mtext>â€…</mtext><mi>o</mi><mtext>â€…</mtext><mi>s</mi><mo>â†’</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">r : (o : O)\\rightarrow(s : S\\:O)\\rightarrow P\\:o\\:s \\rightarrow I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">o</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> the input sort of the data you want in each position. The pattern of dependency reflects the flow of <em>time</em>. You end up with a functor on indexed sets in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>I</mi><mo>â†’</mo><mtext mathvariant=\"bold\">Set</mtext><mo stretchy=\"false\">)</mo><mo>â†’</mo><mo stretchy=\"false\">(</mo><mi>O</mi><mo>â†’</mo><mtext mathvariant=\"bold\">Set</mtext><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(I\\rightarrow \\textbf{Set})\\rightarrow(O\\rightarrow \\textbf{Set})</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord textbf\">Set</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord textbf\">Set</span></span><span class=\"mclose\">)</span></span></span></span> mapping <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>:</mo><mi>I</mi><mo>â†’</mo><mtext mathvariant=\"bold\">Set</mtext></mrow><annotation encoding=\"application/x-tex\">X:I\\rightarrow \\textbf{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68611em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord textbf\">Set</span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>o</mi><mo>:</mo><mi>O</mi></mrow><annotation encoding=\"application/x-tex\">o : O</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>s</mi><mo>:</mo><mi>S</mi><mtext>â€…</mtext><mi>o</mi><mo stretchy=\"false\">)</mo><mo>Ã—</mo><mo stretchy=\"false\">(</mo><mi>p</mi><mo>:</mo><mi>P</mi><mtext>â€…</mtext><mi>o</mi><mtext>â€…</mtext><mi>s</mi><mo stretchy=\"false\">)</mo><mo>â†’</mo><mi>X</mi><mtext>â€…</mtext><mo stretchy=\"false\">(</mo><mi>r</mi><mtext>â€…</mtext><mi>o</mi><mtext>â€…</mtext><mi>s</mi><mtext>â€…</mtext><mi>p</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(s : S\\:o)\\times(p : P\\:o\\:s)\\rightarrow X\\:(r\\:o\\:s\\:p)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">Ã—</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">)</span></span></span></span>. That is, you choose one of the shapes available at sort <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>o</mi></mrow><annotation encoding=\"application/x-tex\">o</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">o</span></span></span></span>, then you fill up its positions with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> data of the input sorts requested.</p>\n<p>What's bothering me is that the sorts <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi></mrow><annotation encoding=\"application/x-tex\">O</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> are here treated has having only discrete structure, but I want to build functors (then take fixpoints) between nontrivial presheaves.</p>",
        "id": 231853209,
        "sender_full_name": "Conor McBride",
        "timestamp": 1616697124
    },
    {
        "content": "<p><a href=\"https://github.com/pigworker/Samizdat/blob/master/STLCThin.agda\">Here is an example in Agda</a> of the presheaf structure of simply typed lambda terms (a functor from the dual of contexts with selection).</p>\n<p>It turns out that in a past life, I made some progress. <a href=\"https://github.com/pigworker/Samizdat/blob/master/DeFunct.agda\">This rather gnarly and inscrutable lump of Agda</a> gives a syntactic presentation of <em>some</em> polynomials which are presheaves by construction. But I'm keen to get my hands on the generic presentation.</p>",
        "id": 231866118,
        "sender_full_name": "Conor McBride",
        "timestamp": 1616702043
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277574\">Conor McBride</span> <a href=\"#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/231815127\">said</a>:</p>\n<blockquote>\n<p>I clearly need to read the markdown instructions more carefully. Sorry.</p>\n</blockquote>\n<p>Just replace all your $'s with double dollars.  Math is twice as expensive here.</p>",
        "id": 231868242,
        "sender_full_name": "John Baez",
        "timestamp": 1616702945
    },
    {
        "content": "<p>Looks like swearing in Asterix now.</p>",
        "id": 231868794,
        "sender_full_name": "Conor McBride",
        "timestamp": 1616703141
    },
    {
        "content": "<p>I hear some areas of category theory are only possible to understand with magic potions.</p>",
        "id": 231870765,
        "sender_full_name": "Cody Roux",
        "timestamp": 1616704028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277574\">Conor McBride</span> <a href=\"#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/231866118\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/pigworker/Samizdat/blob/master/STLCThin.agda\">Here is an example in Agda</a> of the presheaf structure of simply typed lambda terms (a functor from the dual of contexts with selection).</p>\n</blockquote>\n<p>At the bottom of that code, you say</p>\n<blockquote>\n<p>But Agda doesn't let me construct <em>functors</em><br>\n     (Bwd Ty, &lt;=) -&gt; (Set, -&gt;)/Ty<br>\n   so I'm forced to play stupid, work in<br>\n     |Bwd Ty| -&gt; (Set, -&gt;)/Ty<br>\n   and then work hard to \"discover\" the functoriality<br>\n   I already knew I wanted, in advance</p>\n</blockquote>\n<p>But category theory wouldn't let you do that either; more precisely, it would, but give you exactly the same as Agda.</p>\n<p>Question: why are you squishing all that information down into a category? Both on the left and on the right.  This data all feels \"higher dimensional\" (whether it's monoidal, bicategories, double cat, whatever, I don't have the time to puzzle it out atm). And it seems that you're running into problems because you're squishing it down into something too small to make all the bits obvious.</p>",
        "id": 231882129,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1616709140
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277574\">Conor McBride</span> <a href=\"#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/231866118\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/pigworker/Samizdat/blob/master/STLCThin.agda\">Here is an example in Agda</a> of the presheaf structure of simply typed lambda terms (a functor from the dual of contexts with selection).</p>\n<p>It turns out that in a past life, I made some progress. <a href=\"https://github.com/pigworker/Samizdat/blob/master/DeFunct.agda\">This rather gnarly and inscrutable lump of Agda</a> gives a syntactic presentation of <em>some</em> polynomials which are presheaves by construction. But I'm keen to get my hands on the generic presentation.</p>\n</blockquote>\n<p>I don't suppose you could elaborate what you feel is the shortcoming of the approach <span class=\"user-mention\" data-user-id=\"383799\">@Tom Hirschowitz</span> described? It seems to me that this has the properties you are after.</p>",
        "id": 231882569,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1616709370
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276092\">@Nathanael Arkor</span> I think you're using  \"this has all the properties you are after\" very differently from <span class=\"user-mention\" data-user-id=\"277574\">@Conor McBride</span> . Your notion seems to be that of \"it's all obvious to a seasoned category theorist\", while my understanding is that <span class=\"user-mention\" data-user-id=\"277574\">@Conor McBride</span> wants \"it's so obvious that even an interactive theorem prover plainly sees it without needing extra proofs.\" Those two are radically different things!  [At least, that's my understanding...]</p>",
        "id": 231884486,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1616710401
    },
    {
        "content": "<p>Jacques is right. I want the <em>machine</em> to see this is obviously the right thing and has all these properties, without me lifting a finger beyond giving the structure of the data. Moreover, I want the machine to <em>deploy</em> all these properties, without me lifting a finger at all. And I shall make it so.</p>",
        "id": 231884811,
        "sender_full_name": "Conor McBride",
        "timestamp": 1616710571
    },
    {
        "content": "<p>I'm going crazy, but I remember a paper, from years ago where you could prove univalence for specific types of inductives defined using polynomial functors. I think it was Coquand?</p>\n<p>For the life of me, I can't find the paper though.</p>",
        "id": 231886182,
        "sender_full_name": "Cody Roux",
        "timestamp": 1616711300
    },
    {
        "content": "<p>It seems to me, that one might want to apply univalence here, at least to transport isos. Not sure i'm making any sense though.</p>",
        "id": 231886233,
        "sender_full_name": "Cody Roux",
        "timestamp": 1616711343
    },
    {
        "content": "<p>Function extensionality is certainly indispensable in this cause. Univalence is not the only way to obtain function extensionality. But for sure, univalence would improve what's mechanically provable in this direction.</p>",
        "id": 231886965,
        "sender_full_name": "Conor McBride",
        "timestamp": 1616711713
    },
    {
        "content": "<p>I mean, in this case, univalence was a <em>theorem</em>: every \"reasonable\" datatype satisfies some form of transport.</p>",
        "id": 231887384,
        "sender_full_name": "Cody Roux",
        "timestamp": 1616711946
    },
    {
        "content": "<p>eh, maybe I'm mis-remembering.</p>",
        "id": 231887508,
        "sender_full_name": "Cody Roux",
        "timestamp": 1616712012
    },
    {
        "content": "<p>That sounds right. It's a crucial link in the story. Replace \"match on refl\" transport by per-type transport. I'm in the business of noticing when that's possible under weaker assumptions than on-the-nose equality.</p>",
        "id": 231887701,
        "sender_full_name": "Conor McBride",
        "timestamp": 1616712124
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296322\">@Jacques Carette</span>: ah, I see, thanks. I remember being frustrated with similar shortcomings when I was using Coq, so I would be very happy to see progress on this front too :)</p>",
        "id": 231887959,
        "sender_full_name": "Nathanael Arkor",
        "timestamp": 1616712293
    },
    {
        "content": "<p>You still have to careful. (Meant as a reply to <span class=\"user-mention\" data-user-id=\"276030\">@Cody Roux</span>)</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">data</span> <span class=\"kt\">Thing</span> <span class=\"ow\">=</span> <span class=\"kt\">Boom</span> <span class=\"o\">|</span> <span class=\"kt\">Bam</span>\n<span class=\"kr\">data</span> <span class=\"kt\">Other</span> <span class=\"ow\">=</span> <span class=\"kt\">Red</span> <span class=\"o\">|</span> <span class=\"kt\">Bycicle</span>\n</code></pre></div>\n<p>are entirely equivalent as types, and there's no good reason (in a univalent setting) to distinguish <code>Thing</code> from <code>Other</code>. But, well, there are <strong>two</strong> isomorphisms. And which you chose does matter. You have to be careful that you're not just moving the deck chairs around.</p>",
        "id": 231887969,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1616712300
    },
    {
        "content": "<p>Sure, but isn't the whole buisness of this brave new type theory to always keep the isos around?</p>",
        "id": 231888334,
        "sender_full_name": "Cody Roux",
        "timestamp": 1616712500
    },
    {
        "content": "<p>What's worse, there might be no reason whatsoever to consider these types <em>cognate</em>, despite the outrageous coincidence in the number of bits required to represent their values.</p>",
        "id": 231888428,
        "sender_full_name": "Conor McBride",
        "timestamp": 1616712558
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276092\">@Nathanael Arkor</span> There's so much room for improvement. In most proof assistants based on type theory, the typechecker doesn't even know that concatenation of lists is associative, so you have to prove it and point it out all the time.</p>",
        "id": 231890012,
        "sender_full_name": "Conor McBride",
        "timestamp": 1616713458
    },
    {
        "content": "<p>My take on being an intensional type theorist is that I structure the division of labour between people and machines. For reasons of taste, I prefer if it is easy to form simple mental models of what is \"machine work\" (definitely no human intervention needed) and what requires humans to deliver bits. The division of labour is expressed via the judgements: people provide terms but machines check that the terms are correctly composed up to some weak but decidable equality (that's the \"disappointing accident\"). The engineering of that disappointing accident is a subtle task that most mathematicians cannot be bothered with, and why should they? What's the point in worrying about the difference between \"true\" and \"so true even a stupid computer can see it\"?</p>\n<p>But as I am, at heart, a sideshow performer ever in search of clockwork monstrosities with which to captivate my punters, I'm fascinated by the business of walking that line, and finding theory that makes richer classes of theorem require minimal machine time and no human time.</p>",
        "id": 231892121,
        "sender_full_name": "Conor McBride",
        "timestamp": 1616714931
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296322\">Jacques Carette</span> <a href=\"#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/231887969\">said</a>:</p>\n<blockquote>\n<p>there's no good reason (in a univalent setting) to distinguish <code>Thing</code> from <code>Other</code>.</p>\n</blockquote>\n<p>We still have a judgemental inequality between them, which in practice is one we notice a lot.</p>",
        "id": 231894849,
        "sender_full_name": "James Wood",
        "timestamp": 1616716865
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276030\">@Cody Roux</span> Yes, absolutely. But many want to downplay that as much as possible. To me, that is an error.</p>\n<p><span class=\"user-mention\" data-user-id=\"281583\">@James Wood</span> That's kind of the trouble, isn't it? We're told they're the same and yet they're also not.  And indeed, the whole point is that (as Conor says), they might not be <em>cognate</em> at all. Intent is the important part, <em>outrageous coincidence</em> is something that the compiler can take advantage of <strong>post facto</strong>. Our theory shouldn't thrust  that upon us with no way to escape. Damn it, we went out of our way to write down our intent by using 2 different names!</p>",
        "id": 231899122,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1616720065
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277574\">Conor McBride</span> <a href=\"#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/231884811\">said</a>:</p>\n<blockquote>\n<p>Jacques is right. I want the <em>machine</em> to see this is obviously the right thing and has all these properties, without me lifting a finger beyond giving the structure of the data. Moreover, I want the machine to <em>deploy</em> all these properties, without me lifting a finger at all. And I shall make it so.</p>\n</blockquote>\n<p>Thanks, and sorry for taking so long to get it. <span class=\"user-mention\" data-user-id=\"276696\">@Ambroise</span>  has <a href=\"https://github.com/amblafont/Skew-Monoidalcategories\">implemented</a> a generalisation of the Fiore-Plotkin-Turi approach in Unimath, so technically I'd say you can just push a button to get all those properties. But the downside is that you don't get an inductive datatype, it's implemented as a directed colimit. I guess this is not good enough for you?</p>",
        "id": 231918936,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1616738400
    },
    {
        "content": "<p>Probably <a href=\"https://arxiv.org/pdf/2001.11001.pdf\">AACMM20</a>, section 10.3, would be a good starting point for the discussion about the Fiore-Plotkin-Turi work.</p>",
        "id": 231928566,
        "sender_full_name": "James Wood",
        "timestamp": 1616746802
    },
    {
        "content": "<p>I don't understand this: </p>\n<blockquote>\n<p>By contrast, we are working in an implemented type theory where the encoding can<br>\nbe understood as its own foundation without appeal to an external mathematical semantics.</p>\n</blockquote>\n<p>which I guess means I should go read the paper.</p>",
        "id": 231943214,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1616754942
    },
    {
        "content": "<p>I also don't understand some bits like this.</p>",
        "id": 232021349,
        "sender_full_name": "James Wood",
        "timestamp": 1616787833
    },
    {
        "content": "<p>hi, I'm still trying to understand the gnarly bit of Agda. I'm not good at this,<br>\nbut 138 locs is definitely a little less daunting than all the papers written about containers since 2003. so you say:</p>\n<blockquote>\n<p>I'll need simple types...</p>\n</blockquote>\n<p>and this is good, we always do.</p>\n<blockquote>\n<p>...and right-growing (i.e., backward) lists to put them in, to make contexts. -</p>\n</blockquote>\n<p>sure, also fine. (don't know if the capital B is for backward  or for  the base category of the fibration p:E--&gt; B, but this is fine)<br>\nThen stuff starts getting interesting because</p>\n<blockquote>\n<p>Now the semisimplicial category.</p>\n</blockquote>\n<p>(and I always thought that the list of variables with their dependent types was just a list.) sure, we can concatenate new pairs and  contexts always grow, but it hadn't occurred to me to think of this as a \"semisimplicial category\". but fine. why is this </p>\n<blockquote>\n<p>(It's secretly a bit vector.)</p>\n</blockquote>\n<p>I have no idea, but maybe it's about the efficiency of stuff, I don't care.</p>\n<blockquote>\n<p>The two CLUEs show that context extension is   on-the-nose covariantly functorial.</p>\n</blockquote>\n<p>works for me. as does</p>\n<blockquote>\n<p>Now, here are well scoped well typed terms.</p>\n</blockquote>\n<p>after a half a second hesitation on  S &gt;&gt; T being the function space from S to T.<br>\nbut then when we get to</p>\n<blockquote>\n<p>The above is the fixpoint of a polynomial with blah, blah</p>\n</blockquote>\n<p>I am lost. </p>\n<p>I want nothing to do with the Fiori-Plotkin-Turi approach, if I'm reading  right the passage indicated by  James Wood as 10.3 of AACMM20. Because yes, I want my indexed category with de Bruijn encoding on the syntax, not presheaves.  but it looks like reading of the previous version of AACMM20 is required.</p>",
        "id": 232692976,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1617242498
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276656\">Valeria de Paiva</span> <a href=\"#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/232692976\">said</a>:</p>\n<blockquote>\n<p>I want nothing to do with the Fiori-Plotkin-Turi approach, if I'm reading  right the passage indicated by  James Wood as 10.3 of AACMM20. Because yes, I want my indexed category with de Bruijn encoding on the syntax, not presheaves.  but it looks like reading of the previous version of AACMM20 is required.</p>\n</blockquote>\n<p>You seem to understand what got me puzzled earlier: would you please mind explaining in a bit more detail? What do you mean by having your indexed category with de Bruijn encoding on the syntax? What would you get with presheaves, an indexed category with de Bruijn encoding on presheaves?</p>",
        "id": 232712640,
        "sender_full_name": "Tom Hirschowitz",
        "timestamp": 1617260549
    },
    {
        "content": "<blockquote>\n<p>(don't know if the capital B is for backward or for the base category of the fibration p:E--&gt; B, but this is fine)</p>\n</blockquote>\n<p>I write <code>Bwd</code> for \"backward\": by programming convention established in the 1950s, \"normal\" lists grow by extending on the left, but the convention in logic/type theory is to write contexts as lists whose \"local\" end is on the right. I make the data in my code work like the data in my head.</p>\n<p>When I say that morphisms in the semisimplicial category are secretly bit vectors, I'm making a <em>combinatorial</em> observation: the rows of Pascal's triangle sum to powers of two. When you embed a short context into a longer one by making insertions, you're effectively selecting the short context from the long one by giving one bit of information (select or discard) for each of the long context's entries. The values <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">(</mo><mtable columnalign=\"center\" columnspacing=\"1em\" rowspacing=\"0.15999999999999992em\"><mtr><mtd><mstyle displaystyle=\"false\" scriptlevel=\"0\"><mi>m</mi></mstyle></mtd></mtr><mtr><mtd><mstyle displaystyle=\"false\" scriptlevel=\"0\"><mi>n</mi></mstyle></mtd></mtr></mtable><mo fence=\"true\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\left(\\begin{array}{c}m\\\\n\\end{array}\\right)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:2.40003em;vertical-align:-0.95003em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">(</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span></span></span><span style=\"top:-2.4099999999999997em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9500000000000004em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">)</span></span></span></span></span></span> in Pascal's triangle document the number of length <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> bit vectors with population count (the number of 1s) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>. It is missing a trick merely to <em>count</em> them: they have delightful compositional structure, really useful for working with de Bruijn terms. That's the structure being ignored when we treat the indices of the container only as discrete.</p>\n<p>And when it comes to the polynomial...</p>\n<blockquote>\n<p>I am lost.</p>\n</blockquote>\n<p>...I'm not surprised, because it's an inside-out mess. The <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo>â†</mo><mi>S</mi><mo>â†</mo><mi>P</mi><mo>â†’</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">O \\leftarrow S \\leftarrow P \\rightarrow I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> presentation of polynomial functors is a <em>terrible</em> way to compute with any <em>specific</em> polynomial functor. The merit of the \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span>-first\" presentation is in the abstract: thinking about polynomials in general, with as few dependencies/fibrations as you can get away with. The detail is inscrutable but not important: I felt obliged to calculate the polynomial corresponding to the functor whose least fixpoint yields the rather more intelligible inductive datatype definition, only to show that genuine OSPI-polynomials are indeed at work here.</p>\n<p>Returning to the big picture, I work with <em>machines</em> and thus to a finer degree of pedantry than mathematical demonstrability. I'm interested in which of us (me or the machine) has to do the work to establish mathematical demonstrability.</p>\n<p>In particular, I am looking for two related things. Firstly, I'm looking for a suitable interpretation of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo>â†</mo><mi>S</mi><mo>â†</mo><mi>P</mi><mo>â†’</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">O \\leftarrow S \\leftarrow P \\rightarrow I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> story in functor categories, yielding polynomial functors between presheaves. Secondly, I'm looking for a complete syntactic presentation of the same notion, from which the such-thattery required to establish presheaf structure has been eliminated. Concretely, I want to codify which datatype declarations exhibit presheaf structure <em>a priori</em>, so that I can obtain it deliberately and for but the effort of asking. It's kind of funny: I'm not trying to <em>prove</em> that one or two specific constructions yield presheaves; I'm exactly trying to <em>stop</em> proving that and just <em>see</em> it instead.</p>",
        "id": 232733201,
        "sender_full_name": "Conor McBride",
        "timestamp": 1617271997
    },
    {
        "content": "<p>I suppose the Oâ†Sâ†Pâ†’I presentation is a bit â€œif this is the answer, what is the question?â€. P describes where you might find premises of a rule, while S tells you which rule that premise is in.</p>",
        "id": 232745473,
        "sender_full_name": "James Wood",
        "timestamp": 1617278840
    },
    {
        "content": "<p>Maybe <code>fun</code> and <code>arg</code> would be clearer as <code>app left</code> and <code>app right</code>, or something.</p>",
        "id": 232745585,
        "sender_full_name": "James Wood",
        "timestamp": 1617278900
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"277574\">Conor McBride</span> <a href=\"#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/232733201\">said</a>:</p>\n<blockquote>\n<p>Returning to the big picture, I work with <em>machines</em> and thus to a finer degree of pedantry than mathematical demonstrability. I'm interested in which of us (me or the machine) has to do the work to establish mathematical demonstrability.</p>\n<p>[...] Concretely, I want to codify which datatype declarations exhibit presheaf structure <em>a priori</em>, so that I can obtain it deliberately and for but the effort of asking. It's kind of funny: I'm not trying to <em>prove</em> that one or two specific constructions yield presheaves; I'm exactly trying to <em>stop</em> proving that and just <em>see</em> it instead.</p>\n</blockquote>\n<p>This! So much this!</p>\n<p>Computers are really good at eliminating drudgery, at least when we take the time to ask them nicely to do so. It does not happen by a miracle, we have to spot where things are fully automatable. But it's a question that I like to be asking <strong>constantly</strong>.</p>\n<p>\"What should I be getting for free here, if I were to ask <em>in just the right way</em>\" yields all sorts of interesting dividends. Amusingly, it can sometimes force us to shift the focus back onto syntax: the semantics tells us there's automation to be had (the rest of <span class=\"user-mention\" data-user-id=\"277574\">@Conor McBride</span> 's explanation is all about an important specific case), but if you don't set things up correctly, it won't be \"free\".</p>\n<p>All the constructions of Universal Algebra are my current playground. Well, generalized UA - multi-sorted and indexed/parametrized. I'm endlessly amused that while constructing \"homomorphism\" was known since at least 1908, very few people seemed to both with the fact that a \"homomorphism\" needs to live in a theory too. And while you can take a weird multi-sorted view where it can fit, it's very unnatural (right up there with the single-sorted view of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span>-modules where you have to throw in a <em>big infinity</em>'s worth of constants). And yet, in our theorem provers, writing down the definition of what a homomorphism (say of Monoids) is super easy. But it 'lives' in a view of what a 'theory' is that is usually not spoken about.  [Hmm, I should perhaps be starting my own thread in 'practice: our work' for this stuff...]</p>",
        "id": 232768373,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1617288241
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"383799\">Tom Hirschowitz</span> <a href=\"#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/232712640\">said</a>:</p>\n<blockquote>\n<p>You seem to understand what got me puzzled earlier: would you please mind explaining in a bit more detail? What do you mean by having your indexed category with de Bruijn encoding on the syntax? What would you get with presheaves, an indexed category with de Bruijn encoding on presheaves?</p>\n</blockquote>\n<p>hi <span class=\"user-mention\" data-user-id=\"383799\">@Tom Hirschowitz</span> . no deep understanding on my part, simply the  shallow observation that I want *only the categorical structure that I am forced to have, nothing more. My indexed categories come from work with Eike Ritter on categorical combinators for dependent type theories (<a href=\"https://www.sciencedirect.com/science/article/pii/0304397594001253\">https://www.sciencedirect.com/science/article/pii/0304397594001253</a>) and there I need pullback for substitutions, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Î£</mi></mrow><annotation encoding=\"application/x-tex\">\\Sigma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Î£</span></span></span></span>'s and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Î </mi></mrow><annotation encoding=\"application/x-tex\">\\Pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Î </span></span></span></span>'s, satisfying BCC of course. the rest is up for grabs!</p>",
        "id": 232787387,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1617295145
    },
    {
        "content": "<p>Many thanks <span class=\"user-mention\" data-user-id=\"277574\">@Conor McBride</span>  for indulging me with explanations! </p>\n<p>you're of course right about the opposite traditions on the telescopes of dependent types, which I hadn't paid enough attention to.</p>\n<p>and I learned lots from</p>\n<blockquote>\n<p>I'm making a combinatorial observation: the rows of Pascal's triangle sum to powers of two. When you embed a short context into a longer one by making insertions, you're effectively selecting the short context from the long one by giving one bit of information (select or discard) for each of the long context's entries.[...] they have delightful compositional structure, really useful for working with de Bruijn terms. </p>\n</blockquote>\n<p>I have survived so far without understanding de Bruijn terms properly and I hope to be able to carry on the same way. But I begin to see why you say</p>\n<blockquote>\n<p>That's the structure being ignored when we treat the indices of the container only as discrete.</p>\n</blockquote>\n<p>I do understand that a finer degree of pedantry is required for machines.</p>\n<p>When we get to the crux of the matter</p>\n<blockquote>\n<p>I'm looking for a suitable interpretation of the O \\leftarrow S \\leftarrow P \\rightarrow IOâ†Sâ†Pâ†’I story in functor categories, yielding polynomial functors between presheaves.</p>\n</blockquote>\n<p>Great, as I am trying to understand exactly this. no one needs to tell me that polynomials are important in mathematics, this much I know. I am trying to understand why container morphisms are the way they are, as they're reminiscent of dialectica morphisms and I have a single-track mind.</p>\n<blockquote>\n<p>Secondly, I'm looking for a complete syntactic presentation of the same notion, from which the such-thattery required to establish presheaf structure has been eliminated.</p>\n</blockquote>\n<p>Excellent, as I thought this would be a great way of going about it! I have always held the belief that FPers have intuitions about syntax that mathematicians lack and that the uncovering these intuitions is the source of much real progress in maths.</p>",
        "id": 232793842,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1617297945
    },
    {
        "content": "<p>and more  thanks for</p>\n<blockquote>\n<p>..I'm not surprised, because it's an inside-out mess. The O \\leftarrow S \\leftarrow P \\rightarrow IOâ†Sâ†Pâ†’I presentation of polynomial functors is a terrible way to compute with any specific polynomial functor. The merit of the \"PP-first\" presentation is in the abstract: thinking about polynomials in general, with as few dependencies/fibrations as you can get away with. The detail is inscrutable but not important: I felt obliged to calculate the polynomial corresponding to the functor whose least fixpoint yields the rather more intelligible inductive datatype definition, only to show that genuine OSPI-polynomials are indeed at work here.</p>\n</blockquote>\n<p>I'm afraid I had not noticed the O&lt;--S&lt;--P&lt;--I vertically written, so now it makes much more sense!</p>",
        "id": 232963052,
        "sender_full_name": "Valeria de Paiva",
        "timestamp": 1617405478
    },
    {
        "content": "<p>I'm a little late here and haven't read all the discussion below; maybe this has been discussed. In his HoTTEST video, Garner showed that bimodules between polynomial functors are parametric right adjoints between the associated copresheaf categories. So for any categories <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">I</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{I}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.07382em;\">I</span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">O</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span></span></span></span></span>, are the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"script\">I</mi><mo separator=\"true\">,</mo><mi mathvariant=\"script\">O</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\mathcal{I},\\mathcal{O})</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.07382em;\">I</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span></span><span class=\"mclose\">)</span></span></span></span>-bimodules what you're looking for, @Conor? They are richer than profunctors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">I</mi><mo>â†’</mo><mi mathvariant=\"script\">O</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{I}\\to\\mathcal{O}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.07382em;\">I</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span></span></span></span></span>. You can think of any such bimodule as a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">O</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span></span></span></span></span>-indexed ducquery [disjoint union of conjunctive queries] on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">I</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{I}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.07382em;\">I</span></span></span></span></span>.</p>",
        "id": 233559828,
        "sender_full_name": "David Spivak",
        "timestamp": 1617829135
    },
    {
        "content": "<p>This sounds good to me. I'll check it out. Inevitably, I'll be looking for a syntactification of the result, because my favourite proof is \"by inspection\", especially if I can teach a machine to do the inspection.</p>",
        "id": 233563523,
        "sender_full_name": "Conor McBride",
        "timestamp": 1617829946
    },
    {
        "content": "<p>Another thing that might be useful is the notion of \"full internal subcategory\", which you can find in Jacobs 99. [Sorry if you're way ahead of me!] For polynomials p: Set--&gt;Set, you consider the category In(p) whose objects are elements i : p(1) [positions/shapes] and whose morphisms are given by Hom(i,j) = Set( p[i], p[j] ), the set of functions from the [directions/positions] of at i to those at j. This In(p) thing comes with a fully faithful functor to Set.</p>\n<p>This thingy is fairly prominent in Clive's thesis about Natural Models, but I think perhaps it should be generalized to what I'm calling \"p-concrete categories\", which are categories C equipped with an identity-on-objects and faithful functor C--&gt;In(p). </p>\n<p>Anyway, if any of this looks like what you're looking for, let me know!</p>",
        "id": 233671936,
        "sender_full_name": "David Spivak",
        "timestamp": 1617894948
    }
]