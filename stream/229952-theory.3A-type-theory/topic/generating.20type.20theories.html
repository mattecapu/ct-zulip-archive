<!DOCTYPE html>
<html>
<head>
  	<meta charset="utf-8" />
  	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
  	<meta name="viewport" content="width=device-width, initial-scale=1" />
  
<link rel="stylesheet" href="https://mattecapu.github.io/ct-zulip-archive/style.css" /><title>generating type theories · theory: type theory · Zulip Chat Archive</title>
</head>
<body>
<header>
<a href="https://mattecapu.github.io/ct-zulip-archive" class="home-link">
        <img class="logo" src="https://zulip-avatars.s3.amazonaws.com/21317/realm/icon.png?version=3" />
        <h1>Category Theory<br/>Zulip Server<br/>Archive</h1>
        </a>
        <p>
        You're reading the public-facing archive of the <a href="https://categorytheory.zulipchat.com/">Category Theory Zulip server</a>.<br/>
        
        To join the server you need an invite. Anybody can get an invite by contacting <a href="https://matteocapucci.wordpress.com">Matteo Capucci</a> at <em>name dot surname at gmail dot com</em>.<br/>
        
        For all things related to this archive refer to the same person.
        </p>
        </header>
        <hr />
    
<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/index.html">theory: type theory</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html">generating type theories</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com">

<a name="220715460"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220715460" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christian Williams <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220715460">(Dec 22 2020 at 17:44)</a>:</h4>
<p>Hello, hope your holiday is going well enough. I had a question about references, existing literature and implementations:<br>
What has been done toward general methods of taking a programming language and <em>generating a type system</em> for it automatically? Any thoughts are appreciated.</p>



<a name="220715567"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220715567" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220715567">(Dec 22 2020 at 17:45)</a>:</h4>
<p>Could you clarify what you mean by "programming language" if that doesn't already include the type system?</p>



<a name="220715981"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220715981" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christian Williams <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220715981">(Dec 22 2020 at 17:50)</a>:</h4>
<p>The language may already have a type system of its own; but a motivating example would be a language which does not already have a prominent type system, and could still benefit from one, such as Javascript.</p>



<a name="220716235"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220716235" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220716235">(Dec 22 2020 at 17:52)</a>:</h4>
<p>Would a motivating example be automatically generating the rules for the STLC, based on the rules for the untyped LC?</p>



<a name="220716246"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220716246" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christian Williams <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220716246">(Dec 22 2020 at 17:52)</a>:</h4>
<p>In terms of generating a type system, I'm mainly thinking of the idea of "a logic over a type theory" from Jacobs' Categorical Logic. I am really impressed by the idea and I don't know how much it has been implemented in practice. But also, there may be other versions of the idea of generating a type system, and I'm wondering what people may know.</p>



<a name="220716265"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220716265" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christian Williams <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220716265">(Dec 22 2020 at 17:52)</a>:</h4>
<p>Yes, I would say that's a good example.</p>



<a name="220718040"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220718040" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Doel <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220718040">(Dec 22 2020 at 18:09)</a>:</h4>
<p>Why would STLC be automatically generated and not any of dozens of other possible type systems?</p>



<a name="220718435"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220718435" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christian Williams <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220718435">(Dec 22 2020 at 18:14)</a>:</h4>
<p>It just depends on the method of generating. I think I know one that would produce that system, but I would need to work it out.</p>



<a name="220718480"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220718480" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christian Williams <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220718480">(Dec 22 2020 at 18:14)</a>:</h4>
<p>This is meant to be a very open-ended question, so any answers are good. There may be many things that exist under different names than what I'm describing, like some tool that gives languages pattern-matching.</p>



<a name="220718573"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220718573" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christian Williams <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220718573">(Dec 22 2020 at 18:15)</a>:</h4>
<p>I'm just wondering about any general-purpose ideas/tools that provide a broad class of programming languages with higher-level reasoning.</p>



<a name="220719838"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220719838" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Doel <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220719838">(Dec 22 2020 at 18:29)</a>:</h4>
<p>I think in general a type system that correctly describes untyped code that people end up writing ends up being extremely complex. For instance, years ago, there was this one person working on a lisp dialect that had a very programmable type system. They ended up crafting a type system for the Tk bindings (UI toolkit), and it was extremely complicated.</p>



<a name="220719961"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220719961" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Doel <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220719961">(Dec 22 2020 at 18:30)</a>:</h4>
<p>That isn't because you <em>couldn't</em> do the same thing in a way that would be less complicated with respect to types, but when people don't think about simple types from the start, they end up doing ad hoc things that end up very complicated to describe.</p>



<a name="220720314"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220720314" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Doel <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220720314">(Dec 22 2020 at 18:34)</a>:</h4>
<p>But maybe you don't care about rejecting some things that people have written.</p>



<a name="220742929"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220742929" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christian Williams <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220742929">(Dec 22 2020 at 22:44)</a>:</h4>
<p>I think I understand what you mean, but I'm not sure what it means to "correctly describe" untyped code.</p>



<a name="220743566"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220743566" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christian Williams <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220743566">(Dec 22 2020 at 22:52)</a>:</h4>
<p>If an auto-generated type system is meant to be general-purpose, I think probably it should be purely descriptive/agnostic. The main examples I have in mind are akin to pattern-matching, regular expressions, predicate logic.</p>



<a name="220744063"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220744063" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christian Williams <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220744063">(Dec 22 2020 at 22:58)</a>:</h4>
<p>For example in a concurrent language, we can specify the single-threaded processes by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>∧</mo><mi mathvariant="normal">¬</mi><mo stretchy="false">[</mo><mi>p</mi><mi>a</mi><mi>r</mi><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi mathvariant="normal">¬</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\neg[0]\land \neg[par(\neg[0],\neg[0])]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord">¬</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">¬</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span>: not the null process, and not the parallel of two non-null processes. This is a type (predicate) that's just built up from language constructors and logical constructors.</p>



<a name="220744465"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220744465" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220744465">(Dec 22 2020 at 23:03)</a>:</h4>
<p>Do I understand the example correctly: you're defining a predicate that expresses something like the following pseudo-code <code>single_threaded(term) := !matches(term, 0) &amp;&amp; !(matches(term, par(x, y)) &amp;&amp; !matches(x, 0) &amp;&amp; !matches(y, 0))</code>?</p>



<a name="220744575"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220744575" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220744575">(Dec 22 2020 at 23:05)</a>:</h4>
<p>Adding pattern-matching along with a specified logic to a type theory automatically seems much more constrained and feasible than trying to construct a nontrivial type theory corresponding to an arbitrary single-sorted type theory.</p>



<a name="220744635"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220744635" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220744635">(Dec 22 2020 at 23:06)</a>:</h4>
<p>(I know I've seen this example before, but I think I hadn't understood exactly what it was intended to express previously.)</p>



<a name="220745215"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220745215" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220745215">(Dec 22 2020 at 23:13)</a>:</h4>
<p>In that case, it seems like it could be sufficient to add the operators <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi></mrow><annotation encoding="application/x-tex">\neg</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">¬</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi></mrow><annotation encoding="application/x-tex">\exists</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∃</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\land</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∧</span></span></span></span> to the type theory, since that predicate can be expressed as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo mathvariant="normal">≠</mo><mn>0</mn><mo>∧</mo><mi mathvariant="normal">∄</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mtext> </mtext><mi mathvariant="normal">.</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>t</mi><mo>=</mo><mrow><mi mathvariant="sans-serif">p</mi><mi mathvariant="sans-serif">a</mi><mi mathvariant="sans-serif">r</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∧</mo><mi>x</mi><mo mathvariant="normal">≠</mo><mn>0</mn><mo>∧</mo><mi>y</mi><mo mathvariant="normal">≠</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t \neq 0 \land \nexists x, y\ .\ (t = \mathsf{par}(x, y) \land x \neq 0 \land y \neq 0)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord amsrm">∄</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace"> </span><span class="mord">.</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">p</span><span class="mord mathsf">a</span><span class="mord mathsf" style="margin-right:0.01389em;">r</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>.</p>



<a name="220746550"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220746550" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Doel <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220746550">(Dec 22 2020 at 23:32)</a>:</h4>
<p>In the case of something like Tk, if things are completely untyped, the most basic thing would be calling functions with the correct number of arguments. However, the way people do that in untyped settings could in itself be complicated to describe. There might be multiple acceptable numbers of arguments, and the total number expected might depend on the values of earlier arguments.</p>



<a name="220746592"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220746592" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Doel <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220746592">(Dec 22 2020 at 23:32)</a>:</h4>
<p>And the types of arguments expected might depend on earlier or later values.</p>



<a name="220746746"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220746746" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Doel <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220746746">(Dec 22 2020 at 23:34)</a>:</h4>
<p>For a more academic example, you might say that the 'correct' untyped lambda terms are the ones that normalize, and then a type system for that is not simple types, but intersection/union types on top of that.</p>



<a name="220746934"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220746934" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Doel <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220746934">(Dec 22 2020 at 23:36)</a>:</h4>
<p>Like, you mentioned JavaScript, but that is in some ways less well structured than even untyped lambda calculus.</p>



<a name="220747402"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory/topic/generating%20type%20theories/near/220747402" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christian Williams <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory/topic/generating.20type.20theories.html#220747402">(Dec 22 2020 at 23:43)</a>:</h4>
<p>Yes, those are good examples. I think there is a certain reasonable class of "correctness checking" that would not be overly complicated to derive, in the right framework.</p>



<footer class="site-footer">

<hr><p>Last updated: Feb 28 2026 at 12:12 UTC</p>
This archive runs on a customization of <a href="https://github.com/zulip/zulip-archive">zulip-archive</a>
</footer>
</body>

</html>