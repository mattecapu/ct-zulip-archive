<!DOCTYPE html>
<html>
<head>
  	<meta charset="utf-8" />
  	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
  	<meta name="viewport" content="width=device-width, initial-scale=1" />
  
<link rel="stylesheet" href="https://mattecapu.github.io/ct-zulip-archive/style.css" /><title>treating implication as fundamental in linear logic · deprecated: logic · Zulip Chat Archive</title>
</head>
<body>
<header>
<a href="https://mattecapu.github.io/ct-zulip-archive" class="home-link">
        <img class="logo" src="https://zulip-avatars.s3.amazonaws.com/21317/realm/icon.png?version=3" />
        <h1>Category Theory<br/>Zulip Server<br/>Archive</h1>
        </a>
        <p>
        You're reading the public-facing archive of the <a href="https://categorytheory.zulipchat.com/">Category Theory Zulip server</a>.<br/>
        
        To join the server you need an invite. Anybody can get an invite by contacting <a href="https://matteocapucci.wordpress.com">Matteo Capucci</a> at <em>name dot surname at gmail dot com</em>.<br/>
        
        For all things related to this archive refer to the same person.
        </p>
        </header>
        <hr />
    
<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/233104-deprecated.3A-logic/index.html">deprecated: logic</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/233104-deprecated.3A-logic/topic/treating.20implication.20as.20fundamental.20in.20linear.20logic.html">treating implication as fundamental in linear logic</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com">

<a name="251181138"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/233104-deprecated%3A%20logic/topic/treating%20implication%20as%20fundamental%20in%20linear%20logic/near/251181138" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Spencer Baugh <a href="https://mattecapu.github.io/ct-zulip-archive/stream/233104-deprecated.3A-logic/topic/treating.20implication.20as.20fundamental.20in.20linear.20logic.html#251181138">(Aug 30 2021 at 04:08)</a>:</h4>
<p>So far in the presentations of linear logic that I've seen, additive and multiplicative conjunction and disjunction are treated as fundamental and implication is defined in terms of those. In particular, so far all the presentations of linear lambda calculus that I've seen have (various linear forms of) lambda as a primitive, but also have primitives for conjunction and disjunction. That's different from other lambda calculi which often prefer to use lambda as a primitive, and define conjunction and disjunction with Church encoding, rather than have data types as a distinct primitive. (e.g. System F)</p>
<p>Is it possible to have linear logic with implication as the foundation? In particular, is it possible to have a linear lambda calculus where the conjunction and disjunction forms are not primitve, but are recreated with (various linear forms of) lambda terms? What would that look like? (it seems easy and standard for multiplicative conjunction and additive disjunction - it's just Church encoding - but I have no idea if it can be done for additive conjunction and multiplicative disjunction)</p>



<a name="251194464"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/233104-deprecated%3A%20logic/topic/treating%20implication%20as%20fundamental%20in%20linear%20logic/near/251194464" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Damiano Mazza <a href="https://mattecapu.github.io/ct-zulip-archive/stream/233104-deprecated.3A-logic/topic/treating.20implication.20as.20fundamental.20in.20linear.20logic.html#251194464">(Aug 30 2021 at 07:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="436298">Spencer Baugh</span> <a href="#narrow/stream/233104-theory.3A-logic/topic/treating.20implication.20as.20fundamental.20in.20linear.20logic/near/251181138">said</a>:</p>
<blockquote>
<p>That's different from other lambda calculi which often prefer to use lambda as a primitive, and define conjunction and disjunction with Church encoding, rather than have data types as a distinct primitive. (e.g. System F)</p>
</blockquote>
<p>Actually, as far as I know, even in intuitionistic logic conjunction and disjunction cannot be fully defined in terms of implication alone, you need second order quantification.  That is, System F (or calculi with higher order quantification) is the only example of "other lambda calculi" you mention.  For example, in the simply-typed <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">λ</span></span></span></span>-calculus, there's no way of defining <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\times B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> in terms of the arrow alone so that, say, the first projection gets type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A\times B\to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>.</p>
<p>That being said, something similar holds in linear logic: multiplicative conjunction and second order existential quantification are definable in terms of linear implication and second order universal quantification (the definitions are essentially identical to the standard ones of intuitionistic logic, you just trade intuitionistic implication for linear implication):<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>B</mi><mtext> </mtext><mo>:</mo><mo>=</mo><mtext> </mtext><mi mathvariant="normal">∀</mi><mi>X</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>A</mi><mo>⊸</mo><mi>B</mi><mo>⊸</mo><mi>X</mi><mo stretchy="false">)</mo><mo>⊸</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A\otimes B\ :=\ \forall X.(A\multimap B\multimap X)\multimap  X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">.</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mtext> </mtext><mo>:</mo><mo>=</mo><mtext> </mtext><mi mathvariant="normal">∀</mi><mi>X</mi><mi mathvariant="normal">.</mi><mi>X</mi><mo>⊸</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">1\ :=\ \forall X.X\multimap X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>X</mi><mi mathvariant="normal">.</mi><mi>A</mi><mtext> </mtext><mo>:</mo><mo>=</mo><mtext> </mtext><mi mathvariant="normal">∀</mi><mi>Y</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∀</mi><mi>X</mi><mi mathvariant="normal">.</mi><mi>A</mi><mo>⊸</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>⊸</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">\exists X.A\ :=\ \forall Y.(\forall X.A\multimap Y)\multimap Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∃</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">.</span><span class="mord mathnormal">A</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">.</span><span class="mopen">(</span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">.</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span></p>
<p>Then, in order to define additive conjunction and additive disjunction, you need the exponential modality (which, of course, is not itself definable):<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo mathvariant="normal">&amp;</mo><mi>B</mi><mtext> </mtext><mo>:</mo><mo>=</mo><mtext> </mtext><mi mathvariant="normal">∃</mi><mi>X</mi><mi mathvariant="normal">.</mi><mo><mo stretchy="false">!</mo></mo><mo stretchy="false">(</mo><mi>X</mi><mo>⊸</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⊗</mo><mo><mo stretchy="false">!</mo></mo><mo stretchy="false">(</mo><mi>X</mi><mo>⊸</mo><mi>B</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \mathrel{\&amp;} B\ :=\ \exists X.\mathop !(X\multimap A)\otimes\mathop !(X\multimap B)\otimes X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord">&amp;</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∃</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop" style="position:relative;top:0.09721999999999997em;">!</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop" style="position:relative;top:0.09721999999999997em;">!</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊤</mi><mtext> </mtext><mo>:</mo><mo>=</mo><mtext> </mtext><mi mathvariant="normal">∃</mi><mi>X</mi><mi mathvariant="normal">.</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\top\ :=\ \exists X.X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊤</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∃</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊕</mo><mi>B</mi><mtext> </mtext><mo>:</mo><mo>=</mo><mtext> </mtext><mi mathvariant="normal">∀</mi><mi>X</mi><mi mathvariant="normal">.</mi><mo><mo stretchy="false">!</mo></mo><mo stretchy="false">(</mo><mi>A</mi><mo>⊸</mo><mi>X</mi><mo stretchy="false">)</mo><mo>⊸</mo><mo><mo stretchy="false">!</mo></mo><mo stretchy="false">(</mo><mi>B</mi><mo>⊸</mo><mi>X</mi><mo stretchy="false">)</mo><mo>⊸</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A\oplus B\ :=\ \forall X.\mathop !(A\multimap X)\multimap\mathop !(B\multimap X)\multimap X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop" style="position:relative;top:0.09721999999999997em;">!</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop" style="position:relative;top:0.09721999999999997em;">!</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mtext> </mtext><mo>:</mo><mo>=</mo><mtext> </mtext><mi mathvariant="normal">∀</mi><mi>X</mi><mi mathvariant="normal">.</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">0\ :=\ \forall X.X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span></p>
<p>Defining multiplicative disjunction in terms of linear implication is either trivial in the classical case (they are the same connective up to a negation), or does not make sense in the intuitionistic case (the par connective needs more than one formula on the right hand side of sequents to be meaningful).</p>



<a name="251227090"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/233104-deprecated%3A%20logic/topic/treating%20implication%20as%20fundamental%20in%20linear%20logic/near/251227090" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/233104-deprecated.3A-logic/topic/treating.20implication.20as.20fundamental.20in.20linear.20logic.html#251227090">(Aug 30 2021 at 13:15)</a>:</h4>
<p>Of course, in the classical case you can also define multiplicative conjunction from implication and negation:<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>B</mi><mo><mi mathvariant="normal">≔</mi></mo><mo stretchy="false">(</mo><mi>A</mi><mo>⊸</mo><msup><mi>B</mi><mo>⊥</mo></msup><msup><mo stretchy="false">)</mo><mo>⊥</mo></msup></mrow><annotation encoding="application/x-tex">A\otimes B \coloneqq (A \multimap B^\perp)^\perp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mop" style="position:relative;top:-0.03472em;">:</span></span><span class="mrel"><span class="mspace" style="margin-right:-0.06666666666666667em;"></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mrel mtight">⊥</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mrel mtight">⊥</span></span></span></span></span></span></span></span></span></span></span>.</p>



<a name="251245910"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/233104-deprecated%3A%20logic/topic/treating%20implication%20as%20fundamental%20in%20linear%20logic/near/251245910" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Valeria de Paiva <a href="https://mattecapu.github.io/ct-zulip-archive/stream/233104-deprecated.3A-logic/topic/treating.20implication.20as.20fundamental.20in.20linear.20logic.html#251245910">(Aug 30 2021 at 15:22)</a>:</h4>
<p>But NO! in Intuitionistic Logic conjunction, disjunction and implication are ALL independent connectives. In classical logic yes, you can define everything in terms of implication, but not in intuitionistic logic. so  if you have propositional quantification as in system F then the Russell-Prawitz translation works, but not with simple types. </p>
<p>and yes you can have a linear logic formulation that thinks of lambda as the main operation in FILL [Full Intuitionistic Linear Logic] (<a href="http://tinyurl.com/59bpj5ec">tinyurl.com/59bpj5ec</a>)</p>



<a name="251246455"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/233104-deprecated%3A%20logic/topic/treating%20implication%20as%20fundamental%20in%20linear%20logic/near/251246455" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Valeria de Paiva <a href="https://mattecapu.github.io/ct-zulip-archive/stream/233104-deprecated.3A-logic/topic/treating.20implication.20as.20fundamental.20in.20linear.20logic.html#251246455">(Aug 30 2021 at 15:26)</a>:</h4>
<blockquote>
<p>(the par connective needs more than one formula on the right hand side of sequents to be meaningful).</p>
</blockquote>
<p>is not true.  You can have multiple conclusion intuitionistic logic (FIL)  and multiple conclusion intuitionistic linear logic!</p>



<a name="251260993"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/233104-deprecated%3A%20logic/topic/treating%20implication%20as%20fundamental%20in%20linear%20logic/near/251260993" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Damiano Mazza <a href="https://mattecapu.github.io/ct-zulip-archive/stream/233104-deprecated.3A-logic/topic/treating.20implication.20as.20fundamental.20in.20linear.20logic.html#251260993">(Aug 30 2021 at 17:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="276656">Valeria de Paiva</span> <a href="#narrow/stream/233104-theory.3A-logic/topic/treating.20implication.20as.20fundamental.20in.20linear.20logic/near/251246455">said</a>:</p>
<blockquote>
<p>You can have multiple conclusion intuitionistic logic (FIL)  and multiple conclusion intuitionistic linear logic!</p>
</blockquote>
<p>Ha, that's something completely new to me!  Thank you.  The question then would be whether there is a second order definition of the par connective in FILL using only linear implication...</p>



<a name="251278015"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/233104-deprecated%3A%20logic/topic/treating%20implication%20as%20fundamental%20in%20linear%20logic/near/251278015" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Spencer Baugh <a href="https://mattecapu.github.io/ct-zulip-archive/stream/233104-deprecated.3A-logic/topic/treating.20implication.20as.20fundamental.20in.20linear.20logic.html#251278015">(Aug 30 2021 at 19:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="276839">Damiano Mazza</span> <a href="#narrow/stream/233104-theory.3A-logic/topic/treating.20implication.20as.20fundamental.20in.20linear.20logic/near/251194464">said</a>:</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo mathvariant="normal">&amp;</mo><mi>B</mi><mtext> </mtext><mo>:</mo><mo>=</mo><mtext> </mtext><mi mathvariant="normal">∃</mi><mi>X</mi><mi mathvariant="normal">.</mi><mo><mo stretchy="false">!</mo></mo><mo stretchy="false">(</mo><mi>X</mi><mo>⊸</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⊗</mo><mo><mo stretchy="false">!</mo></mo><mo stretchy="false">(</mo><mi>X</mi><mo>⊸</mo><mi>B</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \mathrel{\&amp;} B\ :=\ \exists X.\mathop !(X\multimap A)\otimes\mathop !(X\multimap B)\otimes X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord">&amp;</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∃</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop" style="position:relative;top:0.09721999999999997em;">!</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop" style="position:relative;top:0.09721999999999997em;">!</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span></p>
</blockquote>
<p>Ah, thanks! That's what I was looking for, that makes sense! Thanks all for all the other comments as well.</p>
<p>(Ultimately the reason I wanted to know this is because my programmer brain is reliant on understanding logic through computation, so an encoding of linear logic into some lambda calculus helps me understand. And, indeed, this makes alternative conjunction much clearer to me, since now I can see how you'd write a lambda calculus term for it!)</p>



<a name="251408289"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/233104-deprecated%3A%20logic/topic/treating%20implication%20as%20fundamental%20in%20linear%20logic/near/251408289" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> James Wood <a href="https://mattecapu.github.io/ct-zulip-archive/stream/233104-deprecated.3A-logic/topic/treating.20implication.20as.20fundamental.20in.20linear.20logic.html#251408289">(Aug 31 2021 at 15:51)</a>:</h4>
<p>It may help to notice that Church encodings (or whatever they're called these days) arise as transcriptions of pattern-matching eliminators. For example, in system F, we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>+</mo><mi>B</mi><mo><mi mathvariant="normal">≔</mi></mo><mi mathvariant="normal">∀</mi><mi>X</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>X</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>B</mi><mo>→</mo><mi>X</mi><mo stretchy="false">)</mo><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A + B \coloneqq \forall X.~(A \to X) \to (B \to X) \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mop" style="position:relative;top:-0.03472em;">:</span></span><span class="mrel"><span class="mspace" style="margin-right:-0.06666666666666667em;"></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">.</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>. When using the encoded <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>+</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A + B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, we give the result type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> of the <em>case</em> expression and the two branches/continuations for handling <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>- and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>-values. As such, it's clearer how to encode type formers with pattern-matching eliminators (called <em>positive</em> when talking about polarity, with other type formers, like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊸</mo></mrow><annotation encoding="application/x-tex">\multimap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.54986em;vertical-align:0em;"></span><span class="mrel amsrm">⊸</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">&amp;</mi></mrow><annotation encoding="application/x-tex">\&amp;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">&amp;</span></span></span></span>, called <em>negative</em>).</p>
<p>By fluke, every propositional intuitionistic type former we care about other than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> is equivalent to a positive type former, so just functions are good enough to make encodings (in particular, positive and negative products are equivalent thanks to arbitrary deletion and duplication). An alternative approach in a linear setting would be to afford yourself all of the standard negative type formers, and encode the positive ones. This gives encodings like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊕</mo><mi>B</mi><mo><mi mathvariant="normal">≔</mi></mo><mi mathvariant="normal">∀</mi><mi>X</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>A</mi><mo>⊸</mo><mi>X</mi><mo stretchy="false">)</mo><mtext> </mtext><mi mathvariant="normal">&amp;</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>B</mi><mo>⊸</mo><mi>X</mi><mo stretchy="false">)</mo><mo>⊸</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \oplus B \coloneqq \forall X.~(A \multimap X)\ \&amp;\ (B \multimap X) \multimap X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mop" style="position:relative;top:-0.03472em;">:</span></span><span class="mrel"><span class="mspace" style="margin-right:-0.06666666666666667em;"></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">.</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord">&amp;</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>, which are a tighter fit to the usual eliminators and avoid <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mclose">!</span></span></span></span>.</p>



<a name="251411846"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/233104-deprecated%3A%20logic/topic/treating%20implication%20as%20fundamental%20in%20linear%20logic/near/251411846" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Valeria de Paiva <a href="https://mattecapu.github.io/ct-zulip-archive/stream/233104-deprecated.3A-logic/topic/treating.20implication.20as.20fundamental.20in.20linear.20logic.html#251411846">(Aug 31 2021 at 16:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281583">James Wood</span> <a href="#narrow/stream/233104-theory.3A-logic/topic/treating.20implication.20as.20fundamental.20in.20linear.20logic/near/251408289">said</a>:</p>
<blockquote>
<p>It may help to notice that Church encodings (or whatever they're called these days) </p>
</blockquote>
<p>I learned about the encodings in Peter Aczel's "The Russell-Prawitz Modality" 1999 (<a href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=9FA745910624425FE262012EE70607FD?doi=10.1.1.39.5294&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=9FA745910624425FE262012EE70607FD?doi=10.1.1.39.5294&amp;rep=rep1&amp;type=pdf</a>) so maybe my notation is outdated. just pointing it out to make sure we're talking about the same encodings.</p>



<footer class="site-footer">

<hr><p>Last updated: Nov 01 2025 at 12:09 UTC</p>
This archive runs on a customization of <a href="https://github.com/zulip/zulip-archive">zulip-archive</a>
</footer>
</body>

</html>