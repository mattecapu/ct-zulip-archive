<!DOCTYPE html>
<html>
<head>
  	<meta charset="utf-8" />
  	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
  	<meta name="viewport" content="width=device-width, initial-scale=1" />
  
<link rel="stylesheet" href="https://mattecapu.github.io/ct-zulip-archive/style.css" /><title>K and UIP · theory: type theory &amp; logic · Zulip Chat Archive</title>
</head>
<body>
<header>
<a href="https://mattecapu.github.io/ct-zulip-archive" class="home-link">
        <img class="logo" src="https://zulip-avatars.s3.amazonaws.com/21317/realm/icon.png?version=3" />
        <h1>Category Theory<br/>Zulip Server<br/>Archive</h1>
        </a>
        <p>
        You're reading the public-facing archive of the <a href="https://categorytheory.zulipchat.com/">Category Theory Zulip server</a>.<br/>
        
        To join the server you need an invite. Anybody can get an invite by contacting <a href="https://matteocapucci.wordpress.com">Matteo Capucci</a> at <em>name dot surname at gmail dot com</em>.<br/>
        
        For all things related to this archive refer to the same person.
        </p>
        </header>
        <hr />
    
<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/index.html">theory: type theory &amp; logic</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html">K and UIP</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com">

<a name="244016067"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244016067" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244016067">(Jun 26 2021 at 13:50)</a>:</h4>
<p>What's the difference and the relationship between Streicher's K und UIP?</p>



<a name="244020711"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244020711" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244020711">(Jun 26 2021 at 15:37)</a>:</h4>
<p>They are equivalent.</p>



<a name="244021499"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244021499" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> James Wood <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244021499">(Jun 26 2021 at 15:54)</a>:</h4>
<p>K is a rule, whereas UIP is a theorem. If you're talking about the formal theory or implementation or something, you tend to talk about the K rule, whereas if you're talking about the emergent mathematics or a temporary assumption, you tend to talk about UIP.</p>



<a name="244028246"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244028246" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244028246">(Jun 26 2021 at 18:33)</a>:</h4>
<p>Well, both of then can be asserted internally as axioms too.  But it's true that K can be given a computational interpretation and UIP can't.</p>



<a name="244072391"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244072391" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Xuanrui Qi <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244072391">(Jun 27 2021 at 15:46)</a>:</h4>
<p>The computational interpretation of K is just dependent pattern matching, right?</p>



<a name="244084969"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244084969" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244084969">(Jun 27 2021 at 21:07)</a>:</h4>
<p>Basically.</p>



<a name="244177827"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244177827" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244177827">(Jun 28 2021 at 17:23)</a>:</h4>
<p>Thanks. How can it be the case that K computes while UIP doesn't if they are both equivalent? In what sense are they equivalent?</p>



<a name="244180308"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244180308" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244180308">(Jun 28 2021 at 17:42)</a>:</h4>
<p>They're equivalent in the sense that when stated as axioms, either one can be proven from the other.  But one can state a computation rule for the K axiom that is well-behaved (normalizing), whereas this doesn't seem possible for UIP.</p>



<a name="244180602"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244180602" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jon Sterling <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244180602">(Jun 28 2021 at 17:44)</a>:</h4>
<p>Am I confused, or is this a distinction without a difference? Once I've got a computation rule for the K axiom, then I can define a computation rule for the UIP axiom (have the postulated axiom compute to the now-definable element <code>P : UIP</code>, defined by dependent pattern matching or whatever). This is a definitional extension of the calculus with K, so normalization is preserved.</p>



<a name="244180668"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244180668" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244180668">(Jun 28 2021 at 17:44)</a>:</h4>
<p>Hang on a minute. This will take me a few minutes to do properly. It took me a few years, back in the nineties.</p>



<a name="244181374"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244181374" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244181374">(Jun 28 2021 at 17:50)</a>:</h4>
<p><span class="user-mention" data-user-id="297784">@Jonathan Sterling</span> Can you give a normalizing type theory in which K is defined in terms of UIP rather than vice versa?</p>



<a name="244181454"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244181454" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244181454">(Jun 28 2021 at 17:51)</a>:</h4>
<p>First instalment:</p>
<div class="codehilite"><pre><span></span><code>data I (X : Set)(x : X) : X -&gt; Set where
  refl : I X x x

J : (X : Set)(x y : X)(q : I X x y) -&gt;
    (P : (y : X)(q : I X x y) -&gt; Set) -&gt;
    P x refl -&gt;
    P y q
J X x .x refl P p = p

K : (X : Set)(x : X)(q : I X x x) -&gt;
    (P : (q : I X x x) -&gt; Set) -&gt;
    P refl -&gt;
    P q
K X x refl P p = p

UIP : (X : Set)(x y : X)(q r : I X x y) -&gt; I (I X x y) q r
UIP X x .x refl refl = refl
</code></pre></div>
<p>Here is the identity type, together with J, K and UIP all defined by <em>dependent pattern matching</em>.</p>



<a name="244181469"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244181469" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jon Sterling <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244181469">(Jun 28 2021 at 17:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="276777">Mike Shulman</span> <a href="#narrow/stream/229952-theory.3A-type.20theory/topic/K.20and.20UIP/near/244181374">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="297784">Jonathan Sterling</span> Can you give a normalizing type theory in which K is defined in terms of UIP rather than vice versa?</p>
</blockquote>
<p>I feel the question is really not so well-defined, but perhaps I am misunderstanding it. I think that "rather than" is doing a lot of work in this sentence ;-)</p>



<a name="244181660"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244181660" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244181660">(Jun 28 2021 at 17:52)</a>:</h4>
<p><code>J</code> is exactly the standard induction principle you get for <code>I</code> by the usual scheme. (By yanking x to the left of : I get Christin Paulin's version, rather than Per's but they're equivalent.)</p>



<a name="244181796"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244181796" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244181796">(Jun 28 2021 at 17:53)</a>:</h4>
<p><span class="user-mention" data-user-id="297784">@Jonathan Sterling</span> I mean, if I first add K and UIP as non-computing axioms, and then I add a reduction rule reducing K to its definition in terms of UIP, can I add  further computation rules to make the theory normalizing?</p>



<a name="244181868"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244181868" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244181868">(Jun 28 2021 at 17:54)</a>:</h4>
<p>The main result of my thesis is that anything you can define by dependent pattern matching, you can just as well obtain from induction principles plus K (with its reduction rule as given).</p>



<a name="244182014"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244182014" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jon Sterling <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244182014">(Jun 28 2021 at 17:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="276777">Mike Shulman</span> <a href="#narrow/stream/229952-theory.3A-type.20theory/topic/K.20and.20UIP/near/244181796">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="297784">Jonathan Sterling</span> I mean, if I first add K and UIP as non-computing axioms, and then I add a reduction rule reducing K to its definition in terms of UIP, can I add  further computation rules to make the theory normalizing?</p>
</blockquote>
<p>Thanks for clarifying that.</p>



<a name="244182278"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244182278" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jon Sterling <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244182278">(Jun 28 2021 at 17:57)</a>:</h4>
<p>I think a valid solution to your question is to just add the additional computation rules that reduce both K and UIP! Obviously there is something to be worked out here in terms of coherence, but I hope you see why I think there isn't really any difference here.</p>



<a name="244183518"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244183518" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244183518">(Jun 28 2021 at 18:06)</a>:</h4>
<p>If you reduce K to UIP and also UIP to K, isn't there a circularity problem?  Or are you saying to give UIP only the reduction rule that it <em>would</em> have if defined in terms of K without actually defining it that way?  (I'm not sure offhand what that rule is.)  It seems a little weird to give K two different reduction rules.</p>



<a name="244183970"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244183970" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jon Sterling <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244183970">(Jun 28 2021 at 18:10)</a>:</h4>
<p>Well, we can give a term as many reduction rules as we want... We may run into problems with confluence, but (1) often you can just keep adding rules until it converges, and (2) even lack of confluence does not prevent a computational interpretation that is sound and complete for judgmental equality.</p>



<a name="244184140"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244184140" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jon Sterling <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244184140">(Jun 28 2021 at 18:11)</a>:</h4>
<p>My point here is not to make too precise of technical claims (because I don't have time to check them), but to say that questions like "is there a computational interpretation of Axiom X when there is a computational interpretation of Axiom Y, which is equivalent to X" are very subtle and I have found that the best way to deal with such questions is to explain them away (in a way that respects the principle of equivalence) rather than try to answer them.</p>



<a name="244184209"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244184209" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244184209">(Jun 28 2021 at 18:11)</a>:</h4>
<p>Well, maybe there's no formal way to distinguish them, but informally it still feels to me like your "computation rule" for UIP is fundamentally parasitic on K, so that K is the one that "really" has a computational interpretation.</p>



<a name="244184335"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244184335" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244184335">(Jun 28 2021 at 18:12)</a>:</h4>
<p>Now, here is UIP defined not by pattern matching but from J and K:</p>
<div class="codehilite"><pre><span></span><code>UIP&#39; : (X : Set)(x y : X)(q r : I X x y) -&gt; I (I X x y) q r
UIP&#39; X x y q r =
  J X x y q (\ y q -&gt; (r : I X x y) -&gt; I (I X x y) q r)
    (\ r -&gt; K X x r (\ r -&gt; I (I X x x) refl r)
      (refl {- : I (I X x x) refl refl -})
     {- : (r : I X x x) -&gt; I (I X x x) refl r -})
  r
</code></pre></div>
<p>We can check that UIP's pattern matching equation holds <em>definitionally</em> by observing that refl suffices to prove it.</p>
<div class="codehilite"><pre><span></span><code>UIP&#39;q : (X : Set)(x : X) -&gt;
  I (I (I X x x) refl refl) (UIP&#39; X x x refl refl) refl
UIP&#39;q X x = refl
</code></pre></div>
<p>Meanwhile, we can derive K from UIP</p>
<div class="codehilite"><pre><span></span><code>K&#39; : (X : Set)(x : X)(q : I X x x) -&gt;
     (P : (q : I X x x) -&gt; Set) -&gt;
     P refl -&gt;
     P q
K&#39; X x q P p = J (I X x x) refl q (UIP X x x refl q) (\ y _ -&gt; P y) p
</code></pre></div>
<p>and moreover, if UIP's pattern matching behaviour holds intensionally, then so does K's:</p>
<div class="codehilite"><pre><span></span><code>K&#39;q : (X : Set)(x : X)(q : I X x x) -&gt;
    (P : (q : I X x x) -&gt; Set) -&gt;
    (p : P refl) -&gt;
  I (P refl) (K&#39; X x refl P p) p
K&#39;q X x q P p = refl
</code></pre></div>
<p>The point is that K is a really strong statement about circular paths (corresponding to pattern matching's intuition about covering the constructors), while J is a statement about path-to-somewhere pairs.</p>



<a name="244185037"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244185037" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244185037">(Jun 28 2021 at 18:17)</a>:</h4>
<p><span class="user-mention" data-user-id="277574">@Conor McBride</span> Ah, now I think I see what you're saying: since UIP can also be defined by dependent pattern-matching, it gets a reduction rule from that which is equally computational, and its equivalence to K preserves those computation rules.  So I was wrong -- they're both equally <em>instances</em> of dependent pattern matching (in "with-K" style) and hence equally computational.  Right?</p>



<a name="244185094"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244185094" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244185094">(Jun 28 2021 at 18:17)</a>:</h4>
<p>Right.</p>



<a name="244185564"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244185564" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244185564">(Jun 28 2021 at 18:21)</a>:</h4>
<p>Moreover, they're complete. Either gives you enough to do anything you can do with dependent pattern matching.</p>



<a name="244186077"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244186077" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244186077">(Jun 28 2021 at 18:25)</a>:</h4>
<p>Is there a sense in which the axiom K without its computation rule (that is, UIP) is equivalent to "K + its computation rule"? One cannot say that both yield the same typing judgments, because equality judgments can entail typing judgments, right? (For instance, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>≡</mo><msup><mi>t</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">t\equiv t&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mspace></mspace><mspace width="0.1111111111111111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333333333333333em"/><mi>A</mi></mrow><annotation encoding="application/x-tex">t\colon A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111111111111111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathnormal">A</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>t</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mspace></mspace><mspace width="0.1111111111111111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333333333333333em"/><mi>A</mi></mrow><annotation encoding="application/x-tex">t&#x27;\colon A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111111111111111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathnormal">A</span></span></span></span>.)</p>



<a name="244187488"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244187488" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244187488">(Jun 28 2021 at 18:37)</a>:</h4>
<p>K without its computation rule allows you (especially if you happen to be Matthieu Sozeau) to implement dependent pattern matching in a way that all the pattern matching equations are <em>provable</em>, even though they do not hold judgmentally. However, to recover by proof everything which once held judgmentally requires some additional function extensionality. Nicolas Oury did the spadework on that result.</p>
<p>Observational Type Theory takes this further: you have not only provable UIP but judgmental proof irrelevance for propositions (it's aggressively anti-univalent, as it stands, but rather fun). In OTT, given an axiom K that eliminates over Set but does not compute, you could derive UIP from that K, and then K' as above from UIP...and K' jolly well would compute!</p>



<a name="244212195"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229952-theory%3A%20type%20theory%20%26%20logic/topic/K%20and%20UIP/near/244212195" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory.3A-type-theory-.26-logic/topic/K.20and.20UIP.html#244212195">(Jun 28 2021 at 22:24)</a>:</h4>
<p>Sounds interesting, thanks.</p>



<footer class="site-footer">

<hr><p>Last updated: Feb 28 2026 at 12:12 UTC</p>
This archive runs on a customization of <a href="https://github.com/zulip/zulip-archive">zulip-archive</a>
</footer>
</body>

</html>