<!DOCTYPE html>
<html>
<head>
  	<meta charset="utf-8" />
  	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
  	<meta name="viewport" content="width=device-width, initial-scale=1" />
  
<link rel="stylesheet" href="https://mattecapu.github.io/ct-zulip-archive/style.css" /><title>Conor Mc Bride · community: our work · Zulip Chat Archive</title>
</head>
<body>
<header>
<a href="https://mattecapu.github.io/ct-zulip-archive" class="home-link">
        <img class="logo" src="https://zulip-avatars.s3.amazonaws.com/21317/realm/icon.png?version=3" />
        <h1>Category Theory<br/>Zulip Server<br/>Archive</h1>
        </a>
        <p>
        You're reading the public-facing archive of the <a href="https://categorytheory.zulipchat.com/">Category Theory Zulip server</a>.<br/>
        
        To join the server you need an invite. Anybody can get an invite by contacting <a href="https://matteocapucci.wordpress.com">Matteo Capucci</a> at <em>name dot surname at gmail dot com</em>.<br/>
        
        For all things related to this archive refer to the same person.
        </p>
        </header>
        <hr />
    
<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/index.html">community: our work</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html">Conor Mc Bride</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com">

<a name="231726771"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231726771" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231726771">(Mar 24 2021 at 23:40)</a>:</h4>
<p>Which "indexed containers" are profunctors <em>by construction</em>?</p>



<a name="231727858"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231727858" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231727858">(Mar 24 2021 at 23:52)</a>:</h4>
<p>I mean, a big part of my work is (in a programming languages datatype declaration context) to notice and exploit what is already under my nose.</p>



<a name="231774634"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231774634" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Tom Hirschowitz <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231774634">(Mar 25 2021 at 10:11)</a>:</h4>
<p>I'm not sure I'm parsing the question correctly. Would you mind expanding a little?</p>



<a name="231781233"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231781233" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231781233">(Mar 25 2021 at 11:05)</a>:</h4>
<p>I don't mind mind expanding. My motivation comes from dependently typed programming, where our notion of "inductive datatype" amounts to "proof-relevant relation", i.e. data consistent with some explicit indexing discipline (e.g. terms which are well typed and in scope by construction). These data structures are fixpoints of polynomial functors, but not in an exciting enough way, to my taste. In particular, the types used as indices often have categorical structure giving rise to actions on the indexed data (e.g., scopes form a category with embeddings as morphisms, in a way which well scoped terms respect).</p>
<p>That's to say, these indexed data structures very often are intended by their designers to have nontrivial presheaf/profunctor structure, but the current technology allows that intent to be communicated laboriously, after the fact. I write my datatype of terms as if scopes have no structure; I implement the action of scope embedding on terms; I prove that it respects identity and composition; I die of boredom. I despair of pointing out that structure happens to arise as some sort of outrageous coincidence, when in fact I put it there deliberately but couldn't say so.</p>
<p>Our starting point is polynomial functors on Set. The data are given by diagrams O &lt;- S &lt;- P -&gt; I, giving rise to functors between slices, Set/I -&gt; Set/O. Very often, we take O to be I, and then take the initial algebra, giving us an indexed inductive family of sets, in Set/I, or Set^I if you like. That's a good start, but it's not alert to structure other than equality in I. If my indices have interesting categorical structure, I want to get my hands on nontrivial functors from curly I to Set, and I'm wondering how to refine the notion of the underlying polynomial functors to get that structure for the asking.</p>



<a name="231788879"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231788879" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacques Carette <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231788879">(Mar 25 2021 at 12:08)</a>:</h4>
<p>Two (very obvious) comments:</p>
<ol>
<li>if your <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> has structure, and you don't ask that that structure already be present in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> and preserved, then you're going to have to reconstruct all of that tediously. Same for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span>.</li>
<li>Just like with identity-on-objects functors, which were discussed recently on the Category Zulip, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>=</mo><mi>O</mi></mrow><annotation encoding="application/x-tex">I = O</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span> is not some kind of post facto thing you discover. By then it's too late, and life is tedious. [Same thing arises  when dealing with 2 monoid structures on the same carrier set; one way to say this brings much pain, and the other no pain. Just because we now have equalities that compute doesn't mean that that's the pleasant way to do things when you can avoid all of it altogether.]</li>
</ol>
<p>I think the problem lies in the starting point: it's like starting with block-of-words as your building pieces. Way better than bits, that's for sure, but still way too unstructured. [Which is probably exactly what you're saying in your last line!]</p>
<p>If I were to attack this, I'd figure out all the nice properties I want in my functors <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">e</mi><mi mathvariant="sans-serif">t</mi></mrow><mi mathvariant="normal">/</mi><mi>I</mi><mo>→</mo><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">e</mi><mi mathvariant="sans-serif">t</mi></mrow><mi mathvariant="normal">/</mi><mi>O</mi></mrow><annotation encoding="application/x-tex">\mathsf{Set}/I \rightarrow \mathsf{Set}/O</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">e</span><span class="mord mathsf">t</span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">e</span><span class="mord mathsf">t</span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span>, <strong>then</strong> figure out what diagrams give rise to those functors. Maybe it won't be <em>quite</em> polynomials that you'll end up with.</p>



<a name="231801774"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231801774" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> James Wood <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231801774">(Mar 25 2021 at 13:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="296322">Jacques Carette</span> <a href="#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/231788879">said</a>:</p>
<blockquote>
<p>Same thing arises  when dealing with 2 monoid structures on the same carrier set</p>
</blockquote>
<p>I suppose there must also be something like this for models of bunched implications, right?</p>



<a name="231804477"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231804477" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Tom Hirschowitz <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231804477">(Mar 25 2021 at 13:57)</a>:</h4>
<p>Taking the untyped <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">λ</span></span></span></span>-calculus as an example, we may construct it  following the Fiore-Plotkin-Turi yoga,  using the endofunctor on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>𝔽</mi><mo separator="true">,</mo><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[𝔽,𝐒𝐞𝐭]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathbb">F</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathbf">S</span><span class="mord mathbf">e</span><span class="mord mathbf">t</span><span class="mclose">]</span></span></span></span> defined by</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Σ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>X</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mtext>²</mtext><mo>+</mo><mi>X</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\Sigma(X)(n) = X(n)² + X(n+1).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord">²</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p>
<p>This functor is polynomial in the general sense of familial, hence, I think, so is the free monad on it, say <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐓</mi></mrow><annotation encoding="application/x-tex">𝐓</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord mathbf">T</span></span></span></span>, and the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">λ</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">λ</span></span></span></span>-calculus is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐓</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝐓(I)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbf">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">I(n) := n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>. </p>
<p>Thinking of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">λ</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">λ</span></span></span></span>-terms as proofs in natural deduction (for very basic sequents, of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>⊢</mo></mrow><annotation encoding="application/x-tex">n ⊢</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span></span></span></span>), one may think of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐓</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝐓(X)(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbf">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> as partial proofs with axioms in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>.</p>
<p>Does functoriality in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> satisfy your needs, or do you want more?</p>



<a name="231812694"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231812694" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231812694">(Mar 25 2021 at 14:41)</a>:</h4>
<p>Thanks! This is a good start, but I'm hoping for more. For this example, I'd be trying to get my hands on a functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi mathvariant="normal">Δ</mi><mo>+</mo></msub><mo separator="true">,</mo><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\Delta_+,\mathbf{Set}]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbf">S</span><span class="mord mathbf">e</span><span class="mord mathbf">t</span></span><span class="mclose">]</span></span></span></span>, (where by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mo>+</mo></msub></mrow><annotation encoding="application/x-tex">\Delta_+</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> I mean the category of order-preserving injections on finite sets), so that I can shift terms to anywhere that their support is in scope. Crucially, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋅</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\cdot + 1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> is still a <em>functor</em> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mo>+</mo></msub></mrow><annotation encoding="application/x-tex">\Delta_+</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>. And it's that sort of functoriality requirement that I'm interested in bottling, <em>in general</em>.</p>
<p>That is, where in polynomials on sets, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>←</mo><mi>S</mi><mo>←</mo><mi>P</mi><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">O \leftarrow S \leftarrow P \rightarrow I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> we have functions, we now need a richer functoriality, but I'm struggling (productively) to put my finger on precisely what.</p>
<p>There are lots of situations like this (type preservation explanations spring to mind) where we currently prove things but could potentially just enjoy their truth, if only we knew how to be more deliberately structure-respecting.</p>



<a name="231815127"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231815127" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231815127">(Mar 25 2021 at 14:53)</a>:</h4>
<p>I clearly need to read the markdown instructions more carefully. Sorry.</p>



<a name="231825290"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231825290" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacques Carette <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231825290">(Mar 25 2021 at 15:44)</a>:</h4>
<p>You need two dollars for LaTeX. You are able to edit your posts too.</p>



<a name="231825890"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231825890" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacques Carette <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231825890">(Mar 25 2021 at 15:47)</a>:</h4>
<p><span class="user-mention" data-user-id="281583">@James Wood</span> I was alluding to the bundling/unbundling "problem", that is common to any kind of structure where you may want to expose certain fields as fixed on the interface, some of the time but not all the time.</p>



<a name="231827558"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231827558" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacques Carette <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231827558">(Mar 25 2021 at 15:57)</a>:</h4>
<p>Reminder to <span class="user-mention" data-user-id="277574">@Conor McBride</span> that those are exactly Joyal's <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">L</mi></mrow><annotation encoding="application/x-tex">\mathbb{L}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">L</span></span></span></span></span>-species, covered quite well in chapter 5 of the Bergeron, Labelle, Leroux textbook. It's no wonder you seek these, as they have all sorts of beautiful properties.</p>



<a name="231827683"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231827683" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231827683">(Mar 25 2021 at 15:57)</a>:</h4>
<p>Thanks!</p>



<a name="231830945"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231830945" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Tom Hirschowitz <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231830945">(Mar 25 2021 at 16:17)</a>:</h4>
<p>But can't you do that in the Fiore-Plotkin-Turi setting? Functoriality in yields in particular <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐓</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>→</mo><mi>𝐓</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝐓(I)(n) → 𝐓(I)(n+1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbf">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbf">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, doesn't it? I'm probably misunderstanding your post, sorry!</p>



<a name="231837319"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231837319" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Cody Roux <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231837319">(Mar 25 2021 at 16:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="277574">Conor McBride</span> <a href="#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/231781233">said</a>:</p>
<blockquote>
<p>Our starting point is polynomial functors on Set. The data are given by diagrams O &lt;- S &lt;- P -&gt; I, giving rise to functors between slices, Set/I -&gt; Set/O. </p>
</blockquote>
<p>I feel stupid, but can anyone explain the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>←</mo><mi>S</mi><mo>←</mo><mi>P</mi><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">O\leftarrow S\leftarrow P\rightarrow I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> yoga to me?</p>



<a name="231838754"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231838754" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Spencer Breiner <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231838754">(Mar 25 2021 at 17:03)</a>:</h4>
<p>Hi Cody! Start with a bundle <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">X\to I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> on the right. First pull back, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∏</mo></mrow><annotation encoding="application/x-tex">\prod</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span></span></span></span>, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>. That gives you a new bundle over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span>. That's a sum of products, hence "polynomial".</p>



<a name="231838944"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231838944" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Spencer Breiner <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231838944">(Mar 25 2021 at 17:04)</a>:</h4>
<p>Sorry, I think that's backwards. Start with the bundle over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>.</p>



<a name="231839127"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231839127" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Spencer Breiner <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231839127">(Mar 25 2021 at 17:05)</a>:</h4>
<p>Fixed</p>



<a name="231845474"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231845474" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Valeria de Paiva <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231845474">(Mar 25 2021 at 17:44)</a>:</h4>
<p>Thanks for expanding, I  have not read about containers (indexed, higher-order or any kind really) to make sensible observations. But I like the motivation and would like to understand it better. you say:</p>
<blockquote>
<p>My motivation comes from dependently typed programming, where our notion of "inductive datatype" amounts to "proof-relevant relation", i.e. data consistent with some explicit indexing discipline (e.g. terms which are well typed and in scope by construction).</p>
</blockquote>
<p>ok, this (proof-relevant relations)  explains why  profunctors.</p>
<blockquote>
<p>These data structures are fixpoints of polynomial functors, but not in an exciting enough way, to my taste.</p>
</blockquote>
<p>why? Being fixed points of a polynomial functor is good. and being so  in a non-exciting way is also good, you're just setting up the scene, saying what's need, for whatever happens later.  so, I don't understand</p>
<blockquote>
<p>I despair of pointing out that structure happens to arise as some sort of outrageous coincidence, when in fact I put it there deliberately but couldn't say so.</p>
</blockquote>
<p>but I guess I should go try to read the papers instead of simply going why, why, why like a broken record</p>



<a name="231850794"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231850794" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Cody Roux <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231850794">(Mar 25 2021 at 18:16)</a>:</h4>
<p>Oh I think I get it. Thanks <span class="user-mention" data-user-id="278008">@Spencer Breiner</span> ! After all this time, I still find it hard to stare at diagrams instead of typing rules.</p>



<a name="231851011"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231851011" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Cody Roux <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231851011">(Mar 25 2021 at 18:17)</a>:</h4>
<p><span class="user-mention" data-user-id="276656">@Valeria de Paiva</span> <span class="user-mention" data-user-id="277574">@Conor McBride</span>  I think an example of what the "extra work" is needed to be done might be revealing as well. Do you happen to have an Agda gist handy?</p>



<a name="231853209"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231853209" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231853209">(Mar 25 2021 at 18:32)</a>:</h4>
<p>I expect I could scrape something together. Watch this space.</p>
<p>When you live in type theory, you can turn lots of these arrows around and work dependently. Output sorts <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>:</mo><mtext mathvariant="bold">Set</mtext></mrow><annotation encoding="application/x-tex">O : \textbf{Set}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord text"><span class="mord textbf">Set</span></span></span></span></span>, shapes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>:</mo><mi>O</mi><mo>→</mo><mtext mathvariant="bold">Set</mtext></mrow><annotation encoding="application/x-tex">S : O \rightarrow \textbf{Set}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord text"><span class="mord textbf">Set</span></span></span></span></span> depend on what sort of container you're trying to build. Positions <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>:</mo><mo stretchy="false">(</mo><mi>o</mi><mo>:</mo><mi>O</mi><mo stretchy="false">)</mo><mo>→</mo><mi>S</mi><mtext> </mtext><mi>o</mi><mo>→</mo><mtext mathvariant="bold">Set</mtext></mrow><annotation encoding="application/x-tex">P : (o : O)\rightarrow S\:o \rightarrow \textbf{Set}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord text"><span class="mord textbf">Set</span></span></span></span></span> say where you can put the stuff in the shape. And then you request <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>:</mo><mo stretchy="false">(</mo><mi>o</mi><mo>:</mo><mi>O</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>s</mi><mo>:</mo><mi>S</mi><mtext> </mtext><mi>O</mi><mo stretchy="false">)</mo><mo>→</mo><mi>P</mi><mtext> </mtext><mi>o</mi><mtext> </mtext><mi>s</mi><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">r : (o : O)\rightarrow(s : S\:O)\rightarrow P\:o\:s \rightarrow I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> the input sort of the data you want in each position. The pattern of dependency reflects the flow of <em>time</em>. You end up with a functor on indexed sets in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>I</mi><mo>→</mo><mtext mathvariant="bold">Set</mtext><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>O</mi><mo>→</mo><mtext mathvariant="bold">Set</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(I\rightarrow \textbf{Set})\rightarrow(O\rightarrow \textbf{Set})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textbf">Set</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textbf">Set</span></span><span class="mclose">)</span></span></span></span> mapping <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>:</mo><mi>I</mi><mo>→</mo><mtext mathvariant="bold">Set</mtext></mrow><annotation encoding="application/x-tex">X:I\rightarrow \textbf{Set}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord text"><span class="mord textbf">Set</span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mo>:</mo><mi>O</mi></mrow><annotation encoding="application/x-tex">o : O</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo>:</mo><mi>S</mi><mtext> </mtext><mi>o</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>p</mi><mo>:</mo><mi>P</mi><mtext> </mtext><mi>o</mi><mtext> </mtext><mi>s</mi><mo stretchy="false">)</mo><mo>→</mo><mi>X</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>r</mi><mtext> </mtext><mi>o</mi><mtext> </mtext><mi>s</mi><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s : S\:o)\times(p : P\:o\:s)\rightarrow X\:(r\:o\:s\:p)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">o</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>. That is, you choose one of the shapes available at sort <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi></mrow><annotation encoding="application/x-tex">o</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">o</span></span></span></span>, then you fill up its positions with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> data of the input sorts requested.</p>
<p>What's bothering me is that the sorts <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> are here treated has having only discrete structure, but I want to build functors (then take fixpoints) between nontrivial presheaves.</p>



<a name="231866118"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231866118" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231866118">(Mar 25 2021 at 19:54)</a>:</h4>
<p><a href="https://github.com/pigworker/Samizdat/blob/master/STLCThin.agda">Here is an example in Agda</a> of the presheaf structure of simply typed lambda terms (a functor from the dual of contexts with selection).</p>
<p>It turns out that in a past life, I made some progress. <a href="https://github.com/pigworker/Samizdat/blob/master/DeFunct.agda">This rather gnarly and inscrutable lump of Agda</a> gives a syntactic presentation of <em>some</em> polynomials which are presheaves by construction. But I'm keen to get my hands on the generic presentation.</p>



<a name="231868242"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231868242" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231868242">(Mar 25 2021 at 20:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="277574">Conor McBride</span> <a href="#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/231815127">said</a>:</p>
<blockquote>
<p>I clearly need to read the markdown instructions more carefully. Sorry.</p>
</blockquote>
<p>Just replace all your $'s with double dollars.  Math is twice as expensive here.</p>



<a name="231868794"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231868794" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231868794">(Mar 25 2021 at 20:12)</a>:</h4>
<p>Looks like swearing in Asterix now.</p>



<a name="231870765"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231870765" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Cody Roux <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231870765">(Mar 25 2021 at 20:27)</a>:</h4>
<p>I hear some areas of category theory are only possible to understand with magic potions.</p>



<a name="231882129"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231882129" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacques Carette <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231882129">(Mar 25 2021 at 21:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="277574">Conor McBride</span> <a href="#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/231866118">said</a>:</p>
<blockquote>
<p><a href="https://github.com/pigworker/Samizdat/blob/master/STLCThin.agda">Here is an example in Agda</a> of the presheaf structure of simply typed lambda terms (a functor from the dual of contexts with selection).</p>
</blockquote>
<p>At the bottom of that code, you say</p>
<blockquote>
<p>But Agda doesn't let me construct <em>functors</em><br>
     (Bwd Ty, &lt;=) -&gt; (Set, -&gt;)/Ty<br>
   so I'm forced to play stupid, work in<br>
     |Bwd Ty| -&gt; (Set, -&gt;)/Ty<br>
   and then work hard to "discover" the functoriality<br>
   I already knew I wanted, in advance</p>
</blockquote>
<p>But category theory wouldn't let you do that either; more precisely, it would, but give you exactly the same as Agda.</p>
<p>Question: why are you squishing all that information down into a category? Both on the left and on the right.  This data all feels "higher dimensional" (whether it's monoidal, bicategories, double cat, whatever, I don't have the time to puzzle it out atm). And it seems that you're running into problems because you're squishing it down into something too small to make all the bits obvious.</p>



<a name="231882569"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231882569" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231882569">(Mar 25 2021 at 21:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="277574">Conor McBride</span> <a href="#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/231866118">said</a>:</p>
<blockquote>
<p><a href="https://github.com/pigworker/Samizdat/blob/master/STLCThin.agda">Here is an example in Agda</a> of the presheaf structure of simply typed lambda terms (a functor from the dual of contexts with selection).</p>
<p>It turns out that in a past life, I made some progress. <a href="https://github.com/pigworker/Samizdat/blob/master/DeFunct.agda">This rather gnarly and inscrutable lump of Agda</a> gives a syntactic presentation of <em>some</em> polynomials which are presheaves by construction. But I'm keen to get my hands on the generic presentation.</p>
</blockquote>
<p>I don't suppose you could elaborate what you feel is the shortcoming of the approach <span class="user-mention" data-user-id="383799">@Tom Hirschowitz</span> described? It seems to me that this has the properties you are after.</p>



<a name="231884486"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231884486" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacques Carette <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231884486">(Mar 25 2021 at 22:13)</a>:</h4>
<p><span class="user-mention" data-user-id="276092">@Nathanael Arkor</span> I think you're using  "this has all the properties you are after" very differently from <span class="user-mention" data-user-id="277574">@Conor McBride</span> . Your notion seems to be that of "it's all obvious to a seasoned category theorist", while my understanding is that <span class="user-mention" data-user-id="277574">@Conor McBride</span> wants "it's so obvious that even an interactive theorem prover plainly sees it without needing extra proofs." Those two are radically different things!  [At least, that's my understanding...]</p>



<a name="231884811"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231884811" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231884811">(Mar 25 2021 at 22:16)</a>:</h4>
<p>Jacques is right. I want the <em>machine</em> to see this is obviously the right thing and has all these properties, without me lifting a finger beyond giving the structure of the data. Moreover, I want the machine to <em>deploy</em> all these properties, without me lifting a finger at all. And I shall make it so.</p>



<a name="231886182"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231886182" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Cody Roux <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231886182">(Mar 25 2021 at 22:28)</a>:</h4>
<p>I'm going crazy, but I remember a paper, from years ago where you could prove univalence for specific types of inductives defined using polynomial functors. I think it was Coquand?</p>
<p>For the life of me, I can't find the paper though.</p>



<a name="231886233"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231886233" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Cody Roux <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231886233">(Mar 25 2021 at 22:29)</a>:</h4>
<p>It seems to me, that one might want to apply univalence here, at least to transport isos. Not sure i'm making any sense though.</p>



<a name="231886965"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231886965" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231886965">(Mar 25 2021 at 22:35)</a>:</h4>
<p>Function extensionality is certainly indispensable in this cause. Univalence is not the only way to obtain function extensionality. But for sure, univalence would improve what's mechanically provable in this direction.</p>



<a name="231887384"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231887384" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Cody Roux <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231887384">(Mar 25 2021 at 22:39)</a>:</h4>
<p>I mean, in this case, univalence was a <em>theorem</em>: every "reasonable" datatype satisfies some form of transport.</p>



<a name="231887508"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231887508" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Cody Roux <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231887508">(Mar 25 2021 at 22:40)</a>:</h4>
<p>eh, maybe I'm mis-remembering.</p>



<a name="231887701"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231887701" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231887701">(Mar 25 2021 at 22:42)</a>:</h4>
<p>That sounds right. It's a crucial link in the story. Replace "match on refl" transport by per-type transport. I'm in the business of noticing when that's possible under weaker assumptions than on-the-nose equality.</p>



<a name="231887959"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231887959" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231887959">(Mar 25 2021 at 22:44)</a>:</h4>
<p><span class="user-mention" data-user-id="296322">@Jacques Carette</span>: ah, I see, thanks. I remember being frustrated with similar shortcomings when I was using Coq, so I would be very happy to see progress on this front too :)</p>



<a name="231887969"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231887969" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacques Carette <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231887969">(Mar 25 2021 at 22:45)</a>:</h4>
<p>You still have to careful. (Meant as a reply to <span class="user-mention" data-user-id="276030">@Cody Roux</span>)</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">data</span> <span class="kt">Thing</span> <span class="ow">=</span> <span class="kt">Boom</span> <span class="o">|</span> <span class="kt">Bam</span>
<span class="kr">data</span> <span class="kt">Other</span> <span class="ow">=</span> <span class="kt">Red</span> <span class="o">|</span> <span class="kt">Bycicle</span>
</code></pre></div>
<p>are entirely equivalent as types, and there's no good reason (in a univalent setting) to distinguish <code>Thing</code> from <code>Other</code>. But, well, there are <strong>two</strong> isomorphisms. And which you chose does matter. You have to be careful that you're not just moving the deck chairs around.</p>



<a name="231888334"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231888334" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Cody Roux <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231888334">(Mar 25 2021 at 22:48)</a>:</h4>
<p>Sure, but isn't the whole buisness of this brave new type theory to always keep the isos around?</p>



<a name="231888428"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231888428" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231888428">(Mar 25 2021 at 22:49)</a>:</h4>
<p>What's worse, there might be no reason whatsoever to consider these types <em>cognate</em>, despite the outrageous coincidence in the number of bits required to represent their values.</p>



<a name="231890012"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231890012" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231890012">(Mar 25 2021 at 23:04)</a>:</h4>
<p><span class="user-mention" data-user-id="276092">@Nathanael Arkor</span> There's so much room for improvement. In most proof assistants based on type theory, the typechecker doesn't even know that concatenation of lists is associative, so you have to prove it and point it out all the time.</p>



<a name="231892121"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231892121" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231892121">(Mar 25 2021 at 23:28)</a>:</h4>
<p>My take on being an intensional type theorist is that I structure the division of labour between people and machines. For reasons of taste, I prefer if it is easy to form simple mental models of what is "machine work" (definitely no human intervention needed) and what requires humans to deliver bits. The division of labour is expressed via the judgements: people provide terms but machines check that the terms are correctly composed up to some weak but decidable equality (that's the "disappointing accident"). The engineering of that disappointing accident is a subtle task that most mathematicians cannot be bothered with, and why should they? What's the point in worrying about the difference between "true" and "so true even a stupid computer can see it"?</p>
<p>But as I am, at heart, a sideshow performer ever in search of clockwork monstrosities with which to captivate my punters, I'm fascinated by the business of walking that line, and finding theory that makes richer classes of theorem require minimal machine time and no human time.</p>



<a name="231894849"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231894849" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> James Wood <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231894849">(Mar 26 2021 at 00:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="296322">Jacques Carette</span> <a href="#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/231887969">said</a>:</p>
<blockquote>
<p>there's no good reason (in a univalent setting) to distinguish <code>Thing</code> from <code>Other</code>.</p>
</blockquote>
<p>We still have a judgemental inequality between them, which in practice is one we notice a lot.</p>



<a name="231899122"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231899122" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacques Carette <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231899122">(Mar 26 2021 at 00:54)</a>:</h4>
<p><span class="user-mention" data-user-id="276030">@Cody Roux</span> Yes, absolutely. But many want to downplay that as much as possible. To me, that is an error.</p>
<p><span class="user-mention" data-user-id="281583">@James Wood</span> That's kind of the trouble, isn't it? We're told they're the same and yet they're also not.  And indeed, the whole point is that (as Conor says), they might not be <em>cognate</em> at all. Intent is the important part, <em>outrageous coincidence</em> is something that the compiler can take advantage of <strong>post facto</strong>. Our theory shouldn't thrust  that upon us with no way to escape. Damn it, we went out of our way to write down our intent by using 2 different names!</p>



<a name="231918936"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231918936" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Tom Hirschowitz <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231918936">(Mar 26 2021 at 06:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="277574">Conor McBride</span> <a href="#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/231884811">said</a>:</p>
<blockquote>
<p>Jacques is right. I want the <em>machine</em> to see this is obviously the right thing and has all these properties, without me lifting a finger beyond giving the structure of the data. Moreover, I want the machine to <em>deploy</em> all these properties, without me lifting a finger at all. And I shall make it so.</p>
</blockquote>
<p>Thanks, and sorry for taking so long to get it. <span class="user-mention" data-user-id="276696">@Ambroise</span>  has <a href="https://github.com/amblafont/Skew-Monoidalcategories">implemented</a> a generalisation of the Fiore-Plotkin-Turi approach in Unimath, so technically I'd say you can just push a button to get all those properties. But the downside is that you don't get an inductive datatype, it's implemented as a directed colimit. I guess this is not good enough for you?</p>



<a name="231928566"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231928566" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> James Wood <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231928566">(Mar 26 2021 at 08:20)</a>:</h4>
<p>Probably <a href="https://arxiv.org/pdf/2001.11001.pdf">AACMM20</a>, section 10.3, would be a good starting point for the discussion about the Fiore-Plotkin-Turi work.</p>



<a name="231943214"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/231943214" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Tom Hirschowitz <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#231943214">(Mar 26 2021 at 10:35)</a>:</h4>
<p>I don't understand this: </p>
<blockquote>
<p>By contrast, we are working in an implemented type theory where the encoding can<br>
be understood as its own foundation without appeal to an external mathematical semantics.</p>
</blockquote>
<p>which I guess means I should go read the paper.</p>



<a name="232021349"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/232021349" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> James Wood <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#232021349">(Mar 26 2021 at 19:43)</a>:</h4>
<p>I also don't understand some bits like this.</p>



<a name="232692976"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/232692976" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Valeria de Paiva <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#232692976">(Apr 01 2021 at 02:01)</a>:</h4>
<p>hi, I'm still trying to understand the gnarly bit of Agda. I'm not good at this,<br>
but 138 locs is definitely a little less daunting than all the papers written about containers since 2003. so you say:</p>
<blockquote>
<p>I'll need simple types...</p>
</blockquote>
<p>and this is good, we always do.</p>
<blockquote>
<p>...and right-growing (i.e., backward) lists to put them in, to make contexts. -</p>
</blockquote>
<p>sure, also fine. (don't know if the capital B is for backward  or for  the base category of the fibration p:E--&gt; B, but this is fine)<br>
Then stuff starts getting interesting because</p>
<blockquote>
<p>Now the semisimplicial category.</p>
</blockquote>
<p>(and I always thought that the list of variables with their dependent types was just a list.) sure, we can concatenate new pairs and  contexts always grow, but it hadn't occurred to me to think of this as a "semisimplicial category". but fine. why is this </p>
<blockquote>
<p>(It's secretly a bit vector.)</p>
</blockquote>
<p>I have no idea, but maybe it's about the efficiency of stuff, I don't care.</p>
<blockquote>
<p>The two CLUEs show that context extension is   on-the-nose covariantly functorial.</p>
</blockquote>
<p>works for me. as does</p>
<blockquote>
<p>Now, here are well scoped well typed terms.</p>
</blockquote>
<p>after a half a second hesitation on  S &gt;&gt; T being the function space from S to T.<br>
but then when we get to</p>
<blockquote>
<p>The above is the fixpoint of a polynomial with blah, blah</p>
</blockquote>
<p>I am lost. </p>
<p>I want nothing to do with the Fiori-Plotkin-Turi approach, if I'm reading  right the passage indicated by  James Wood as 10.3 of AACMM20. Because yes, I want my indexed category with de Bruijn encoding on the syntax, not presheaves.  but it looks like reading of the previous version of AACMM20 is required.</p>



<a name="232712640"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/232712640" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Tom Hirschowitz <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#232712640">(Apr 01 2021 at 07:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="276656">Valeria de Paiva</span> <a href="#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/232692976">said</a>:</p>
<blockquote>
<p>I want nothing to do with the Fiori-Plotkin-Turi approach, if I'm reading  right the passage indicated by  James Wood as 10.3 of AACMM20. Because yes, I want my indexed category with de Bruijn encoding on the syntax, not presheaves.  but it looks like reading of the previous version of AACMM20 is required.</p>
</blockquote>
<p>You seem to understand what got me puzzled earlier: would you please mind explaining in a bit more detail? What do you mean by having your indexed category with de Bruijn encoding on the syntax? What would you get with presheaves, an indexed category with de Bruijn encoding on presheaves?</p>



<a name="232733201"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/232733201" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#232733201">(Apr 01 2021 at 10:13)</a>:</h4>
<blockquote>
<p>(don't know if the capital B is for backward or for the base category of the fibration p:E--&gt; B, but this is fine)</p>
</blockquote>
<p>I write <code>Bwd</code> for "backward": by programming convention established in the 1950s, "normal" lists grow by extending on the left, but the convention in logic/type theory is to write contexts as lists whose "local" end is on the right. I make the data in my code work like the data in my head.</p>
<p>When I say that morphisms in the semisimplicial category are secretly bit vectors, I'm making a <em>combinatorial</em> observation: the rows of Pascal's triangle sum to powers of two. When you embed a short context into a longer one by making insertions, you're effectively selecting the short context from the long one by giving one bit of information (select or discard) for each of the long context's entries. The values <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mtable columnalign="center" columnspacing="1em" rowspacing="0.15999999999999992em"><mtr><mtd><mstyle displaystyle="false" scriptlevel="0"><mi>m</mi></mstyle></mtd></mtr><mtr><mtd><mstyle displaystyle="false" scriptlevel="0"><mi>n</mi></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(\begin{array}{c}m\\n\end{array}\right)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span> in Pascal's triangle document the number of length <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> bit vectors with population count (the number of 1s) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>. It is missing a trick merely to <em>count</em> them: they have delightful compositional structure, really useful for working with de Bruijn terms. That's the structure being ignored when we treat the indices of the container only as discrete.</p>
<p>And when it comes to the polynomial...</p>
<blockquote>
<p>I am lost.</p>
</blockquote>
<p>...I'm not surprised, because it's an inside-out mess. The <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>←</mo><mi>S</mi><mo>←</mo><mi>P</mi><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">O \leftarrow S \leftarrow P \rightarrow I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> presentation of polynomial functors is a <em>terrible</em> way to compute with any <em>specific</em> polynomial functor. The merit of the "<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>-first" presentation is in the abstract: thinking about polynomials in general, with as few dependencies/fibrations as you can get away with. The detail is inscrutable but not important: I felt obliged to calculate the polynomial corresponding to the functor whose least fixpoint yields the rather more intelligible inductive datatype definition, only to show that genuine OSPI-polynomials are indeed at work here.</p>
<p>Returning to the big picture, I work with <em>machines</em> and thus to a finer degree of pedantry than mathematical demonstrability. I'm interested in which of us (me or the machine) has to do the work to establish mathematical demonstrability.</p>
<p>In particular, I am looking for two related things. Firstly, I'm looking for a suitable interpretation of the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>←</mo><mi>S</mi><mo>←</mo><mi>P</mi><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">O \leftarrow S \leftarrow P \rightarrow I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> story in functor categories, yielding polynomial functors between presheaves. Secondly, I'm looking for a complete syntactic presentation of the same notion, from which the such-thattery required to establish presheaf structure has been eliminated. Concretely, I want to codify which datatype declarations exhibit presheaf structure <em>a priori</em>, so that I can obtain it deliberately and for but the effort of asking. It's kind of funny: I'm not trying to <em>prove</em> that one or two specific constructions yield presheaves; I'm exactly trying to <em>stop</em> proving that and just <em>see</em> it instead.</p>



<a name="232745473"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/232745473" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> James Wood <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#232745473">(Apr 01 2021 at 12:07)</a>:</h4>
<p>I suppose the O←S←P→I presentation is a bit “if this is the answer, what is the question?”. P describes where you might find premises of a rule, while S tells you which rule that premise is in.</p>



<a name="232745585"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/232745585" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> James Wood <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#232745585">(Apr 01 2021 at 12:08)</a>:</h4>
<p>Maybe <code>fun</code> and <code>arg</code> would be clearer as <code>app left</code> and <code>app right</code>, or something.</p>



<a name="232768373"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/232768373" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacques Carette <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#232768373">(Apr 01 2021 at 14:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="277574">Conor McBride</span> <a href="#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/232733201">said</a>:</p>
<blockquote>
<p>Returning to the big picture, I work with <em>machines</em> and thus to a finer degree of pedantry than mathematical demonstrability. I'm interested in which of us (me or the machine) has to do the work to establish mathematical demonstrability.</p>
<p>[...] Concretely, I want to codify which datatype declarations exhibit presheaf structure <em>a priori</em>, so that I can obtain it deliberately and for but the effort of asking. It's kind of funny: I'm not trying to <em>prove</em> that one or two specific constructions yield presheaves; I'm exactly trying to <em>stop</em> proving that and just <em>see</em> it instead.</p>
</blockquote>
<p>This! So much this!</p>
<p>Computers are really good at eliminating drudgery, at least when we take the time to ask them nicely to do so. It does not happen by a miracle, we have to spot where things are fully automatable. But it's a question that I like to be asking <strong>constantly</strong>.</p>
<p>"What should I be getting for free here, if I were to ask <em>in just the right way</em>" yields all sorts of interesting dividends. Amusingly, it can sometimes force us to shift the focus back onto syntax: the semantics tells us there's automation to be had (the rest of <span class="user-mention" data-user-id="277574">@Conor McBride</span> 's explanation is all about an important specific case), but if you don't set things up correctly, it won't be "free".</p>
<p>All the constructions of Universal Algebra are my current playground. Well, generalized UA - multi-sorted and indexed/parametrized. I'm endlessly amused that while constructing "homomorphism" was known since at least 1908, very few people seemed to both with the fact that a "homomorphism" needs to live in a theory too. And while you can take a weird multi-sorted view where it can fit, it's very unnatural (right up there with the single-sorted view of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span>-modules where you have to throw in a <em>big infinity</em>'s worth of constants). And yet, in our theorem provers, writing down the definition of what a homomorphism (say of Monoids) is super easy. But it 'lives' in a view of what a 'theory' is that is usually not spoken about.  [Hmm, I should perhaps be starting my own thread in 'practice: our work' for this stuff...]</p>



<a name="232787387"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/232787387" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Valeria de Paiva <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#232787387">(Apr 01 2021 at 16:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="383799">Tom Hirschowitz</span> <a href="#narrow/stream/274877-practice.3A-our.20work/topic/Conor.20Mc.20Bride/near/232712640">said</a>:</p>
<blockquote>
<p>You seem to understand what got me puzzled earlier: would you please mind explaining in a bit more detail? What do you mean by having your indexed category with de Bruijn encoding on the syntax? What would you get with presheaves, an indexed category with de Bruijn encoding on presheaves?</p>
</blockquote>
<p>hi <span class="user-mention" data-user-id="383799">@Tom Hirschowitz</span> . no deep understanding on my part, simply the  shallow observation that I want *only the categorical structure that I am forced to have, nothing more. My indexed categories come from work with Eike Ritter on categorical combinators for dependent type theories (<a href="https://www.sciencedirect.com/science/article/pii/0304397594001253">https://www.sciencedirect.com/science/article/pii/0304397594001253</a>) and there I need pullback for substitutions, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>'s and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Π</span></span></span></span>'s, satisfying BCC of course. the rest is up for grabs!</p>



<a name="232793842"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/232793842" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Valeria de Paiva <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#232793842">(Apr 01 2021 at 17:25)</a>:</h4>
<p>Many thanks <span class="user-mention" data-user-id="277574">@Conor McBride</span>  for indulging me with explanations! </p>
<p>you're of course right about the opposite traditions on the telescopes of dependent types, which I hadn't paid enough attention to.</p>
<p>and I learned lots from</p>
<blockquote>
<p>I'm making a combinatorial observation: the rows of Pascal's triangle sum to powers of two. When you embed a short context into a longer one by making insertions, you're effectively selecting the short context from the long one by giving one bit of information (select or discard) for each of the long context's entries.[...] they have delightful compositional structure, really useful for working with de Bruijn terms. </p>
</blockquote>
<p>I have survived so far without understanding de Bruijn terms properly and I hope to be able to carry on the same way. But I begin to see why you say</p>
<blockquote>
<p>That's the structure being ignored when we treat the indices of the container only as discrete.</p>
</blockquote>
<p>I do understand that a finer degree of pedantry is required for machines.</p>
<p>When we get to the crux of the matter</p>
<blockquote>
<p>I'm looking for a suitable interpretation of the O \leftarrow S \leftarrow P \rightarrow IO←S←P→I story in functor categories, yielding polynomial functors between presheaves.</p>
</blockquote>
<p>Great, as I am trying to understand exactly this. no one needs to tell me that polynomials are important in mathematics, this much I know. I am trying to understand why container morphisms are the way they are, as they're reminiscent of dialectica morphisms and I have a single-track mind.</p>
<blockquote>
<p>Secondly, I'm looking for a complete syntactic presentation of the same notion, from which the such-thattery required to establish presheaf structure has been eliminated.</p>
</blockquote>
<p>Excellent, as I thought this would be a great way of going about it! I have always held the belief that FPers have intuitions about syntax that mathematicians lack and that the uncovering these intuitions is the source of much real progress in maths.</p>



<a name="232963052"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/232963052" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Valeria de Paiva <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#232963052">(Apr 02 2021 at 23:17)</a>:</h4>
<p>and more  thanks for</p>
<blockquote>
<p>..I'm not surprised, because it's an inside-out mess. The O \leftarrow S \leftarrow P \rightarrow IO←S←P→I presentation of polynomial functors is a terrible way to compute with any specific polynomial functor. The merit of the "PP-first" presentation is in the abstract: thinking about polynomials in general, with as few dependencies/fibrations as you can get away with. The detail is inscrutable but not important: I felt obliged to calculate the polynomial corresponding to the functor whose least fixpoint yields the rather more intelligible inductive datatype definition, only to show that genuine OSPI-polynomials are indeed at work here.</p>
</blockquote>
<p>I'm afraid I had not noticed the O&lt;--S&lt;--P&lt;--I vertically written, so now it makes much more sense!</p>



<a name="233559828"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/233559828" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> David Spivak <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#233559828">(Apr 07 2021 at 20:58)</a>:</h4>
<p>I'm a little late here and haven't read all the discussion below; maybe this has been discussed. In his HoTTEST video, Garner showed that bimodules between polynomial functors are parametric right adjoints between the associated copresheaf categories. So for any categories <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi></mrow><annotation encoding="application/x-tex">\mathcal{I}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi></mrow><annotation encoding="application/x-tex">\mathcal{O}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span></span></span></span>, are the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="script">I</mi><mo separator="true">,</mo><mi mathvariant="script">O</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathcal{I},\mathcal{O})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mclose">)</span></span></span></span>-bimodules what you're looking for, @Conor? They are richer than profunctors <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi><mo>→</mo><mi mathvariant="script">O</mi></mrow><annotation encoding="application/x-tex">\mathcal{I}\to\mathcal{O}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span></span></span></span>. You can think of any such bimodule as a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi></mrow><annotation encoding="application/x-tex">\mathcal{O}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span></span></span></span>-indexed ducquery [disjoint union of conjunctive queries] on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi></mrow><annotation encoding="application/x-tex">\mathcal{I}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span></span></span></span></span>.</p>



<a name="233563523"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/233563523" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Conor McBride <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#233563523">(Apr 07 2021 at 21:12)</a>:</h4>
<p>This sounds good to me. I'll check it out. Inevitably, I'll be looking for a syntactification of the result, because my favourite proof is "by inspection", especially if I can teach a machine to do the inspection.</p>



<a name="233671936"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/274877-community%3A%20our%20work/topic/Conor%20Mc%20Bride/near/233671936" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> David Spivak <a href="https://mattecapu.github.io/ct-zulip-archive/stream/274877-community.3A-our-work/topic/Conor.20Mc.20Bride.html#233671936">(Apr 08 2021 at 15:15)</a>:</h4>
<p>Another thing that might be useful is the notion of "full internal subcategory", which you can find in Jacobs 99. [Sorry if you're way ahead of me!] For polynomials p: Set--&gt;Set, you consider the category In(p) whose objects are elements i : p(1) [positions/shapes] and whose morphisms are given by Hom(i,j) = Set( p[i], p[j] ), the set of functions from the [directions/positions] of at i to those at j. This In(p) thing comes with a fully faithful functor to Set.</p>
<p>This thingy is fairly prominent in Clive's thesis about Natural Models, but I think perhaps it should be generalized to what I'm calling "p-concrete categories", which are categories C equipped with an identity-on-objects and faithful functor C--&gt;In(p). </p>
<p>Anyway, if any of this looks like what you're looking for, let me know!</p>



<footer class="site-footer">

<hr><p>Last updated: Nov 01 2025 at 12:09 UTC</p>
This archive runs on a customization of <a href="https://github.com/zulip/zulip-archive">zulip-archive</a>
</footer>
</body>

</html>