<!DOCTYPE html>
<html>
<head>
  	<meta charset="utf-8" />
  	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
  	<meta name="viewport" content="width=device-width, initial-scale=1" />
  
<link rel="stylesheet" href="https://mattecapu.github.io/ct-zulip-archive/style.css" /><title>Presheaf Categories, Comma Objects, Equipments · learning: questions · Zulip Chat Archive</title>
</head>
<body>
<header>
<a href="https://mattecapu.github.io/ct-zulip-archive" class="home-link">
        <img class="logo" src="https://zulip-avatars.s3.amazonaws.com/21317/realm/icon.png?version=3" />
        <h1>Category Theory<br/>Zulip Server<br/>Archive</h1>
        </a>
        <p>
        You're reading the public-facing archive of the <a href="https://categorytheory.zulipchat.com/">Category Theory Zulip server</a>.<br/>
        
        To join the server you need an invite. Anybody can get an invite by contacting <a href="https://matteocapucci.wordpress.com">Matteo Capucci</a> at <em>name dot surname at gmail dot com</em>.<br/>
        
        For all things related to this archive refer to the same person.
        </p>
        </header>
        <hr />
    
<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/index.html">learning: questions</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Presheaf.20Categories.2C.20Comma.20Objects.2C.20Equipments.html">Presheaf Categories, Comma Objects, Equipments</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com">

<a name="435001418"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Presheaf%20Categories%2C%20Comma%20Objects%2C%20Equipments/near/435001418" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Onstead <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Presheaf.20Categories.2C.20Comma.20Objects.2C.20Equipments.html#435001418">(Apr 23 2024 at 14:45)</a>:</h4>
<p>On the nlab page for <a href="https://ncatlab.org/nlab/show/2-category+equipped+with+proarrows#motivation">proarrow equipments</a>, it states that the reason why some V-Cat need proarrow equipments to fully do category theory within is because they may lack comma objects. Specifically it states that in Cat, "hom-functors can be recovered by looking at comma categories... in some sense this is what all the above internalizations are secretly doing" with the "above internalizations" referring to concepts like limits, fully faithful morphisms, and pointwise kan extensions. My first question is: how is it that you can recover hom functors and related internalizations in Cat from the comma categories? Is it really as simple as finding the comma category (a/b) for C (with a and b functors from the terminal category picking out the objects a and b in C), or is something else at work?</p>
<p>Secondly, not all categories V-Cat have all comma objects. However, any category can be "upgraded" easily into one with all limits, including comma objects, by taking the Yoneda embedding into the presheaf category. In this case, we can find the 2-category [V-Cat^op, Cat] and the Yoneda embedding y: V-Cat -&gt; [V-Cat^op, Cat]. This does have all comma objects. So why do we need proarrow equipments when we could just do this operation to "uncover" the "hidden" comma objects of any V-Cat, and then we can do all internalizations with that?</p>



<a name="435012233"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Presheaf%20Categories%2C%20Comma%20Objects%2C%20Equipments/near/435012233" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Presheaf.20Categories.2C.20Comma.20Objects.2C.20Equipments.html#435012233">(Apr 23 2024 at 15:34)</a>:</h4>
<p>The basic issue is that many aspects of category theory rely on being able to talk about hom-sets, e.g. full faithfulness, the hom-set isomorphism characterisation of adjunctions, etc. In formal category, we therefore need some way to talk about these aspects without being able to "look inside" our objects and see that they contain a notion of morphism in them (just like how we don't want to look inside the objects of the category of sets to see that they contain elements).</p>
<p>For instance, if we want to talk about full faithfulness, we need to represent in some way a collection of morphisms <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi><mo stretchy="false">(</mo><mi>F</mi><mo lspace="0em" rspace="0em">−</mo><mo separator="true">,</mo><mi>F</mi><mo lspace="0em" rspace="0em">−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal D(F{-}, F{-})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord">−</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord">−</span></span><span class="mclose">)</span></span></span></span>. How can we do this? Well, it depends on what we understand <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi><mo stretchy="false">(</mo><mi>F</mi><mo lspace="0em" rspace="0em">−</mo><mo separator="true">,</mo><mi>F</mi><mo lspace="0em" rspace="0em">−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal D(F{-}, F{-})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord">−</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord">−</span></span><span class="mclose">)</span></span></span></span> to represent. One obvious candidate is the comma category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>↓</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">F \downarrow F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↓</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>. This seems reasonable, because we know, following Lawvere, that many aspects of category theory that rely upon hom-sets can be reformulated in terms of comma categories. However, there is a problem with this approach when we do enriched category theory. The problem is not about the existence of comma objects: rather, it is that comma objects do not suffice to faithfully capture the aspects of enriched category theory that involve hom-objects. Intuitively, this is because comma objects capture structure described by individual morphisms in a category, but individual morphisms in an enriched category (meaning morphisms of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>→</mo><mi mathvariant="script">C</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">I \to \mathcal C(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> in the base of enrichment) do not suffice to capture all of the structure of the hom-objects in general. For instance, it is not true that we can capture enriched full faithfulness using (enriched) comma categories.</p>
<p>Another candidate for capturing these aspects is the notion of distributor/profunctor, which is the approach taken for proarrow equipments. In contrast to comma objects, it turns out that these do suffice to capture the structure of hom-objects in enriched category theory. (Alternatively, presheaf categories also suffice, essentially because they represent distributors, and this is the approach taken by Yoneda structures.)</p>



<a name="435012741"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Presheaf%20Categories%2C%20Comma%20Objects%2C%20Equipments/near/435012741" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Presheaf.20Categories.2C.20Comma.20Objects.2C.20Equipments.html#435012741">(Apr 23 2024 at 15:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="673117">John Onstead</span> <a href="#narrow/stream/229199-learning.3A-questions/topic/Presheaf.20Categories.2C.20Comma.20Objects.2C.20Equipments/near/435001418">said</a>:</p>
<blockquote>
<p>My first question is: how is it that you can recover hom functors and related internalizations in Cat from the comma categories? Is it really as simple as finding the comma category (a/b) for C (with a and b functors from the terminal category picking out the objects a and b in C), or is something else at work?</p>
</blockquote>
<p>Essentially yes, though you usually want to work with <a href="https://ncatlab.org/nlab/show/generalised%20elements">[[generalised elements]]</a> rather than <a href="https://ncatlab.org/nlab/show/global%20elements">[[global elements]]</a>. For instance, Lawvere proved that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊣</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \dashv R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> if and only if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>↓</mo><mn>1</mn><mo>≅</mo><mn>1</mn><mo>↓</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \downarrow 1 \cong 1 \downarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↓</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↓</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> and this isomorphism is concrete over the product category. So the hom-set formulation of an ordinary adjunction can be captured 2-categorically. However, this technique does not work for enriched adjunctions for the reasons explained above.</p>



<a name="435014122"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Presheaf%20Categories%2C%20Comma%20Objects%2C%20Equipments/near/435014122" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Presheaf.20Categories.2C.20Comma.20Objects.2C.20Equipments.html#435014122">(Apr 23 2024 at 15:44)</a>:</h4>
<p>Unfortunately, although it was already realised in the late 1970s – mid 1980s that 2-categories and property-like structure does not suffice for formal category theory (at least if intended to capture enriched category theory), you can find a lot of subsequent 2-categorical literature that ignores this, and therefore establishes theorems at a weaker level of generality than would be natural with proarrow equipments or related structures.</p>



<a name="435056221"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Presheaf%20Categories%2C%20Comma%20Objects%2C%20Equipments/near/435056221" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Onstead <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Presheaf.20Categories.2C.20Comma.20Objects.2C.20Equipments.html#435056221">(Apr 23 2024 at 19:42)</a>:</h4>
<p>Ah thanks for all the help! </p>
<p><span class="user-mention silent" data-user-id="276092">Nathanael Arkor</span> <a href="#narrow/stream/229199-learning.3A-questions/topic/Presheaf.20Categories.2C.20Comma.20Objects.2C.20Equipments/near/435014122">said</a>:</p>
<blockquote>
<p>Unfortunately, although it was already realised in the late 1970s – mid 1980s that 2-categories and property-like structure does not suffice for formal category theory (at least if intended to capture enriched category theory), you can find a lot of subsequent 2-categorical literature that ignores this, and therefore establishes theorems at a weaker level of generality than would be natural with proarrow equipments or related structures.</p>
</blockquote>
<p>I guess this explains why extra "structure" or "stuff" is needed to do this, like in a Yoneda Structure or Proarrow Equipment!</p>



<footer class="site-footer">

<hr><p>Last updated: Feb 28 2026 at 12:12 UTC</p>
This archive runs on a customization of <a href="https://github.com/zulip/zulip-archive">zulip-archive</a>
</footer>
</body>

</html>