<!DOCTYPE html>
<html>
<head>
  	<meta charset="utf-8" />
  	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
  	<meta name="viewport" content="width=device-width, initial-scale=1" />
  
<link rel="stylesheet" href="https://mattecapu.github.io/ct-zulip-archive/style.css" /><title>Enumerating properties of categories · learning: questions · Zulip Chat Archive</title>
</head>
<body>
<header>
<a href="https://mattecapu.github.io/ct-zulip-archive" class="home-link">
        <img class="logo" src="https://zulip-avatars.s3.amazonaws.com/21317/realm/icon.png?version=3" />
        <h1>Category Theory<br/>Zulip Server<br/>Archive</h1>
        </a>
        <p>
        You're reading the public-facing archive of the <a href="https://categorytheory.zulipchat.com/">Category Theory Zulip server</a>.<br/>
        
        To join the server you need an invite. Anybody can get an invite by contacting <a href="https://matteocapucci.wordpress.com">Matteo Capucci</a> at <em>name dot surname at gmail dot com</em>.<br/>
        
        For all things related to this archive refer to the same person.
        </p>
        </header>
        <hr />
    
<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/index.html">learning: questions</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html">Enumerating properties of categories</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com">

<a name="431620323"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431620323" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431620323">(Apr 05 2024 at 23:59)</a>:</h4>
<p>This is a sub-question I would like to sort out before returning to my thoughts on terminal objects.</p>
<p>I would like to enumerate, in a logical language, all possible properties which a category could have. By property, I mean anything like, “being a thin category”, “being a dagger category”, “having a terminal object”, etc.</p>
<p>I am going to assume all properties about a category will be expressed via quantification over the “elements” of the category. I will only need the universal and existential quantifier. By “elements”, I mean “things” that the category is built out of. For example, a standard category has a set of objects, and a set of arrows. But some category-theoretic structures could have, say, a set of 0-morphisms, a set of 1-morphisms, and a set of 2-morphisms.</p>
<p>To keep this simple, I’ll just explore statements involving a universal quantifier, at first.</p>
<p>The simplest “property” I could think of so far, is:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>X</mi><mo>∈</mo><mi>C</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall X \in C (X = X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span></p>
<p>To keep my enumeration simple, I’ll also focus on enumerating properties on the objects, and not the arrows, for now.</p>
<p>Here are some other syntactically simple statements I can think of:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>X</mi><mo>∈</mo><mi>C</mi><mo stretchy="false">(</mo><mi>X</mi><mo>∈</mo><mi>C</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>X</mi><mo>∈</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall X \in C (X \in C \implies X \in C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7073em;vertical-align:-0.024em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>X</mi><mo>∈</mo><mi>C</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∀</mi><mi>Y</mi><mo>∈</mo><mi>C</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><mi>Y</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>X</mi><mo>=</mo><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall X \in C (\forall Y \in C (X = Y \implies X = Y))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7073em;vertical-align:-0.024em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">))</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>X</mi><mo>∈</mo><mi>C</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∀</mi><mi>Y</mi><mo>∈</mo><mi>C</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><mi>Y</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>Y</mi><mo>=</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall X \in C (\forall Y \in C (X = Y \implies Y = X))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7073em;vertical-align:-0.024em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">))</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>X</mi><mo>∈</mo><mi>C</mi><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><mi>X</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>X</mi><mo>=</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall X \in C (\neg (X = X) \implies X = X))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">¬</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">))</span></span></span></span></p>
<p>To be clear, I am trying to list out every well-formed logical statement about a category, whether it is true or not. I am struggling to formulate how to enumerate over all possible such statements, but I am going to practice stating some less comprehensive ones first.</p>



<a name="431621019"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431621019" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431621019">(Apr 06 2024 at 00:09)</a>:</h4>
<p>If we assume <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> is a variable ranging over “the objects in a category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>”, then let’s consider all statements that begin with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>X</mi><mo>:</mo></mrow><annotation encoding="application/x-tex">\forall X:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span></span></span></span>. I.e., this is a “single-variable” theory / “fragment of first-order logic”.</p>
<p>I believe that as long as we have some “atomic proposition”, it is already well known what the entire “theory” generated from it is, using “standard” logical connectives - a Boolean algebra (and, there are multiple “functionally complete” choices of operators that generate an equivalent structure, such as NAND.)</p>
<p>What is interesting is that both on objects and arrows, there is, as far as I can tell, only one “truth-bearing” predicate on them, which is equality. So, if I take “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X=X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> as my “atomic proposition”, then there is a Boolean algebra generated from it. </p>
<p>For this reason, it shouldn’t be that hard to enumerate statements about objects. We only have one possible predicate. The only other thing we can “vary” are the number of variable terms - for example, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>X</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∀</mi><mi>Y</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∀</mi><mi>Z</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><mi>Y</mi><mo>=</mo><mi>Z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall X (\forall Y(\forall Z(X = Y = Z)))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mopen">(</span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mopen">(</span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">)))</span></span></span></span>.</p>



<a name="431621061"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431621061" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431621061">(Apr 06 2024 at 00:09)</a>:</h4>
<p>There is more potential interest when enumerating statements about arrows, because there, we have 2 predicates, not one: composition and equality. (Actually, composition is a function, not a predicate.)</p>



<a name="431621387"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431621387" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431621387">(Apr 06 2024 at 00:14)</a>:</h4>
<p>I’m thinking maybe I can pinpoint underlying “enumerative axes”, then put them all together. You can enumerate over:</p>
<ul>
<li>the number of variable terms present in a given statement </li>
<li>the <em>sort</em> that a variable term quantifies over (objects, arrows, something else)</li>
<li>the <em>type</em> of quantification (existential, universal)</li>
<li>which predicate you quantify (composition, equality)</li>
<li>the possible arrangements of arguments in a predicate (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X = X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> vs. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X = Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">f \circ f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> vs. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∘</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f \circ g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>.</li>
<li>the number of arrangements of propositions via logical connectives</li>
</ul>



<a name="431621886"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431621886" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431621886">(Apr 06 2024 at 00:22)</a>:</h4>
<p>I think I see it so much clearer now.</p>
<p>The zero-order terms are a collection of <em>objects</em>, a collection of <em>arrows</em>, and a collection of <em>truth-values</em>.</p>
<p>There is a first-order function called <em>composition</em>, which takes 2 arrows as arguments. Its terms look like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>m</mi><mi>p</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Comp(f, g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span>.</p>
<p>There is a first-order function, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>O</mi><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">=_{Ob}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, which takes 2 objects and 1 truth value. Its terms look like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>O</mi><mi>b</mi></mrow></msub><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">=_{Ob}(A, B, True)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>.</p>
<p>There is a first-order function, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>A</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">=_{Ar}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, which takes 2 arrows and 1 truth value (analogously to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>O</mi><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">=_{Ob}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>).</p>
<p>There is a first-order function Dom, which takes an arrow, an object, and a truth value. Its terms look like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>a</mi><mo separator="true">,</mo><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Dom(A, a, False)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Do</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class="mclose">)</span></span></span></span>.</p>
<p>There is a first-order function Cod (analogous to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Dom()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Do</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>).</p>



<a name="431622046"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431622046" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431622046">(Apr 06 2024 at 00:25)</a>:</h4>
<p>I think it should be possible to state a “closed formula” to enumerate all possible terms, in the above system.</p>



<a name="431622074"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431622074" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> David Egolf <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431622074">(Apr 06 2024 at 00:25)</a>:</h4>
<p>You may find this (broadly related) nLab article interesting to browse: <a href="https://ncatlab.org/nlab/show/stuff%2C+structure%2C+property">stuff, structure, property</a>. I really like how it talks about "stuff", "structure" and "properties" in terms of functors "forgetting" different things.</p>
<p>On a related note, you may also enjoy taking a look at section 2.4 of <a href="https://arxiv.org/pdf/math/0608420.pdf">Lectures on n-categories and cohomology</a>. That section starts out like this:</p>
<blockquote>
<p>Stuff, structure, and properties. What’s all this nonsense about? In math<br>
we’re often interested in equipping things with extra structure, stuff, or properties,<br>
and people are often a little vague about what these mean. For example, a group<br>
is a set (stuff ) with operations (structure) such that a bunch of equations hold<br>
(properties).</p>
<p>You can make these concepts very precise by thinking about forgetful functors.</p>
</blockquote>
<p>I'm not sure how related these resources are to what you've been discussing in this topic. But these resources talk about "properties", which is what brought them to mind for me!</p>



<a name="431622963"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431622963" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431622963">(Apr 06 2024 at 00:38)</a>:</h4>
<p>I will enjoy reading them greatly. Thank you!</p>



<a name="431623380"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431623380" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431623380">(Apr 06 2024 at 00:44)</a>:</h4>
<p>I’m going to respond to the information you shared, because especially the idea of a “stuff type” and a “structure type” has to do with some of my thoughts.</p>
<p>That said, I want to try to finish my train of thought about how to enumerate the expressions above.</p>



<a name="431624023"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431624023" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431624023">(Apr 06 2024 at 00:54)</a>:</h4>
<p>It appears that a first order function acts like a “formation rule” on zero order terms.</p>
<p>I said I had 5 first-order functions: Dom, Cod, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>O</mi><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">=_{Ob}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>A</mi><mi>r</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">=_{Arr}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">rr</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∘</mo></mrow><annotation encoding="application/x-tex">\circ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">∘</span></span></span></span>.</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∘</mo></mrow><annotation encoding="application/x-tex">\circ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">∘</span></span></span></span> is binary; the other 4 are ternary.</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∘</mo></mrow><annotation encoding="application/x-tex">\circ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">∘</span></span></span></span> is restricted to the sort <em>arrows</em>.</p>
<p>Then, it is easy to enumerate the terms it will generate. Let’s say we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> arrow symbols. Then in the first argument, we will have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> choices, and for each of them, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> choices for the second argument. Then there are <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∘</mo></mrow><annotation encoding="application/x-tex">\circ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">∘</span></span></span></span>-terms.</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>O</mi><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">=_{Ob}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>A</mi><mi>r</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">=_{Arr}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">rr</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are analogous. (I suppose I realize I did not specify any properties for equality, like symmetry and transitivity, so I’ll have to work that out later). If we keep with the simple formula of multiplying the size of the set that each argument takes values in, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>O</mi><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">=_{Ob}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> has <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msup><mi>o</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2o^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> terms, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi></mrow><annotation encoding="application/x-tex">o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">o</span></span></span></span> is the number of object symbols, and similarly, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>A</mi><mi>r</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">=_{Arr}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">rr</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> has <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msup><mi>a</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2a^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> terms.</p>
<p>Dom and Cod are simple - both are <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>o</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">2oa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span></span></span></span>.</p>



<a name="431624059"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431624059" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431624059">(Apr 06 2024 at 00:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="699750">Julius Hamilton</span> <a href="#narrow/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories/near/431620323">said</a>:</p>
<blockquote>
<p>Here are some other syntactically simple statements I can think of:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>X</mi><mo>∈</mo><mi>C</mi><mo stretchy="false">(</mo><mi>X</mi><mo>∈</mo><mi>C</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>X</mi><mo>∈</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall X \in C (X \in C \implies X \in C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7073em;vertical-align:-0.024em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>X</mi><mo>∈</mo><mi>C</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∀</mi><mi>Y</mi><mo>∈</mo><mi>C</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><mi>Y</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>X</mi><mo>=</mo><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall X \in C (\forall Y \in C (X = Y \implies X = Y))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7073em;vertical-align:-0.024em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">))</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>X</mi><mo>∈</mo><mi>C</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∀</mi><mi>Y</mi><mo>∈</mo><mi>C</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><mi>Y</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>Y</mi><mo>=</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall X \in C (\forall Y \in C (X = Y \implies Y = X))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7073em;vertical-align:-0.024em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">))</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>X</mi><mo>∈</mo><mi>C</mi><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><mi>X</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>X</mi><mo>=</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall X \in C (\neg (X = X) \implies X = X))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">¬</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">))</span></span></span></span></p>
<p>To be clear, I am trying to list out every well-formed logical statement about a category, whether it is true or not. </p>
</blockquote>
<p>Above you're only listing some true ones, and omitting some simpler false ones.  </p>
<p>It's much easier to list all well-formed statements, regardless of whether they're true or not.    Logicians call these 'sentences'.  And it's even easier to list the 'formulas'.   An example of a formula that's not a sentence is</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mi>Y</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>Y</mi><mo>=</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex"> X = Y \implies Y = Z </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7073em;vertical-align:-0.024em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></p>
<p>and an example of a sentence is</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>X</mi><mi mathvariant="normal">∀</mi><mi>Y</mi><mi mathvariant="normal">∀</mi><mi>Z</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><mi>Y</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>Y</mi><mo>=</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \forall X \forall Y \forall Z( X = Y \implies Y = Z) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7073em;vertical-align:-0.024em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span></span></span></span></p>
<p>(Here I'm not bothering to write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">X \in C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>, etc.)</p>
<p>Wikipedia gives the rules for generating all formulas <a href="https://en.wikipedia.org/wiki/First-order_logic#Syntax">here</a>. First you choose your non-logical symbols, then you inductively define 'terms', and then, using those, you inductively define 'formulas'.    </p>
<p>None of this is really about category theory: you are really studying first-order logic.  The theory of categories, at least the way you're starting to describe it, is an example of a theory in first-order logic.</p>



<a name="431624205"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431624205" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431624205">(Apr 06 2024 at 00:57)</a>:</h4>
<p>By the way, where I said the word 'true' above, I would normally say 'provable'.   Only God knows what's 'true' (though I heard even she has some doubts).  But we can show certain sentences are provable using certain axioms and certain deduction rules.  Indeed we can write computer programs to do this.</p>



<a name="431624306"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431624306" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431624306">(Apr 06 2024 at 00:58)</a>:</h4>
<p>I’m familiar with that Wikipedia page, but I don’t find the presentation clear enough.</p>



<a name="431624495"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431624495" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431624495">(Apr 06 2024 at 01:01)</a>:</h4>
<p>For example, that presentation of FOL distinguishes between terms, which are well-defined “entities”, and formula, which are expressions which map to “true” or “false”. My presentation above does not make this distinction. It just includes the set of truth-values as other terms.</p>



<a name="431624892"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431624892" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431624892">(Apr 06 2024 at 01:07)</a>:</h4>
<p>Hmmm.   So you're blending the concept of "theory" and "model" in a nonstandard way.    Is there anything unclear about the Wikipedia page - i.e., hard to understand - or is it just that you don't like it?  They're trying to present first-order logic in the usual way.   If there's anything <em>unclear</em> about it, I might fix it.</p>



<a name="431625213"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431625213" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431625213">(Apr 06 2024 at 01:12)</a>:</h4>
<p>I appreciate you saying that. I can try to answer your question in detail, but I need to keep going in my own investigation to figure out what it is I am trying to work out. I’m about to post my thoughts on a possible enumeration algorithm. (After that, I have to revise the algorithm to only generate “self-consistent” theories, hopefully - ie, not generating “nonsense” categories where the arrows don’t compose).</p>
<p>I know of only one philosophical angle that might be relevant - there is apparently a minority view in logic that thinks “there is no real semantics; it’s all syntax”. I am really interested in this perspective. I think it’s touched on <a href="https://en.m.wikipedia.org/wiki/Logical_harmony">here</a> (but it’s not that important for me to go on in my approach.)</p>



<a name="431625277"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431625277" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431625277">(Apr 06 2024 at 01:14)</a>:</h4>
<p>If you want to avoid semantics and stick to syntax, the usual way is to inductively define "provable" sentences given a set of axioms.    Then purely syntactic rules let you enumerate all the provable sentences.</p>



<a name="431625329"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431625329" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431625329">(Apr 06 2024 at 01:14)</a>:</h4>
<p>The map from sentences to "true" and "false" is part of what we call semantics.</p>



<a name="431625380"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431625380" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431625380">(Apr 06 2024 at 01:15)</a>:</h4>
<p>But anyway, go ahead and try stuff!   I do a lot of that too.</p>



<a name="431627743"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431627743" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431627743">(Apr 06 2024 at 01:42)</a>:</h4>
<p>^That’s probably what I’m going for. Anyway, here is the next chunk of thought:</p>
<p>Basically, my intuition tells me that it will be impossible to write the “formation rule” to generate all terms, without recursion, but I need to dwell on why that is.</p>
<p>I have a hope that each “n-order” function in the theory can be “instructed” to apply itself to every term in a collection (of the relevant <em>sort</em>). After it does that, it is instructed to do the same thing again (since it just generated a bunch of new terms).</p>
<p>This may lead to the issue of, “but in what order should you choose to apply the n-ary functions”? My hope is, you could enumerate “one level up” over them, as well.</p>
<p>Something like this (maybe):</p>
<p>3 zero-order “functions”:<br>
objects = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mo>…</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{a, b, c, …\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mclose">}</span></span></span></span><br>
arrows = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo separator="true">,</mo><mo>…</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{x, y, z, …\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mclose">}</span></span></span></span><br>
truthvalues = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{0, 1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span></p>
<p>5 first-order “functions”:<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>O</mi><mi>b</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>s</mi><mo separator="true">,</mo><mi>y</mi><mo>:</mo><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>s</mi><mo separator="true">,</mo><mi>z</mi><mo>:</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>t</mi><mi>h</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">=_{Ob}(x : Objects, y : Objects, z : truthvalues)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">es</span><span class="mclose">)</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>A</mi><mi>r</mi><mi>r</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi><mi>s</mi><mo separator="true">,</mo><mi>y</mi><mo>:</mo><mi>A</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi><mi>s</mi><mo separator="true">,</mo><mi>z</mi><mo>:</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>t</mi><mi>h</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">=_{Arr}(x : Arrows, y : Arrows, z : truthvalues)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">rr</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">rro</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">rro</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">es</span><span class="mclose">)</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>s</mi><mo separator="true">,</mo><mi>y</mi><mo>:</mo><mi>A</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi><mi>s</mi><mo separator="true">,</mo><mi>z</mi><mo>:</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>t</mi><mi>h</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Dom(x : Objects, y : Arrows, z : truthvalues)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Do</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">rro</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">es</span><span class="mclose">)</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>s</mi><mo separator="true">,</mo><mi>y</mi><mo>:</mo><mi>A</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi><mi>s</mi><mo separator="true">,</mo><mi>z</mi><mo>:</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>t</mi><mi>h</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Cod(x : Objects, y : Arrows, z : truthvalues)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">rro</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">es</span><span class="mclose">)</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∘</mo><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi><mi>s</mi><mo separator="true">,</mo><mi>y</mi><mo>:</mo><mi>A</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\circ(x : Arrows, y : Arrows)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∘</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">rro</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">rro</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></p>
<p>(Possibly 2nd-order functions are logical connectives like “and”. The problem here is I haven’t defined my functions to have a “return type”, so maybe I have to start over in that regard.)</p>
<p>(Note that these are “syntactic” functions - they just form new syntactic units, by plugging in a specific value into the variables.)</p>
<p>(Maybe later we can add in an ability to define a “category” with a “membership” function, equality of categories, etc.)</p>
<p>As sketched in a previous message, it is easy to “enumerate” all terms of <em>one</em> of the above functions, with universal quantification over its arguments (which corresponds to “for-loops”):</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">[</mo><msub><mo>=</mo><mrow><mi>O</mi><mi>b</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\forall x, y, z [=_{Ob}(x, y, z)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mopen">[</span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)]</span></span></span></span> suffices. </p>
<p>There is some reason I can’t see clearly now why this isn’t good enough. </p>
<p>The main idea I was getting at was, there is a way to enumerate a function over all the terms in its domain. However, these functions generate new terms. For example, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>O</mi><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">=_{Ob}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> can form a new expression, which is essentialy of “truth_value” type. When that happens, a “logical connective” function, like “and”, needs to include that term in its enumeration, in order to count as “comprehensive”.</p>
<p>So, what if we just went in a loop, each function taking turns to enumerate all the terms it can? It reminds me sort of of the Von Neumann cumulative hierarchy.</p>
<p>Thus, we have a… “list” or “collection” of <em>functions</em>: [objects, arrows, truth_values, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>O</mi><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">=_{Ob}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>A</mi><mi>r</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">=_{Arr}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">rr</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, Dom, Cod, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∘</mo></mrow><annotation encoding="application/x-tex">\circ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">∘</span></span></span></span>].</p>
<p>Hopefully, there is a general “instruction set” which <em>understands</em> that “when you come across a variable, enter a <em>sub-routine</em> where you loop over every term in that variable’s type”.</p>
<p>So, it would do nothing for the first three nullary functions. When it came to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>O</mi><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">=_{Ob}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, it would enter a sub-routine of iterating over all terms in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">objects</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span></span></span></span>. For each, it would proceed to the second argument of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>O</mi><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">=_{Ob}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, and enter a second iterative sub-routine. So doing, it would generate all possible “first-generation” terms possible, for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>O</mi><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">=_{Ob}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. It would then continue its top-level iteration, passing to the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mrow><mi>A</mi><mi>r</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">=_{Arr}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">rr</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> function.</p>
<p>When it has done that, it has appended many new terms into collection <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>t</mi><mi>h</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">truthvalues</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">es</span></span></span></span> (actually no, I now realize it should append those terms to a collection called “propositions”).</p>
<p>The hope would be, this would be an effective algorithm in enumerating all terms. And maybe, with some more work, it could enumerate all <em>properties</em> of categories (the original hope) - in that list of expressions, we would find the logical definition of “has all product objects”, etc. Will think more on this.</p>



<a name="431629292"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431629292" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431629292">(Apr 06 2024 at 02:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="275920">John Baez</span> <a href="#narrow/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories/near/431624892">said</a>:</p>
<blockquote>
<p>Is there anything unclear about the Wikipedia page - i.e., hard to understand - or is it just that you don't like it?  They're trying to present first-order logic in the usual way.   If there's anything <em>unclear</em> about it, I might fix it.</p>
</blockquote>
<p>I am really big on stuff like editing Wikipedia and Stack Exchange, so if you want to discuss this article in detail (ie, how I think it could be improved), that would probably be very, very intellectually stimulating for me.</p>
<p><a href="https://en.m.wikipedia.org/wiki/First-order_logic">https://en.m.wikipedia.org/wiki/First-order_logic</a></p>



<a name="431638624"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431638624" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431638624">(Apr 06 2024 at 04:42)</a>:</h4>
<p>You said it was "unclear" so I'm curious what's unclear about it.</p>



<a name="431641013"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431641013" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> David Egolf <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431641013">(Apr 06 2024 at 05:08)</a>:</h4>
<p>For what it's worth, I've tried and failed various times to productively engage with Wikipedia articles on logic. (Although I can't point to any particular thing about those articles that I didn't like). Actually, it took me a while to find <em>any</em> resources on first-order logic that worked well for me. These are the two books that I've personally found quite helpful:</p>
<ul>
<li>"Mathematical Logic" (by Ebbinghaus, Flum, and Thomas)</li>
<li>"A Mathematical Introduction to Logic" (by Enderton)</li>
</ul>



<a name="431641254"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431641254" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431641254">(Apr 06 2024 at 05:12)</a>:</h4>
<p>(Response to John Baez before David Egolf’s message.)</p>
<p>Well, it’s easier for me to start with the first paragraph, since I feel like I can’t pinpoint just one part of the article.</p>
<blockquote>
<p>First-order logic—also known as predicate logic, quantificational logic, and first-order predicate calculus—is a collection of formal systems used in mathematics, philosophy, linguistics, and computer science.</p>
</blockquote>
<p>The synonymous terms may be loosely valid, but it isn’t that informationally useful. It would be much better to start off with a clear conceptual definition of what first-order logic really is. A “collection of formal systems” does not leave a strong impression. Listing some fields where it’s used is also not necessarily inaccurate, but kind of a distraction for the first introductory sentence, maybe.</p>
<blockquote>
<p>First-order logic uses quantified variables over non-logical objects,</p>
</blockquote>
<p>If this is one’s initial introduction to first order logic, this probably is almost impossible to understand. But if you already have some exposure to logic, it’s not very informative or insightful. It’s not that clear what the intended value of the sentence is. Are they trying to highlight that a key characteristic distinguishing first-order logic as opposed to zeroth-order is that it features <strong>quantification</strong>? If so, the sentence could be completely rephrased to highlight that - and then provide a clear, succinct explanation of what quantification is.</p>
<blockquote>
<p>and allows the use of sentences that contain variables,</p>
</blockquote>
<p>Didn’t they just say it “quantifies over variables”, and now they are adding in that it “allows the use of sentences that contain variables”? This is sort of diluted word salad to me. There is no compelling informational content. It is not teaching or explaining to someone not just what technical features FOL has, but far more critically, its significance in the history of ideas, why it was developed, how it came to have the form it does, why it’s useful, what problems it solves, and so on.</p>
<blockquote>
<p>so that rather than propositions such as "Socrates is a man", one can have expressions in the form "there exists x such that x is Socrates and x is a man", </p>
</blockquote>
<p>This is an arguably terrible example to introduce someone to logic. It makes logic seem asinine and trivial, like that you can reformulate useless statements about the world like “I have an umbrella” by replacing the word umbrella with a variable. Of course, a simple example in an introductory context helps someone get familiar with how variables act as referents, but it doesn’t really fit in here in the introduction. It could come later in a more “tutorial” part of the article. I’m not trying to be excessively negative, just trying to claim the article has so much greater potential than its current form.</p>
<blockquote>
<p>where "there exists" is a quantifier, while x is a variable.[1]</p>
</blockquote>
<p>This sentence is ok with me.</p>
<blockquote>
<p>This distinguishes it from propositional logic, which does not use quantifiers or relations;[2]</p>
</blockquote>
<p>This part is actually kind of useful and interesting.</p>
<blockquote>
<p>in this sense, propositional logic is the foundation of first-order logic.</p>
</blockquote>
<p>Sort of. It’s a bit too vague of a claim to be true or false, in my opinion. In calling it “the foundation”, it sort of implies that you need propositional logic to “build” FOL. But that’s not usually how it’s presented or thought about.</p>
<p>I can offer a sketch of what I think a better introduction to FOL would be like, or I can continue my commentary on the next paragraph. The key thing to me is that it should not just list mathematical axioms. It needs to give conceptual motivation for why we would need it, and exactly why everything in it is the way it is (why do we have “terms”, “formulas”, etc.)</p>
<p>Also, the Wikipedia talk page is full of commentary of others suggesting the article is kind of bloated and mish-mash. I’d love to try to revise it, but I got banned from Wikipedia for arguing with an admin! Oh well.</p>



<a name="431641287"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431641287" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431641287">(Apr 06 2024 at 05:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="277503">David Egolf</span> <a href="#narrow/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories/near/431641013">said</a>:</p>
<blockquote>
<p>For what it's worth, I've tried and failed various times to productively engage with Wikipedia articles on logic. (Although I can't point to any particular thing about those articles that I didn't like). Actually, it took me a while to find <em>any</em> resources on first-order logic that worked well for me. These are the two books that I've personally found quite helpful:</p>
<ul>
<li>"Mathematical Logic" (by Ebbinghaus, Flum, and Thomas)</li>
<li>"A Mathematical Introduction to Logic" (by Enderton)</li>
</ul>
</blockquote>
<p>I will check them out, thank you. PDFs are always appreciated but I can google for them. Thanks <span aria-label="pray" class="emoji emoji-1f64f" role="img" title="pray">:pray:</span></p>



<a name="431649794"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431649794" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431649794">(Apr 06 2024 at 07:27)</a>:</h4>
<p><span class="user-mention" data-user-id="699750">@Julius Hamilton</span> - I agree with many of your criticisms of the Wikipedia article "First-order logic", though I'm not sure I'll have the energy to rewrite the introduction.</p>
<p>I hadn't bothered looking at the introduction, since my big concern was whether the article gives a precise specification of some fairly common version of first-order logic... which it attempts to do later on.</p>



<a name="431649842"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431649842" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431649842">(Apr 06 2024 at 07:28)</a>:</h4>
<p>But of course for many readers the introduction is the most important part.</p>



<a name="431650488"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431650488" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431650488">(Apr 06 2024 at 07:39)</a>:</h4>
<p>I agree with <span class="user-mention" data-user-id="277503">@David Egolf</span> that anyone who really wants to learn first-order logic should read a book or take a course.  I was really into logic as a kid so in high school I took a college course based on Kleene's <em>Mathematical Logic</em>, which is good.  But the book by Enderton is also good and I bet the other book David recommended is also good.   For logic one thing you need is a systematic careful treatment, and a well-written book can do that far better than any article thrown together by a bunch of people.</p>



<a name="431686354"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431686354" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431686354">(Apr 06 2024 at 16:24)</a>:</h4>
<p><a href="https://link.springer.com/book/10.1007/978-3-030-73839-6">Ebbinghaus</a> seems to be right where I am. I’m at a point where I would appreciate its content a lot more now. Thank you David.</p>



<a name="431687941"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431687941" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431687941">(Apr 06 2024 at 16:51)</a>:</h4>
<p><a href="/user_uploads/21317/-ux0IkauacXNIa4v5PNKtnUd/Graduate-Texts-in-Mathematics-Heinz-Dieter-Ebbinghaus-Jörg-Flum-Wolfgang-Thomas-Mathematical-Logic-Springer-Nature-Switzerland-2021.pdf">(Graduate Texts in Mathematics) Heinz-Dieter Ebbinghaus, Jörg Flum, Wolfgang Thomas - Mathematical Logic-Springer Nature Switzerland (2021).pdf</a></p>



<a name="431688029"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431688029" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431688029">(Apr 06 2024 at 16:52)</a>:</h4>
<p><a href="/user_uploads/21317/oBSNeiwTGjII-9twJqvp735R/Stewart-Shapiro_-William-J.-Wainwright-The-Oxford-Handbook-of-Philosophy-of-Mathematics-and-Logic-OUP-USA-2005.pdf">Stewart Shapiro_ William J. Wainwright - The Oxford Handbook of Philosophy of Mathematics and Logic-OUP USA (2005).pdf</a></p>



<a name="431688450"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431688450" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431688450">(Apr 06 2024 at 16:58)</a>:</h4>
<p>Now that I have more free time, being unemployed, I do try to state a “goal” in my mathematical learning for my day. Today, I will try to study Ebbinghaus, to get enough contextualization for my thoughts about logic, to return to my question of “enumerating properties of categories”, which in turn was part of my desire to understand the “significance” of terminal objects in a new light.</p>



<a name="431696872"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431696872" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vincent R.B. Blazy <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431696872">(Apr 06 2024 at 18:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="699750">Julius Hamilton</span> <a href="#narrow/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories/near/431627743">said</a>:</p>
<blockquote>
<p>5 first-order “functions”:<br>
$=_{Ob}(x : Objects, y : Objects, z : truthvalues)$<br>
$=_{Arr}(x : Arrows, y : Arrows, z : truthvalues)$<br>
$Dom(x : Objects, y : Arrows, z : truthvalues)$<br>
$Cod(x : Objects, y : Arrows, z : truthvalues)$<br>
$\circ(x : Arrows, y : Arrows)$</p>
<p>(Possibly 2nd-order functions are logical connectives like “and”. The problem here is I haven’t defined my functions to have a “return type”, so maybe I have to start over in that regard.)</p>
<p>(Note that these are “syntactic” functions - they just form new syntactic units, by plugging in a specific value into the variables.)</p>
</blockquote>
<p>I’m really not sure why you distinguish function/predicate symbols this peculiar way. Usually, either what (intuitively or semantically) returns or is mappable to truth values is presented (at least in the first-order case) as <em>formula</em> (exo)formers from terms, that is predicate or relation symbols such as equalities here, with no mention of T.V. in the syntax.<br>
And <em>term</em> formers from terms or endoformers of terms as I call them in the big picture of syntax, aka function symbols, are presented again without any truth value involved… Since it’s syntax (even semantics is syntax when formalized, as you mentioned to be interested in, but let’s focus on syntax itself).</p>
<p>Or, predicate symbols may be presented as function symbols into an extra sort of truth values (and then the only remaining actual predicate symbol is equality). But as a codomain not another domain? <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span><br>
Conversely, indeed function symbols may be presented as predicate ones, since conceptually functions are functional relations. But then they are formulæ - not term - formers, and the only terms are variables, and no formula is closed without quantifier.</p>
<p>But you, seem to more or less mix them both so weirdly to me: why is $\circ$ the only actual function symbol, when cod and dom should also construct terms for objects just as $\circ$ does for arrows? The T.V. could account for partiality… But they precisely are the total ones when $\circ$ is the partial one (at least in some actual formalization of cat theory, as an essentially algebraic theory)?</p>
<p>Sorry, but I’m lost… <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span><span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="431697173"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431697173" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431697173">(Apr 06 2024 at 18:56)</a>:</h4>
<p>It’s ok - this is exactly the kind of response I want. Seems like you know a lot about this. I’ll read through your response soon when I have a second. Thanks <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="431805696"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/431805696" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#431805696">(Apr 07 2024 at 18:51)</a>:</h4>
<p>Basically, <strong>this</strong> is what I was looking for: <a href="https://arxiv.org/pdf/1210.2610.pdf">https://arxiv.org/pdf/1210.2610.pdf</a></p>
<p>They provide an explicit algorithm for generating all expressions of lambda calculus (which is Turing-complete) up to string length <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>, and also count the number of terms in each case.</p>
<p>My hope/goal for today will be to make sure I understand how to do that myself, before trying to build on that idea to enumerate “the theory of categories” if possible. I imagine that would consist of writing the axioms for categories in lambda calculus, and then enumerating all derivations from them.</p>
<p>I am pretty sure Andrej Bauer’s <a href="https://math.andrej.com/2011/01/22/alg/">Alg</a> does this, which I have been eyeing for a while now.</p>
<p>That said, should probably focus on job-hunting so I don’t run out of money.</p>



<a name="433257498"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433257498" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vincent R.B. Blazy <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433257498">(Apr 15 2024 at 10:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="699750">Julius Hamilton</span> Oh okay, so for algorithmics and combinatorics of the syntax of FOL! Ok then, that seems to need nothing different than how this syntax is currently presented… And different syntax would give different answers anyway <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>
<p>For naked categories it would be the generalized or essentially algebraic theory of a category — or, outright ET2CC — with or without λ-terms as a systematic grammar of higher-order functional terms (a mono-sorted simple type theory) or of first-order symbols of functions (in which case their syntactic structural construction is meta), indeed.</p>
<p><em>Alg</em> doesn’t enumerate theorems but finite models of some theory… I’m not sure how one could, even potentially, be reducible to the other one <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>
<p>All the best for your hunt… I’ll go back to that soon too <span aria-label="smiling face with tear" class="emoji emoji-1f972" role="img" title="smiling face with tear">:smiling_face_with_tear:</span></p>



<a name="433271348"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433271348" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433271348">(Apr 15 2024 at 12:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="492072">Vincent R.B. Blazy</span> <a href="#narrow/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories/near/433257498">said</a>:</p>
<blockquote>
<p><em>Alg</em> doesn’t enumerate theorems but finite models of some theory… I’m not sure how one could even potentially be reducible to the other one</p>
</blockquote>
<p>Alg enumerates all the <em>models</em> of a theory? That is to say, since there are countably infinite models of ZFC, it could enumerate the models?</p>
<p>But how does it achieve enumerating even <em>one</em> of the models? A “model” is just something for which the “theory” holds true. If we enumerate all the theorems of the theory, what is the difference between that, and a “model” of the theory?</p>



<a name="433303254"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433303254" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433303254">(Apr 15 2024 at 14:17)</a>:</h4>
<p>Theorems are about syntax: they are the sentences which can be proved using the axioms  of your chosen theory.  Models are a completely different thing: they're about semantics.  Very <em>very</em> roughly, a model is a map sending all items of syntax in your chosen theory (variables, constants, predicates, function symbols, formulas and sentences) to what they "mean" in the world of set theory.  So you need to have set theory up and running before you can talk about models!</p>



<a name="433303543"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433303543" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433303543">(Apr 15 2024 at 14:19)</a>:</h4>
<p>A sentence is <strong>provable</strong> if you can prove it from the axioms in your theory: this is a syntactic notion, since it just involves manipulating strings of symbols.  A sentence is <strong>valid</strong> if it holds in all models of  your theory: this is a semantic notion, since it's defined using models.</p>



<a name="433303591"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433303591" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433303591">(Apr 15 2024 at 14:19)</a>:</h4>
<p>Right - but can’t we only define set theory in terms of FOL to begin with? How do we describe the “model”?</p>



<a name="433304111"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433304111" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433304111">(Apr 15 2024 at 14:21)</a>:</h4>
<p>If we start a priori with the primitive notions of first order logic, I thought we would assume there is a constant <em>c</em> in the language <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> which maps to the empty set - the empty set is the model of the symbol <em>c</em>. Everything else that we know about the universe of sets has to come from rules of inference on the axioms of ZFC.</p>



<a name="433304225"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433304225" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433304225">(Apr 15 2024 at 14:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="699750">Julius Hamilton</span> <a href="#narrow/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories/near/433303591">said</a>:</p>
<blockquote>
<p>Right - but can’t we only define set theory in terms of FOL to begin with? How do we describe the “model”?</p>
</blockquote>
<p>You can define set theory in lots of ways, but a standard one is first-order logic.  People do this, and  then  they <em>use</em> set theory to define all the concepts I was just talking about: first-order logic, sentences, axioms, variables, constants, predicates, function symbols, formulas, sentences, models, provabilty, and validity.</p>



<a name="433304529"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433304529" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433304529">(Apr 15 2024 at 14:22)</a>:</h4>
<p>That's why this subject is called "metamathematics": we are using mathematics (our starting-point set theory, defined using first-order logic) to study mathematics (for example first-order logic).</p>



<a name="433304746"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433304746" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433304746">(Apr 15 2024 at 14:23)</a>:</h4>
<p>So when someone says “syntax and semantics”, they actually just mean “metatheory and theory”. Right?</p>



<a name="433304781"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433304781" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433304781">(Apr 15 2024 at 14:23)</a>:</h4>
<p>No.</p>



<a name="433304942"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433304942" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433304942">(Apr 15 2024 at 14:24)</a>:</h4>
<p>I really urge reading a good book or two on logic.</p>



<a name="433305955"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433305955" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433305955">(Apr 15 2024 at 14:28)</a>:</h4>
<p>I can roughly explain ideas: e.g. I wrote a paragraph explaining the difference between syntax and semantics, and I'm not sure it sunk in.   But a paragraph-long sketch is not the same as a careful treatment from a book.</p>



<a name="433310390"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433310390" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vincent R.B. Blazy <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433310390">(Apr 15 2024 at 14:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="699750">Julius Hamilton</span> <a href="#narrow/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories/near/433271348">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="492072">Vincent R.B. Blazy</span> <a href="#narrow/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories/near/433257498">said</a>:</p>
<blockquote>
<p><em>Alg</em> doesn’t enumerate theorems but finite models of some theory… I’m not sure how one could even potentially be reducible to the other one</p>
</blockquote>
<p>Alg enumerates all the <em>models</em> of a theory? That is to say, since there are countably infinite models of ZFC, it could enumerate the models?</p>
<p>But how does it achieve enumerating even <em>one</em> of the models? A “model” is just something for which the “theory” holds true. If we enumerate all the theorems of the theory, what is the difference between that, and a “model” of the theory?</p>
</blockquote>
<p>The key-word here is <em>finite</em> <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="433312840"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433312840" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433312840">(Apr 15 2024 at 14:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="492072">Vincent R.B. Blazy</span> <a href="#narrow/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories/near/433310390">said</a>:</p>
<blockquote>
<p>The key-word here is <em>finite</em> <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>
</blockquote>
<p>This remark fixes one confusion Julius was having: you said Alg enumerates all the <em>finite</em> models of a theory and he asked how it enumerates <em>all</em> the models of a theory.  But it doesn't fix another: he apparently didn't know the difference between the models of a theory and the <em>theorems</em> of a theory:</p>
<blockquote>
<p>If we enumerate all the theorems of the theory, what is the difference between that, and a “model” of the theory?</p>
</blockquote>
<p>So I think he needs to understand 1) what's a model of a theory, and 2) what's a finite model of a theory before he can understand what it means for a piece of software to enumerate all finite models of a theory.</p>



<a name="433314184"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433314184" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433314184">(Apr 15 2024 at 14:59)</a>:</h4>
<p>That's why I tried to sketch out the concept of "model".  The explanation in the Stanford Encyclopedia of Philosophy article <a href="https://plato.stanford.edu/entries/modeltheory-fo/">model theory</a> sort of sucks because it precisely explains what a <em>structure</em> for a <em>signature</em> is, but then seems to lose interest before getting to the point: when is a structure for a signature a <em>model</em> for a <em>theory!</em>   That's right, the article on model theory doesn't come out and say what a model of a theory is.   (It says in an off-hand way what it means for a signature to be a model of a given sentence, and we can squeak by with that if necessary, but it doesn't put the defined term in italics, so it's easy to miss.)</p>
<p>The Wikipedia article "First-order logic" <em>does</em> say what a model is, in the section <a href="https://en.wikipedia.org/wiki/First-order_logic#First-order_theories,_models,_and_elementary_classes">First-order theories, models, and elementary classes</a>.   But you definitely have to read and understand most of the article up to that point to follow that definition: you need to know what a <br>
"structure" is, and what are the "sentences in a theory".</p>



<a name="433314969"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433314969" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433314969">(Apr 15 2024 at 15:02)</a>:</h4>
<p>That’s good to know. Philosophy Stack Exchange relies on the SEP heavily.</p>
<p>I will read this section of this book today (Ebbinghaus) <a href="/user_uploads/21317/vT0BWj5rDiZ1C_MGDfleN6-O/B267D4F6-FC69-4DA6-97AB-3A94DE774CDD.png">B267D4F6-FC69-4DA6-97AB-3A94DE774CDD.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/21317/vT0BWj5rDiZ1C_MGDfleN6-O/B267D4F6-FC69-4DA6-97AB-3A94DE774CDD.png" title="B267D4F6-FC69-4DA6-97AB-3A94DE774CDD.png"><img src="/user_uploads/21317/vT0BWj5rDiZ1C_MGDfleN6-O/B267D4F6-FC69-4DA6-97AB-3A94DE774CDD.png"></a></div><p>I am trying to write up a little bit right now though about my view on “soundness”.</p>



<a name="433316547"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433316547" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433316547">(Apr 15 2024 at 15:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="699750">Julius Hamilton</span> <a href="#narrow/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories/near/433314969">said</a>:</p>
<blockquote>
<p>That’s good to know. Philosophy Stack Exchange relies on the SEP heavily.</p>
<p>I will read this section of this book today (Ebbinghaus).</p>
</blockquote>
<p>Good - I don't know that book, but it looks like he explains syntax and semantics.  I can't tell if he defines models.   He defines "satisfaction", which gets close.</p>



<a name="433318354"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433318354" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vincent R.B. Blazy <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433318354">(Apr 15 2024 at 15:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="699750">Julius Hamilton</span> <a href="#narrow/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories/near/433303591">said</a>:</p>
<blockquote>
<p>Right - but can’t we only define set theory in terms of FOL to begin with? How do we describe the “model”?</p>
<p>If we start a priori with the primitive notions of first order logic, I thought we would assume there is a constant <em>c</em> in the language $L$ which maps to the empty set - the empty set is the model of the symbol <em>c</em>. Everything else that we know about the universe of sets has to come from rules of inference on the axioms of ZFC.</p>
</blockquote>
<p>To answer as I’d have but taking into account John’s one:<br>
Models can be taken into set theories (or other ones), independently of the fact that those can themselves be FOL theories:<br>
1/Metamathematically — that is, for me, syntactically outside of any specific theory — models or interpretations are formally (meta)definable maps (typically, computable ones) from the syntax one some <em>source</em> theory to <em>the one of another target one</em>, preserving provability: they can perfectly both be based on FOL, or even be the same one! Even if that would often mean loosing the intuition of "meaning in another, actual and better-understood world".<br>
2/One can always mathematize any metamathematics by encoding, internalizing it into the mathematical language of some particular theory, and then defining and proving in it as John describes. That’s conceptually interesting, way more powerful, and useful too; even if that chosen theory may perfectly, at least a priori, lie/be wrong about what it thinks true or not of the actual syntax: it’s limited to only talk internally about its coded version. <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span> In that framework, models of a theory — which is now a mathematical object, an abstract individual such as some set, formally defined inside a fixed set theory — are also internal objects such as set-theoretic functions or tuples; and the fact that the <em>object</em> "theory" may be in FOL doesn’t either impact its encodability or not into another, FOL or not, theory — here often called <em>meta</em>theory, even if it's a normal theory (or even an encoded one, if the game is mis en abîme even further) just relatively and locally "meta".</p>
<p>To continue with your example, your <em>c</em> is usually noted <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\emptyset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">∅</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex">{}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;"></span><span class="mord"></span></span></span></span>. <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span> But there are models of set theories studied, usually into other extended set theories, though not only.</p>
<p>So to sum up, syntax and semantics are provability respectively direct or after (the diverse ways of) mapping it into another one, and they both may be metamath or math (at least as far as I see the picture).</p>



<a name="433318761"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433318761" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vincent R.B. Blazy <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433318761">(Apr 15 2024 at 15:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="275920">John Baez</span> <a href="#narrow/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories/near/433312840">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="492072">Vincent R.B. Blazy</span> <a href="#narrow/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories/near/433310390">said</a>:</p>
<blockquote>
<p>The key-word here is <em>finite</em> <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>
</blockquote>
<p>This remark fixes one confusion Julius was having: you said Alg enumerates all the <em>finite</em> models of a theory and he asked how it enumerates <em>all</em> the models of a theory.  But it doesn't fix another: he apparently didn't know the difference between the models of a theory and the <em>theorems</em> of a theory:</p>
<blockquote>
<p>If we enumerate all the theorems of the theory, what is the difference between that, and a “model” of the theory?</p>
</blockquote>
<p>So I think he needs to understand 1) what's a model of a theory, and 2) what's a finite model of a theory before he can understand what it means for a piece of software to enumerate all finite models of a theory.</p>
</blockquote>
<p>Yes indeed, thanks, hence my second, longer answer, hopefully clarifying a bit syntax and semantics <span aria-label="blush" class="emoji emoji-1f60a" role="img" title="blush">:blush:</span></p>



<a name="433323014"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433323014" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433323014">(Apr 15 2024 at 15:34)</a>:</h4>
<p>Just wanted to state my current understanding of first-order logic, before I read:</p>
<p>We can start out with a single symbol, and with a successor function, generate an alphabet of distinct symbols.</p>
<p>We can then classify the symbols into groups, depending on how we will use them. Some are constants, some are variables, some are functions, some are predicates, some are quantifiers, some are logical connectives, and some are punctuation (the latter of which I believe we could do without).</p>
<p>Let’s call variables and constants “terms”. Intuitively, they represent some <em>things</em> in a domain of discourse. A function applied to a term is considered a new term. This means that we pre-assume there is a little bit more structure in the domain of discourse than just a “collection of things” - there are ways to relate them to each other.</p>
<p>A predicate is like a function, except it takes terms and returns a type called a <em>proposition</em>. (A predicate applied to a term is more normally called a “formula”).</p>
<p>Quantifiers are basically functions: they take propositions (formula) and return a truth value of 0 or 1.</p>
<p>Logical connectives are like functions, but they take truth values and return truth values. </p>
<p>So we have a hierarchy of types: terms <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> formula <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> Boolean values.</p>
<p>There are two main classes of “formation rules”. From terms we can construct new terms. From formula we can construct new formula. The rules tell us precisely under what conditions we may do so and in what way.</p>
<p>Imagine a theory of only one rule, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">R1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">1</span></span></span></span>. It says “from any formulae of <em>this</em> form, construct a new formula of <em>that</em> form.”</p>
<p>Conventionally, you do not actually evaluate formula to be true or false. Actually, if a formula is derived, it implies it is true. If one writes, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">\forall x f(x) = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>, they mean “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">\forall x f(x) = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> <em>is true</em>”. To say it is false, they can simply append the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi></mrow><annotation encoding="application/x-tex">\neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">¬</span></span></span></span> operator to it.</p>
<p>If we had 2 formula, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, consider if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">R1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">1</span></span></span></span> says you can construct formula <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∧</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \wedge B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>. Then we can say <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo>⊢</mo><mi>A</mi><mo>∧</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A, B \vdash A \wedge B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>. That means, “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∧</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \wedge B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is provable from axioms/assumptions <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.”</p>
<p>Here is the drop-off in my understanding. People say a theory is “unsound” if it can prove things that are not true. In the example above, with reference to <em>what</em> could we possible say <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∧</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \wedge B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is not actually true? </p>
<p>It’s as if we have to cross-reference 2 formal theories with each other to see if they “match up”. </p>
<p>In order for me to say “it is not the case that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> actually implies <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∧</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \wedge B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>”, it requires me to “define a semantics” for these symbolic expressions. Sure. But what should it be?</p>
<p>If I decide, “well, with recourse to the axioms of FOL”, then that is circular.</p>
<p>If I say, “well, with recourse to a different formal system than FOL”, then I feel that’s what I’m getting at: the “semantics” have to just be “some other formal system”. </p>
<p>So there is no deep difference between “syntax” and “semantics”. It’s just “syntax” and “syntax”.</p>
<p>I know I’m wrong, just stating my view before I begin reading. <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="433323209"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433323209" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433323209">(Apr 15 2024 at 15:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="492072">Vincent R.B. Blazy</span> <a href="#narrow/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories/near/433318354">said</a>:</p>
<div class="codehilite"><pre><span></span><code>So to sum up, syntax and semantics are provability respectively direct or after (the diverse ways of) mapping it into another one, and they both may be metamath or math (at least as far as I see the picture).
</code></pre></div>
<p>Thanks - I’ll respond to this soon.</p>



<a name="433327836"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433327836" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433327836">(Apr 15 2024 at 15:55)</a>:</h4>
<p><span class="user-mention" data-user-id="699750">@Julius Hamilton</span> wrote:</p>
<blockquote>
<p>Here is the drop-off in my understanding. People say a theory is “unsound” if it can prove things that are not true.</p>
</blockquote>
<p>There are a lot of things to correct in what you wrote, but I'll just note that this is <em>not</em> the definition of "unsound".  The word "truth" never appears in a serious way in mathematical logic - we sometimes use it informally, but not in a serious definition like this.  The whole point of modern mathematical logic is renouncing the metaphysical concept of truth and trying to replace it with concepts that are precise enough to prove theorems about.</p>
<p>The two more important replacements for "truth"are <em>provability</em> and <em>validity</em>.   I explained, probably too briefly, the all-important difference between provability and validity of sentences, given a theory in first-order logic:</p>
<blockquote>
<p>A sentence is <strong>provable</strong> if you can prove it from the axioms in your theory: this is a syntactic notion, since it just involves manipulating strings of symbols.  A sentence is <strong>valid</strong> if it holds in all models of  your theory: this is a semantic notion, since it's defined using models.</p>
</blockquote>
<p>We say first-order logic is <strong>sound</strong> because for every theory in first-order logic, any sentence is valid if it's provable.    The soundness of first-order logic is a theorem!</p>
<p>Goedel's completeness theorem states the converse:  for every theory in first-order logic, any sentence is provable if it's valid.</p>
<p>Taken together these two theorems are the crucial link between syntax and semantics for first-order logic.</p>



<a name="433328591"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433328591" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433328591">(Apr 15 2024 at 15:58)</a>:</h4>
<p>When we understand these theorems well, we can relax a little about the difference between provability and validity for first-order logic.  But these theorems are not trivial to prove - especially the completeness theorem.</p>



<a name="433378596"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433378596" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433378596">(Apr 15 2024 at 20:16)</a>:</h4>
<p>Ok.<br>
According to Ebbinghaus, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> is a set of symbols, an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>-structure <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> is a pair <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A, a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is a set called a domain, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> is a map. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> maps relation symbols in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> to actual relations on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, function symbols in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> to actual functions on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, and constant symbols to actual elements in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.</p>
<p>An <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>-assignment is an additional map for all the variable symbols in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> to elements of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.</p>
<p>An <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>-interpretation is a pair - a structure, and an assignment.</p>
<p>In other words, the “semantics” for a formal system require you to designate more specifically what set the variables range over, what elements the constant symbols actually refer to, what the nature of the functions in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> are, and concrete definitions (on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>) for all the relations in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>, too.</p>
<p>A common simple theory is the theory of equivalence relations: (symmetry, reflexivity, transitivity). These are axioms. A structure that might satisfy them would be an equivalence relation on integers. An assignment would amount to choosing basically 3 integers to plug into the axioms: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>=</mo><mn>2</mn><mo>→</mo><mn>2</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1=2 \to 2=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>=</mo><mn>2</mn><mo>∧</mo><mn>2</mn><mo>=</mo><mn>3</mn><mo>→</mo><mn>1</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">1=2 \wedge 2=3 \to 1=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>. An interpretation is just a structure and an assignment simultaneously. </p>
<p>I am not sure if my previous example is a model of the theory of equivalence relations or not. I chose a structure (the set of integers, with their notion of equality), and a variable assignment. The second axiom does not say “1=2”, but rather, “if 1 equaled 2, then 2 would equal 1”. </p>
<p><strong>I would say I’m confused about the definition of the satisfaction relation</strong>.</p>
<p>On the next page they define the semantic idea of consequence as opposed to the syntactic idea of provability, which seems to be what I’ve been looking for. The idea is that a formula is a consequence of a set of formula if every model of that set of formula is also a model of that formula. In other words, you would never have that set of formula without also having that specific formula.</p>
<p><a href="/user_uploads/21317/o19d__S8ykDGdKpb0-PbN0Xz/766D862E-F1BF-4421-959D-A1BFE6BE1358.png">766D862E-F1BF-4421-959D-A1BFE6BE1358.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/21317/o19d__S8ykDGdKpb0-PbN0Xz/766D862E-F1BF-4421-959D-A1BFE6BE1358.png" title="766D862E-F1BF-4421-959D-A1BFE6BE1358.png"><img src="/user_uploads/21317/o19d__S8ykDGdKpb0-PbN0Xz/766D862E-F1BF-4421-959D-A1BFE6BE1358.png"></a></div><p><a href="/user_uploads/21317/axOTsEJ6q9jFVmkt_8tgA5Ft/CEB02869-76D9-490F-A0AF-C0F2084F2221.png">CEB02869-76D9-490F-A0AF-C0F2084F2221.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/21317/axOTsEJ6q9jFVmkt_8tgA5Ft/CEB02869-76D9-490F-A0AF-C0F2084F2221.png" title="CEB02869-76D9-490F-A0AF-C0F2084F2221.png"><img src="/user_uploads/21317/axOTsEJ6q9jFVmkt_8tgA5Ft/CEB02869-76D9-490F-A0AF-C0F2084F2221.png"></a></div>



<a name="433384933"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433384933" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433384933">(Apr 15 2024 at 20:55)</a>:</h4>
<p>I think I understand. “Satisfies” is trivial. Take a collection of symbols. Simply decide what they mean, ie, in what mathematical structure they are interpreted in. Check if they are true.</p>
<p>My interpretation of a theory of equivalence is indeed a model. A way to find an interpretation that is not a model would be to use some relation that is known to not be an equivalence relation. For example, if I keep the equivalence relation axioms, but I interpret the relation symbol <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> as the well-known “less than” operator on integers, the axioms fail: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0 &lt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> is false. It’s an interpretation, but it’s not a model.</p>
<p>What I find odd so far is that a model requires a variable assignment. I thought a model of equality on integers would be the set of all integers, and the standard notion of equality. According to this, you have to choose 3 integers as variables <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x, y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>.</p>



<a name="433406348"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433406348" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433406348">(Apr 15 2024 at 23:26)</a>:</h4>
<p>Where does Ebbinghaus say a model requires a variable assignment?  I'd like to see this, to see exactly what he's up to.</p>



<a name="433410786"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433410786" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433410786">(Apr 16 2024 at 00:06)</a>:</h4>
<p><a href="/user_uploads/21317/fSOgcF2G-F0axZexZKczRp6g/67CBF84F-9566-4CE8-9369-ACB9A8B398A0.png">67CBF84F-9566-4CE8-9369-ACB9A8B398A0.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/21317/fSOgcF2G-F0axZexZKczRp6g/67CBF84F-9566-4CE8-9369-ACB9A8B398A0.png" title="67CBF84F-9566-4CE8-9369-ACB9A8B398A0.png"><img src="/user_uploads/21317/fSOgcF2G-F0axZexZKczRp6g/67CBF84F-9566-4CE8-9369-ACB9A8B398A0.png"></a></div><p><a href="/user_uploads/21317/WYs63KBV_5zHFSP9cERQZ9T9/52C3DF4F-2079-4E1C-8E9D-C8076E29343C.png">52C3DF4F-2079-4E1C-8E9D-C8076E29343C.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/21317/WYs63KBV_5zHFSP9cERQZ9T9/52C3DF4F-2079-4E1C-8E9D-C8076E29343C.png" title="52C3DF4F-2079-4E1C-8E9D-C8076E29343C.png"><img src="/user_uploads/21317/WYs63KBV_5zHFSP9cERQZ9T9/52C3DF4F-2079-4E1C-8E9D-C8076E29343C.png"></a></div><p><a href="/user_uploads/21317/cNnyYB5CuevJ-zGbAjddBe3a/943EC761-C7A6-49BB-98D4-3BED59A513F4.png">943EC761-C7A6-49BB-98D4-3BED59A513F4.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/21317/cNnyYB5CuevJ-zGbAjddBe3a/943EC761-C7A6-49BB-98D4-3BED59A513F4.png" title="943EC761-C7A6-49BB-98D4-3BED59A513F4.png"><img src="/user_uploads/21317/cNnyYB5CuevJ-zGbAjddBe3a/943EC761-C7A6-49BB-98D4-3BED59A513F4.png"></a></div><p><a href="/user_uploads/21317/cinUsS6rZvRlREVQJjv7va0V/D69E16A2-2E5A-4660-8555-7418A9FA12F4.png">D69E16A2-2E5A-4660-8555-7418A9FA12F4.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/21317/cinUsS6rZvRlREVQJjv7va0V/D69E16A2-2E5A-4660-8555-7418A9FA12F4.png" title="D69E16A2-2E5A-4660-8555-7418A9FA12F4.png"><img src="/user_uploads/21317/cinUsS6rZvRlREVQJjv7va0V/D69E16A2-2E5A-4660-8555-7418A9FA12F4.png"></a></div><p>I see now, that he says an “arbitrary” interpretation. So the “assignment” could be over any of the elements of domain <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, rather than choosing specific ones as I thought.</p>
<p>I feel like the idea is that the syntax has no connection to the semantics. There is no way to know if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo>⊨</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">J \vDash \phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6922em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊨</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span>. A human has to just decide that they feel it holds. Or they have to decide it holds in reference to some other mathematical system.</p>



<a name="433471749"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433471749" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433471749">(Apr 16 2024 at 08:44)</a>:</h4>
<p>Thanks for showing me Ebbinghaus' definition of 'model'.  You said it requires a 'variable assignment', so I thought you meant a model assigns to each variable an element of the domain <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.  But no - much to my relief, it does not.   </p>
<p>I guess you already got this, but anyway:</p>
<p>A model, or more generally a 'structure', does assign to each <em>constant</em> an element of the domain <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.  It also does more.    But it does not assign to each variable an element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>. </p>
<p>Then Ebbinghaus introduces a concept he officially calls an <strong>assignment</strong>, on top of a structure, which assigns to each <em>variable</em> an element of the domain <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.   He defines a <strong>interpretation</strong> to be a structure together with an assignment.</p>
<p>This is more terminology than I usually carry in my head for this branch of logic, but it seems okay.  We need assignments so we can see which sentences in a model are 'satisfied'.    </p>
<p>For example if we have a sentence </p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mtext> </mtext><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \forall x \, P(x) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></p>
<p>a 'structure' will need to choose a set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> to be the 'domain' and a 1-ary relation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>.   An 'interpretation' will need to do all that and also choose an 'assignment': an element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> for the variable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>.  </p>
<p>Then we say the above sentence is 'satisfied' if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> holds for <em>all</em> interpretations.   And clearly it won't be.   But the sentence</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mtext> </mtext><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∨</mo><mi mathvariant="normal">¬</mi><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \forall x \, P(x) \vee \neg P(x) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></p>
<p>will be satisfied.</p>



<a name="433473142"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433473142" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433473142">(Apr 16 2024 at 08:53)</a>:</h4>
<blockquote>
<p>I feel like the idea is that the syntax has no connection to the semantics. There is no way to know if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo>⊨</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">J \vDash \phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6922em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊨</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span>. A human has to just decide that they feel it holds. Or they have to decide it holds in reference to some other mathematical system.</p>
</blockquote>
<p>I think "just has to decide that they feel it holds" is going way overboard with the subjectivity of it all.  Your last sentence is more accurate.   In the material we're reading, Ebbinghaus is building up the theory of semantics in the usual way we develop math: by definitions, theorems, etc.    If we want, we can do all of this very formally, in your favorite set theory.    But what Ebbinghaus is doing - mathematical English that can be translated into formal mathematics - is a lot easier to read if you're trying to <em>learn</em> this stuff.</p>



<a name="433531444"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433531444" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433531444">(Apr 16 2024 at 14:09)</a>:</h4>
<p>Thanks.</p>
<p>The highlighted section is what I have been trying to express. If you say the notion of truth in the domain of semantics is not formal but psychological, you are sort of renouncing “formalism” as the true basis of mathematical truth. But if you think truth in the domain of the semantics has to be formally established, then you have the problem that you are trying to validate a formal system (the syntax of first order logic as being “reliable”) by checking if it “mirrors” a second formal system (say, an axiomitization of set theory). Does the second formal system need to be checked relative to a third formal system, or should we accept that it doesn’t make sense to do this at all, and just stick to one formal system? I’ll see what I think after reading this chapter. <a href="/user_uploads/21317/BD-gP4FqYvbqPD_kyB0qqNAI/7D510603-3B3E-4753-B7A2-2EF9EFB144ED.png">7D510603-3B3E-4753-B7A2-2EF9EFB144ED.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/21317/BD-gP4FqYvbqPD_kyB0qqNAI/7D510603-3B3E-4753-B7A2-2EF9EFB144ED.png" title="7D510603-3B3E-4753-B7A2-2EF9EFB144ED.png"><img src="/user_uploads/21317/BD-gP4FqYvbqPD_kyB0qqNAI/7D510603-3B3E-4753-B7A2-2EF9EFB144ED.png"></a></div>



<a name="433531958"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433531958" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433531958">(Apr 16 2024 at 14:11)</a>:</h4>
<p>He explicitly distinguishes between “formal proof” and “mathematical proof”, and that’s the crux, to me - to understand how that distinction can be made valid.</p>



<a name="433535637"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433535637" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius Hamilton <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433535637">(Apr 16 2024 at 14:29)</a>:</h4>
<p>This is my problem:</p>
<p><a href="/user_uploads/21317/CH0Lj0tRdV7HQPjzzmgN_-Bt/7AC0B2C2-4A25-4332-A847-1FB9729CB128.png">7AC0B2C2-4A25-4332-A847-1FB9729CB128.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/21317/CH0Lj0tRdV7HQPjzzmgN_-Bt/7AC0B2C2-4A25-4332-A847-1FB9729CB128.png" title="7AC0B2C2-4A25-4332-A847-1FB9729CB128.png"><img src="/user_uploads/21317/CH0Lj0tRdV7HQPjzzmgN_-Bt/7AC0B2C2-4A25-4332-A847-1FB9729CB128.png"></a></div><p><a href="/user_uploads/21317/74xLnMzl8CAnuOhh9Dt1Jau1/C7580C25-E4CC-417A-9C5D-6A192D17624A.png">C7580C25-E4CC-417A-9C5D-6A192D17624A.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/21317/74xLnMzl8CAnuOhh9Dt1Jau1/C7580C25-E4CC-417A-9C5D-6A192D17624A.png" title="C7580C25-E4CC-417A-9C5D-6A192D17624A.png"><img src="/user_uploads/21317/74xLnMzl8CAnuOhh9Dt1Jau1/C7580C25-E4CC-417A-9C5D-6A192D17624A.png"></a></div><p>Anyone who devises a formal system ostensibly has succeeded in taking “human judgment” completely out of the equation. The syntactic formation rules are meant to be “unambiguous” - even a computer can do them.</p>
<p>To believe that your formal system actually “says something about the world” requires an epistemic leap of faith.</p>
<p>That is why I think I am looking for some kind of “intuitionistic model theory” instead.</p>



<a name="433692681"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433692681" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Morgan Rogers (he/him) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433692681">(Apr 17 2024 at 07:39)</a>:</h4>
<p>All forms of belief require an epistemic leap of faith. The reasoning principles which are considered valid by the mathematical community are socially and historically (and empirically) determined. Much work in the philosophy of logic has gone into identifying the qualities that make some rules but not others admissible and the basis for those judgements. A typical situation is that a reasoning principle that people were previously using heuristically is promoted ("reified") to a formal reasoning principle without much deeper inspection. Have you ever questioned the rules for reasoning with "and" and "or"? Certainly we see situations in CT where we can substitute those rules for others. What about modus ponens?<br>
The essential thing is that a formal system can indeed not prove the validity of an arbitrary interpretation of its own rules: in using a formal system we must always assume or prove such assertions in a meta-theory. To some extent Löb's theorem "formalises" this observation, but I've seen that theorem abused in the past...</p>



<a name="433760459"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Enumerating%20properties%20of%20categories/near/433760459" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Enumerating.20properties.20of.20categories.html#433760459">(Apr 17 2024 at 13:44)</a>:</h4>
<p>Yeah, as a kid I was very worried about certainty, how we can be sure we know things, what assumptions we need to develop mathematics, and how to avoid circularity.   It's not really anything special about me: this has been an obsession in western mathematics at least since Descartes!    In high school I took a course at a local college where we went through Kleene's <em>Mathematical Logic</em>.  Then I logic further when I went to university, working through the proof of Goedel's theorems in a painfully rigorous course with Kripke, while studying the philosophy of Ayer, Quine, Wittgenstein and other such folks on the side.   It's very interesting, but one thing you quickly learn is that</p>
<blockquote>
<p>All forms of belief require an epistemic leap of faith. </p>
</blockquote>
<p>Having spent a decade or so obsessed with this, I have had enough.   I'm not interested in certainty anymore, and I don't care how we know or  pretend to know mathematical truths.  We just muddle along... and then we die.  So I don't really much care if people study model theory using an "informal" metamathematics or an already "formalized" system - either formalized in the old sense or in the new sense of doing it with the help of Lean or Coq or something like.   I still like thinking about logic, but I treat it like other branches of math, meaning I'm willing to reason about it in all sorts of ways.</p>



<footer class="site-footer">

<hr><p>Last updated: Feb 28 2026 at 12:12 UTC</p>
This archive runs on a customization of <a href="https://github.com/zulip/zulip-archive">zulip-archive</a>
</footer>
</body>

</html>