<!DOCTYPE html>
<html>
<head>
  	<meta charset="utf-8" />
  	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
  	<meta name="viewport" content="width=device-width, initial-scale=1" />
  
<link rel="stylesheet" href="https://mattecapu.github.io/ct-zulip-archive/style.css" /><title>Locally closed cartesian categories · learning: questions · Zulip Chat Archive</title>
</head>
<body>
<header>
<a href="https://mattecapu.github.io/ct-zulip-archive" class="home-link">
        <img class="logo" src="https://zulip-avatars.s3.amazonaws.com/21317/realm/icon.png?version=3" />
        <h1>Category Theory<br/>Zulip Server<br/>Archive</h1>
        </a>
        <p>
        You're reading the public-facing archive of the <a href="https://categorytheory.zulipchat.com/">Category Theory Zulip server</a>.<br/>
        
        To join the server you need an invite. Anybody can get an invite by contacting <a href="https://matteocapucci.wordpress.com">Matteo Capucci</a> at <em>name dot surname at gmail dot com</em>.<br/>
        
        For all things related to this archive refer to the same person.
        </p>
        </header>
        <hr />
    
<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/index.html">learning: questions</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html">Locally closed cartesian categories</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com">

<a name="506206495"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/506206495" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#506206495">(Mar 17 2025 at 16:39)</a>:</h4>
<p><a href="https://mathstodon.xyz/@juli/114175592791722085">On Mastodon</a>, Juli O'Connor asked:</p>
<blockquote>
<p>Why is it usually said that the internal language of a LCCC is extensional dependent type theory (that is, dependent type theory with a rewrite rule making typal equalities judgemental), and not that the internal language of a LCCC is a dependent type theory where all equality types are propositions?</p>
<p>Like, I get that in such a setting you can assume the rewrite rule and not create any contradictions. But with the rewrite rule you have don't have decidable type checking, and without the rule you do. I mean, you're basically just left with something like Lean, where you have to explicitly rewrite over any equalities.</p>
<p>I don't know. I feel like I shied away from the undecidability of it all, but after thinking about it some more, I don't see why that part is even mentioned much. It just seems distracting compared to the actual utility of knowing that this is the internal language of an LCCC.</p>
</blockquote>



<a name="506218739"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/506218739" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ryan Wisnesky <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#506218739">(Mar 17 2025 at 17:31)</a>:</h4>
<p>To my way of thinking, to have a type of propositions at all requires a subobject classifier in the categorical model, which LCCCs do not necessarily have; without that, you can instead perform "equality reflection" to turn equalities in the type theory into equalities in the model, which makes the models extensional.</p>



<a name="506223162"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/506223162" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Madeleine Birchfield <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#506223162">(Mar 17 2025 at 17:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281326">Ryan Wisnesky</span> <a href="#narrow/channel/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories/near/506218739">said</a>:</p>
<blockquote>
<p>To my way of thinking, to have a type of propositions at all requires a subobject classifier in the categorical model, which LCCCs do not necessarily have. </p>
</blockquote>
<p>Juli O'Connor's question is not about having a type of propositions, it's about having axiom K/UIP (equalities are propositions) vs equality reflection.</p>



<a name="506241673"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/506241673" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ryan Wisnesky <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#506241673">(Mar 17 2025 at 19:21)</a>:</h4>
<p>Indeed: if you don't have a type of propositions / subobject classifer in your LCCC, you must take equality reflection as a meta-theoretic axiom to interpret equality.  If you do have a type of propositions, because say you are in a topos, then you don't need to use a meta-theoretic rule such as equality reflection, you can use an actual proposition (object level) such as K/UIP as an axiom (or not an axiom).</p>



<a name="506244523"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/506244523" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ryan Wisnesky <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#506244523">(Mar 17 2025 at 19:35)</a>:</h4>
<p>To put it another way, in my opinion the reason LCCCs are a model of extensional dependent type theory (no type Prop), rather than intensional dependent type theory (with a type Prop), is that the latter requires the structure of a sub-object classifier to interpret the type of propositions (which isn't present in an arbitrary LCCC).  Whereas the former can still interpret equalities, but not Prop itself, using equality reflection.  But maybe I'm not understanding the question, or rusty with my type theory.</p>



<a name="506245272"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/506245272" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Madeleine Birchfield <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#506245272">(Mar 17 2025 at 19:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281326">Ryan Wisnesky</span> <a href="#narrow/channel/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories/near/506244523">said</a>:</p>
<blockquote>
<p>To put it another way, in my opinion the reason LCCCs are a model of extensional dependent type theory (no type Prop), rather than intensional dependent type theory (with a type Prop)</p>
</blockquote>
<p>Intensional dependent type theories don't need to have universes or a type Prop either.</p>



<a name="506247535"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/506247535" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ryan Wisnesky <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#506247535">(Mar 17 2025 at 19:53)</a>:</h4>
<p>Ok, sure, you don't necessarily need all Props in an intensional type theory but there should at least be an identity prop; to interpret the identity prop without a sub-object classifier (such as in an LCCC) you need a rule like equality reflection.</p>



<a name="506305308"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/506305308" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> James Deikun <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#506305308">(Mar 18 2025 at 02:14)</a>:</h4>
<p>Axiom K doesn't mention a type of propositions; nor does UIP.  UIP explicitly spells out that equality types are (-1)-truncated.</p>



<a name="506525405"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/506525405" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#506525405">(Mar 18 2025 at 16:23)</a>:</h4>
<p>Correct; dependent type theory with identity types (defined by J) and UIP but no universes or subobject classifier is a perfectly good theory that can serve as an internal language for LCCCs.</p>



<a name="506525737"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/506525737" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#506525737">(Mar 18 2025 at 16:25)</a>:</h4>
<p>As to Juli's original question, I would respond: why do you think that</p>
<blockquote>
<p>it [is] usually said that the internal language of a LCCC is extensional dependent type theory</p>
</blockquote>
<p>?</p>



<a name="506527875"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/506527875" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Madeleine Birchfield <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#506527875">(Mar 18 2025 at 16:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="276777">Mike Shulman</span> <a href="#narrow/channel/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories/near/506525405">said</a>:</p>
<blockquote>
<p>Correct; dependent type theory with identity types (defined by J) and UIP but no universes or subobject classifier is a perfectly good theory that can serve as an internal language for LCCCs.</p>
</blockquote>
<p>There's also this paper which proves the equivalence of extensional type theory and intensional type theory with UIP and function extensionality</p>
<p><a href="https://www.sciencedirect.com/science/article/pii/S0304397524006686">https://www.sciencedirect.com/science/article/pii/S0304397524006686</a></p>



<a name="506528620"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/506528620" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#506528620">(Mar 18 2025 at 16:37)</a>:</h4>
<p><em>Morita</em> equivalence.</p>



<a name="506528942"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/506528942" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Madeleine Birchfield <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#506528942">(Mar 18 2025 at 16:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="276777">Mike Shulman</span> <a href="#narrow/channel/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories/near/506525737">said</a>:</p>
<blockquote>
<p>As to Juli's original question, I would respond: why do you think that</p>
<blockquote>
<p>it [is] usually said that the internal language of a LCCC is extensional dependent type theory</p>
</blockquote>
<p>?</p>
</blockquote>
<p>I wonder, how much of this confusion comes from the nLab previously using "extensional type theory" to refer to type theories with UIP? From the <a href="https://ncatlab.org/nlab/show/extensional%20type%20theory">[[extensional type theory]]</a> article:</p>
<blockquote>
<p>Note: For a while, the nLab incorrectly used “extensional type theory” to refer to what we now call set-level type theory. If you encounter uses of this sort, please correct them.</p>
</blockquote>



<a name="507454219"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/507454219" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Nicodemus <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#507454219">(Mar 22 2025 at 13:58)</a>:</h4>
<p>This is a bit of a tangent but I feel that category theory as a semantic model does not model dependent types as faithfully as we might want it to, basically because category theory does not provide a primitive and basic notion of "a family of objects parameterized by another object." For example, a basic construction in category theory is the Grothendieck construction which takes a pseudo-functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ψ</mi><mo>:</mo><msup><mi mathvariant="bold">B</mi><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup><mo>→</mo><mrow><mi mathvariant="bold">C</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">t</mi></mrow></mrow><annotation encoding="application/x-tex">\Psi : \mathbf{B}^{\rm op}\to \mathbf{Cat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Ψ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">op</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">Cat</span></span></span></span></span> and tells us how to construct a Grothendieck fibration <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mi mathvariant="bold">E</mi><mo>→</mo><mi mathvariant="bold">B</mi></mrow><annotation encoding="application/x-tex">p : \mathbf{E}\to\mathbf{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">B</span></span></span></span> from it. If one tries to state and prove such a theorem in the internal language of an elementary topos, one has to give a notion of "a family of small categories indexed by the small category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">B</mi></mrow><annotation encoding="application/x-tex">\mathbf{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">B</span></span></span></span>" which <br>
 either one cannot prove it or rather one ends up formulating it in such a way that it becomes a near-tautology.<br>
To me, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ψ</mi><mo>:</mo><msup><mi mathvariant="bold">B</mi><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup><mo>→</mo><mrow><mi mathvariant="bold">C</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">t</mi></mrow></mrow><annotation encoding="application/x-tex">\Psi : \mathbf{B}^{\rm op}\to \mathbf{Cat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Ψ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">op</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">Cat</span></span></span></span></span> is somehow a more faithful representation of the concept of "a family of categories indexed by a category" than a fibration.</p>
<p>Maybe the key point here is that in dependent type theory, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>-types are a nontrivial language feature which allows one to prove theorems analogous to what the axiom of replacement allows you to prove in set theory. But in category theory we essentially model dependent types by their corresponding <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>-type. (I understand that this is not always literally true, because in the fibrational semantics there are additional conditions that need to be satisfied.)</p>
<p>So does anyone know of any interesting models for dependent type theory where the semantics of "indexing" is different than a morphism in a category?</p>



<a name="507503433"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/507503433" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#507503433">(Mar 22 2025 at 23:34)</a>:</h4>
<p>Indeed, the way we actually interpret dependent type theory is usually by using one of the <a href="https://ncatlab.org/nlab/show/categorical%20models%20of%20dependent%20types">[[categorical models of dependent types]]</a>.</p>



<a name="507714988"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/507714988" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josselin Poiret <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#507714988">(Mar 24 2025 at 10:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="424412">Patrick Nicodemus</span> <a href="#narrow/channel/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories/near/507454219">said</a>:</p>
<blockquote>
<p>If one tries to state and prove such a theorem in the internal language of an elementary topos, one has to give a notion of "a family of small categories indexed by the small category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">B</mi></mrow><annotation encoding="application/x-tex">\mathbf{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">B</span></span></span></span>" which</p>
</blockquote>
<p>I don't think this is true: grothendieck fibrations are definitively distinct definitions from just pseudo functors into <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">C</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">t</mi></mrow><annotation encoding="application/x-tex"> \mathbf{Cat} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">Cat</span></span></span></span></span>, even using "the internal language of an elementary topos" (which I think you just mean constructive logic)</p>



<a name="507715309"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/507715309" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josselin Poiret <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#507715309">(Mar 24 2025 at 10:35)</a>:</h4>
<p>see any formalization of the two concepts in your favorite proof assistants (self-plug, you can see the definition of an opfibration in agda/cubical <a href="https://github.com/agda/cubical/blob/35d29193477fe168edfe4bff66af984068bf85e4/Cubical/Categories/Displayed/Cartesian.agda#L58">here</a>)</p>



<a name="507859121"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/507859121" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#507859121">(Mar 24 2025 at 19:23)</a>:</h4>
<p>It depends on what doctrine you take your "internal language of an elementary topos" in.  If it's a dependent type theory like Agda, then yes you can define a notion of "pseudofunctor into Cat" that's distinct from a fibration, at least if you assume some universes (which an arbitrary elementary topos doesn't have) or are willing to operate a bit at the meta-level and talk about indexed families of types without a universe to internalize them.  But the traditional internal language of an elementary topos is in the doctrine of higher-order logic, which doesn't have dependent types, so there is no real way to say "pseudofunctor into Cat".</p>



<a name="507981842"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/507981842" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Morgan Rogers (he/him) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#507981842">(Mar 25 2025 at 10:21)</a>:</h4>
<p>I remember there being a comparison between internal presheaves in the Elephant and internal discrete opfibrations over an internal category, but searching my copy for "presheaf" turns up almost no results. I hadn't noticed until now that Johnstone seems to reserve this term for the localic case.</p>



<a name="508074546"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/508074546" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Nicodemus <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#508074546">(Mar 25 2025 at 16:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284453">Josselin Poiret</span> <a href="#narrow/channel/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories/near/507714988">said</a>:</p>
<blockquote>
<p>I don't think this is true: grothendieck fibrations are definitively distinct definitions from just pseudo functors into <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">C</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">t</mi></mrow><annotation encoding="application/x-tex"> \mathbf{Cat} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">Cat</span></span></span></span></span>, even using "the internal language of an elementary topos" (which I think you just mean constructive logic)</p>
</blockquote>
<p>I can clarify. First, what Mike said is closer to what I meant. Second, when I said "it becomes a near tautology", this was a misleading statement, what I meant was that they are <em>semantically</em> very similar, if you understand the semantics of a type family<code>B : A -&gt; Type</code> as being interpreted as a projection morphism <code>pi : B -&gt; A</code> in an elementary topos, where the fibers are encodings of the type families, then the part of the Grothendieck construction which talks about the objects is semantically a truism. (If you assume a universe object in your topos, they have different semantics. This is a good semantics for a type theory where the universe itself is a type, it is incomplete semantics if you have a type theory where Type is a Kind and not a type, where Kind is a simpler and more restrictive sort than Type)</p>
<p>I think the correspondence between families of sets <code>B : A -&gt; Set</code> and projections <code>pi : B -&gt; A</code> is an interesting and nontrivial one. The ability to prove such an equivalence requires some logical strength in the underlying theory, in ZFC this is the replacement axiom. I am suggesting that it would be interesting/important to study models where it is clear how such a correspondence could fail, and the LCCC model cannot really illuminate this for us because the correspondence becomes trivial. (Similarly to how the strong extensionality properties of topos theory make it not a great fit for studying type theories which lack functional extensionality, propositional extensionality and so on.)</p>



<a name="508077998"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/508077998" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Nicodemus <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#508077998">(Mar 25 2025 at 16:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="276777">Mike Shulman</span> <a href="#narrow/channel/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories/near/507503433">said</a>:</p>
<blockquote>
<p>Indeed, the way we actually interpret dependent type theory is usually by using one of the <a href="https://ncatlab.org/nlab/show/categorical%20models%20of%20dependent%20types">[[categorical models of dependent types]]</a>.</p>
</blockquote>
<p>I am familiar with most of these models, but not all. I would have to think individually about them to see whether they satisfy my objection, because some of them are pretty close to just the fiber bundle model but with a level of indirection (e.g., for a fibration that models dependent type theory, there is often a "comprehension" functor that allows us to reflect types from the total category of the fibration into the base category of types, equipped with a projection morphism. If the base category is a category of types/objects modelling types, then this is just the fiber bundle model in different dress. If it is a category of contexts, this is is a bit better. But a "context" is not really a semantic notion so perhaps this is wandering from the point.)</p>
<p>Note that the first paragraph of the page you linked summarizes the various models in precisely the terms I am criticizing here.</p>



<a name="508085601"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/508085601" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#508085601">(Mar 25 2025 at 17:25)</a>:</h4>
<p>The introduction to that nLab page is written assuming that you're starting from a plain category in which the only notion of "family of objects" is the "fibered" one <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>:</mo><mi>B</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\pi:B\to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, and your only concern is to deal with coherence problems.  This is the practical approach, not the philosophical one, since that's the way these things usually arise in practice.  But these models are also relevant to the philosophical question, because if you're in a situation where you <em>do</em> have an "indexed" notion <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>:</mo><mi>A</mi><mo>→</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow></mrow><annotation encoding="application/x-tex">B:A\to \rm Set</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Set</span></span></span></span></span>, you can take the "comprehension operation" to be the Grothendieck construction that takes an indexed family to a fibered one.  For instance, in a CwF model, you would take <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">y</mi></mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathrm{Ty}(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">Ty</span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> to be the set of functions <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow></mrow><annotation encoding="application/x-tex">A \to \rm Set</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Set</span></span></span></span></span>, and for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>:</mo><mi>A</mi><mo>→</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow></mrow><annotation encoding="application/x-tex">B:A\to \rm Set</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Set</span></span></span></span></span> the comprehension <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo separator="true">;</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A;B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is the "total space" <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∐</mo><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow></msub><mi>B</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\coprod_{a\in A} B(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0771em;vertical-align:-0.3271em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∐</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3271em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> with its projection down to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.</p>



<a name="508089637"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/Locally%20closed%20cartesian%20categories/near/508089637" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories.html#508089637">(Mar 25 2025 at 17:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="424412">Patrick Nicodemus</span> <a href="#narrow/channel/229199-learning.3A-questions/topic/Locally.20closed.20cartesian.20categories/near/508074546">said</a>:</p>
<blockquote>
<p>The ability to prove such an equivalence requires some logical strength in the underlying theory, in ZFC this is the replacement axiom</p>
</blockquote>
<p>Whether or not that's true depends on what you mean by "a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>:</mo><mi>A</mi><mo>→</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow></mrow><annotation encoding="application/x-tex">B:A\to \rm Set</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Set</span></span></span></span></span>".  You need replacement if "a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>:</mo><mi>A</mi><mo>→</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow></mrow><annotation encoding="application/x-tex">B:A\to \rm Set</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Set</span></span></span></span></span>" means a two-variable formula <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> such that for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x\in A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> there exists a unique set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>.  But this isn't usually what people mean by "a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>:</mo><mi>A</mi><mo>→</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow></mrow><annotation encoding="application/x-tex">B:A\to \rm Set</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Set</span></span></span></span></span>", among other reasons because it's a metatheoretic object rather than a mathematical one.  If you want "a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>:</mo><mi>A</mi><mo>→</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow></mrow><annotation encoding="application/x-tex">B:A\to \rm Set</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Set</span></span></span></span></span>" to be an object of ZFC, then you have to define it to be something like a set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> of ordered pairs such that for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x\in A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> there exists a unique set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">(x,y)\in B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.  And with this definition, you don't need replacement to prove the correspondence to projections <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>:</mo><msup><mi>B</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\pi : B&#x27;\to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>; you can just define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>B</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>∣</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo>∧</mo><mi mathvariant="normal">∃</mi><mi>y</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>B</mi><mo>∧</mo><mi>z</mi><mo>∈</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">B&#x27; = \{ (x,z) \mid x\in A \land \exists y. ((x,y)\in B \land z\in y) \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∃</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">.</span><span class="mopen">((</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)}</span></span></span></span>, which doesn't need replacement to prove it is a set.</p>



<footer class="site-footer">

<hr><p>Last updated: Feb 28 2026 at 12:12 UTC</p>
This archive runs on a customization of <a href="https://github.com/zulip/zulip-archive">zulip-archive</a>
</footer>
</body>

</html>