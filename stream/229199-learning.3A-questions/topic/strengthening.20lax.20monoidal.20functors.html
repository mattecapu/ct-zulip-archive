<!DOCTYPE html>
<html>
<head>
  	<meta charset="utf-8" />
  	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
  	<meta name="viewport" content="width=device-width, initial-scale=1" />
  
<link rel="stylesheet" href="https://mattecapu.github.io/ct-zulip-archive/style.css" /><title>strengthening lax monoidal functors · learning: questions · Zulip Chat Archive</title>
</head>
<body>
<header>
<a href="https://mattecapu.github.io/ct-zulip-archive" class="home-link">
        <img class="logo" src="https://zulip-avatars.s3.amazonaws.com/21317/realm/icon.png?version=3" />
        <h1>Category Theory<br/>Zulip Server<br/>Archive</h1>
        </a>
        <p>
        You're reading the public-facing archive of the <a href="https://categorytheory.zulipchat.com/">Category Theory Zulip server</a>.<br/>
        
        To join the server you need an invite. Anybody can get an invite by contacting <a href="https://matteocapucci.wordpress.com">Matteo Capucci</a> at <em>name dot surname at gmail dot com</em>.<br/>
        
        For all things related to this archive refer to the same person.
        </p>
        </header>
        <hr />
    
<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/index.html">learning: questions</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/strengthening.20lax.20monoidal.20functors.html">strengthening lax monoidal functors</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com">

<a name="219244753"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/strengthening%20lax%20monoidal%20functors/near/219244753" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joe Moeller <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/strengthening.20lax.20monoidal.20functors.html#219244753">(Dec 08 2020 at 18:38)</a>:</h4>
<p>Does anybody know about an adjunction between SMC = [symmetric monoidal categories, symmetric monoidal functors] and SMC_lax = [symmetric monoidal categories, lax symmetric monoidal functors]? I don't have much intuition for adjoints of inclusions of wide subcategories.</p>



<a name="219245880"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/strengthening%20lax%20monoidal%20functors/near/219245880" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/strengthening.20lax.20monoidal.20functors.html#219245880">(Dec 08 2020 at 18:47)</a>:</h4>
<p>There's a left adjoint to the inclusion of SMC into SMC_lax, by Theorem 3.13 of <a href="https://www.sciencedirect.com/science/article/pii/0022404989901606">Two-dimensional monad theory</a> using the 2-monad for symmetric monoidal categories.</p>



<a name="219246146"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/strengthening%20lax%20monoidal%20functors/near/219246146" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joe Moeller <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/strengthening.20lax.20monoidal.20functors.html#219246146">(Dec 08 2020 at 18:49)</a>:</h4>
<p>Nice, this is perfect. Do you have any intuition for what the left adjoint should do?</p>



<a name="219246519"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/strengthening%20lax%20monoidal%20functors/near/219246519" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Doel <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/strengthening.20lax.20monoidal.20functors.html#219246519">(Dec 08 2020 at 18:53)</a>:</h4>
<p>Adds formal inverses to the lax arrows?</p>



<a name="219246714"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/strengthening%20lax%20monoidal%20functors/near/219246714" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/strengthening.20lax.20monoidal.20functors.html#219246714">(Dec 08 2020 at 18:54)</a>:</h4>
<p><em>Edit:</em> That would be my intuition for a right adjoint, but it's not so clear this is accurate for a left adjoint.</p>



<a name="219246732"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/strengthening%20lax%20monoidal%20functors/near/219246732" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joe Moeller <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/strengthening.20lax.20monoidal.20functors.html#219246732">(Dec 08 2020 at 18:54)</a>:</h4>
<p>I think it's probably non-identity on objects.</p>



<a name="219248023"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/strengthening%20lax%20monoidal%20functors/near/219248023" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joe Moeller <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/strengthening.20lax.20monoidal.20functors.html#219248023">(Dec 08 2020 at 19:04)</a>:</h4>
<p>I'll use U for SMC-&gt;SMC_lax, which is identity on objects, and F for its left adjoint. We should get that lax monoidal functors X-&gt;UY=Y are the same as monoidal functors FX-&gt;Y. So I don't think it would do much for it to just be identity on objects and "fix" the morphisms.</p>



<a name="219250375"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/strengthening%20lax%20monoidal%20functors/near/219250375" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/strengthening.20lax.20monoidal.20functors.html#219250375">(Dec 08 2020 at 19:26)</a>:</h4>
<p>I've not thought about this before, so this may be nonsense, but here's an idea. Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi mathvariant="bold">C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(\mathbf C)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathbf">C</span><span class="mclose">)</span></span></span></span> contain <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">C</mi></mrow><annotation encoding="application/x-tex">\mathbf C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord mathbf">C</span></span></span></span> and also contain another monoidal structure <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊙</mo></mrow><annotation encoding="application/x-tex">\odot</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">⊙</span></span></span></span>, then we can add a morphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>B</mi><mo>→</mo><mi>A</mi><mo>⊙</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \otimes B \to A \odot B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊙</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> for each pair of objects in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">C</mi></mrow><annotation encoding="application/x-tex">\mathbf C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord mathbf">C</span></span></span></span>. Then a strong monoidal functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>L</mi><mo stretchy="false">(</mo><mi mathvariant="bold">C</mi><mo stretchy="false">)</mo><mo>→</mo><mi mathvariant="bold">D</mi></mrow><annotation encoding="application/x-tex">F : L(\mathbf C) \to \mathbf D</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathbf">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord mathbf">D</span></span></span></span> sends <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>F</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>F</mi><mo stretchy="false">(</mo><mi>A</mi><mo>⊗</mo><mi>B</mi><mo stretchy="false">)</mo><mo>→</mo><mi>F</mi><mo stretchy="false">(</mo><mi>A</mi><mo>⊙</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(A) \otimes F(B) \cong F(A \otimes B) \to F(A \odot B)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊙</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>, which simulates the action of a lax monoidal functor to some extent. The unit would work in the same way. Maybe this can be made more precise to properly characterise the left adjoint.</p>



<a name="219250488"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/strengthening%20lax%20monoidal%20functors/near/219250488" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/strengthening.20lax.20monoidal.20functors.html#219250488">(Dec 08 2020 at 19:27)</a>:</h4>
<p>(The left adjoint is called the "lax morphism classifier" if that helps to search for examples.)</p>



<a name="219252159"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/strengthening%20lax%20monoidal%20functors/near/219252159" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joe Moeller <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/strengthening.20lax.20monoidal.20functors.html#219252159">(Dec 08 2020 at 19:40)</a>:</h4>
<p>I have some particular cases in mind that I'll have to check that against, but it sounds good so far.</p>



<a name="219295825"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/strengthening%20lax%20monoidal%20functors/near/219295825" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Doel <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/strengthening.20lax.20monoidal.20functors.html#219295825">(Dec 09 2020 at 04:04)</a>:</h4>
<p>I see. The left adjoint needs to make a symmetric thing act like a directed thing, not vice versa.</p>



<a name="219375050"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/strengthening%20lax%20monoidal%20functors/near/219375050" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Doel <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/strengthening.20lax.20monoidal.20functors.html#219375050">(Dec 09 2020 at 18:10)</a>:</h4>
<p>I was thinking about this, and I realized the first thing I said doesn't even really make sense. Like, if that's how the right adjoint acts, you still can't just modify <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> by inverting the lax stuff for a <em>specific</em> functor. So, does a right adjoint just add formal inverses to every arrow, essentially?</p>



<a name="219376533"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/strengthening%20lax%20monoidal%20functors/near/219376533" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Doel <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/strengthening.20lax.20monoidal.20functors.html#219376533">(Dec 09 2020 at 18:20)</a>:</h4>
<p>It seems, prima facie at least, that just adding inverses might not work, because then functors in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">C</mi></mrow><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mi>K</mi><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathsf{SMC}(C,KD)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">M</span><span class="mord mathsf">C</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mclose">)</span></span></span></span> (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> being the proposed 'add formal inverses') could actually be oplax instead of lax (or some kind of mix where the tensor part is oplax but the unit is lax, or vice versa).</p>



<a name="219377007"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229199-learning%3A%20questions/topic/strengthening%20lax%20monoidal%20functors/near/219377007" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning.3A-questions/topic/strengthening.20lax.20monoidal.20functors.html#219377007">(Dec 09 2020 at 18:24)</a>:</h4>
<p>I think if a right adjoint existed, it'd have to do something like add inverses for every possible functor. But as you say, this would seem to add too many morphisms to recover an exact correspondence with lax functors: there's nothing stopping you from mapping to the formal inverses that are irrelevant for any given functor. So there should be more functors to this category with formal inverses than there are lax functors. I think, then, a right adjoint is unlikely to exist in general.</p>



<footer class="site-footer">

<hr><p>Last updated: Feb 28 2026 at 12:12 UTC</p>
This archive runs on a customization of <a href="https://github.com/zulip/zulip-archive">zulip-archive</a>
</footer>
</body>

</html>