<!DOCTYPE html>
<html>
<head>
  	<meta charset="utf-8" />
  	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
  	<meta name="viewport" content="width=device-width, initial-scale=1" />
  
<link rel="stylesheet" href="https://mattecapu.github.io/ct-zulip-archive/style.css" /><title>Programming Language Semantics · deprecated: recommendations · Zulip Chat Archive</title>
</head>
<body>
<header>
<a href="https://mattecapu.github.io/ct-zulip-archive" class="home-link">
        <img class="logo" src="https://zulip-avatars.s3.amazonaws.com/21317/realm/icon.png?version=3" />
        <h1>Category Theory<br/>Zulip Server<br/>Archive</h1>
        </a>
        <p>
        You're reading the public-facing archive of the <a href="https://categorytheory.zulipchat.com/">Category Theory Zulip server</a>.<br/>
        
        To join the server you need an invite. Anybody can get an invite by contacting <a href="https://matteocapucci.wordpress.com">Matteo Capucci</a> at <em>name dot surname at gmail dot com</em>.<br/>
        
        For all things related to this archive refer to the same person.
        </p>
        </header>
        <hr />
    
<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/index.html">deprecated: recommendations</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html">Programming Language Semantics</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com">

<a name="193710946"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/193710946" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Todd Schmid (he/they) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#193710946">(Apr 12 2020 at 12:23)</a>:</h4>
<p>I'm looking out for an intro to programming language semantics appropriate for a first/second year grad student, specifically something that covers algebraic or categorical semantics. I've heard that automata have a semantics-type role in programming language theory; is this true? If so, I'd like to know more!</p>



<a name="193712506"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/193712506" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ralph Sarkis <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#193712506">(Apr 12 2020 at 13:07)</a>:</h4>
<p>If you'd like a reading partner, I might join in. I am doing a research internship in semantics (probabilistic and non-deterministic systems with Matteo Mio) this summer, so I will have a lot of paper to read already, but I could spend some time discussing other readings with you :) How much semantics have you done already? I have course notes on parts of Principles of Model Checking by  Baier, C. and Katoen, J.-P which I found to be a good intro to semantics while mainly on the logical side (no category or algebra), it uses automata a bit.</p>



<a name="193714325"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/193714325" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Todd Schmid (he/they) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#193714325">(Apr 12 2020 at 14:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284005">Ralph Sarkis</span> I am quite new to formal computer science, but I do have a background in model theory and topos theory (I'm not sure how much this helps, yet). I have also spent the last few months with automata, proof theory, and modal logic, so I feel pretty ready to give it a go. I will check out your reference (thank you!). I sincerely would love a reading partner.</p>



<a name="193714983"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/193714983" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> James Wood <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#193714983">(Apr 12 2020 at 14:18)</a>:</h4>
<p>Programming languages is a very broad area, and likewise there are all sorts of different semanticses. What kind of programming languages/models are you interested in? In any case, I guess simply typed lambda calculus and its semantics in Cartesian closed categories (or just Set) is a good place to start. Not sure of any particular reference, though.</p>



<a name="193757911"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/193757911" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Todd Schmid (he/they) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#193757911">(Apr 13 2020 at 09:49)</a>:</h4>
<p><span class="user-mention" data-user-id="281583">@James Wood</span> I've actually spent quite a bit of time with Lambek and Scott's book, so I think the λ-calculus story (and the CHL-correspondance) isn't quite what I'm after. I had something more coalgebraic in mind, and more geared to "abstract machines", if that makes any sense. To be honest, I'm not sure exactly what I'm looking for (which is why I started this, I guess)! That being said, I imagine I'll have to learn about the μ-calculus at some point, so I also welcome suggestions in that direction.</p>



<a name="193763419"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/193763419" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ralph Sarkis <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#193763419">(Apr 13 2020 at 11:27)</a>:</h4>
<p>Another recommendation: While not strictly semantics, <a href="https://dl.acm.org/doi/10.1145/2490818" title="https://dl.acm.org/doi/10.1145/2490818">this paper</a> has been one of my favorites for a while. It uses the coalgberaic representation of automata to prove correctness of the Brzozowski's algorithm to minimize an automata. It is very basic, but they describe many different machines and the references probably have more stuff to look at in this direction.</p>
<p>(You might have read it already as Alexandra Silva is a co-author; at least three other authors are in this community :)</p>



<a name="193767053"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/193767053" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Todd Schmid (he/they) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#193767053">(Apr 13 2020 at 12:27)</a>:</h4>
<p><span class="user-mention" data-user-id="284005">@Ralph Sarkis</span>  Oh, yeah! Embarrassingly, I haven't read this paper yet, though I should probably make that a priority sooner than later. This is certainly the direction I'm going for.</p>



<a name="193782698"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/193782698" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gershom <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#193782698">(Apr 13 2020 at 15:22)</a>:</h4>
<p>The classic more rigorous texts for programming language semantics for early graduate students are Mitchell's "Foundations for Programming Languages" and Reynolds' "Theories of Programming Languages". There's also "Advanced Topics in Types and Programming Languages." None of these hit the categorical stuff at the level you'd want, I think, but they do give an overview of the field. Rutten (one of the authors of the paper above) is one of the go-to references on coalgebraic stuff.</p>
<p>For something that scratches your itch directly, you may want to look at Joyal, Nielson, Winskel's "Bisimulation from Open Maps" and then work backwards and forward from there: <a href="https://www.brics.dk/RS/94/7/BRICS-RS-94-7.pdf" title="https://www.brics.dk/RS/94/7/BRICS-RS-94-7.pdf">https://www.brics.dk/RS/94/7/BRICS-RS-94-7.pdf</a></p>



<a name="193786100"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/193786100" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Todd Schmid (he/they) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#193786100">(Apr 13 2020 at 15:54)</a>:</h4>
<p><span class="user-mention" data-user-id="276650">@Gershom</span> Thank you for all of the references! It's nice to see Joyal's name again, haha. I will have to take a look at the open maps paper.</p>



<a name="193792859"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/193792859" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#193792859">(Apr 13 2020 at 16:54)</a>:</h4>
<blockquote>
<p>Brzozowski's algorithm to minimize an automaton</p>
</blockquote>
<p>What does it mean to "minimize" an automaton.  I can guess... and I could look it up... but I'll ask anyway.</p>



<a name="193793166"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/193793166" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Doel <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#193793166">(Apr 13 2020 at 16:57)</a>:</h4>
<p>Find an automaton that does the same work, but with the fewest possible states.</p>



<a name="193793253"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/193793253" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Doel <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#193793253">(Apr 13 2020 at 16:58)</a>:</h4>
<p>'Does the same work' is rather coalgebraic.</p>
<p>Maybe that's still to vague, though. Decides the same language is the work. <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span></p>



<a name="193828637"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/193828637" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gershom <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#193828637">(Apr 13 2020 at 22:18)</a>:</h4>
<p>A bit handwavy here, but it seems pretty clear to me that Deterministic Finite Automata are in some sense a reflective subcategory of Nondeterministic Finite Automata, and there's a a lovely contraction operator called "determinization" that preserves "meaning".  What makes Brzozowski’s algorithm so beautiful is that there's an involution operator "reverse" on NFA that doesn't stay within the DFA subcategory, and the chain reverse -&gt; determinize -&gt; reverse -&gt; determinize somehow pulls you into an even tighter reflective subcategory, which is "minimal DFA". I've had the rutten, silva et. al paper on my "to read" list for a little time now, because I want to see if how they analyze it can be fitted into my handwavy intuition above. (Additionally it seems to me that "determinize" should really end up being some variant of the yoneda lemma, if one examines what the algorithm does, and I'd like to understand just that portion alone more categorically).</p>



<a name="193829284"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/193829284" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#193829284">(Apr 13 2020 at 22:24)</a>:</h4>
<p>All this sounds pretty interesting.  Trying to find the automaton with the fewest states that decides a given language sounds like a horrendously tricky problem that's not likely to have a good answer or support an interesting theory - sort of like finding the minimal presentation of a group.  But it sounds like there is something good to say about this!</p>



<a name="193833927"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/193833927" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> sarahzrf <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#193833927">(Apr 13 2020 at 23:18)</a>:</h4>
<p>man, i dont know that much about automata :/</p>



<a name="193833932"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/193833932" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> sarahzrf <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#193833932">(Apr 13 2020 at 23:18)</a>:</h4>
<p>i should fix that someday...</p>



<a name="194224913"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/194224913" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Cody Roux <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#194224913">(Apr 15 2020 at 20:45)</a>:</h4>
<p>This is definitely true in general, except that for some reason, there are algorithms for this for regular languages! Given that, and how incredibly useful such an algorithm is, it's worth trying to see if there is some general pattern. For Finite Automata, minimizing involves computing the largest possible equivalence class of a set of states, which feels nicely algebraic in nature.</p>



<a name="194237327"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/194237327" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gershom <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#194237327">(Apr 15 2020 at 22:39)</a>:</h4>
<p>I mean for finite automata, minimizing can be done by the Brzozowski algorithm I sketched above (the handwavey bit being I didn't specify the categories which make the above "reflective" characterization of it work, but the algorithm itself is a classic solid result), which is even more ridiculously algebraic, and which relates to the manes stuff about observability and reachability as duals as in the paper above-above.</p>



<a name="194288272"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/194288272" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Todd Schmid (he/they) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#194288272">(Apr 16 2020 at 11:17)</a>:</h4>
<p>I actually just finished reading the <em>Duality in Brzozowski's Minimization Algorithm</em> paper, and it seems pretty general! It works for finite automata of many different flavours. I think the algorithm is a little different than <span class="user-mention" data-user-id="276650">@Gershom</span> stated it, though: For deterministic finite automata, accepting a specific language <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>, there's a dual adjunction <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>A</mi><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo><mo>⊢</mo><mi>D</mi><msup><mi>A</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo stretchy="false">(</mo><mi>r</mi><mi>e</mi><mi>v</mi><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">DA(L) \vdash DA^{op}(rev(L))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">p</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> which swaps reachability maps for observability maps, and injective maps for surjective maps (the functor at play is the contravariant powerset functor). So, the algorithm is</p>
<ol>
<li>push the automaton across the dual adjunction,</li>
<li>take the reachable component,</li>
<li>push the new, reachable automaton across the adjunction,</li>
<li>take the reachable component.</li>
</ol>
<p>After step 1, we have a DFA on our hands that accepts the reversed language. Since the dual adjunction swaps reachability and observability, step 3 produces an observable automaton accepting <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>v</mi><mo stretchy="false">(</mo><mi>r</mi><mi>e</mi><mi>v</mi><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">rev(rev(L)) = L</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>, so taking the reachable component (step 4) produces a minimal automaton for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>. For other flavours of automaton, step 1 needs to be replaced by a determinization process that reverses the language. Is this what you were talking about <span class="user-mention" data-user-id="276650">@Gershom</span> ?</p>



<a name="194326562"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/194326562" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gershom <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#194326562">(Apr 16 2020 at 15:55)</a>:</h4>
<p>I was simply describing the classic algorithm, not the paper's treatment of it. The classic algorithm as far as I know is the four steps I describe.  I have no doubt the paper generalizes it in the way you describe.  As the paper states in the abstract, it gives not only a new proof of correctness, but a new presentation in terms of  reachability and observability.</p>



<a name="194853315"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/194853315" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gershom <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#194853315">(Apr 21 2020 at 19:57)</a>:</h4>
<p>Here is another interesting categorical approach to minimization I just came across: <a href="https://arxiv.org/abs/1712.07121v3" title="https://arxiv.org/abs/1712.07121v3">https://arxiv.org/abs/1712.07121v3</a></p>



<a name="194868499"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/194868499" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gershom <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#194868499">(Apr 21 2020 at 22:13)</a>:</h4>
<p>In fact, the factorization given in that  paper gives reflective subcategories of the form I was after!</p>



<a name="195545695"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/232161-deprecated%3A%20recommendations/topic/Programming%20Language%20Semantics/near/195545695" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Todd Schmid (he/they) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/232161-deprecated.3A-recommendations/topic/Programming.20Language.20Semantics.html#195545695">(Apr 28 2020 at 10:45)</a>:</h4>
<p>Oh, nice! Sorry I didn't see this earlier. I will have to check this out.</p>



<footer class="site-footer">

<hr><p>Last updated: Feb 28 2026 at 12:12 UTC</p>
This archive runs on a customization of <a href="https://github.com/zulip/zulip-archive">zulip-archive</a>
</footer>
</body>

</html>