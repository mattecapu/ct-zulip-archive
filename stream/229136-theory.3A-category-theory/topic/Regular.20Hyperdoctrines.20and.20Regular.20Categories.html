<!DOCTYPE html>
<html>
<head>
  	<meta charset="utf-8" />
  	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
  	<meta name="viewport" content="width=device-width, initial-scale=1" />
  
<link rel="stylesheet" href="https://mattecapu.github.io/ct-zulip-archive/style.css" /><title>Regular Hyperdoctrines and Regular Categories · theory: category theory · Zulip Chat Archive</title>
</head>
<body>
<header>
<a href="https://mattecapu.github.io/ct-zulip-archive" class="home-link">
        <img class="logo" src="https://zulip-avatars.s3.amazonaws.com/21317/realm/icon.png?version=3" />
        <h1>Category Theory<br/>Zulip Server<br/>Archive</h1>
        </a>
        <p>
        You're reading the public-facing archive of the <a href="https://categorytheory.zulipchat.com/">Category Theory Zulip server</a>.<br/>
        
        To join the server you need an invite. Anybody can get an invite by contacting <a href="https://matteocapucci.wordpress.com">Matteo Capucci</a> at <em>name dot surname at gmail dot com</em>.<br/>
        
        For all things related to this archive refer to the same person.
        </p>
        </header>
        <hr />
    
<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/index.html">theory: category theory</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Regular.20Hyperdoctrines.20and.20Regular.20Categories.html">Regular Hyperdoctrines and Regular Categories</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com">

<a name="367214977"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Regular%20Hyperdoctrines%20and%20Regular%20Categories/near/367214977" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Max New <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Regular.20Hyperdoctrines.20and.20Regular.20Categories.html#367214977">(Jun 17 2023 at 16:42)</a>:</h4>
<p>I just read Carsten Butz's nice article <a href="https://www.brics.dk/LS/98/2/BRICS-LS-98-2.pdf">Regular Categories and Regular Logic</a> and I noticed that the construction of the classifying regular category for a regular category had a very syntactic character. </p>
<p>Basically, he took the syntax of regular logic, which is the free <a href="https://ncatlab.org/nlab/show/regular%20hyperdoctrine">[[regular hyperdoctrine]]</a> and he performed a kind of syntactic completion where he constructed a new logic where the objects were essentially pairs of a list of objects and a proposition over them, and the morphisms were the total functional relations in the regular hyperdoctrine.</p>
<p>The fact that this works suggests to me the following conjecture and I wonder if it's known to be true.</p>
<p><em>Conjecture</em>: A regular hyperdoctrine is the hyperdoctrine of subobjects of a regular category if and only if:</p>
<ol>
<li>Its objects are closed under "subobject comprehension", i.e., for every object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and predicate <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>∈</mo><mi>L</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi \in L(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> there is an object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi>ϕ</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ A | \phi \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mord mathnormal">ϕ</span><span class="mclose">}</span></span></span></span> with universal property <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo>→</mo><mo stretchy="false">{</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi>ϕ</mi><mo stretchy="false">}</mo><mo>≅</mo><mo stretchy="false">{</mo><mi>f</mi><mo>:</mo><mi mathvariant="normal">Γ</mi><mo>→</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">⊤</mi><mo>≤</mo><msup><mi>f</mi><mo>∗</mo></msup><mi>ϕ</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Gamma \to \{ A | \phi \} \cong \{ f : \Gamma \to A | \top \leq f^*\phi\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mord mathnormal">ϕ</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord">∣⊤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathnormal">ϕ</span><span class="mclose">}</span></span></span></span>. In the syntax this looks like a "subset type" or "refinement type" in PL terminology.</li>
<li>It satisfies the principle of unique choice. I.e., in the internal language from any total functional relation $R$ you can construct a function $f$ whose graph is $R$.</li>
</ol>



<a name="367216022"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Regular%20Hyperdoctrines%20and%20Regular%20Categories/near/367216022" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ivan Di Liberti <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Regular.20Hyperdoctrines.20and.20Regular.20Categories.html#367216022">(Jun 17 2023 at 16:49)</a>:</h4>
<p>See the discussion at the beginning of page 33 here: <a href="https://arxiv.org/abs/2304.07539">https://arxiv.org/abs/2304.07539</a>.</p>



<a name="367231261"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Regular%20Hyperdoctrines%20and%20Regular%20Categories/near/367231261" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Max New <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Regular.20Hyperdoctrines.20and.20Regular.20Categories.html#367231261">(Jun 17 2023 at 18:30)</a>:</h4>
<p>Right so this says that the regular categories for a reflective sub 2-category of the regular hyperdoctrines, where the reflection is given by the construction I mentioned. I'm proposing an alternative, explicit characterization of that sub 2-category as regular hyperdoctrines that have some essentially unique structure</p>



<footer class="site-footer">

<hr><p>Last updated: Feb 28 2026 at 12:12 UTC</p>
This archive runs on a customization of <a href="https://github.com/zulip/zulip-archive">zulip-archive</a>
</footer>
</body>

</html>