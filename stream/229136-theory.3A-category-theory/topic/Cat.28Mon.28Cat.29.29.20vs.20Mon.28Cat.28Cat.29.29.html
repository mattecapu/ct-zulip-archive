<!DOCTYPE html>
<html>
<head>
  	<meta charset="utf-8" />
  	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
  	<meta name="viewport" content="width=device-width, initial-scale=1" />
  
<link rel="stylesheet" href="https://mattecapu.github.io/ct-zulip-archive/style.css" /><title>Cat(Mon(Cat)) vs Mon(Cat(Cat)) · theory: category theory · Zulip Chat Archive</title>
</head>
<body>
<header>
<a href="https://mattecapu.github.io/ct-zulip-archive" class="home-link">
        <img class="logo" src="https://zulip-avatars.s3.amazonaws.com/21317/realm/icon.png?version=3" />
        <h1>Category Theory<br/>Zulip Server<br/>Archive</h1>
        </a>
        <p>
        You're reading the public-facing archive of the <a href="https://categorytheory.zulipchat.com/">Category Theory Zulip server</a>.<br/>
        
        To join the server you need an invite. Anybody can get an invite by contacting <a href="https://matteocapucci.wordpress.com">Matteo Capucci</a> at <em>name dot surname at gmail dot com</em>.<br/>
        
        For all things related to this archive refer to the same person.
        </p>
        </header>
        <hr />
    
<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/index.html">theory: category theory</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html">Cat(Mon(Cat)) vs Mon(Cat(Cat))</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com">

<a name="432520849"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432520849" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matteo Capucci (he/him) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432520849">(Apr 10 2024 at 14:44)</a>:</h4>
<p>Monoidal double categories are pseudomonoids in pseudocategories in Cat, or, alternatively, pseudocategories in pseudomonoids in Cat.<br>
A proof of this fact is that both are special kinds of degenerate triple categories (having only one 1-cells in one of the loose directions), and their equivalence is induced by exchanging loose directions.<br>
Does anyone have a better proof? Or better still, a reference I can cite?</p>



<a name="432521120"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432521120" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matteo Capucci (he/him) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432521120">(Apr 10 2024 at 14:45)</a>:</h4>
<p>(cc'ing <span class="user-mention" data-user-id="275965">@Evan Patterson</span> whom I expect to be able to help)</p>



<a name="432523755"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432523755" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432523755">(Apr 10 2024 at 14:56)</a>:</h4>
<p>Someday there may be a better proof based on "commutativity of internalization".    This principle is well-established for structures definable by finite limits theories, like categories and monoids.   Using this principle, we instantly know that for any category K with finite limits, the category of</p>
<p>monoids in (categories in K)</p>
<p>is equivalent to the category of</p>
<p>categories in (monoids in K)</p>
<p>We'd really like an equivalence of <em>2-categories</em> here, because there happens to be a <em>2-category</em> of categories in any category with finite limits.   So there is more work to be done even at this level (if it hasn't been done already).</p>
<p>But anyway, someone should categorify "commutativity of internalization" so that it applies to algebraic structures definable by '"finite limits 2-theories"', such as pseudocategories and pseudomonoids.</p>



<a name="432524421"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432524421" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432524421">(Apr 10 2024 at 14:59)</a>:</h4>
<p>I'm putting '"finite limits 2-theories"' in quotes because it needs to be clarified a bit: there are several things one might mean, and one wants to pick the right one(s) to handle the examples that come up.</p>



<a name="432539457"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432539457" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432539457">(Apr 10 2024 at 16:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="275932">Matteo Capucci (he/him)</span> <a href="#narrow/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29/near/432520849">said</a>:</p>
<blockquote>
<p>Monoidal double categories are pseudomonoids in pseudocategories in Cat, or, alternatively, pseudocategories in pseudomonoids in Cat.<br>
A proof of this fact is that both are special kinds of degenerate triple categories (having only one 1-cells in one of the loose directions), and their equivalence is induced by exchanging loose directions.<br>
Does anyone have a better proof? Or better still, a reference I can cite?</p>
</blockquote>
<p>This isn't quite true – you need to be careful about strictness (as pointed out in Remark 2.12 of Shulman's <a href="https://arxiv.org/abs/1004.0993">Constructing symmetric monoidal bicategories</a>). A monoidal double category is a pseudomonoid in the 2-category of double categories and pseudo double functors. Equivalently, it is a pseudocategory in the 2-category of monoidal categories and pseudo monoidal functors <em>such that</em> the source and target morphisms are strict monoidal.</p>



<a name="432540409"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432540409" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432540409">(Apr 10 2024 at 16:17)</a>:</h4>
<blockquote>
<p>Or better still, a reference I can cite?</p>
</blockquote>
<p>John Bourke, Joanna Ko and I have been working on a paper on this topic; we have a symmetry result for a class of two-dimensional limit sketches, which includes monoidal double categories as an example. (John gave a talk about it at the <a href="https://www.math.muni.cz/~bourkej/BAS.html">Masaryk University Algebra Seminar</a>, but it doesn't appear the slides have been uploaded yet.) I am hopeful it will be ready before too long; I will send you a link when it is available.</p>



<a name="432553460"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432553460" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Kevin Carlson (Arlin) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432553460">(Apr 10 2024 at 17:26)</a>:</h4>
<p>That’ll be great to see, both for the specific result and more broadly to have a paper about 2-sketches finally in the literature!</p>



<a name="432643220"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432643220" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matteo Capucci (he/him) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432643220">(Apr 11 2024 at 07:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="276092">Nathanael Arkor</span> <a href="#narrow/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29/near/432539457">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="275932">Matteo Capucci (he/him)</span> <a href="#narrow/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29/near/432520849">said</a>:</p>
<blockquote>
<p>Monoidal double categories are pseudomonoids in pseudocategories in Cat, or, alternatively, pseudocategories in pseudomonoids in Cat.<br>
A proof of this fact is that both are special kinds of degenerate triple categories (having only one 1-cells in one of the loose directions), and their equivalence is induced by exchanging loose directions.<br>
Does anyone have a better proof? Or better still, a reference I can cite?</p>
</blockquote>
<p>This isn't quite true – you need to be careful about strictness (as pointed out in Remark 2.12 of Shulman's <a href="https://arxiv.org/abs/1004.0993">Constructing symmetric monoidal bicategories</a>). A monoidal double category is a pseudomonoid in the 2-category of double categories and pseudo double functors. Equivalently, it is a pseudocategory in the 2-category of monoidal categories and pseudo monoidal functors <em>such that</em> the source and target morphisms are strict monoidal.</p>
</blockquote>
<p>Uhm I see, thanks for pointing it out!</p>



<a name="432647595"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432647595" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matteo Capucci (he/him) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432647595">(Apr 11 2024 at 07:58)</a>:</h4>
<p>This is a very interesting thing to me.<br>
I previously stumbled upon the fact that we are usually quite cavalier about strictness in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">p</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">n</mi><mo stretchy="false">(</mo><mi mathvariant="bold">C</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\bf Span(Cat)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">Span</span><span class="mopen">(</span><span class="mord mathbf">Cat</span><span class="mclose">)</span></span></span></span></span> because we can just get away with it there, but as soon as you work in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">p</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">n</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="script">K</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\bf Span(\cal K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">Span</span><span class="mopen">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.01445em;">K</span><span class="mclose">)</span></span></span></span></span></span> for some other 2-category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">K</mi></mrow><annotation encoding="application/x-tex">\cal K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.01445em;">K</span></span></span></span></span> then strict pullbacks might become a luxury you can't afford. In fact the 'biblically accurate' version of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">p</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">n</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="script">K</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\bf Span(\cal K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">Span</span><span class="mopen">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.01445em;">K</span><span class="mclose">)</span></span></span></span></span></span>, described <a href="https://arxiv.org/abs/1112.0560">here</a>, uses isocommas for compositions and maps of spans are maps between apexes with invertible fillers witnessing the commutativity of the two induced triangles.</p>
<p>This introduces a discrepancy between 'weak double categories' and 'pseudocategories in Cat', where the latter is taken to mean pseudmonad in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">p</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">n</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="script">K</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\bf Span(\cal K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">Span</span><span class="mopen">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.01445em;">K</span><span class="mclose">)</span></span></span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">K</mi><mo>=</mo><mrow><mi mathvariant="bold">C</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">t</mi></mrow></mrow><annotation encoding="application/x-tex">\cal K=\bf Cat</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.01445em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathbf">Cat</span></span></span></span></span></span>; which amounts to the fact that the structural equations of weak double categories defining e.g. what a composable pair of loose arrows is, or what functoriality means, are weakened to mere isomorphisms.</p>
<p>This highlights an hypocrisy in the traditional usage of equality and isomorphism: we strongly believe equality in a categry should be isomorphism, but then in the definition of weak double category we insist <em>we want strict equality</em>! This is not to point fingers (I wouldn't know to whom anyway), just to notice an interesting conceptual issue here.</p>
<p>Anyway, the reason I'm bringing this up is that it seems that insisting on weak double categories introduces the hiccup <span class="user-mention" data-user-id="276092">@Nathanael Arkor</span> pointed out. In fact, a pseudomonoid in pseudocategories would only satisfy <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">∂</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo>⊗</mo><mi>g</mi><mo stretchy="false">)</mo><mo>≅</mo><msub><mi mathvariant="normal">∂</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>⊗</mo><msub><mi mathvariant="normal">∂</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\partial_i(f \otimes g) \cong \partial_i(f)\otimes\partial_i(g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span>, which is what we get from a pseudocategory in pseudomonoids, though I admit I didn't check if the rest of the data &amp; coherence also matches up.</p>



<a name="432649455"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432649455" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matteo Capucci (he/him) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432649455">(Apr 11 2024 at 08:09)</a>:</h4>
<p>A possible way to get out of this is to work with isofibrant spans instead, meaning those spans which are two-sided isofibrations. Then a pseudomonad therein is an isofibrant double category, meaning isomorphisms can be traded freely between the tight and loose directions. It then seems one can produce an equivalent monoidal (in the strict sense) isofibrant double category for each monoidal (in the weak sense) double category</p>



<a name="432651585"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432651585" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432651585">(Apr 11 2024 at 08:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="275932">Matteo Capucci (he/him)</span> <a href="#narrow/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29/near/432647595">said</a>:</p>
<blockquote>
<p>This highlights an hypocrisy in the traditional usage of equality and isomorphism: we strongly believe equality in a categry should be isomorphism, but then in the definition of weak double category we insist <em>we want strict equality</em>! This is not to point fingers (I wouldn't know to whom anyway), just to notice an interesting conceptual issue here.</p>
</blockquote>
<p>I think there's a common misconception in category theory (due to some extent to the nLab, which at some point in the past used rather incendiary language) that in category theory it is always true that one should work with the weakest notion of "sameness" as possible. However, the "principle of equivalence" really amounts to saying that when you work with objects of a category, you should only identify objects up to isomorphism, not equality – in other words, that properties of categories should be invariant under equivalence. What it <em>doesn't</em> say is that, when you give a definition, the definition should only make use of isomorphism rather than equality.</p>
<p>Clearly, there are definitions for which we really do want to use equality rather than isomorphism. For instance, in a pseudofunctor, we want sources and targets to be preserved strictly, so that when we have two composable 1-cells in the domain, they are still composable in the codomain. The "pseudo" in "pseudofunctor" refers to the weak preservation of composition and identities, not source and target. There's a good heuristic to check whether one should expect certain data to be preserved strictly or not. If you present the structure in a metatheory that has a notion of type dependency, for instance a generalised algebraic theory, then the dependencies (a.k.a. display maps) should be preserved strictly, whereas the operations may be preserved only weakly. For instance, in the typical presentation of a category, you have a sort of morphisms, which is dependent on the source and target variables. Thus, these should be preserved strictly by homomorphisms.</p>



<a name="432651978"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432651978" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432651978">(Apr 11 2024 at 08:25)</a>:</h4>
<p>In other words, I don't think there is anything wrong with the definitions of pseudocategory or monoidal double category: they capture the appropriate strictness for the examples we care about. However, the fact they they do involve differing levels of strictness needs we need to be a little more careful when we manipulate them.</p>



<a name="432663074"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432663074" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matteo Capucci (he/him) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432663074">(Apr 11 2024 at 09:26)</a>:</h4>
<p>I appreciate your argument on a practical level, but empirically and philosophically I have a hard time accepting it. Empirically, I observe that things work without hiccups when I work fully weakly and when you try to strictify it there's often some place where this strictification breaks or requires some clever workaround. Philosophically, when you say </p>
<blockquote>
<p>[W]hen you work with objects of a category, you should only identify objects up to isomorphism, not equality – in other words, that properties of categories should be invariant under equivalence. What it <em>doesn't</em> say is that, when you give a definition, the definition should only make use of isomorphism rather than equality.</p>
</blockquote>
<p>These seem in contradiction to me: when I define structure on top of categories, why is this in a privileged position to access strict equality rather than isomorphism only? In other words, 'properties of categories should be invariant under equivalence', why not structure?</p>



<a name="432669208"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432669208" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432669208">(Apr 11 2024 at 09:59)</a>:</h4>
<p>From an empirical point of view, I would say these concepts are even easier to justify: they capture the examples we care about, and are convenient to work with, which makes them good definitions.</p>
<p>From an abstract point of view, in these examples the structures we are defining (e.g. monoidal double categories) involve morphisms of structures (e.g. pseudo double functors). This is true generally in functorial semantics. Morphisms of structures are not completely weak. For instance, a pseudo functor preserves source and target strictly. You could argue that this is too strong, but I think you will have difficulty finding examples of notions of morphism that do not preserve source and target strictly.</p>



<a name="432674800"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432674800" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432674800">(Apr 11 2024 at 10:33)</a>:</h4>
<p>People like Makkai have argued convincingly (to me) that source and target are fundamentally different than composition.  For example, there's a definition of category where we start with a collection of objects and then for each pair of objects <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x , y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> a set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">h</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{hom}(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">hom</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>; after this we give composition and identities obeying equational laws.    In this approach the homsets are a "dependent type", and saying <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi mathvariant="normal">h</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f : \mathrm{hom}(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">hom</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> is a "typing judgement".  This is conceptually different than starting with an undifferentiated collection of all morphisms, defining functions <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo separator="true">,</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s,t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span></span></span></span> from this to the collection of objects, and then asserting equations <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">s(f) = x, t(f) = y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>.  In the dependently typed approach it makes no sense to talk about a morphism without first knowing its source and target.   So, for example, it makes no sense to ask whether <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f = g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> unless we already know <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo separator="true">,</mo><mi>g</mi><mo>:</mo><mrow><mi mathvariant="normal">h</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f, g: \mathrm{hom}(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">hom</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> for some objects <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>.</p>
<p>This explains why it's not evil - to use incendiary language <span aria-label="smiling devil" class="emoji emoji-1f608" role="img" title="smiling devil">:smiling_devil:</span> - to demand that functors preserve the source and target of morphisms.</p>



<a name="432676408"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432676408" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Morgan Rogers (he/him) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432676408">(Apr 11 2024 at 10:44)</a>:</h4>
<p>It's a fun coincidence that <span class="user-mention" data-user-id="277289">@Jonas Frey</span> was talking about that dependently typed presentation at LIPN this morning.</p>



<a name="432676881"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432676881" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432676881">(Apr 11 2024 at 10:46)</a>:</h4>
<p>Makkai developed his theory of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span>-categories based on his system FOLDS: "first-order logic with dependent sorts".  This avoids "evil" in a very elegant way.</p>



<a name="432694241"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432694241" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matteo Capucci (he/him) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432694241">(Apr 11 2024 at 12:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="276092">Nathanael Arkor</span> <a href="#narrow/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29/near/432669208">said</a>:</p>
<blockquote>
<p>From an empirical point of view, I would say these concepts are even easier to justify: they capture the examples we care about, and are convenient to work with, which makes them good definitions.</p>
</blockquote>
<p>Of course, I'm not arguing against that :) but we also observe that working up to the correct level of equivalence makes life easier from a technical standpoint, if messy. So I'm highlighting this... tension?</p>



<a name="432698209"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432698209" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matteo Capucci (he/him) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432698209">(Apr 11 2024 at 12:48)</a>:</h4>
<p>Actually I believe non-strictly consecutive morphisms are composed all the time in mathematical practice, since we rarely take care of precisely aligning boundaries of morphisms with e.g. structural morphisms we know to be coherent, and instead it is understood those morphisms are implicitly around. The very fact I'm asking this question is because I have some concrete construction that churns out double monoidal categories with possibly non-strictly monoidal source/target.</p>



<a name="432698531"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432698531" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Morgan Rogers (he/him) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432698531">(Apr 11 2024 at 12:50)</a>:</h4>
<p>(eg. we are often happy to suppress the associators when composing morphisms in monoidal categories)</p>



<a name="432700244"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432700244" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matteo Capucci (he/him) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432700244">(Apr 11 2024 at 12:58)</a>:</h4>
<p>To answer <span class="user-mention" data-user-id="275920">@John Baez</span>, the definition you bring up seems innocuous but it 'sneaks in' meta-level equality when one defines composition when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi mathvariant="normal">h</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f: {\rm hom}(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">hom</span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mrow><mi mathvariant="normal">h</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g:{\rm hom}(y,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">hom</span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>. This is a way to say <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">y=y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> with notation, but then in practice we know this level of strictness can be hard to maintain, hence the struggle for univalent foundations and <a href="http://strictlypositive.org/thesis.pdf">heterogeneous equality</a>.</p>
<p>But it seems that this is always the culprit with strictness, at some point we draw a line between 'object theory' and 'metatheory' and we tacitly assume metatheory has oracle-like properties (like LEM, decidable equality) whereas object theory has to be 'constructive' somehow (so e.g. you have to witness equality judgments). So this seems an issue on where we draw the line for categories, is it at the 0-level or at the 1-level?</p>



<a name="432702505"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432702505" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Morgan Rogers (he/him) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432702505">(Apr 11 2024 at 13:09)</a>:</h4>
<p>I think it's more of an inevitable problem with syntax requiring repetition. For a full specification of the composition operation you would write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo>:</mo><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">b</mi></mrow><mo separator="true">,</mo><mtext> </mtext><mi>g</mi><mo>:</mo><mrow><mi mathvariant="normal">h</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>f</mi><mo>:</mo><mrow><mi mathvariant="normal">h</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>⊢</mo><mi>g</mi><mo>∘</mo><mi>f</mi><mo>:</mo><mrow><mi mathvariant="normal">h</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x, y, z: {\rm ob}, \,g:{\rm hom}(y,z), \, f: {\rm hom}(x,y) \vdash g \circ f : {\rm hom}(x,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">ob</span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">hom</span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">hom</span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">hom</span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>, and as such we already have a repetition of the object variables even before the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> is 'used' a second time in the type of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>: we 'name' <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x,y,z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> as terms of the type of objects and then 'use' those terms in the morphism type constructor. There are notions of linearity that prevent a variable from being used more than once (after it is named, that is), but if we wanted a weaker version where identical types are replaced with equivalent ones it would actually have the same amount of repetition, since we would need a further statement presenting the identity between the terms.</p>



<a name="432702927"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432702927" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Morgan Rogers (he/him) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432702927">(Apr 11 2024 at 13:11)</a>:</h4>
<p>I suppose this observation is related to notions of identity type etc.</p>



<a name="432707096"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432707096" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432707096">(Apr 11 2024 at 13:33)</a>:</h4>
<p>Yes, I agree with Morgan. You want to be able to duplicate variables without viewing that as identification of variables via a meta-level equality. It depends on your philosophy, but I would argue it is possible to refer to an object multiple times without having a notion of sameness of objects, other than the identity.</p>



<a name="432707436"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432707436" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432707436">(Apr 11 2024 at 13:35)</a>:</h4>
<p>Having contraction in a type theory means you have invariance under some operation on a context; it does not require a meta-level equality.</p>



<a name="432707688"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432707688" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432707688">(Apr 11 2024 at 13:36)</a>:</h4>
<p>I think if you distinguish identification of variables, and equality of terms, the apparent problem with strictness in the definition of functors, monoidal double categories, etc., goes away.</p>



<a name="432730638"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432730638" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432730638">(Apr 11 2024 at 15:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="275932">Matteo Capucci (he/him)</span> <a href="#narrow/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29/near/432647595">said</a>:</p>
<blockquote>
<p>This highlights an hypocrisy in the traditional usage of equality and isomorphism: we strongly believe equality in a categry should be isomorphism, but then in the definition of weak double category we insist <em>we want strict equality</em>!</p>
</blockquote>
<p>When I was a graduate student in Chicago back in the oughts, I met Bob Paré for the first time at a conference (I think it was the Mac Lane Memorial Conference), and this was the first question I asked him.  If memory serves, he answered by asking me what I thought.  I gave essentially the same two answers that have been given here: first, that many double categories are isofibrant and so we can strictify isomorphisms involving domains and codomains; and second, that we don't need to weaken when talking about "structure" (I didn't know the phrase "dependent types" back then, but I think this is essentially the same point).</p>



<a name="432735477"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432735477" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432735477">(Apr 11 2024 at 15:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="275932">Matteo Capucci (he/him)</span> <a href="#narrow/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29/near/432663074">said</a>:</p>
<blockquote>
<p>Philosophically, when you say </p>
<blockquote>
<p>[W]hen you work with objects of a category, you should only identify objects up to isomorphism, not equality – in other words, that properties of categories should be invariant under equivalence. What it <em>doesn't</em> say is that, when you give a definition, the definition should only make use of isomorphism rather than equality.</p>
</blockquote>
<p>These seem in contradiction to me: when I define structure on top of categories, why is this in a privileged position to access strict equality rather than isomorphism only? In other words, 'properties of categories should be invariant under equivalence', why not structure?</p>
</blockquote>
<p>Maybe this was answered already, but I think this is a misunderstanding.  I think what Nathanael was saying is that <em>talking</em> about equality in its statement doesn't mean a definition (be it property or structure) isn't invariant under equivalence.</p>



<a name="432735663"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432735663" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432735663">(Apr 11 2024 at 15:42)</a>:</h4>
<p>Rather, there are precise ways in which we <em>can</em> talk about equality -- namely, those that can be encoded using dependent types -- while <em>still</em> remaining invariant under equivalence.</p>



<a name="432735916"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432735916" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432735916">(Apr 11 2024 at 15:43)</a>:</h4>
<p>Another point that I think hasn't been made yet is that it's impossible to avoid at least the dependent-types kind of equality.  Suppose you weaken the composition operation so that when composing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f:x\to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">g:y&#x27;\to z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> you only require <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">y&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> to be isomorphic.  But that means you have an isomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>:</mo><mi>y</mi><mo>≅</mo><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">h:y \cong y&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7834em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> whose domain is <em>equal</em> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> and whose target is <em>equal</em> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">y&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>!</p>



<a name="432737358"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432737358" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matteo Capucci (he/him) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432737358">(Apr 11 2024 at 15:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="276777">Mike Shulman</span> <a href="#narrow/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29/near/432735916">said</a>:</p>
<blockquote>
<p>Another point that I think hasn't been made yet is that it's impossible to avoid at least the dependent-types kind of equality.  Suppose you weaken the composition operation so that when composing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f:x\to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">g:y&#x27;\to z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> you only require <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">y&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> to be isomorphic.  But that means you have an isomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>:</mo><mi>y</mi><mo>≅</mo><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">h:y \cong y&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7834em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> whose domain is <em>equal</em> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> and whose target is <em>equal</em> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">y&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>!</p>
</blockquote>
<p>Yeah I think this is the most 'convincing' issue with weakening everything (<span class="user-mention" data-user-id="277473">@Morgan Rogers (he/him)</span> mentioned this earlier btw). I'm putting 'convincing' in quotes because I'm not arguing for dropping strictness in the definition of monoidal double category or double category, I'm just trying to grasp the nuances in the principle of equivalence.</p>



<a name="432737473"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432737473" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432737473">(Apr 11 2024 at 15:51)</a>:</h4>
<p>Ok, sorry I missed it.</p>



<a name="432738156"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432738156" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matteo Capucci (he/him) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432738156">(Apr 11 2024 at 15:54)</a>:</h4>
<p>No problem!</p>
<p><span class="user-mention silent" data-user-id="276777">Mike Shulman</span> <a href="#narrow/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29/near/432735663">said</a>:</p>
<blockquote>
<p>Rather, there are precise ways in which we <em>can</em> talk about equality -- namely, those that can be encoded using dependent types -- while <em>still</em> remaining invariant under equivalence.</p>
</blockquote>
<p>I think this perspective is the one that I like best. But then we shouldn't be using functors for things like source and target of a double category, which really should be thought as displaying maps, and instead have them being isofibrations.</p>



<a name="432738578"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432738578" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Matteo Capucci (he/him) <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432738578">(Apr 11 2024 at 15:57)</a>:</h4>
<p>If that's the case I'd say this vindicates my hunch that's there's a tension to be resolved, the resolution being adopting isofibrations for things that need to 'see' equality (better: display data invariant under equivalence)</p>



<a name="432740091"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432740091" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432740091">(Apr 11 2024 at 16:03)</a>:</h4>
<p>Dependent types FTW!</p>



<a name="432865068"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/432865068" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Graham Manuell <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#432865068">(Apr 12 2024 at 09:21)</a>:</h4>
<p>I don't know if this is related or not, but I never know how to think of isomorphisms in double categories. Usually when two objects are isomorphic I think of them as the same thing, but what if they are, say, horizontally isomorphic, but not vertically isomorphic? Relatedly there doesn't appear to be one accepted notion of equivalence of double categories? I never know what to make of that. Things are bit simpler when you have companions and so there is a stronger and weaker version of isomorphism, but in general I don't really have any feeling for what is going on.</p>



<a name="488167563"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/488167563" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#488167563">(Dec 11 2024 at 19:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="276092">Nathanael Arkor</span> <a href="#narrow/channel/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29/near/432540409">said</a>:</p>
<blockquote>
<blockquote>
<p>Or better still, a reference I can cite?</p>
</blockquote>
<p>John Bourke, Joanna Ko and I have been working on a paper on this topic; we have a symmetry result for a class of two-dimensional limit sketches, which includes monoidal double categories as an example. (John gave a talk about it at the <a href="https://www.math.muni.cz/~bourkej/BAS.html">Masaryk University Algebra Seminar</a>, but it doesn't appear the slides have been uploaded yet.) I am hopeful it will be ready before too long; I will send you a link when it is available.</p>
</blockquote>
<p>The paper is now out: <a href="https://arxiv.org/abs/2412.07475">Enhanced 2-categorical structures, two-dimensional limit sketches and the symmetry of internalisation</a>! (I've created a dedicated thread here: <a class="stream-topic" data-stream-id="274877" href="/#narrow/channel/274877-community.3A-our-work/topic/Enhanced.202-categorical.20structures">#community: our work &gt; Enhanced 2-categorical structures</a>.)</p>



<a name="488869210"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/488869210" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chaitanya Leena Subramaniam <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#488869210">(Dec 13 2024 at 15:45)</a>:</h4>
<p>I'm sorry to be seeing this interesting conversation only now.</p>
<p><span class="user-mention silent" data-user-id="276092">Nathanael Arkor</span> <a href="#narrow/channel/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29/near/432539457">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="275932">Matteo Capucci (he/him)</span> <a href="#narrow/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29/near/432520849">said</a>:</p>
<blockquote>
<p>Monoidal double categories are pseudomonoids in pseudocategories in Cat, or, alternatively, pseudocategories in pseudomonoids in Cat.<br>
A proof of this fact is that both are special kinds of degenerate triple categories (having only one 1-cells in one of the loose directions), and their equivalence is induced by exchanging loose directions.<br>
Does anyone have a better proof? Or better still, a reference I can cite?</p>
</blockquote>
<p>This isn't quite true – you need to be careful about strictness (as pointed out in Remark 2.12 of Shulman's <a href="https://arxiv.org/abs/1004.0993">Constructing symmetric monoidal bicategories</a>). A monoidal double category is a pseudomonoid in the 2-category of double categories and pseudo double functors. Equivalently, it is a pseudocategory in the 2-category of monoidal categories and pseudo monoidal functors <em>such that</em> the source and target morphisms are strict monoidal.</p>
</blockquote>
<p>A naïve question---shouldn't the two (2,1)-categories (with and without the strict monoidal condition on source and target morphisms) be bi-equivalent? This should follow from the tensor product of locally presentable (oo,1)-categories. Explicitly, <br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">M</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mo stretchy="false">(</mo><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mo stretchy="false">(</mo><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mo>≃</mo><mrow><mi mathvariant="normal">M</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mo>⊗</mo><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mo>⊗</mo><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mrow><mo>≃</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mo>⊗</mo><mi mathvariant="normal">M</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mo>⊗</mo><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mrow><mo>≃</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mo stretchy="false">(</mo><mi mathvariant="normal">M</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mo stretchy="false">(</mo><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{Mon(Cat(Cat))}\simeq\mathrm{Mon\otimes Cat\otimes Cat}\simeq \mathrm{Cat\otimes Mon\otimes Cat}\simeq \mathrm{Cat(Mon(Cat))}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Mon</span><span class="mopen">(</span><span class="mord mathrm">Cat</span><span class="mopen">(</span><span class="mord mathrm">Cat</span><span class="mclose">))</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathrm">Mon</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">Cat</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">Cat</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathrm">Cat</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">Mon</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">Cat</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Cat</span><span class="mopen">(</span><span class="mord mathrm">Mon</span><span class="mopen">(</span><span class="mord mathrm">Cat</span><span class="mclose">))</span></span></span></span></span><br>
Here, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">M</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi></mrow><annotation encoding="application/x-tex">\mathrm{Mon}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Mon</span></span></span></span></span> is the 1-category of monoids, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mrow><annotation encoding="application/x-tex">\mathrm{Cat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Cat</span></span></span></span></span> is the (2,1)-category of 1-categories.</p>
<p>It's early-ish in the morning here in California, and I'm on my first cup of coffee, so it's very possible that there is some simple detail that I'm missing :D</p>



<a name="488873009"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/488873009" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#488873009">(Dec 13 2024 at 16:03)</a>:</h4>
<p>Doesn't that only work when <em>everything</em> is pseudo?  It doesn't tell you that you can strictify the source and target morphisms.</p>



<a name="488876585"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/488876585" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chaitanya Leena Subramaniam <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#488876585">(Dec 13 2024 at 16:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="276777">Mike Shulman</span> <a href="#narrow/channel/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29/near/488873009">said</a>:</p>
<blockquote>
<p>Doesn't that only work when <em>everything</em> is pseudo?  It doesn't tell you that you can strictify the source and target morphisms.</p>
</blockquote>
<p>You mean that the (2,1)-category of double categories and pseudo-double functors (as it's usually defined) is not bi-equivalent to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mo>⊗</mo><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mrow><annotation encoding="application/x-tex">\mathrm{Cat\otimes Cat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathrm">Cat</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">Cat</span></span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mrow><annotation encoding="application/x-tex">\mathrm{Cat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Cat</span></span></span></span></span> is really the (2,1)-category of univalent pseudocategories (whose hom-spaces are 0-truncated) in 1-truncated spaces (but biequivalently, is the usual (2,1)-category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mrow><annotation encoding="application/x-tex">\mathrm{Cat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Cat</span></span></span></span></span>?</p>



<a name="488888686"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/488888686" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#488888686">(Dec 13 2024 at 17:30)</a>:</h4>
<p>Yes -- at least, it's not obvious to me that it would be.</p>



<a name="488893096"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/488893096" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chaitanya Leena Subramaniam <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#488893096">(Dec 13 2024 at 17:55)</a>:</h4>
<p>Hmm, that's a little worrisome (to me, since I've gotten used to thinking of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">D</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mrow><annotation encoding="application/x-tex">\mathrm{DblCat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">DblCat</span></span></span></span></span> in the higher sense as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mrow><mo>⊗</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{Cat}\otimes\mathrm{Cat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathrm">Cat</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Cat</span></span></span></span></span>)...</p>



<a name="488893659"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/488893659" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#488893659">(Dec 13 2024 at 17:59)</a>:</h4>
<p>They do become equivalent if you restrict to isofibrant double categories.  So I regard this more as an indictment of non-isofibrant double categories.</p>



<a name="488894738"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/488894738" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#488894738">(Dec 13 2024 at 18:05)</a>:</h4>
<p>Put differently, the thing that should be equivalent to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mo>⊗</mo><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mrow><annotation encoding="application/x-tex">\rm Cat\otimes Cat</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathrm">Cat</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">Cat</span></span></span></span></span> is the (weak?) <em>model</em> category of ordinary double categories.  The morphisms of the latter should be strict double functors, and its cofibrant objects would be fattened up so as to represent pseudo double functors, but in addition its fibrant objects should be be the isofibrant ones.  (I don't remember offhand whether one of the known model structures on DblCat is exactly that.)</p>



<a name="488895488"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/488895488" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#488895488">(Dec 13 2024 at 18:10)</a>:</h4>
<p>Although, hmm, now I'm second-guessing myself, because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mo>⊗</mo><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mrow><annotation encoding="application/x-tex">\rm Cat\otimes Cat</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathrm">Cat</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">Cat</span></span></span></span></span> is symmetrical in the two copies of Cat, whereas what I described isn't.  Maybe the fibrant objects should be isofibrant in both directions, and the cofibrant objects should be fattened up in both directions to represent double functors that are pseudo in both directions?</p>



<a name="488895863"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/488895863" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chaitanya Leena Subramaniam <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#488895863">(Dec 13 2024 at 18:13)</a>:</h4>
<p>This is interesting! Perhaps there is a nice tribe/contextual category with Id-types whose category of models is this (weak?) model category. Food for thought :)</p>



<a name="488917100"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/488917100" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathanael Arkor <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#488917100">(Dec 13 2024 at 20:42)</a>:</h4>
<p>I believe Example 8.18 of our paper essentially exhibits a counterexample (it is formulated slightly differently, in terms of pseudocategories and their morphisms in Cat, rather than tensor products, but the obstruction is the same). My impression is the same as Mike's, that this is really an illustration that non-isofibrant double categories are badly behaved generally (but also that, if one does want to consider all double categories, care is needed regarding strictness).</p>



<a name="488923804"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/Cat%28Mon%28Cat%29%29%20vs%20Mon%28Cat%28Cat%29%29/near/488923804" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chaitanya Leena Subramaniam <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/Cat.28Mon.28Cat.29.29.20vs.20Mon.28Cat.28Cat.29.29.html#488923804">(Dec 13 2024 at 21:27)</a>:</h4>
<p>Thanks for the pointer!</p>



<footer class="site-footer">

<hr><p>Last updated: Feb 28 2026 at 12:12 UTC</p>
This archive runs on a customization of <a href="https://github.com/zulip/zulip-archive">zulip-archive</a>
</footer>
</body>

</html>