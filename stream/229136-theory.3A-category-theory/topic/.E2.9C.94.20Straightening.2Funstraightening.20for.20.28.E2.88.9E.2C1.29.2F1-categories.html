<!DOCTYPE html>
<html>
<head>
  	<meta charset="utf-8" />
  	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
  	<meta name="viewport" content="width=device-width, initial-scale=1" />
  
<link rel="stylesheet" href="https://mattecapu.github.io/ct-zulip-archive/style.css" /><title>✔ Straightening/unstraightening for (∞,1)/1-categories · theory: category theory · Zulip Chat Archive</title>
</head>
<body>
<header>
<a href="https://mattecapu.github.io/ct-zulip-archive" class="home-link">
        <img class="logo" src="https://zulip-avatars.s3.amazonaws.com/21317/realm/icon.png?version=3" />
        <h1>Category Theory<br/>Zulip Server<br/>Archive</h1>
        </a>
        <p>
        You're reading the public-facing archive of the <a href="https://categorytheory.zulipchat.com/">Category Theory Zulip server</a>.<br/>
        
        To join the server you need an invite. Anybody can get an invite by contacting <a href="https://matteocapucci.wordpress.com">Matteo Capucci</a> at <em>name dot surname at gmail dot com</em>.<br/>
        
        For all things related to this archive refer to the same person.
        </p>
        </header>
        <hr />
    
<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/index.html">theory: category theory</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html">✔ Straightening/unstraightening for (∞,1)/1-categories</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com">

<a name="374921900"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/374921900" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josselin Poiret <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#374921900">(Jul 13 2023 at 12:57)</a>:</h4>
<p>I've been thinking a bit about straightening/unstraightening, and although I can't pretend I've read the proof for ∞,1-categories (I ought to at some point), am I right in my intuition that the complicated part of straightening/unstraightening isn't doing the Grothendieck construction part, but rather actually straightening the data of an ∞,2-functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mrow><mrow><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex"> B → \mathrm{Cat}_{∞,1} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Cat</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> into a bona-fide ∞-functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mrow><mrow><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex"> B → \mathrm{Cat}_{∞,1} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Cat</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> that ought to be equivalent with it?</p>
<p>If so, then am I right in expecting a 1-categorical analogue of straightening/unstraightening along the lines of: the 1-category of Grothendieck fibrations over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex"> B </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> up to equivalence is equivalent to the category of 1-functors <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>B</mi><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup><mo>→</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mrow></mrow><annotation encoding="application/x-tex"> B^\mathrm{op} → \mathrm{Cat} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">op</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Cat</span></span></span></span></span></p>



<a name="374970865"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/374970865" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joe Moeller <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#374970865">(Jul 13 2023 at 15:21)</a>:</h4>
<p>The Grothendieck construction gives an equivalence between fibrations over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and <em>pseudo</em>functors <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>B</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mi>C</mi><mi>a</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">B^{op} \to Cat</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span></span></span></span>.</p>



<a name="374982789"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/374982789" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josselin Poiret <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#374982789">(Jul 13 2023 at 15:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="275914">Joe Moeller</span> <a href="#narrow/stream/229136-theory.3A-category-theory/topic/Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories/near/374970865">said</a>:</p>
<blockquote>
<p>The Grothendieck construction gives an equivalence between fibrations over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and <em>pseudo</em>functors <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>B</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mi>C</mi><mi>a</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">B^{op} \to Cat</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span></span></span></span>.</p>
</blockquote>
<p>yes, but that's not what I'm asking here, I'm asking for a strictification of this result, and first whether this strictification underlies the straightening/unstraightening for (∞,1)-categories</p>



<a name="374983668"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/374983668" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Kevin Arlin <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#374983668">(Jul 13 2023 at 16:01)</a>:</h4>
<p>To get a split fibration (i.e. a strict functor into Cat) equivalent to an arbitrary Grothendieck fibration, I believe you generally have to change the base to an equivalent category.</p>



<a name="374987972"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/374987972" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joe Moeller <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#374987972">(Jul 13 2023 at 16:13)</a>:</h4>
<p>Sorry, I misunderstood the question. I see now why the question seemed odd to me.</p>



<a name="374990690"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/374990690" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joe Moeller <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#374990690">(Jul 13 2023 at 16:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="609515">Kevin Arlin</span> <a href="#narrow/stream/229136-theory.3A-category-theory/topic/Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories/near/374983668">said</a>:</p>
<blockquote>
<p>To get a split fibration (i.e. a strict functor into Cat) equivalent to an arbitrary Grothendieck fibration, I believe you generally have to change the base to an equivalent category.</p>
</blockquote>
<p>Could you explain how this would work with like short exact sequences of groups? Split sequences correspond to split fibrations. What can you change in a non-split sequence to get an equivalent split one?</p>



<a name="374991838"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/374991838" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Kevin Arlin <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#374991838">(Jul 13 2023 at 16:27)</a>:</h4>
<p>I'll think about it more if I get a chance but in particular I'm pretty sure you won't end up with a functor into groups.</p>



<a name="374991882"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/374991882" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#374991882">(Jul 13 2023 at 16:27)</a>:</h4>
<p>No, you don't have to change the base.  It's true in general that to replace a pseudofunctor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> between arbitrary 2-categories by a strict one, you have to change the domain.  But in the special case when the codomain is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mrow><annotation encoding="application/x-tex">\rm Cat</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Cat</span></span></span></span></span>, you don't.</p>



<a name="374992008"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/374992008" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Kevin Arlin <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#374992008">(Jul 13 2023 at 16:28)</a>:</h4>
<p>Oh oops, thanks Mike.</p>



<a name="374992462"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/374992462" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#374992462">(Jul 13 2023 at 16:29)</a>:</h4>
<p>A highfalutin' way to explain it is that there's a 2-monad (and also a 2-comonad) whose strict (co)algebras are strict 2-functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mrow></mrow><annotation encoding="application/x-tex">A\to\rm Cat</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Cat</span></span></span></span></span> and whose pseudoalgebras are pseudofunctors, and it satisfies the general strictification theorem, so any pseudoalgebra can be replaced by a strict one.</p>



<a name="374993600"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/374993600" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#374993600">(Jul 13 2023 at 16:33)</a>:</h4>
<p>There are also more explicit constructions.  For instance, given a pseudofunctor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>A</mi><mo>→</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mrow></mrow><annotation encoding="application/x-tex">F:A\to \rm Cat</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Cat</span></span></span></span></span>, you can define an object of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F&#x27;(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> to be an object of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> together with isomorphic "choices" of its image under all maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\to b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> (this is the comonad version).  Or, you can define an object of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F&#x27;(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> to be a morphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">c\to a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> together with an object of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span> (this is the monad version).  In both cases you define the morphisms to be induced from those of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span>.</p>



<a name="374995017"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/374995017" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Kevin Arlin <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#374995017">(Jul 13 2023 at 16:38)</a>:</h4>
<p>Is giving the explicit construction the usual way you'd suggest showing these co/monads satisfy strictification? I don't really know how to check in concrete cases in general using the condition that there's a splitting of the counit of the pseudomorphism classifier or whatever.</p>



<a name="374996271"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/374996271" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josselin Poiret <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#374996271">(Jul 13 2023 at 16:42)</a>:</h4>
<p>Right, but can you strictify the whole equivalence you get from the Grothendieck construction?</p>



<a name="374999843"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/374999843" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#374999843">(Jul 13 2023 at 16:55)</a>:</h4>
<p>There's a general theorem of Power ("A general coherence theorem"), generalized further by Lack ("Codescent objects and coherence"), which is usually my first resort when asking whether a 2-monad satisfies strictification.  You observe that the base 2-category has a certain sort of factorization system and that the monad preserves the left class of it.</p>



<a name="375000800"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/375000800" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#375000800">(Jul 13 2023 at 16:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284453">Josselin Poiret</span> <a href="#narrow/stream/229136-theory.3A-category-theory/topic/Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories/near/374996271">said</a>:</p>
<blockquote>
<p>Right, but can you strictify the whole equivalence you get from the Grothendieck construction?</p>
</blockquote>
<p>Oh argh, this is the thing I always get wrong.  Let's see, I think the 1-category of fibrations and morphisms of fibrations is equivalent to the 1-category of pseudofunctors and pseudonatural transformations.  But the 1-category of pseudofunctors is not equivalent to the 1-category of 2-functors, for two reasons: every pseudofunctor is <em>equivalent</em> to a 2-functor, but not isomorphic to it, and even between 2-functors not every pseudonatural transformation is isomorphic to a strict natural transformation.</p>



<a name="375009096"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/375009096" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josselin Poiret <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#375009096">(Jul 13 2023 at 17:28)</a>:</h4>
<p>What if you quotient by equivalences of fibrations on the left, and strictify to the 1-category of functors and pseudonatural transformations on the right side? I'm trying to mirror the straightening/unstraightening for ∞,1-categories</p>



<a name="375016111"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/375016111" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Kevin Arlin <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#375016111">(Jul 13 2023 at 17:54)</a>:</h4>
<p>A theorem that seems to be in the direction you're looking for is on page 12-13 of Streicher's notes on fibered categories, and states that the forgetful functor from the 2-category of split fibrations and split cartesian functors to the 2-category of fibrations and cartesian functors is the 2-functor freely inverting the split cartesian functors which are equivalences on every fiber, but it's not an equivalence. So this says that if you quotient split fibrations by a weak notion of equivalence of fibration, one which isn't visible in the underlying 1-category, then the result is the same as the 2-category of fibrations.</p>
<p>The fact that this isn't an equivalence illustrates Mike's point that not every pseudonatural transformation comes from a 2-natural transformation.</p>



<a name="375016327"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/375016327" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Kevin Arlin <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#375016327">(Jul 13 2023 at 17:55)</a>:</h4>
<p>This localizing forgetful functor also has both left and right adjoints, which may be relevant to the straightening and unstraightening argument you're trying to follow.</p>



<a name="375028807"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/375028807" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#375028807">(Jul 13 2023 at 18:40)</a>:</h4>
<p>Quotienting is very rarely what you want to do.  Taking pseudonatural transformations between 1-functors (which accidentally form a 1-category) solves one problem but not the other.</p>



<a name="375028897"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/375028897" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#375028897">(Jul 13 2023 at 18:40)</a>:</h4>
<p>You also don't have an equivalence of 1-categories in the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span> world, so I'm not sure what you're hoping to mirror.</p>



<a name="375030945"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/375030945" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josselin Poiret <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#375030945">(Jul 13 2023 at 18:48)</a>:</h4>
<p>Isn't there a Quillen equivalence between sSet-enriched presheaves and the slice category of simplical sets? But yeah I guess what you're alluding to is that while you can lower ∞,2 to ∞,1 you can't really get rid of all the 2-morphisms here.</p>



<a name="375032548"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/375032548" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#375032548">(Jul 13 2023 at 18:54)</a>:</h4>
<p>A Quillen equivalence is an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-equivalence, which is much weaker than a 1-equivalence.  There's nothing to be done in "lowering" an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>-equivalence to an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-equivalence: since the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span> is still the same, the former isn't any weaker than the latter, it just contains more data that you can easily forget.</p>



<a name="375032840"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/375032840" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#375032840">(Jul 13 2023 at 18:55)</a>:</h4>
<p>In other words: the weakness of the equivalence lies in the <em>invertible</em> morphisms, which are the same in the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> and the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span> world.  The analogue in lower dimensions would be a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-equivalence, which is likewise easy to get from a 2-equivalence by forgetting the noninvertible 2-cells.</p>



<a name="375034082"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/375034082" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josselin Poiret <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#375034082">(Jul 13 2023 at 18:59)</a>:</h4>
<p>ah, yes, it's much clearer now, I don't know why I didn't think of that... thanks!</p>



<a name="375034114"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/375034114" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Notification Bot <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#375034114">(Jul 13 2023 at 18:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284453">Josselin Poiret</span> has marked this topic as resolved.</p>



<a name="375034718"></a>
<h4><a href="https://categorytheory.zulipchat.com#narrow/stream/229136-theory%3A%20category%20theory/topic/%E2%9C%94%20Straightening/unstraightening%20for%20%28%E2%88%9E%2C1%29/1-categories/near/375034718" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josselin Poiret <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory.3A-category-theory/topic/.E2.9C.94.20Straightening.2Funstraightening.20for.20.28.E2.88.9E.2C1.29.2F1-categories.html#375034718">(Jul 13 2023 at 19:01)</a>:</h4>
<p>(FTR, I was looking for universe construction similar to eg. regular functions X → Sets, but for 1-categories, but I guess the picture is much more complicated since you can't just take functors B → Cat to faithfully represent all opfibrations over B)</p>



<footer class="site-footer">

<hr><p>Last updated: Feb 28 2026 at 12:12 UTC</p>
This archive runs on a customization of <a href="https://github.com/zulip/zulip-archive">zulip-archive</a>
</footer>
</body>

</html>